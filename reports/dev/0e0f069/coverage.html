
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>build: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/FITHSCS/backend/api/services/auth/build/all.go (0.0%)</option>
				
				<option value="file1">github.com/FITHSCS/backend/api/services/auth/main.go (0.0%)</option>
				
				<option value="file2">github.com/FITHSCS/backend/api/services/core/build/all/all.go (0.0%)</option>
				
				<option value="file3">github.com/FITHSCS/backend/api/services/core/main.go (0.0%)</option>
				
				<option value="file4">github.com/FITHSCS/backend/api/services/metrics/collector/expvar.go (0.0%)</option>
				
				<option value="file5">github.com/FITHSCS/backend/api/services/metrics/main.go (0.0%)</option>
				
				<option value="file6">github.com/FITHSCS/backend/api/services/metrics/publisher/datadog/datadog.go (0.0%)</option>
				
				<option value="file7">github.com/FITHSCS/backend/api/services/metrics/publisher/expvar/expvar.go (0.0%)</option>
				
				<option value="file8">github.com/FITHSCS/backend/api/services/metrics/publisher/prometheus/prometheus.go (0.0%)</option>
				
				<option value="file9">github.com/FITHSCS/backend/api/services/metrics/publisher/publisher.go (0.0%)</option>
				
				<option value="file10">github.com/FITHSCS/backend/api/services/sync/build/all/all.go (0.0%)</option>
				
				<option value="file11">github.com/FITHSCS/backend/api/services/sync/main.go (0.0%)</option>
				
				<option value="file12">github.com/FITHSCS/backend/api/tooling/admin/commands/genkey.go (0.0%)</option>
				
				<option value="file13">github.com/FITHSCS/backend/api/tooling/admin/commands/migrate.go (0.0%)</option>
				
				<option value="file14">github.com/FITHSCS/backend/api/tooling/admin/commands/seed.go (0.0%)</option>
				
				<option value="file15">github.com/FITHSCS/backend/api/tooling/admin/commands/useradd.go (0.0%)</option>
				
				<option value="file16">github.com/FITHSCS/backend/api/tooling/admin/main.go (0.0%)</option>
				
				<option value="file17">github.com/FITHSCS/backend/api/tooling/logfmt/main.go (0.0%)</option>
				
				<option value="file18">github.com/FITHSCS/backend/business/domain/auditbus/auditbus.go (69.2%)</option>
				
				<option value="file19">github.com/FITHSCS/backend/business/domain/auditbus/stores/auditdb/auditdb.go (0.0%)</option>
				
				<option value="file20">github.com/FITHSCS/backend/business/domain/auditbus/stores/auditdb/filter.go (0.0%)</option>
				
				<option value="file21">github.com/FITHSCS/backend/business/domain/auditbus/stores/auditdb/model.go (0.0%)</option>
				
				<option value="file22">github.com/FITHSCS/backend/business/domain/auditbus/stores/auditdb/order.go (0.0%)</option>
				
				<option value="file23">github.com/FITHSCS/backend/business/domain/auditbus/testutil.go (93.3%)</option>
				
				<option value="file24">github.com/FITHSCS/backend/business/domain/delexceptionbus/delexceptionbus.go (78.7%)</option>
				
				<option value="file25">github.com/FITHSCS/backend/business/domain/delexceptionbus/store/delexceptiondb/delexceptiondb.go (0.0%)</option>
				
				<option value="file26">github.com/FITHSCS/backend/business/domain/delexceptionbus/store/delexceptiondb/filter.go (0.0%)</option>
				
				<option value="file27">github.com/FITHSCS/backend/business/domain/delexceptionbus/store/delexceptiondb/model.go (0.0%)</option>
				
				<option value="file28">github.com/FITHSCS/backend/business/domain/delexceptionbus/store/delexceptiondb/order.go (0.0%)</option>
				
				<option value="file29">github.com/FITHSCS/backend/business/domain/delexceptionbus/testutil.go (95.2%)</option>
				
				<option value="file30">github.com/FITHSCS/backend/business/domain/facilitybus/facilitybus.go (68.5%)</option>
				
				<option value="file31">github.com/FITHSCS/backend/business/domain/facilitybus/stores/facilitydb/facilitydb.go (0.0%)</option>
				
				<option value="file32">github.com/FITHSCS/backend/business/domain/facilitybus/stores/facilitydb/filter.go (0.0%)</option>
				
				<option value="file33">github.com/FITHSCS/backend/business/domain/facilitybus/stores/facilitydb/model.go (0.0%)</option>
				
				<option value="file34">github.com/FITHSCS/backend/business/domain/facilitybus/stores/facilitydb/order.go (0.0%)</option>
				
				<option value="file35">github.com/FITHSCS/backend/business/domain/facilitybus/testutil.go (93.8%)</option>
				
				<option value="file36">github.com/FITHSCS/backend/business/domain/gpstrackingbus/gpstrackingbus.go (79.1%)</option>
				
				<option value="file37">github.com/FITHSCS/backend/business/domain/gpstrackingbus/stores/gpstrackingdb/filter.go (0.0%)</option>
				
				<option value="file38">github.com/FITHSCS/backend/business/domain/gpstrackingbus/stores/gpstrackingdb/gpstrackingdb.go (0.0%)</option>
				
				<option value="file39">github.com/FITHSCS/backend/business/domain/gpstrackingbus/stores/gpstrackingdb/model.go (0.0%)</option>
				
				<option value="file40">github.com/FITHSCS/backend/business/domain/gpstrackingbus/stores/gpstrackingdb/order.go (0.0%)</option>
				
				<option value="file41">github.com/FITHSCS/backend/business/domain/gpstrackingbus/testutil.go (93.8%)</option>
				
				<option value="file42">github.com/FITHSCS/backend/business/domain/imagebus/imagebus.go (79.6%)</option>
				
				<option value="file43">github.com/FITHSCS/backend/business/domain/imagebus/stores/imagedb/filter.go (0.0%)</option>
				
				<option value="file44">github.com/FITHSCS/backend/business/domain/imagebus/stores/imagedb/imagedb.go (0.0%)</option>
				
				<option value="file45">github.com/FITHSCS/backend/business/domain/imagebus/stores/imagedb/model.go (0.0%)</option>
				
				<option value="file46">github.com/FITHSCS/backend/business/domain/imagebus/stores/imagedb/order.go (0.0%)</option>
				
				<option value="file47">github.com/FITHSCS/backend/business/domain/imagebus/testutil.go (95.0%)</option>
				
				<option value="file48">github.com/FITHSCS/backend/business/domain/manifestbus/manifestbus.go (79.6%)</option>
				
				<option value="file49">github.com/FITHSCS/backend/business/domain/manifestbus/stores/manifestdb/filter.go (0.0%)</option>
				
				<option value="file50">github.com/FITHSCS/backend/business/domain/manifestbus/stores/manifestdb/manifestdb.go (0.0%)</option>
				
				<option value="file51">github.com/FITHSCS/backend/business/domain/manifestbus/stores/manifestdb/model.go (0.0%)</option>
				
				<option value="file52">github.com/FITHSCS/backend/business/domain/manifestbus/stores/manifestdb/order.go (0.0%)</option>
				
				<option value="file53">github.com/FITHSCS/backend/business/domain/manifestbus/testutil.go (95.2%)</option>
				
				<option value="file54">github.com/FITHSCS/backend/business/domain/pickupbatchbus/pickupbatchbus.go (78.8%)</option>
				
				<option value="file55">github.com/FITHSCS/backend/business/domain/pickupbatchbus/stores/pickupbatchdb/filter.go (0.0%)</option>
				
				<option value="file56">github.com/FITHSCS/backend/business/domain/pickupbatchbus/stores/pickupbatchdb/model.go (0.0%)</option>
				
				<option value="file57">github.com/FITHSCS/backend/business/domain/pickupbatchbus/stores/pickupbatchdb/order.go (0.0%)</option>
				
				<option value="file58">github.com/FITHSCS/backend/business/domain/pickupbatchbus/stores/pickupbatchdb/pickupbatchdb.go (0.0%)</option>
				
				<option value="file59">github.com/FITHSCS/backend/business/domain/pickupbatchbus/testutil.go (94.7%)</option>
				
				<option value="file60">github.com/FITHSCS/backend/business/domain/routebus/routebus.go (79.6%)</option>
				
				<option value="file61">github.com/FITHSCS/backend/business/domain/routebus/stores/routedb/filter.go (0.0%)</option>
				
				<option value="file62">github.com/FITHSCS/backend/business/domain/routebus/stores/routedb/model.go (0.0%)</option>
				
				<option value="file63">github.com/FITHSCS/backend/business/domain/routebus/stores/routedb/order.go (0.0%)</option>
				
				<option value="file64">github.com/FITHSCS/backend/business/domain/routebus/stores/routedb/routedb.go (0.0%)</option>
				
				<option value="file65">github.com/FITHSCS/backend/business/domain/routebus/testutil.go (93.3%)</option>
				
				<option value="file66">github.com/FITHSCS/backend/business/domain/signaturebus/signaturebus.go (82.0%)</option>
				
				<option value="file67">github.com/FITHSCS/backend/business/domain/signaturebus/stores/signaturedb/filter.go (0.0%)</option>
				
				<option value="file68">github.com/FITHSCS/backend/business/domain/signaturebus/stores/signaturedb/model.go (0.0%)</option>
				
				<option value="file69">github.com/FITHSCS/backend/business/domain/signaturebus/stores/signaturedb/order.go (0.0%)</option>
				
				<option value="file70">github.com/FITHSCS/backend/business/domain/signaturebus/stores/signaturedb/signaturedb.go (0.0%)</option>
				
				<option value="file71">github.com/FITHSCS/backend/business/domain/signaturebus/testutil.go (95.0%)</option>
				
				<option value="file72">github.com/FITHSCS/backend/business/domain/syncbatchbus/stores/syncbatchdb/model.go (0.0%)</option>
				
				<option value="file73">github.com/FITHSCS/backend/business/domain/syncbatchbus/stores/syncbatchdb/syncbatchdb.go (0.0%)</option>
				
				<option value="file74">github.com/FITHSCS/backend/business/domain/syncbatchbus/syncbatchbus.go (0.0%)</option>
				
				<option value="file75">github.com/FITHSCS/backend/business/domain/userbus/extensions/useraudit/useraudit.go (0.0%)</option>
				
				<option value="file76">github.com/FITHSCS/backend/business/domain/userbus/stores/usercache/usercache.go (0.0%)</option>
				
				<option value="file77">github.com/FITHSCS/backend/business/domain/userbus/stores/userdb/filter.go (0.0%)</option>
				
				<option value="file78">github.com/FITHSCS/backend/business/domain/userbus/stores/userdb/model.go (0.0%)</option>
				
				<option value="file79">github.com/FITHSCS/backend/business/domain/userbus/stores/userdb/order.go (0.0%)</option>
				
				<option value="file80">github.com/FITHSCS/backend/business/domain/userbus/stores/userdb/userdb.go (0.0%)</option>
				
				<option value="file81">github.com/FITHSCS/backend/business/domain/userbus/testutil.go (93.3%)</option>
				
				<option value="file82">github.com/FITHSCS/backend/business/domain/userbus/userbus.go (50.8%)</option>
				
				<option value="file83">github.com/FITHSCS/backend/business/domain/vehiclebus/stores/vehicledb/filter.go (0.0%)</option>
				
				<option value="file84">github.com/FITHSCS/backend/business/domain/vehiclebus/stores/vehicledb/model.go (0.0%)</option>
				
				<option value="file85">github.com/FITHSCS/backend/business/domain/vehiclebus/stores/vehicledb/order.go (0.0%)</option>
				
				<option value="file86">github.com/FITHSCS/backend/business/domain/vehiclebus/stores/vehicledb/vehicledb.go (0.0%)</option>
				
				<option value="file87">github.com/FITHSCS/backend/business/domain/vehiclebus/testutil.go (93.3%)</option>
				
				<option value="file88">github.com/FITHSCS/backend/business/domain/vehiclebus/vehiclebus.go (80.0%)</option>
				
				<option value="file89">github.com/FITHSCS/backend/business/sdk/dbtest/business.go (0.0%)</option>
				
				<option value="file90">github.com/FITHSCS/backend/business/sdk/dbtest/dbtest.go (0.0%)</option>
				
				<option value="file91">github.com/FITHSCS/backend/business/sdk/dbtest/pointer.go (0.0%)</option>
				
				<option value="file92">github.com/FITHSCS/backend/business/sdk/delegate/delegate.go (0.0%)</option>
				
				<option value="file93">github.com/FITHSCS/backend/business/sdk/delegate/model.go (0.0%)</option>
				
				<option value="file94">github.com/FITHSCS/backend/business/sdk/migrate/migrate.go (0.0%)</option>
				
				<option value="file95">github.com/FITHSCS/backend/business/sdk/order/order.go (0.0%)</option>
				
				<option value="file96">github.com/FITHSCS/backend/business/sdk/page/page.go (0.0%)</option>
				
				<option value="file97">github.com/FITHSCS/backend/business/sdk/sqldb/dbarray/dbarray.go (0.0%)</option>
				
				<option value="file98">github.com/FITHSCS/backend/business/sdk/sqldb/dbarray/encode.go (0.0%)</option>
				
				<option value="file99">github.com/FITHSCS/backend/business/sdk/sqldb/sqldb.go (0.0%)</option>
				
				<option value="file100">github.com/FITHSCS/backend/business/sdk/sqldb/tran.go (0.0%)</option>
				
				<option value="file101">github.com/FITHSCS/backend/business/sdk/unitest/unittest.go (0.0%)</option>
				
				<option value="file102">github.com/FITHSCS/backend/business/types/domain/domain.go (0.0%)</option>
				
				<option value="file103">github.com/FITHSCS/backend/business/types/facilitytype/facilitytype.go (0.0%)</option>
				
				<option value="file104">github.com/FITHSCS/backend/business/types/genstringtype/genstringtype.go (0.0%)</option>
				
				<option value="file105">github.com/FITHSCS/backend/business/types/name/name.go (0.0%)</option>
				
				<option value="file106">github.com/FITHSCS/backend/business/types/role/role.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package authall all binds all the routes into the specified app.
package authall

import (
        "github.com/FITHSCS/backend/app/domain/authapp"
        "github.com/FITHSCS/backend/app/domain/statusapp"
        "github.com/FITHSCS/backend/app/sdk/mux"
        "github.com/FITHSCS/backend/foundation/web"
)

// Routes constructs the add value which provides the implementation of
// of RouteAdder for specifying what routes to bind to this instance.
func Routes() add <span class="cov0" title="0">{
        return add{}
}</span>

type add struct{}

// Add implements the RouterAdder interface.
func (add) Add(app *web.App, cfg mux.Config) <span class="cov0" title="0">{
        statusapp.Routes(app, statusapp.Config{
                Log: cfg.Log,
                DB:  cfg.DB,
        })

        authapp.Routes(app, authapp.Config{
                UserBus: cfg.BusConfig.UserBus,
                Auth:    cfg.AuthConfig.Auth,
        })
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "context"
        "errors"
        "expvar"
        "fmt"
        "net/http"
        "os"
        "os/signal"
        "runtime"
        "syscall"
        "time"

        authall "github.com/FITHSCS/backend/api/services/auth/build"
        "github.com/FITHSCS/backend/app/sdk/auth"
        "github.com/FITHSCS/backend/app/sdk/debug"
        "github.com/FITHSCS/backend/app/sdk/mux"

        "github.com/FITHSCS/backend/business/domain/userbus"

        "github.com/FITHSCS/backend/business/domain/userbus/stores/usercache"
        "github.com/FITHSCS/backend/business/domain/userbus/stores/userdb"

        "github.com/FITHSCS/backend/business/sdk/sqldb"
        "github.com/FITHSCS/backend/foundation/keystore"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/FITHSCS/backend/foundation/otel"
        "github.com/ardanlabs/conf/v3"
)

var build = "develop"

func main() <span class="cov0" title="0">{
        var log *logger.Logger

        events := logger.Events{
                Error: func(ctx context.Context, r logger.Record) </span><span class="cov0" title="0">{
                        log.Info(ctx, "******* SEND ALERT *******")
                }</span>,
        }

        <span class="cov0" title="0">traceIDFn := func(ctx context.Context) string </span><span class="cov0" title="0">{
                return otel.GetTraceID(ctx)
        }</span>

        <span class="cov0" title="0">log = logger.NewWithEvents(os.Stdout, logger.LevelInfo, "AUTH", traceIDFn, events)

        // -------------------------------------------------------------------------

        ctx := context.Background()

        if err := run(ctx, log); err != nil </span><span class="cov0" title="0">{
                log.Error(ctx, "startup", "err", err)
                os.Exit(1)
        }</span>
}

func run(ctx context.Context, log *logger.Logger) error <span class="cov0" title="0">{

        // -------------------------------------------------------------------------
        // GOMAXPROCS

        log.Info(ctx, "startup", "GOMAXPROCS", runtime.GOMAXPROCS(0))

        // -------------------------------------------------------------------------
        // Configuration

        cfg := struct {
                conf.Version
                Web struct {
                        ReadTimeout        time.Duration `conf:"default:5s"`
                        WriteTimeout       time.Duration `conf:"default:10s"`
                        IdleTimeout        time.Duration `conf:"default:120s"`
                        ShutdownTimeout    time.Duration `conf:"default:20s"`
                        APIHost            string        `conf:"default:0.0.0.0:6000"`
                        DebugHost          string        `conf:"default:0.0.0.0:6010"`
                        CORSAllowedOrigins []string      `conf:"default:*"`
                }
                Auth struct {
                        KeysEnvVar string
                        KeysFolder string `conf:"default:zarf/keys/"`
                        ActiveKID  string `conf:"default:54bb2165-71e1-41a6-af3e-7da4a0e1e2c1"`
                        Issuer     string `conf:"default:FITHSCS core project"`
                }
                DB struct {
                        User         string `conf:"default:postgres"`
                        Password     string `conf:"default:postgres,mask"`
                        Host         string `conf:"default:database"`
                        Name         string `conf:"default:postgres"`
                        MaxIdleConns int    `conf:"default:0"`
                        MaxOpenConns int    `conf:"default:0"`
                        DisableTLS   bool   `conf:"default:true"`
                }
        }{
                Version: conf.Version{
                        Build: build,
                        Desc:  "Auth",
                },
        }

        const prefix = "AUTH"
        help, err := conf.Parse(prefix, &amp;cfg)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, conf.ErrHelpWanted) </span><span class="cov0" title="0">{
                        fmt.Println(help)
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("parsing config: %w", err)</span>
        }

        // -------------------------------------------------------------------------
        // App Starting

        <span class="cov0" title="0">log.Info(ctx, "starting service", "version", cfg.Build)
        defer log.Info(ctx, "shutdown complete")

        out, err := conf.String(&amp;cfg)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("generating config for output: %w", err)
        }</span>
        <span class="cov0" title="0">log.Info(ctx, "startup", "config", out)

        log.BuildInfo(ctx)

        expvar.NewString("build").Set(cfg.Build)

        // -------------------------------------------------------------------------
        // Database Support

        log.Info(ctx, "startup", "status", "initializing database support", "hostport", cfg.DB.Host)

        db, err := sqldb.Open(sqldb.Config{
                User:         cfg.DB.User,
                Password:     cfg.DB.Password,
                Host:         cfg.DB.Host,
                Name:         cfg.DB.Name,
                MaxIdleConns: cfg.DB.MaxIdleConns,
                MaxOpenConns: cfg.DB.MaxOpenConns,
                DisableTLS:   cfg.DB.DisableTLS,
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("connecting to db: %w", err)
        }</span>

        <span class="cov0" title="0">defer db.Close()

        // -------------------------------------------------------------------------
        // Create Business Packages

        userBus := userbus.NewBusiness(log, usercache.NewStore(log, userdb.NewStore(log, db), time.Minute))

        // -------------------------------------------------------------------------
        // Initialize authentication support

        log.Info(ctx, "startup", "status", "initializing authentication support")

        // Check the enviornment first to see if a key is being provided. Then
        // load any private keys files from disk. We can assume some system like
        // Vault has created these files already. How that happens is not our
        // concern.

        ks := keystore.New()

        n1, err := ks.LoadByJSON(cfg.Auth.KeysEnvVar)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("loading keys by env: %w", err)
        }</span>

        <span class="cov0" title="0">n2, err := ks.LoadByFileSystem(os.DirFS(cfg.Auth.KeysFolder))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("loading keys by fs: %w", err)
        }</span>

        <span class="cov0" title="0">if n1+n2 == 0 </span><span class="cov0" title="0">{
                return errors.New("no keys exist")
        }</span>

        <span class="cov0" title="0">authCfg := auth.Config{
                Log:       log,
                UserBus:   userBus,
                KeyLookup: ks,
                Issuer:    cfg.Auth.Issuer,
        }

        ath, err := auth.New(authCfg)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("constructing auth: %w", err)
        }</span>

        // -------------------------------------------------------------------------
        // Start Debug Service

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                log.Info(ctx, "startup", "status", "debug v1 router started", "host", cfg.Web.DebugHost)

                if err := http.ListenAndServe(cfg.Web.DebugHost, debug.Mux()); err != nil </span><span class="cov0" title="0">{
                        log.Error(ctx, "shutdown", "status", "debug v1 router closed", "host", cfg.Web.DebugHost, "msg", err)
                }</span>
        }()

        // -------------------------------------------------------------------------
        // Start API Service

        <span class="cov0" title="0">log.Info(ctx, "startup", "status", "initializing V1 API support")

        shutdown := make(chan os.Signal, 1)
        signal.Notify(shutdown, syscall.SIGINT, syscall.SIGTERM)

        cfgMux := mux.Config{
                Build: build,
                Log:   log,
                DB:    db,
                BusConfig: mux.BusConfig{
                        UserBus: userBus,
                },
                AuthConfig: mux.AuthConfig{
                        Auth: ath,
                },
        }

        api := http.Server{
                Addr:         cfg.Web.APIHost,
                Handler:      mux.WebAPI(cfgMux, authall.Routes(), mux.WithCORS(cfg.Web.CORSAllowedOrigins)),
                ReadTimeout:  cfg.Web.ReadTimeout,
                WriteTimeout: cfg.Web.WriteTimeout,
                IdleTimeout:  cfg.Web.IdleTimeout,
                ErrorLog:     logger.NewStdLogger(log, logger.LevelError),
        }

        serverErrors := make(chan error, 1)

        go func() </span><span class="cov0" title="0">{
                log.Info(ctx, "startup", "status", "api router started", "host", api.Addr)

                serverErrors &lt;- api.ListenAndServe()
        }</span>()

        // -------------------------------------------------------------------------
        // Shutdown

        <span class="cov0" title="0">select </span>{
        case err := &lt;-serverErrors:<span class="cov0" title="0">
                return fmt.Errorf("server error: %w", err)</span>

        case sig := &lt;-shutdown:<span class="cov0" title="0">
                log.Info(ctx, "shutdown", "status", "shutdown started", "signal", sig)
                defer log.Info(ctx, "shutdown", "status", "shutdown complete", "signal", sig)

                ctx, cancel := context.WithTimeout(ctx, cfg.Web.ShutdownTimeout)
                defer cancel()

                if err := api.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                        api.Close()
                        return fmt.Errorf("could not stop server gracefully: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>

}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Package coreall binds all the routes into the specified app.
package coreall

import (
        "github.com/FITHSCS/backend/app/domain/auditapp"
        "github.com/FITHSCS/backend/app/domain/delexceptionapp"
        "github.com/FITHSCS/backend/app/domain/facilityapp"
        "github.com/FITHSCS/backend/app/domain/gpstrackingapp"
        "github.com/FITHSCS/backend/app/domain/imageapp"
        "github.com/FITHSCS/backend/app/domain/manifestapp"
        "github.com/FITHSCS/backend/app/domain/pickupbatchapp"
        "github.com/FITHSCS/backend/app/domain/routeapp"
        "github.com/FITHSCS/backend/app/domain/signatureapp"
        "github.com/FITHSCS/backend/app/domain/statusapp"
        "github.com/FITHSCS/backend/app/domain/userapp"
        "github.com/FITHSCS/backend/app/domain/vehicleapp"
        "github.com/FITHSCS/backend/app/sdk/mux"
        "github.com/FITHSCS/backend/foundation/web"
)

// Routes constructs the add value which provides the implementation of
// of RouteAdder for specifying what routes to bind to this instance.
func Routes() add <span class="cov0" title="0">{
        return add{}
}</span>

type add struct{}

// Add implements the RouterAdder interface.
func (add) Add(app *web.App, cfg mux.Config) <span class="cov0" title="0">{
        statusapp.Routes(app, statusapp.Config{
                Log: cfg.Log,
                DB:  cfg.DB,
        })

        userapp.Routes(app, userapp.Config{
                Log:        cfg.Log,
                UserBus:    cfg.BusConfig.UserBus,
                AuthClient: cfg.AuthClientConfig.AuthClient,
        })

        auditapp.Routes(app, auditapp.Config{
                Log:        cfg.Log,
                AuditBus:   cfg.BusConfig.AuditBus,
                AuthClient: cfg.AuthClientConfig.AuthClient,
        })

        vehicleapp.Routes(app, vehicleapp.Config{
                Log:        cfg.Log,
                VehicleBus: cfg.BusConfig.VehicleBus,
                AuthClient: cfg.AuthClientConfig.AuthClient,
        })

        gpstrackingapp.Routes(app, gpstrackingapp.Config{
                Log:           cfg.Log,
                TrackTraceBus: cfg.BusConfig.GPSTrackingBus,
                AuthClient:    cfg.AuthClientConfig.AuthClient,
        })

        facilityapp.Routes(app, facilityapp.Config{
                Log:         cfg.Log,
                FacilityBus: cfg.BusConfig.FacilityBus,
                AuthClient:  cfg.AuthClientConfig.AuthClient,
        })

        pickupbatchapp.Routes(app, pickupbatchapp.Config{
                Log:            cfg.Log,
                PickupBatchBus: cfg.BusConfig.PickupBatchBus,
                AuthClient:     cfg.AuthClientConfig.AuthClient,
        })

        manifestapp.Routes(app, manifestapp.Config{
                Log:         cfg.Log,
                ManifestBus: cfg.BusConfig.ManifestBus,
                AuthClient:  cfg.AuthClientConfig.AuthClient,
        })

        signatureapp.Routes(app, signatureapp.Config{
                Log:          cfg.Log,
                SignatureBus: cfg.BusConfig.SignatureBus,
                AuthClient:   cfg.AuthClientConfig.AuthClient,
        })

        delexceptionapp.Routes(app, delexceptionapp.Config{
                Log:          cfg.Log,
                Delexception: cfg.BusConfig.DeliveryExceptionBus,
                AuthClient:   cfg.AuthClientConfig.AuthClient,
        })

        imageapp.Routes(app, imageapp.Config{
                Log:        cfg.Log,
                ImageBus:   cfg.BusConfig.ImageBus,
                AuthClient: cfg.AuthClientConfig.AuthClient,
        })

        routeapp.Routes(app, routeapp.Config{
                Log:        cfg.Log,
                RouteBus:   cfg.BusConfig.RouteBus,
                AuthClient: cfg.AuthClientConfig.AuthClient,
        })

}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "context"
        "errors"
        "expvar"
        "fmt"
        "net/http"
        "os"
        "os/signal"
        "runtime"
        "syscall"
        "time"

        coreall "github.com/FITHSCS/backend/api/services/core/build/all"
        "github.com/FITHSCS/backend/app/domain/consumerapp"
        "github.com/FITHSCS/backend/app/sdk/authclient"
        "github.com/FITHSCS/backend/app/sdk/debug"
        "github.com/FITHSCS/backend/app/sdk/mux"
        "github.com/FITHSCS/backend/business/domain/auditbus"
        "github.com/FITHSCS/backend/business/domain/auditbus/stores/auditdb"
        "github.com/FITHSCS/backend/business/domain/delexceptionbus"
        "github.com/FITHSCS/backend/business/domain/delexceptionbus/store/delexceptiondb"
        "github.com/FITHSCS/backend/business/domain/facilitybus"
        "github.com/FITHSCS/backend/business/domain/facilitybus/stores/facilitydb"
        "github.com/FITHSCS/backend/business/domain/gpstrackingbus"
        "github.com/FITHSCS/backend/business/domain/gpstrackingbus/stores/gpstrackingdb"
        "github.com/FITHSCS/backend/business/domain/imagebus"
        "github.com/FITHSCS/backend/business/domain/imagebus/stores/imagedb"
        "github.com/FITHSCS/backend/business/domain/manifestbus"
        "github.com/FITHSCS/backend/business/domain/manifestbus/stores/manifestdb"
        "github.com/FITHSCS/backend/business/domain/pickupbatchbus"
        "github.com/FITHSCS/backend/business/domain/pickupbatchbus/stores/pickupbatchdb"
        "github.com/FITHSCS/backend/business/domain/routebus"
        "github.com/FITHSCS/backend/business/domain/routebus/stores/routedb"
        "github.com/FITHSCS/backend/business/domain/signaturebus"
        "github.com/FITHSCS/backend/business/domain/signaturebus/stores/signaturedb"
        "github.com/FITHSCS/backend/business/domain/userbus"
        "github.com/FITHSCS/backend/business/domain/userbus/extensions/useraudit"
        "github.com/FITHSCS/backend/business/domain/userbus/stores/usercache"
        "github.com/FITHSCS/backend/business/domain/userbus/stores/userdb"
        "github.com/FITHSCS/backend/business/domain/vehiclebus"
        "github.com/FITHSCS/backend/business/domain/vehiclebus/stores/vehicledb"
        "github.com/FITHSCS/backend/business/sdk/sqldb"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/FITHSCS/backend/foundation/otel"
        "github.com/ardanlabs/conf/v3"
)

var build = "develop"

func main() <span class="cov0" title="0">{
        var log *logger.Logger

        events := logger.Events{
                Error: func(ctx context.Context, r logger.Record) </span><span class="cov0" title="0">{
                        log.Info(ctx, "******* SEND ALERT *******")
                }</span>,
        }

        <span class="cov0" title="0">traceIDFn := func(ctx context.Context) string </span><span class="cov0" title="0">{
                return otel.GetTraceID(ctx)
        }</span>

        <span class="cov0" title="0">log = logger.NewWithEvents(os.Stdout, logger.LevelInfo, "CORE", traceIDFn, events)

        // -------------------------------------------------------------------------

        ctx := context.Background()

        if err := run(ctx, log); err != nil </span><span class="cov0" title="0">{
                log.Error(ctx, "startup", "err", err)
                os.Exit(1)
        }</span>
}

func run(ctx context.Context, log *logger.Logger) error <span class="cov0" title="0">{

        // -------------------------------------------------------------------------
        // GOMAXPROCS

        log.Info(ctx, "startup", "GOMAXPROCS", runtime.GOMAXPROCS(0))

        // -------------------------------------------------------------------------
        // Configuration

        cfg := struct {
                conf.Version
                Web struct {
                        ReadTimeout        time.Duration `conf:"default:5s"`
                        WriteTimeout       time.Duration `conf:"default:10s"`
                        IdleTimeout        time.Duration `conf:"default:120s"`
                        ShutdownTimeout    time.Duration `conf:"default:20s"`
                        APIHost            string        `conf:"default:0.0.0.0:3000"`
                        DebugHost          string        `conf:"default:0.0.0.0:3010"`
                        CORSAllowedOrigins []string      `conf:"default:*"`
                }
                Auth struct {
                        Host string `conf:"default:http://0.0.0.0:6000"`
                }
                DB struct {
                        User         string `conf:"default:postgres"`
                        Password     string `conf:"default:postgres,mask"`
                        Host         string `conf:"default:database"`
                        Name         string `conf:"default:postgres"`
                        MaxIdleConns int    `conf:"default:0"`
                        MaxOpenConns int    `conf:"default:0"`
                        DisableTLS   bool   `conf:"default:true"`
                }
                Consumer struct {
                        Enabled     bool     `conf:"default:true"`
                        Brokers     []string `conf:"default:localhost:9092"`
                        Topic       string   `conf:"default:epod-persist"`
                        GroupID     string   `conf:"default:core-consumer-group"`
                        WorkerCount int      `conf:"default:6"`
                        QueueSize   int      `conf:"default:100"`
                }
                Tempo struct {
                        Host        string  `conf:"default:tempo:4317"`
                        ServiceName string  `conf:"default:core"`
                        Probability float64 `conf:"default:0.05"`
                        // Shouldn't use a high Probability value in non-developer systems.
                        // 0.05 should be enough for most systems. Some might want to have
                        // this even lower.
                }
        }{
                Version: conf.Version{
                        Build: build,
                        Desc:  "core with Kafka consumer",
                },
        }
        const prefix = "CORE"
        help, err := conf.Parse(prefix, &amp;cfg)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, conf.ErrHelpWanted) </span><span class="cov0" title="0">{
                        fmt.Println(help)
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("parsing config: %w", err)</span>
        }

        // -------------------------------------------------------------------------
        // App Starting

        <span class="cov0" title="0">log.Info(ctx, "starting service", "version", cfg.Build)
        defer log.Info(ctx, "shutdown complete")

        out, err := conf.String(&amp;cfg)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("generating config for output: %w", err)
        }</span>
        <span class="cov0" title="0">log.Info(ctx, "startup", "config", out)

        log.BuildInfo(ctx)

        expvar.NewString("build").Set(cfg.Build)

        // -------------------------------------------------------------------------
        // Database Support

        log.Info(ctx, "startup", "status", "initializing database support", "hostport", cfg.DB.Host)
        fmt.Println("Password: ", cfg.DB.Password)
        db, err := sqldb.Open(sqldb.Config{
                User:         cfg.DB.User,
                Password:     cfg.DB.Password,
                Host:         cfg.DB.Host,
                Name:         cfg.DB.Name,
                MaxIdleConns: cfg.DB.MaxIdleConns,
                MaxOpenConns: cfg.DB.MaxOpenConns,
                DisableTLS:   cfg.DB.DisableTLS,
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("connecting to db: %w", err)
        }</span>

        <span class="cov0" title="0">defer db.Close()

        // -------------------------------------------------------------------------
        // Initialize authentication support

        log.Info(ctx, "startup", "status", "initializing authentication support")

        autclint := authclient.New(log, cfg.Auth.Host)

        // -------------------------------------------------------------------------
        // Create Business Packages

        userAuditExt := useraudit.NewExtension(auditbus.NewBusiness(log, auditdb.NewStore(log, db)))
        userStorage := usercache.NewStore(log, userdb.NewStore(log, db), time.Minute)

        auditBus := auditbus.NewBusiness(log, auditdb.NewStore(log, db))
        userBus := userbus.NewBusiness(log, userStorage, userAuditExt)
        facilityBus := facilitybus.NewBusiness(log, facilitydb.NewStore(log, db))
        vehicleBus := vehiclebus.NewBusiness(log, vehicledb.NewStore(log, db))
        gpsTracking := gpstrackingbus.NewBusiness(log, gpstrackingdb.NewStore(log, db))
        pickupbatchBus := pickupbatchbus.NewBusiness(log, pickupbatchdb.NewStore(log, db))
        manifestBus := manifestbus.NewBusiness(log, manifestdb.NewStore(log, db))
        signatureBus := signaturebus.NewBusiness(log, signaturedb.NewStore(log, db))
        delexceptionBus := delexceptionbus.NewBusiness(log, delexceptiondb.NewStore(log, db))
        imageBus := imagebus.NewBusiness(log, imagedb.NewStore(log, db))
        routeBus := routebus.NewBusiness(log, routedb.NewStore(log, db))

        // -----------------------------------------------------------------------
        // create consumer app
        var consumer *consumerapp.App

        if cfg.Consumer.Enabled </span><span class="cov0" title="0">{
                log.Info(ctx, "startup", "status", "intializing kafka consumer",
                        "brokers", cfg.Consumer.Brokers,
                        "topic", cfg.Consumer.Topic,
                        "group_id", cfg.Consumer.GroupID,
                        "worker_count", cfg.Consumer.WorkerCount)

                consumerCfg := consumerapp.Config{
                        Log: log,
                        KafkaConfig: consumerapp.KafkaConfig{
                                Brokers: cfg.Consumer.Brokers,
                                Topic:   cfg.Consumer.Topic,
                                GroupID: cfg.Consumer.GroupID,
                        },
                        WorkerCount:    cfg.Consumer.WorkerCount,
                        QueueSize:      cfg.Consumer.QueueSize,
                        UserBus:        userBus,
                        FacilityBus:    facilityBus,
                        VehicleBus:     vehicleBus,
                        PickupBatchBus: pickupbatchBus,
                        ManifestBus:    manifestBus,
                        GpsTrackingBus: gpsTracking,
                        SignatureBus:   signatureBus,
                }
                consumer = consumerapp.New(consumerCfg)

                if err := consumer.Start(ctx); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to start kafka consumer: %w", err)
                }</span>
                <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                        log.Info(ctx, "shutdown", "status", "stopping kafka consumer")
                        if err := consumer.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                                log.Error(ctx, "graceful shutdown of consumer", "ERROR", err)
                        }</span>
                }()
        }

        // -------------------------------------------------------------------------
        // Start Debug Service

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                log.Info(ctx, "startup", "status", "debug v1 router started", "host", cfg.Web.DebugHost)

                if err := http.ListenAndServe(cfg.Web.DebugHost, debug.Mux()); err != nil </span><span class="cov0" title="0">{
                        log.Error(ctx, "shutdown", "status", "debug v1 router closed", "host", cfg.Web.DebugHost, "msg", err)
                }</span>
        }()

        // -------------------------------------------------------------------------
        // Start API Service

        <span class="cov0" title="0">log.Info(ctx, "startup", "status", "initializing V1 API support")

        shutdown := make(chan os.Signal, 1)
        signal.Notify(shutdown, syscall.SIGINT, syscall.SIGTERM)

        cfgMux := mux.Config{
                Build: build,
                Log:   log,
                DB:    db,
                BusConfig: mux.BusConfig{
                        AuditBus:             auditBus,
                        UserBus:              userBus,
                        FacilityBus:          facilityBus,
                        VehicleBus:           vehicleBus,
                        GPSTrackingBus:       gpsTracking,
                        PickupBatchBus:       pickupbatchBus,
                        ManifestBus:          manifestBus,
                        SignatureBus:         signatureBus,
                        DeliveryExceptionBus: delexceptionBus,
                        ImageBus:             imageBus,
                        RouteBus:             routeBus,
                },
                AuthClientConfig: mux.AuthClientConfig{
                        AuthClient: autclint,
                },
        }

        webAPI := mux.WebAPI(cfgMux, coreall.Routes(), mux.WithCORS(cfg.Web.CORSAllowedOrigins))

        api := http.Server{
                Addr:         cfg.Web.APIHost,
                Handler:      webAPI,
                ReadTimeout:  cfg.Web.ReadTimeout,
                WriteTimeout: cfg.Web.WriteTimeout,
                IdleTimeout:  cfg.Web.IdleTimeout,
                ErrorLog:     logger.NewStdLogger(log, logger.LevelError),
        }

        serverErrors := make(chan error, 1)

        go func() </span><span class="cov0" title="0">{
                log.Info(ctx, "startup", "status", "api router started", "host", api.Addr)

                serverErrors &lt;- api.ListenAndServe()
        }</span>()

        // -------------------------------------------------------------------------
        // Shutdown

        <span class="cov0" title="0">select </span>{
        case err := &lt;-serverErrors:<span class="cov0" title="0">
                return fmt.Errorf("server error: %w", err)</span>

        case sig := &lt;-shutdown:<span class="cov0" title="0">
                log.Info(ctx, "shutdown", "status", "shutdown started", "signal", sig)
                defer log.Info(ctx, "shutdown", "status", "shutdown complete", "signal", sig)

                ctx, cancel := context.WithTimeout(ctx, cfg.Web.ShutdownTimeout)
                defer cancel()

                if err := api.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                        api.Close()
                        return fmt.Errorf("could not stop server gracefully: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Package collector is a simple collector for
package collector

import (
        "errors"
        "io"
        "net"
        "net/http"
        "time"

        "github.com/go-json-experiment/json"
)

// Expvar provides the ability to receive metrics
// from internal services using expvar.
type Expvar struct {
        host   string
        tr     *http.Transport
        client http.Client
}

// New creates a Expvar for collection metrics.
func New(host string) (*Expvar, error) <span class="cov0" title="0">{
        tr := http.Transport{
                Proxy: http.ProxyFromEnvironment,
                DialContext: (&amp;net.Dialer{
                        Timeout:   30 * time.Second,
                        KeepAlive: 30 * time.Second,
                }).DialContext,
                MaxIdleConns:          2,
                IdleConnTimeout:       90 * time.Second,
                TLSHandshakeTimeout:   10 * time.Second,
                ExpectContinueTimeout: 1 * time.Second,
        }

        exp := Expvar{
                host: host,
                tr:   &amp;tr,
                client: http.Client{
                        Transport: &amp;tr,
                        Timeout:   1 * time.Second,
                },
        }

        return &amp;exp, nil
}</span>

// Collect captures metrics on the host configure to this endpoint.
func (exp *Expvar) Collect() (map[string]any, error) <span class="cov0" title="0">{
        req, err := http.NewRequest("GET", exp.host, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">resp, err := exp.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                msg, err := io.ReadAll(resp.Body)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return nil, errors.New(string(msg))</span>
        }

        <span class="cov0" title="0">data := make(map[string]any)
        if err := json.UnmarshalRead(resp.Body, &amp;data); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return data, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package main

import (
        "context"
        "errors"
        "fmt"
        "net/http"
        "os"
        "os/signal"
        "runtime"
        "syscall"
        "time"

        "github.com/FITHSCS/backend/api/services/metrics/collector"
        "github.com/FITHSCS/backend/api/services/metrics/publisher"
        expvarsrv "github.com/FITHSCS/backend/api/services/metrics/publisher/expvar"
        prometheussrv "github.com/FITHSCS/backend/api/services/metrics/publisher/prometheus"
        "github.com/FITHSCS/backend/app/sdk/debug"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/ardanlabs/conf/v3"
)

var build = "develop"

func main() <span class="cov0" title="0">{
        var log *logger.Logger

        events := logger.Events{
                Error: func(ctx context.Context, r logger.Record) </span><span class="cov0" title="0">{ log.Info(ctx, "******* SEND ALERT ******") }</span>,
        }

        <span class="cov0" title="0">traceIDFn := func(ctx context.Context) string </span><span class="cov0" title="0">{
                return "00000000-0000-0000-0000-000000000000"
        }</span>

        <span class="cov0" title="0">log = logger.NewWithEvents(os.Stdout, logger.LevelInfo, "METRICS", traceIDFn, events)

        // -------------------------------------------------------------------------

        ctx := context.Background()

        if err := run(ctx, log); err != nil </span><span class="cov0" title="0">{
                log.Error(ctx, "startup", "err", err)
                os.Exit(1)
        }</span>
}

func run(ctx context.Context, log *logger.Logger) error <span class="cov0" title="0">{

        // -------------------------------------------------------------------------
        // GOMAXPROCS

        log.Info(ctx, "startup", "GOMAXPROCS", runtime.GOMAXPROCS(0))

        // -------------------------------------------------------------------------
        // Configuration

        cfg := struct {
                conf.Version
                Web struct {
                        DebugHost string `conf:"default:0.0.0.0:4010"`
                }
                Expvar struct {
                        Host            string        `conf:"default:0.0.0.0:4000"`
                        Route           string        `conf:"default:/metrics"`
                        ReadTimeout     time.Duration `conf:"default:5s"`
                        WriteTimeout    time.Duration `conf:"default:10s"`
                        IdleTimeout     time.Duration `conf:"default:120s"`
                        ShutdownTimeout time.Duration `conf:"default:5s"`
                }
                Prometheus struct {
                        Host            string        `conf:"default:0.0.0.0:4020"`
                        Route           string        `conf:"default:/metrics"`
                        ReadTimeout     time.Duration `conf:"default:5s"`
                        WriteTimeout    time.Duration `conf:"default:10s"`
                        IdleTimeout     time.Duration `conf:"default:120s"`
                        ShutdownTimeout time.Duration `conf:"default:5s"`
                }
                Collect struct {
                        From string `conf:"default:http://localhost:3010/debug/vars"`
                }
                Publish struct {
                        To       string        `conf:"default:console"`
                        Interval time.Duration `conf:"default:5s"`
                }
        }{
                Version: conf.Version{
                        Build: build,
                        Desc:  "copyright information here",
                },
        }

        const prefix = "METRICS"
        help, err := conf.Parse(prefix, &amp;cfg)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, conf.ErrHelpWanted) </span><span class="cov0" title="0">{
                        fmt.Println(help)
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("parsing config: %w", err)</span>
        }

        // -------------------------------------------------------------------------
        // App Starting

        <span class="cov0" title="0">log.Info(ctx, "starting service", "version", build)
        defer log.Info(ctx, "shutdown complete")

        out, err := conf.String(&amp;cfg)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("generating config for output: %w", err)
        }</span>
        <span class="cov0" title="0">log.Info(ctx, "startup", "config", out)

        log.BuildInfo(ctx)

        // -------------------------------------------------------------------------
        // Start Debug Service

        go func() </span><span class="cov0" title="0">{
                log.Info(ctx, "startup", "status", "debug router started", "host", cfg.Web.DebugHost)

                if err := http.ListenAndServe(cfg.Web.DebugHost, debug.Mux()); err != nil </span><span class="cov0" title="0">{
                        log.Error(ctx, "shutdown", "status", "debug router closed", "host", cfg.Web.DebugHost, "err", err)
                }</span>
        }()

        // -------------------------------------------------------------------------
        // Start Prometheus Service

        <span class="cov0" title="0">prom := prometheussrv.New(log, cfg.Prometheus.Host, cfg.Prometheus.Route, cfg.Prometheus.ReadTimeout, cfg.Prometheus.WriteTimeout, cfg.Prometheus.IdleTimeout)
        defer prom.Stop(cfg.Prometheus.ShutdownTimeout)

        // -------------------------------------------------------------------------
        // Start expvar Service

        exp := expvarsrv.New(log, cfg.Expvar.Host, cfg.Expvar.Route, cfg.Expvar.ReadTimeout, cfg.Expvar.WriteTimeout, cfg.Expvar.IdleTimeout)
        defer exp.Stop(cfg.Expvar.ShutdownTimeout)

        // -------------------------------------------------------------------------
        // Start collectors and publishers

        collector, err := collector.New(cfg.Collect.From)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("starting collector: %w", err)
        }</span>

        <span class="cov0" title="0">stdout := publisher.NewStdout(log)

        publish, err := publisher.New(log, collector, cfg.Publish.Interval, prom.Publish, exp.Publish, stdout.Publish)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("starting publisher: %w", err)
        }</span>
        <span class="cov0" title="0">defer publish.Stop()

        // -------------------------------------------------------------------------
        // Shutdown

        shutdown := make(chan os.Signal, 1)
        signal.Notify(shutdown, syscall.SIGINT, syscall.SIGTERM)
        &lt;-shutdown

        log.Info(ctx, "shutdown", "status", "shutdown started")
        defer log.Info(ctx, "shutdown", "status", "shutdown complete")

        return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Package datadog provides support for publishing metrics to DD.
package datadog

import (
        "bytes"
        "encoding/json"
        "fmt"
        "io"
        "log"
        "net"
        "net/http"
        "time"
)

// Datadog provides the ability to publish metrics to Datadog.
type Datadog struct {
        log    *log.Logger
        apiKey string
        host   string
        tr     *http.Transport
        client http.Client
}

// New initializes Datadog access for publishing metrics.
func New(log *log.Logger, apiKey string, host string) *Datadog <span class="cov0" title="0">{
        tr := http.Transport{
                Proxy: http.ProxyFromEnvironment,
                DialContext: (&amp;net.Dialer{
                        Timeout:   30 * time.Second,
                        KeepAlive: 30 * time.Second,
                }).DialContext,
                MaxIdleConns:          2,
                IdleConnTimeout:       90 * time.Second,
                TLSHandshakeTimeout:   10 * time.Second,
                ExpectContinueTimeout: 1 * time.Second,
        }

        d := Datadog{
                log:    log,
                apiKey: apiKey,
                host:   host,
                tr:     &amp;tr,
                client: http.Client{
                        Transport: &amp;tr,
                        Timeout:   1 * time.Second,
                },
        }

        return &amp;d
}</span>

// Publish handles the processing of metrics for deliver
// to the DataDog.
func (d *Datadog) Publish(data map[string]any) <span class="cov0" title="0">{
        doc, err := marshalDatadog(d.log, data)
        if err != nil </span><span class="cov0" title="0">{
                d.log.Println("datadog.publish :", err)
                return
        }</span>

        <span class="cov0" title="0">if err := sendDatadog(d, doc); err != nil </span><span class="cov0" title="0">{
                d.log.Println("datadog.publish :", err)
                return
        }</span>

        <span class="cov0" title="0">log.Println("datadog.publish : published :", string(doc))</span>
}

// marshalDatadog converts the data map to datadog JSON document.
func marshalDatadog(log *log.Logger, data map[string]any) ([]byte, error) <span class="cov0" title="0">{
        /*
                { "series" : [
                                {
                                        "metric":"test.metric",
                                        "points": [
                                                [
                                                        $currenttime,
                                                        20
                                                ]
                                        ],
                                        "type":"gauge",
                                        "host":"test.example.com",
                                        "tags": [
                                                "environment:test"
                                        ]
                                }
                        ]
                }
        */

        // Extract the base keys/values.
        mType := "gauge"
        host, ok := data["host"].(string)
        if !ok </span><span class="cov0" title="0">{
                host = "unknown"
        }</span>
        <span class="cov0" title="0">env := "dev"
        if host != "localhost" </span><span class="cov0" title="0">{
                env = "prod"
        }</span>
        <span class="cov0" title="0">envTag := "environment:" + env

        // Define the Datadog data format.
        type series struct {
                Metric string   `json:"metric"`
                Points [][]any  `json:"points"`
                Type   string   `json:"type"`
                Host   string   `json:"host"`
                Tags   []string `json:"tags"`
        }

        // Populate the data into the data structure.
        var doc struct {
                Series []series `json:"series"`
        }
        for key, value := range data </span><span class="cov0" title="0">{
                switch value.(type) </span>{
                case int, float64:<span class="cov0" title="0">
                        doc.Series = append(doc.Series, series{
                                Metric: env + "." + key,
                                Points: [][]any{{"$currenttime", value}},
                                Type:   mType,
                                Host:   host,
                                Tags:   []string{envTag},
                        })</span>
                }
        }

        // Convert the data into JSON.
        <span class="cov0" title="0">out, err := json.Marshal(doc)
        if err != nil </span><span class="cov0" title="0">{
                log.Println("datadog.publish : marshaling :", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return out, nil</span>
}

// sendDatadog sends data to the datadog servers.
func sendDatadog(d *Datadog, data []byte) error <span class="cov0" title="0">{
        url := fmt.Sprintf("%s?api_key=%s", d.host, d.apiKey)
        b := bytes.NewBuffer(data)

        r, err := http.NewRequest("POST", url, b)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">resp, err := d.client.Do(r)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusAccepted </span><span class="cov0" title="0">{
                out, err := io.ReadAll(resp.Body)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("status[%d] : %s", resp.StatusCode, out)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("status[%d]", resp.StatusCode)</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Package expvar manages the publishing of metrics to stdout.
package expvar

import (
        "context"
        "encoding/json"
        "fmt"
        "net/http"
        "sync"
        "time"

        "github.com/FITHSCS/backend/foundation/logger"
)

// Expvar provide our basic publishing.
type Expvar struct {
        log    *logger.Logger
        server http.Server
        data   map[string]any
        mu     sync.Mutex
}

// New starts a service for consuming the raw expvar stats.
func New(log *logger.Logger, host string, route string, readTimeout, writeTimeout time.Duration, idleTimeout time.Duration) *Expvar <span class="cov0" title="0">{
        mux := http.NewServeMux()
        exp := Expvar{
                log: log,
                server: http.Server{
                        Addr:         host,
                        Handler:      mux,
                        ReadTimeout:  readTimeout,
                        WriteTimeout: writeTimeout,
                        IdleTimeout:  idleTimeout,
                        ErrorLog:     logger.NewStdLogger(log, logger.LevelError),
                },
        }

        mux.HandleFunc(route, exp.handler)

        go func() </span><span class="cov0" title="0">{
                ctx := context.Background()

                log.Info(ctx, "expvar", "status", "API listening", "host", host)
                if err := exp.server.ListenAndServe(); err != nil </span><span class="cov0" title="0">{
                        log.Error(ctx, "expvar", "err", err)
                }</span>
        }()

        <span class="cov0" title="0">return &amp;exp</span>
}

// Stop shuts down the service.
func (exp *Expvar) Stop(shutdownTimeout time.Duration) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), shutdownTimeout)
        defer cancel()

        exp.log.Info(ctx, "expvar", "status", "start shutdown...")
        defer exp.log.Info(ctx, "expvar: Completed")

        if err := exp.server.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                exp.log.Error(ctx, "expvar", "status", "graceful shutdown did not complete", "err", err, "shutdownTimeout", shutdownTimeout)
                if err := exp.server.Close(); err != nil </span><span class="cov0" title="0">{
                        exp.log.Error(ctx, "expvar", "status", "could not stop http server", "err", err)
                }</span>
        }
}

// Publish is called by the publisher goroutine and saves the raw stats.
func (exp *Expvar) Publish(data map[string]any) <span class="cov0" title="0">{
        exp.mu.Lock()
        </span><span class="cov0" title="0">{
                exp.data = data
        }</span>
        <span class="cov0" title="0">exp.mu.Unlock()</span>
}

// handler is what consumers call to get the raw stats.
func (exp *Expvar) handler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := context.Background()

        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)

        var data map[string]any
        exp.mu.Lock()
        </span><span class="cov0" title="0">{
                data = exp.data
        }</span>
        <span class="cov0" title="0">exp.mu.Unlock()

        if err := json.NewEncoder(w).Encode(data); err != nil </span><span class="cov0" title="0">{
                exp.log.Error(ctx, "expvar", "status", "encoding data", "err", err)
        }</span>

        <span class="cov0" title="0">exp.log.Info(ctx, "expvar", "metrics", fmt.Sprintf("(%d) : %s %s -&gt; %s", http.StatusOK, r.Method, r.URL.Path, r.RemoteAddr))</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// Package prometheus provides suppoert for sending metrics to prometheus.
package prometheus

import (
        "context"
        "fmt"
        "io"
        "net/http"
        "sync"
        "time"

        "github.com/FITHSCS/backend/foundation/logger"
)

// Exporter implements the prometheus exporter support.
type Exporter struct {
        log    *logger.Logger
        server http.Server
        data   map[string]any
        mu     sync.Mutex
}

// New constructs an Exporter for use.
func New(log *logger.Logger, host string, route string, readTimeout, writeTimeout time.Duration, idleTimeout time.Duration) *Exporter <span class="cov0" title="0">{
        mux := http.NewServeMux()

        exp := Exporter{
                log: log,
                server: http.Server{
                        Addr:         host,
                        Handler:      mux,
                        ReadTimeout:  readTimeout,
                        WriteTimeout: writeTimeout,
                        IdleTimeout:  idleTimeout,
                        ErrorLog:     logger.NewStdLogger(log, logger.LevelError),
                },
        }

        mux.HandleFunc(route, exp.handler)

        go func() </span><span class="cov0" title="0">{
                ctx := context.Background()

                log.Info(ctx, "prometheus", "status", "API listening", "host", host)

                if err := exp.server.ListenAndServe(); err != nil </span><span class="cov0" title="0">{
                        log.Error(ctx, "prometheus", "err", err)
                }</span>
        }()

        <span class="cov0" title="0">return &amp;exp</span>
}

// Publish stores a deep copy of the data for publishing.
func (exp *Exporter) Publish(data map[string]any) <span class="cov0" title="0">{
        exp.mu.Lock()
        defer exp.mu.Unlock()

        exp.data = deepCopyMap(data)
}</span>

// Stop turns off all the prometheus support.
func (exp *Exporter) Stop(shutdownTimeout time.Duration) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), shutdownTimeout)
        defer cancel()

        exp.log.Info(ctx, "prometheus", "status", "start shutdown...")
        defer exp.log.Info(ctx, "prometheus: Completed")

        if err := exp.server.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                exp.log.Error(ctx, "prometheus", "status", "graceful shutdown did not complete", "err", err, "shutdownTimeout", shutdownTimeout)

                if err := exp.server.Close(); err != nil </span><span class="cov0" title="0">{
                        exp.log.Error(ctx, "prometheus", "status", "could not stop http server", "err", err)
                }</span>
        }
}

func (exp *Exporter) handler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := context.Background()

        w.Header().Set("Content-Type", "text/plain; version=0.0.4")
        w.WriteHeader(http.StatusOK)

        var data map[string]any
        exp.mu.Lock()
        </span><span class="cov0" title="0">{
                data = deepCopyMap(exp.data)
        }</span>
        <span class="cov0" title="0">exp.mu.Unlock()

        out(w, "", data)

        exp.log.Info(ctx, "prometheus", "metrics", fmt.Sprintf("expvar : (%d) : %s %s -&gt; %s", http.StatusOK, r.Method, r.URL.Path, r.RemoteAddr))</span>
}

func deepCopyMap(source map[string]any) map[string]any <span class="cov0" title="0">{
        result := make(map[string]any)

        for k, v := range source </span><span class="cov0" title="0">{
                switch vm := v.(type) </span>{
                case map[string]any:<span class="cov0" title="0">
                        result[k] = deepCopyMap(vm)</span>

                case int64:<span class="cov0" title="0">
                        result[k] = float64(vm)</span>

                case float64:<span class="cov0" title="0">
                        result[k] = vm</span>

                case bool:<span class="cov0" title="0">
                        result[k] = 0.0
                        if vm </span><span class="cov0" title="0">{
                                result[k] = 1.0
                        }</span>
                }
        }

        <span class="cov0" title="0">return result</span>
}

func out(w io.Writer, prefix string, data map[string]any) <span class="cov0" title="0">{
        if prefix != "" </span><span class="cov0" title="0">{
                prefix += "_"
        }</span>

        <span class="cov0" title="0">for k, v := range data </span><span class="cov0" title="0">{
                writeKey := fmt.Sprintf("%s%s", prefix, k)

                switch vm := v.(type) </span>{
                case float64:<span class="cov0" title="0">
                        fmt.Fprintf(w, "%s %.f\n", writeKey, vm)</span>

                case map[string]any:<span class="cov0" title="0">
                        out(w, writeKey, vm)</span>

                default:<span class="cov0" title="0"></span>
                        // Discard this value.
                }
        }
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// Package publisher manages the publishing of metrics.
package publisher

import (
        "context"
        "encoding/json"
        "sync"
        "time"

        "github.com/FITHSCS/backend/foundation/logger"
)

// Set of possible publisher types.
const (
        TypeStdout  = "stdout"
        TypeDatadog = "datadog"
)

// Collector defines a contract a collector must support
// so a consumer can retrieve metrics.
type Collector interface {
        Collect() (map[string]any, error)
}

// Publisher defines a handler function that will be called
// on each interval.
type Publisher func(map[string]any)

// Publish provides the ability to receive metrics
// on an interval.
type Publish struct {
        log       *logger.Logger
        collector Collector
        publisher []Publisher
        wg        sync.WaitGroup
        timer     *time.Timer
        shutdown  chan struct{}
}

// New creates a Publish for consuming and publishing metrics.
func New(log *logger.Logger, collector Collector, interval time.Duration, publisher ...Publisher) (*Publish, error) <span class="cov0" title="0">{
        p := Publish{
                log:       log,
                collector: collector,
                publisher: publisher,
                timer:     time.NewTimer(interval),
                shutdown:  make(chan struct{}),
        }

        p.wg.Add(1)
        go func() </span><span class="cov0" title="0">{
                defer p.wg.Done()
                for </span><span class="cov0" title="0">{
                        p.timer.Reset(interval)
                        select </span>{
                        case &lt;-p.timer.C:<span class="cov0" title="0">
                                p.update()</span>
                        case &lt;-p.shutdown:<span class="cov0" title="0">
                                return</span>
                        }
                }
        }()

        <span class="cov0" title="0">return &amp;p, nil</span>
}

// Stop is used to shut down the goroutine collecting metrics.
func (p *Publish) Stop() <span class="cov0" title="0">{
        close(p.shutdown)
        p.wg.Wait()
}</span>

// update pulls the metrics and publishes them to the specified system.
func (p *Publish) update() <span class="cov0" title="0">{
        data, err := p.collector.Collect()
        if err != nil </span><span class="cov0" title="0">{
                p.log.Error(context.Background(), "publish", "status", "collect data", "err", err)
                return
        }</span>

        <span class="cov0" title="0">for _, pub := range p.publisher </span><span class="cov0" title="0">{
                pub(data)
        }</span>
}

// Stdout provide our basic publishing.
type Stdout struct {
        log *logger.Logger
}

// NewStdout initializes stdout for publishing metrics.
func NewStdout(log *logger.Logger) *Stdout <span class="cov0" title="0">{
        return &amp;Stdout{log}
}</span>

// Publish publishers for writing to stdout.
func (s *Stdout) Publish(data map[string]any) <span class="cov0" title="0">{
        ctx := context.Background()

        rawJSON, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Error(ctx, "stdout", "status", "marshal data", "err", err)
                return
        }</span>

        <span class="cov0" title="0">var d map[string]any
        if err := json.Unmarshal(rawJSON, &amp;d); err != nil </span><span class="cov0" title="0">{
                s.log.Error(ctx, "stdout", "status", "unmarshal data", "err", err)
                return
        }</span>

        // Add heap value into the data set.
        <span class="cov0" title="0">memStats, ok := (d["memstats"]).(map[string]any)
        if ok </span><span class="cov0" title="0">{
                d["heap"] = memStats["Alloc"]
        }</span>

        // Remove unnecessary keys.
        <span class="cov0" title="0">delete(d, "memstats")
        delete(d, "cmdline")

        out, err := json.Marshal(d)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">s.log.Info(ctx, "stdout", "data", string(out))</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Package syncall binds all the routes into the specified app.
package syncall

import (
        "time"

        "github.com/FITHSCS/backend/app/domain/syncapp"
        "github.com/FITHSCS/backend/app/sdk/mux"
        "github.com/FITHSCS/backend/foundation/web"
        "github.com/segmentio/kafka-go"
)

// Routes constructs the add value which provides the implementation of
// RouteAdder for specifying what routes to bind to this instance.
func Routes() add <span class="cov0" title="0">{
        return add{}
}</span>

type add struct{}

// Add implements the RouterAdder interface.
func (add) Add(app *web.App, cfg mux.Config) <span class="cov0" title="0">{

        syncapp.Routes(app, syncapp.Config{
                Log:          cfg.Log,
                SyncBatchBus: cfg.BusConfig.SyncBatchBus,
                AuthClient:   cfg.AuthClientConfig.AuthClient,
                KafkaConfig: mux.KafkaConfig{
                        Brokers: cfg.KafkaConfig.Brokers,
                        Topic:   cfg.KafkaConfig.Topic,
                },
                KafkaRequiredAcks: kafka.RequireOne, //add default or get from cfg
                KafkaMaxAttempts:  3,                // add default or get from cfg
                KafkaTimeout:      10 * time.Second, // add default or get from cfg
        })
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package main

import (
    "context"
    "errors"
    "expvar"
    "fmt"
    "net/http"
    "os"
    "os/signal"
    "runtime"
    "syscall"
    "time"

    syncall "github.com/FITHSCS/backend/api/services/sync/build/all"
    "github.com/FITHSCS/backend/app/sdk/authclient"
    "github.com/FITHSCS/backend/app/sdk/debug"
    "github.com/FITHSCS/backend/app/sdk/mux"
    "github.com/FITHSCS/backend/foundation/logger"
    //"github.com/FITHSCS/backend/foundation/web"
    "github.com/FITHSCS/backend/business/domain/syncbatchbus"
    "github.com/FITHSCS/backend/business/domain/syncbatchbus/stores/syncbatchdb"
    "github.com/ardanlabs/conf/v3"
    "github.com/FITHSCS/backend/business/sdk/sqldb"
    "github.com/FITHSCS/backend/foundation/otel"
)

var build = "develop"

func main() <span class="cov0" title="0">{
    var log *logger.Logger
    
    events := logger.Events{
      Error: func(ctx context.Context, r logger.Record) </span><span class="cov0" title="0">{
        log.Info(ctx, "******* SEND ALERT *******")
      }</span>,
    }

    <span class="cov0" title="0">traceIDFn := func(ctx context.Context) string </span><span class="cov0" title="0">{
        return otel.GetTraceID(ctx)
    }</span>

    <span class="cov0" title="0">log = logger.NewWithEvents(os.Stdout, logger.LevelInfo, "SYNC", traceIDFn, events)

    ctx := context.Background()

    if err := run(ctx, log); err != nil </span><span class="cov0" title="0">{
        log.Error(ctx, "startup", "err", err)
        os.Exit(1)
    }</span>
}

func run(ctx context.Context, log *logger.Logger) error <span class="cov0" title="0">{
    // GOMAXPROCS
    log.Info(ctx, "startup", "GOMAXPROCS", runtime.GOMAXPROCS(0))

    // Configuration
    cfg := struct {
        conf.Version
        Web struct {
            ReadTimeout        time.Duration `conf:"default:5s"`
            WriteTimeout       time.Duration `conf:"default:10s"`
            IdleTimeout        time.Duration `conf:"default:120s"`
            ShutdownTimeout    time.Duration `conf:"default:20s"`
            APIHost            string        `conf:"default:0.0.0.0:8000"`
            DebugHost          string        `conf:"default:0.0.0.0:8010"`
            CORSAllowedOrigins []string      `conf:"default:*"`
        }
        Auth struct {
            Host string `conf:"default:http://0.0.0.0:6000"`
        }
        DB struct {
          User          string        `conf:"default:postgres"`
          Password      string        `conf:"default:postgres,mask"`
          Host          string        `conf:"default:sync-database"`
          Name          string        `conf:"default:postgres"`
          MaxIdleConns  int           `conf:"default:0"`
          MaxOpenConns  int           `conf:"default:0"`
          DisableTLS    bool          `conf:"default:true"`
        }
        Kafka struct {
            Brokers []string `conf:"default:localhost:9092"`
            Topic   string   `conf:"default:epod-persist"`
        }
    }{
        Version: conf.Version{
            Build: build,
            Desc:  "sync",
        },
    }

    const prefix = "SYNC"
    help, err := conf.Parse(prefix, &amp;cfg)
    if err != nil </span><span class="cov0" title="0">{
        if errors.Is(err, conf.ErrHelpWanted) </span><span class="cov0" title="0">{
            fmt.Println(help)
            return nil
        }</span>
        <span class="cov0" title="0">return fmt.Errorf("parsing config: %w", err)</span>
    }

    // App Starting
    <span class="cov0" title="0">log.Info(ctx, "starting service", "version", cfg.Build)
    defer log.Info(ctx, "shutdown complete")

    out, err := conf.String(&amp;cfg)
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("generating config for output: %w", err)
    }</span>
    <span class="cov0" title="0">log.Info(ctx, "startup", "config", out)

    log.BuildInfo(ctx)

    expvar.NewString("build").Set(cfg.Build)

    //&lt;============= Database ==================&gt;
    log.Info(ctx, "startup", "status", "initializing database support", "hostport", cfg.DB.Host)
    db ,err := sqldb.Open(sqldb.Config {
        User:           cfg.DB.User,
        Password:       cfg.DB.Password,
        Host:           cfg.DB.Host,
        Name:           cfg.DB.Name,
        MaxIdleConns:   cfg.DB.MaxIdleConns,
        MaxOpenConns:   cfg.DB.MaxOpenConns,
        DisableTLS:     cfg.DB.DisableTLS,
    })
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("connecting to db: %w", err)
    }</span>
    <span class="cov0" title="0">defer db.Close()

    // Initialize authentication support
    log.Info(ctx, "startup", "status", "initializing authentication support")
    au := authclient.New(log, cfg.Auth.Host)
    //&lt;=============================Create the syncbatch bus ======================================&gt;

    syncbatchbus := syncbatchbus.NewBusiness(log, syncbatchdb.NewStore(log, db))

    // Start Debug Service
    go func() </span><span class="cov0" title="0">{
        log.Info(ctx, "startup", "status", "debug v1 router started", "host", cfg.Web.DebugHost)
        if err := http.ListenAndServe(cfg.Web.DebugHost, debug.Mux()); err != nil </span><span class="cov0" title="0">{
            log.Error(ctx, "shutdown", "status", "debug v1 router closed", "host", cfg.Web.DebugHost, "msg", err)
        }</span>
    }()

    // Start API Service
    <span class="cov0" title="0">log.Info(ctx, "startup", "status", "initializing V1 API support")

    shutdown := make(chan os.Signal, 1)
    signal.Notify(shutdown, syscall.SIGINT, syscall.SIGTERM)

    cfgMux := mux.Config{
        Build: build,
        Log:   log,
        BusConfig: mux.BusConfig{
            SyncBatchBus: syncbatchbus,
        },
        AuthClientConfig: mux.AuthClientConfig{
            AuthClient: au,
        },
        KafkaConfig: mux.KafkaConfig{
            Brokers: cfg.Kafka.Brokers,
            Topic:   cfg.Kafka.Topic,
        },
    }
    log.Info(ctx, "KafkaBroker", cfgMux.KafkaConfig.Brokers[0], "Kafka Topic", cfgMux.KafkaConfig.Topic)
    webAPI := mux.WebAPI(cfgMux, syncall.Routes(), mux.WithCORS(cfg.Web.CORSAllowedOrigins))

    api := http.Server{
        Addr:         cfg.Web.APIHost,
        Handler:      webAPI,
        ReadTimeout:  cfg.Web.ReadTimeout,
        WriteTimeout: cfg.Web.WriteTimeout,
        IdleTimeout:  cfg.Web.IdleTimeout,
        ErrorLog:     logger.NewStdLogger(log, logger.LevelError),
    }

    serverErrors := make(chan error, 1)

    go func() </span><span class="cov0" title="0">{
        log.Info(ctx, "startup", "status", "api router started", "host", api.Addr)
        serverErrors &lt;- api.ListenAndServe()
    }</span>()

    // Shutdown
    <span class="cov0" title="0">select </span>{
    case err := &lt;-serverErrors:<span class="cov0" title="0">
        return fmt.Errorf("server error: %w", err)</span>
    case sig := &lt;-shutdown:<span class="cov0" title="0">
        log.Info(ctx, "shutdown", "status", "shutdown started", "signal", sig)
        defer log.Info(ctx, "shutdown", "status", "shutdown complete", "signal", sig)

        ctx, cancel := context.WithTimeout(ctx, cfg.Web.ShutdownTimeout)
        defer cancel()

        if err := api.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
            api.Close()
            return fmt.Errorf("could not stop server gracefully: %w", err)
        }</span>
    }

    <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package commands

import (
        "crypto/rand"
        "crypto/rsa"
        "crypto/x509"
        "encoding/pem"
        "fmt"
        "os"
)

// GenKey creates an x509 private/public key for auth tokens.
func GenKey() error <span class="cov0" title="0">{

        // Generate a new private key.
        privateKey, err := rsa.GenerateKey(rand.Reader, 2048)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("generating key: %w", err)
        }</span>

        // Create a file for the private key information in PEM form.
        <span class="cov0" title="0">privateFile, err := os.Create("private.pem")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("creating private file: %w", err)
        }</span>
        <span class="cov0" title="0">defer privateFile.Close()

        // Construct a PEM block for the private key.
        privateBlock := pem.Block{
                Type:  "PRIVATE KEY",
                Bytes: x509.MarshalPKCS1PrivateKey(privateKey),
        }

        // Write the private key to the private key file.
        if err := pem.Encode(privateFile, &amp;privateBlock); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("encoding to private file: %w", err)
        }</span>

        // Create a file for the public key information in PEM form.
        <span class="cov0" title="0">publicFile, err := os.Create("public.pem")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("creating public file: %w", err)
        }</span>
        <span class="cov0" title="0">defer publicFile.Close()

        // Marshal the public key from the private key to PKIX.
        asn1Bytes, err := x509.MarshalPKIXPublicKey(&amp;privateKey.PublicKey)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("marshaling public key: %w", err)
        }</span>

        // Construct a PEM block for the public key.
        <span class="cov0" title="0">publicBlock := pem.Block{
                Type:  "PUBLIC KEY",
                Bytes: asn1Bytes,
        }

        // Write the public key to the public key file.
        if err := pem.Encode(publicFile, &amp;publicBlock); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("encoding to public file: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Println("private and public key files generated")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package commands

import (
        "context"
        "errors"
        "fmt"
        "time"

        "github.com/FITHSCS/backend/business/sdk/migrate"
        "github.com/FITHSCS/backend/business/sdk/sqldb"
)

// ErrHelp provides context that help was given.
var ErrHelp = errors.New("provided help")

// Migrate creates the schema in the database.
func Migrate(cfg sqldb.Config) error <span class="cov0" title="0">{
        db, err := sqldb.Open(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("connect database: %w", err)
        }</span>
        <span class="cov0" title="0">defer db.Close()

        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        if err := migrate.Migrate(ctx, db); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("migrate database: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Println("migrations complete")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package commands

import (
        "context"
        "fmt"
        "time"

        "github.com/FITHSCS/backend/business/sdk/migrate"
        "github.com/FITHSCS/backend/business/sdk/sqldb"
)

// Seed loads test data into the database.
func Seed(cfg sqldb.Config) error <span class="cov0" title="0">{
        db, err := sqldb.Open(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("connect database: %w", err)
        }</span>
        <span class="cov0" title="0">defer db.Close()

        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        if err := migrate.Seed(ctx, db); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("seed database: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Println("seed data complete")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package commands

import (
        "context"
        "fmt"
        "net/mail"
        "time"

        "github.com/FITHSCS/backend/business/domain/userbus"
        "github.com/FITHSCS/backend/business/domain/userbus/stores/userdb"
        "github.com/FITHSCS/backend/business/sdk/sqldb"
        "github.com/FITHSCS/backend/business/types/name"
        "github.com/FITHSCS/backend/business/types/role"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/google/uuid"
)

// UserAdd adds new users into the database.
func UserAdd(log *logger.Logger, cfg sqldb.Config, nme string, email string, password string) error <span class="cov0" title="0">{
        if nme == "" || email == "" || password == "" </span><span class="cov0" title="0">{
                fmt.Println("help: useradd &lt;name&gt; &lt;email&gt; &lt;password&gt;")
                return ErrHelp
        }</span>

        <span class="cov0" title="0">db, err := sqldb.Open(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("connect database: %w", err)
        }</span>
        <span class="cov0" title="0">defer db.Close()

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        userBus := userbus.NewBusiness(log, userdb.NewStore(log, db))

        addr, err := mail.ParseAddress(email)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("parsing email: %w", err)
        }</span>

        <span class="cov0" title="0">nu := userbus.NewUser{
                Name:     name.MustParse(nme),
                Email:    *addr,
                Password: password,
                Roles:    []role.Role{role.Admin, role.User},
        }

        usr, err := userBus.Create(ctx, uuid.UUID{}, nu)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("create user: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Println("user id:", usr.ID)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package main

import (
        "context"
        "errors"
        "fmt"
        "io"
        "os"

        "github.com/FITHSCS/backend/api/tooling/admin/commands"
        "github.com/FITHSCS/backend/business/sdk/sqldb"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/ardanlabs/conf/v3"
)

var build = "develop"

type config struct {
        conf.Version
        Args conf.Args
        DB   struct {
                User         string `conf:"default:postgres"`
                Password     string `conf:"default:postgres,mask"`
                Host         string `conf:"default:database"`
                Name         string `conf:"default:postgres"`
                MaxIdleConns int    `conf:"default:0"`
                MaxOpenConns int    `conf:"default:0"`
                DisableTLS   bool   `conf:"default:true"`
        }
        Auth struct {
                KeysFolder string `conf:"default:zarf/keys/"`
                DefaultKID string `conf:"default:54bb2165-71e1-41a6-af3e-7da4a0e1e2c1"`
        }
}

func main() <span class="cov0" title="0">{
        log := logger.New(io.Discard, logger.LevelInfo, "ADMIN", func(context.Context) string </span><span class="cov0" title="0">{ return "00000000-0000-0000-0000-000000000000" }</span>)

        <span class="cov0" title="0">if err := run(log); err != nil </span><span class="cov0" title="0">{
                if !errors.Is(err, commands.ErrHelp) </span><span class="cov0" title="0">{
                        fmt.Println("msg", err)
                }</span>
                <span class="cov0" title="0">os.Exit(1)</span>
        }
}

func run(log *logger.Logger) error <span class="cov0" title="0">{
        cfg := config{
                Version: conf.Version{
                        Build: build,
                        Desc:  "copyright information here",
                },
        }

        const prefix = "CORE"
        help, err := conf.Parse(prefix, &amp;cfg)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, conf.ErrHelpWanted) </span><span class="cov0" title="0">{
                        fmt.Println(help)
                        return nil
                }</span>

                <span class="cov0" title="0">out, err := conf.String(&amp;cfg)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("generating config for output: %w", err)
                }</span>
                <span class="cov0" title="0">log.Info(context.Background(), "startup", "config", out)

                return fmt.Errorf("parsing config: %w", err)</span>
        }

        <span class="cov0" title="0">return processCommands(cfg.Args, log, cfg)</span>
}

// processCommands handles the execution of the commands specified on
// the command line.
func processCommands(args conf.Args, log *logger.Logger, cfg config) error <span class="cov0" title="0">{
        dbConfig := sqldb.Config{
                User:         cfg.DB.User,
                Password:     cfg.DB.Password,
                Host:         cfg.DB.Host,
                Name:         cfg.DB.Name,
                MaxIdleConns: cfg.DB.MaxIdleConns,
                MaxOpenConns: cfg.DB.MaxOpenConns,
                DisableTLS:   cfg.DB.DisableTLS,
        }

        switch args.Num(0) </span>{
        case "migrate":<span class="cov0" title="0">
                if err := commands.Migrate(dbConfig); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("migrating database: %w", err)
                }</span>

        case "seed":<span class="cov0" title="0">
                if err := commands.Seed(dbConfig); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("seeding database: %w", err)
                }</span>

        case "migrate-seed":<span class="cov0" title="0">
                if err := commands.Migrate(dbConfig); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("migrating database: %w", err)
                }</span>
                <span class="cov0" title="0">if err := commands.Seed(dbConfig); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("seeding database: %w", err)
                }</span>

        case "useradd":<span class="cov0" title="0">
                name := args.Num(1)
                email := args.Num(2)
                password := args.Num(3)
                if err := commands.UserAdd(log, dbConfig, name, email, password); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("adding user: %w", err)
                }</span>

        default:<span class="cov0" title="0">
                fmt.Println("migrate:    create the schema in the database")
                fmt.Println("seed:       add data to the database")
                fmt.Println("useradd:    add a new user to the database")
                return commands.ErrHelp</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">// This program takes the structured log output and makes it readable.
package main

import (
        "bufio"
        "encoding/json"
        "flag"
        "fmt"
        "log"
        "os"
        "os/signal"
        "strings"
        "syscall"
)

var service string

func init() <span class="cov0" title="0">{
        flag.StringVar(&amp;service, "service", "", "filter which service to see")

        shutdown := make(chan os.Signal, 1)
        signal.Notify(shutdown, syscall.SIGINT)
        syscall.Kill(os.Getppid(), syscall.SIGINT)
}</span>

func main() <span class="cov0" title="0">{
        flag.Parse()
        var b strings.Builder

        service := strings.ToLower(service)

        scanner := bufio.NewScanner(os.Stdin)
        for scanner.Scan() </span><span class="cov0" title="0">{
                s := scanner.Text()

                m := make(map[string]any)
                err := json.Unmarshal([]byte(s), &amp;m)
                if err != nil </span><span class="cov0" title="0">{
                        if service == "" </span><span class="cov0" title="0">{
                                fmt.Println(s)
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                // If a service filter was provided, check.
                <span class="cov0" title="0">if service != "" &amp;&amp; strings.ToLower(m["service"].(string)) != service </span><span class="cov0" title="0">{
                        continue</span>
                }

                // I like always having a traceid present in the logs.
                <span class="cov0" title="0">traceID := "00000000-0000-0000-0000-000000000000"
                if v, ok := m["trace_id"]; ok </span><span class="cov0" title="0">{
                        traceID = fmt.Sprintf("%v", v)
                }</span>

                // {"time":"2023-06-01T17:21:11.13704718Z","level":"INFO","msg":"startup","service":"SALES-API","GOMAXPROCS":1}

                // Build out the know portions of the log in the order
                // I want them in.
                <span class="cov0" title="0">b.Reset()
                b.WriteString(fmt.Sprintf("%s: %s: %s: %s: %s: %s: ",
                        m["service"],
                        m["time"],
                        m["file"],
                        m["level"],
                        traceID,
                        m["msg"],
                ))

                // Add the rest of the keys ignoring the ones we already
                // added for the log.
                for k, v := range m </span><span class="cov0" title="0">{
                        switch k </span>{
                        case "service", "time", "file", "level", "trace_id", "msg":<span class="cov0" title="0">
                                continue</span>
                        }

                        // It's nice to see the key[value] in this format
                        // especially since map ordering is random.
                        <span class="cov0" title="0">b.WriteString(fmt.Sprintf("%s[%v]: ", k, v))</span>
                }

                // Write the new log format, removing the last :
                <span class="cov0" title="0">out := b.String()
                fmt.Println(out[:len(out)-2])</span>
        }

        <span class="cov0" title="0">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                log.Println(err)
        }</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">// Package auditbus provides a business logic layer for handling audit events.
package auditbus

import (
        "context"
        "encoding/json"
        "fmt"
        "time"

        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/google/uuid"
)

// Storer interface declares the behavior this package needs to persist and
// retrieve data.
type Storer interface {
        Create(ctx context.Context, audit Audit) error
        Query(ctx context.Context, filter QueryFilter, orderBy order.By, page page.Page) ([]Audit, error)
        Count(ctx context.Context, filter QueryFilter) (int, error)
}

// Business manages the set of APIs for audit access.
type Business struct {
        log    *logger.Logger
        storer Storer
}

// NewBusiness constructs a audit business API for use.
func NewBusiness(log *logger.Logger, storer Storer) *Business <span class="cov1" title="1">{
        return &amp;Business{
                log:    log,
                storer: storer,
        }
}</span>

// Create adds a new audit record to the system.
func (b *Business) Create(ctx context.Context, na NewAudit) (Audit, error) <span class="cov10" title="2">{

        jsonData, err := json.Marshal(na.Data)
        if err != nil </span><span class="cov0" title="0">{
                return Audit{}, fmt.Errorf("marshal object: %w", err)
        }</span>

        <span class="cov10" title="2">audit := Audit{
                ID:        uuid.New(),
                ObjID:     na.ObjID,
                ObjDomain: na.ObjDomain,
                ObjName:   na.ObjName,
                ActorID:   na.ActorID,
                Action:    na.Action,
                Data:      jsonData,
                Message:   na.Message,
                Timestamp: time.Now(),
        }

        if err := b.storer.Create(ctx, audit); err != nil </span><span class="cov0" title="0">{
                return Audit{}, fmt.Errorf("create audit: %w", err)
        }</span>

        <span class="cov10" title="2">return audit, nil</span>
}

// Query retrieves a list of existing audit records.
func (b *Business) Query(ctx context.Context, filter QueryFilter, orderBy order.By, page page.Page) ([]Audit, error) <span class="cov1" title="1">{

        audits, err := b.storer.Query(ctx, filter, orderBy, page)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("query audits: %w", err)
        }</span>

        <span class="cov1" title="1">return audits, nil</span>
}

// Count returns the total number of users.
func (b *Business) Count(ctx context.Context, filter QueryFilter) (int, error) <span class="cov0" title="0">{
        return b.storer.Count(ctx, filter)
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">// Package auditdb contains audit related CRUD functionality.
package auditdb

import (
        "bytes"
        "context"
        "fmt"

        "github.com/FITHSCS/backend/business/domain/auditbus"
        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/business/sdk/sqldb"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/jmoiron/sqlx"
)

// Store manages the set of APIs for audit database access.
type Store struct {
        log *logger.Logger
        db  sqlx.ExtContext
}

// NewStore constructs the API for data access.
func NewStore(log *logger.Logger, db *sqlx.DB) *Store <span class="cov0" title="0">{
        return &amp;Store{
                log: log,
                db:  db,
        }
}</span>

// Create inserts a new audit record into the database.
func (s *Store) Create(ctx context.Context, a auditbus.Audit) error <span class="cov0" title="0">{
        const q = `
        INSERT INTO audit
                (id, obj_id, obj_domain, obj_name, actor_id, action, data, message, timestamp)
        VALUES
                (:id, :obj_id, :obj_domain, :obj_name, :actor_id, :action, :data, :message, :timestamp)`

        dbAudit, err := toDBAudit(a)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := sqldb.NamedExecContext(ctx, s.log, s.db, q, dbAudit); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("namedexeccontext: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *Store) Query(ctx context.Context, filter auditbus.QueryFilter, orderBy order.By, page page.Page) ([]auditbus.Audit, error) <span class="cov0" title="0">{
        data := map[string]any{
                "offset":        (page.Number() - 1) * page.RowsPerPage(),
                "rows_per_page": page.RowsPerPage(),
        }

        const q = `
        SELECT
                id, obj_id, obj_domain, obj_name, actor_id, action, data, message, timestamp
        FROM
                audit
        `

        buf := bytes.NewBufferString(q)
        applyFilter(filter, data, buf)

        orderByClause, err := orderByClause(orderBy)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">buf.WriteString(orderByClause)
        buf.WriteString(" OFFSET :offset ROWS FETCH NEXT :rows_per_page ROWS ONLY")

        var dbAudits []audit
        if err := sqldb.NamedQuerySlice(ctx, s.log, s.db, buf.String(), data, &amp;dbAudits); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("namedqueryslice: %w", err)
        }</span>

        <span class="cov0" title="0">return toBusAudits(dbAudits)</span>
}

// Count returns the total number of users in the DB.
func (s *Store) Count(ctx context.Context, filter auditbus.QueryFilter) (int, error) <span class="cov0" title="0">{
        data := map[string]any{}

        const q = `
        SELECT
                count(1)
        FROM
                audit`

        buf := bytes.NewBufferString(q)
        applyFilter(filter, data, buf)

        var count struct {
                Count int `db:"count"`
        }
        if err := sqldb.NamedQueryStruct(ctx, s.log, s.db, buf.String(), data, &amp;count); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("db: %w", err)
        }</span>

        <span class="cov0" title="0">return count.Count, nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package auditdb

import (
        "bytes"
        "fmt"
        "strings"

        "github.com/FITHSCS/backend/business/domain/auditbus"
)

func applyFilter(filter auditbus.QueryFilter, data map[string]any, buf *bytes.Buffer) <span class="cov0" title="0">{
        var wc []string

        if filter.ObjID != nil </span><span class="cov0" title="0">{
                data["obj_id"] = filter.ObjID
                wc = append(wc, "obj_id = :obj_id")
        }</span>

        <span class="cov0" title="0">if filter.ObjDomain != nil </span><span class="cov0" title="0">{
                data["obj_domain"] = filter.ObjDomain.String()
                wc = append(wc, "obj_domain = :obj_domain")
        }</span>

        <span class="cov0" title="0">if filter.ObjName != nil </span><span class="cov0" title="0">{
                data["obj_name"] = fmt.Sprintf("%%%s%%", filter.ObjName.String())
                wc = append(wc, "obj_name LIKE :obj_name")
        }</span>

        <span class="cov0" title="0">if filter.ActorID != nil </span><span class="cov0" title="0">{
                data["actor_id"] = filter.ActorID
                wc = append(wc, "actor_id = :actor_id")
        }</span>

        <span class="cov0" title="0">if filter.Action != nil </span><span class="cov0" title="0">{
                data["action"] = filter.Action
                wc = append(wc, "action = :action")
        }</span>

        <span class="cov0" title="0">if filter.Since != nil </span><span class="cov0" title="0">{
                data["since"] = filter.Since
                wc = append(wc, "timestamp &gt;= :since")
        }</span>

        <span class="cov0" title="0">if filter.Until != nil </span><span class="cov0" title="0">{
                data["until"] = filter.Until
                wc = append(wc, "timestamp &lt;= :until")
        }</span>

        <span class="cov0" title="0">if len(wc) &gt; 0 </span><span class="cov0" title="0">{
                buf.WriteString(" WHERE ")
                buf.WriteString(strings.Join(wc, " AND "))
        }</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package auditdb

import (
        "encoding/json"
        "fmt"
        "time"

        "github.com/FITHSCS/backend/business/domain/auditbus"
        "github.com/FITHSCS/backend/business/types/domain"
        "github.com/FITHSCS/backend/business/types/name"
        "github.com/google/uuid"
        "github.com/jmoiron/sqlx/types"
)

type audit struct {
        ID        uuid.UUID          `db:"id"`
        ObjID     uuid.UUID          `db:"obj_id"`
        ObjDomain string             `db:"obj_domain"`
        ObjName   string             `db:"obj_name"`
        ActorID   uuid.UUID          `db:"actor_id"`
        Action    string             `db:"action"`
        Data      types.NullJSONText `db:"data"`
        Message   string             `db:"message"`
        Timestamp time.Time          `db:"timestamp"`
}

func toDBAudit(bus auditbus.Audit) (audit, error) <span class="cov0" title="0">{
        db := audit{
                ID:        bus.ID,
                ObjID:     bus.ObjID,
                ObjDomain: bus.ObjDomain.String(),
                ObjName:   bus.ObjName.String(),
                ActorID:   bus.ActorID,
                Action:    bus.Action,
                Data:      types.NullJSONText{JSONText: []byte(bus.Data), Valid: true},
                Message:   bus.Message,
                Timestamp: bus.Timestamp.UTC(),
        }

        return db, nil
}</span>

func toBusAudit(db audit) (auditbus.Audit, error) <span class="cov0" title="0">{
        domain, err := domain.Parse(db.ObjDomain)
        if err != nil </span><span class="cov0" title="0">{
                return auditbus.Audit{}, fmt.Errorf("parse domain: %w", err)
        }</span>

        <span class="cov0" title="0">name, err := name.Parse(db.ObjName)
        if err != nil </span><span class="cov0" title="0">{
                return auditbus.Audit{}, fmt.Errorf("parse name: %w", err)
        }</span>

        <span class="cov0" title="0">bus := auditbus.Audit{
                ID:        db.ID,
                ObjID:     db.ObjID,
                ObjDomain: domain,
                ObjName:   name,
                ActorID:   db.ActorID,
                Action:    db.Action,
                Data:      json.RawMessage(db.Data.JSONText),
                Message:   db.Message,
                Timestamp: db.Timestamp.Local(),
        }

        return bus, nil</span>
}

func toBusAudits(dbs []audit) ([]auditbus.Audit, error) <span class="cov0" title="0">{
        audits := make([]auditbus.Audit, len(dbs))

        for i, db := range dbs </span><span class="cov0" title="0">{
                a, err := toBusAudit(db)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">audits[i] = a</span>
        }

        <span class="cov0" title="0">return audits, nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package auditdb

import (
        "fmt"

        "github.com/FITHSCS/backend/business/domain/auditbus"
        "github.com/FITHSCS/backend/business/sdk/order"
)

var orderByFields = map[string]string{
        auditbus.OrderByObjID:     "obj_id",
        auditbus.OrderByObjDomain: "obj_domain",
        auditbus.OrderByObjName:   "obj_name",
        auditbus.OrderByActorID:   "actor_id",
        auditbus.OrderByAction:    "action",
}

func orderByClause(orderBy order.By) (string, error) <span class="cov0" title="0">{

        by, exists := orderByFields[orderBy.Field]
        if !exists </span><span class="cov0" title="0">{
                return "", fmt.Errorf("field %q does not exist", orderBy.Field)
        }</span>

        <span class="cov0" title="0">return " ORDER BY " + by + " " + orderBy.Direction, nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package auditbus

import (
        "context"
        "fmt"
        "math/rand"

        "github.com/FITHSCS/backend/business/types/domain"
        "github.com/FITHSCS/backend/business/types/name"
        "github.com/google/uuid"
)

// TestNewAudits is a helper method for testing.
func TestNewAudits(n int, actorID uuid.UUID, objDomain domain.Domain, action string) []NewAudit <span class="cov1" title="1">{
        newAudits := make([]NewAudit, n)

        idx := rand.Intn(10000)
        for i := range n </span><span class="cov10" title="2">{
                idx++

                na := NewAudit{
                        ObjID:     uuid.New(),
                        ObjDomain: objDomain,
                        ObjName:   name.MustParse(fmt.Sprintf("ObjName%d", idx)),
                        ActorID:   actorID,
                        Action:    action,
                        Data:      struct{ Name string }{Name: fmt.Sprintf("Name%d", idx)},
                        Message:   fmt.Sprintf("Message%d", idx),
                }

                newAudits[i] = na
        }</span>

        <span class="cov1" title="1">return newAudits</span>
}

// TestSeedAudits is a helper method for testing.
func TestSeedAudits(ctx context.Context, n int, actorID uuid.UUID, objDomain domain.Domain, action string, api *Business) ([]Audit, error) <span class="cov1" title="1">{
        newAudits := TestNewAudits(n, actorID, objDomain, action)

        audits := make([]Audit, len(newAudits))
        for i, na := range newAudits </span><span class="cov10" title="2">{
                adt, err := api.Create(ctx, na)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("seeding audit: idx: %d : %w", i, err)
                }</span>

                <span class="cov10" title="2">audits[i] = adt</span>
        }

        <span class="cov1" title="1">return audits, nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">// Package delexceptionbus provides business access to facilities domain.
package delexceptionbus

import (
        "context"
        "errors"
        "fmt"
        "time"

        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/google/uuid"
)

var (
        ErrNotFound              = errors.New("exception not found")
        ErrAuthenticationFailure = errors.New("authentication failed")
)

type Storer interface {
        Create(ctx context.Context, delexception DeliveryException) error
        Update(ctx context.Context, delexception DeliveryException) error
        SoftDelete(ctx context.Context, delexceptionID uuid.UUID) error
        HardDelete(ctx context.Context, delexceptionID uuid.UUID) error
        Query(ctx context.Context, filter QueryFilter, orderby order.By, page page.Page) ([]DeliveryException, error)
        Count(ctx context.Context, filter QueryFilter) (int, error)
        QueryByID(ctx context.Context, facilityID uuid.UUID) (DeliveryException, error)
}

type Business struct {
        log    *logger.Logger
        storer Storer
}

func NewBusiness(log *logger.Logger, storer Storer) *Business <span class="cov1" title="1">{
        return &amp;Business{
                log:    log,
                storer: storer,
        }
}</span>

func (b *Business) Create(ctx context.Context, nde NewDeliveryException) (DeliveryException, error) <span class="cov10" title="6">{
        now := time.Now().Truncate(time.Microsecond)

        facility := DeliveryException{
                ExceptionID:      uuid.New(),
                ManifestID:       nde.ManifestID,
                DeliveryPersonID: nde.DeliveryPersonID,
                Severity:         nde.Severity,
                ExceptionType:    nde.ExceptionType,
                Description:      nde.Description,
                CapturedAt:       nde.CapturedAt,
                ResolutionStatus: nde.ResolutionStatus,
                ResolvedBy:       nde.ResolvedBy,
                IsDeleted:        false,
                IsSynced:         nde.IsSynced,
                TimeStamp:        nde.TimeStamp,
                CreatedAt:        now,
                UpdatedAt:        now,
        }
        if err := b.storer.Create(ctx, facility); err != nil </span><span class="cov0" title="0">{
                return DeliveryException{}, fmt.Errorf("create: %w", err)
        }</span>
        <span class="cov10" title="6">return facility, nil</span>
}

func (b *Business) Update(ctx context.Context, excID uuid.UUID, uptdelexc UpdateDeliveryException) (DeliveryException, error) <span class="cov4" title="2">{

        delexcDBRtrvd, err := b.storer.QueryByID(ctx, excID)
        if err != nil </span><span class="cov0" title="0">{
                return DeliveryException{}, fmt.Errorf("Update: %w", err)
        }</span>

        <span class="cov4" title="2">if uptdelexc.ManifestID != nil </span><span class="cov4" title="2">{
                delexcDBRtrvd.ManifestID = *uptdelexc.ManifestID
        }</span>

        <span class="cov4" title="2">if uptdelexc.DeliveryPersonID != nil </span><span class="cov4" title="2">{
                delexcDBRtrvd.DeliveryPersonID = *uptdelexc.DeliveryPersonID
        }</span>

        <span class="cov4" title="2">if uptdelexc.Severity != nil </span><span class="cov4" title="2">{
                delexcDBRtrvd.Severity = *uptdelexc.Severity
        }</span>

        <span class="cov4" title="2">if uptdelexc.ExceptionType != nil </span><span class="cov4" title="2">{
                delexcDBRtrvd.ExceptionType = *uptdelexc.ExceptionType
        }</span>

        <span class="cov4" title="2">if uptdelexc.Description != nil </span><span class="cov4" title="2">{
                delexcDBRtrvd.Description = *uptdelexc.Description
        }</span>

        <span class="cov4" title="2">if uptdelexc.ResolutionStatus != nil </span><span class="cov4" title="2">{
                delexcDBRtrvd.ResolutionStatus = *uptdelexc.ResolutionStatus
        }</span>

        <span class="cov4" title="2">if uptdelexc.ResolvedBy != nil </span><span class="cov4" title="2">{
                delexcDBRtrvd.ResolvedBy = *uptdelexc.ResolvedBy
        }</span>

        <span class="cov4" title="2">delexcDBRtrvd.UpdatedAt = time.Now().Truncate(time.Microsecond)

        if err := b.storer.Update(ctx, delexcDBRtrvd); err != nil </span><span class="cov0" title="0">{
                return DeliveryException{}, fmt.Errorf("update: %w", err)
        }</span>
        <span class="cov4" title="2">return delexcDBRtrvd, nil</span>
}

func (b *Business) QueryByID(ctx context.Context, excID uuid.UUID) (DeliveryException, error) <span class="cov1" title="1">{

        facility, err := b.storer.QueryByID(ctx, excID)
        if err != nil </span><span class="cov0" title="0">{
                return DeliveryException{}, fmt.Errorf("query: deliveryExceptionID[%s]: %w", excID, err)
        }</span>
        <span class="cov1" title="1">return facility, nil</span>
}
func (b *Business) Query(ctx context.Context, filter QueryFilter, orderBy order.By, page page.Page) ([]DeliveryException, error) <span class="cov1" title="1">{

        delExceptions, err := b.storer.Query(ctx, filter, orderBy, page)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Query: %w", err)
        }</span>
        <span class="cov1" title="1">return delExceptions, nil</span>
}

func (b *Business) Count(ctx context.Context, filter QueryFilter) (int, error) <span class="cov0" title="0">{
        return b.storer.Count(ctx, filter)
}</span>

func (b *Business) SoftDelete(ctx context.Context, delExceptionID uuid.UUID) error <span class="cov4" title="2">{

        facility, err := b.storer.QueryByID(ctx, delExceptionID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("softdeletequery: delExceptionID[%s]: %w", delExceptionID, err)
        }</span>

        <span class="cov4" title="2">if facility.IsDeleted </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: already deleted", delExceptionID)
        }</span>

        <span class="cov4" title="2">if err := b.storer.SoftDelete(ctx, delExceptionID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("delete: %w", err)
        }</span>
        <span class="cov4" title="2">return nil</span>

}

func (b *Business) HardDelete(ctx context.Context, delExceptionID uuid.UUID) error <span class="cov4" title="2">{

        if err := b.storer.HardDelete(ctx, delExceptionID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("delete: %w", err)
        }</span>
        <span class="cov4" title="2">return nil</span>

}
</pre>
		
		<pre class="file" id="file25" style="display: none">// Package delexceptiondb contains product related CRUD functionality.
package delexceptiondb

import (
        "bytes"
        "context"
        "errors"
        "fmt"

        "github.com/FITHSCS/backend/business/domain/delexceptionbus"
        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/business/sdk/sqldb"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/google/uuid"
        "github.com/jmoiron/sqlx"
)

type Store struct {
        log *logger.Logger
        db  sqlx.ExtContext
}

func NewStore(log *logger.Logger, db *sqlx.DB) *Store <span class="cov0" title="0">{
        return &amp;Store{
                log: log,
                db:  db,
        }
}</span>

func (s *Store) Create(ctx context.Context, f delexceptionbus.DeliveryException) error <span class="cov0" title="0">{
        const stmt = `
    INSERT INTO delivery_exception (
      exception_id,
          manifest_id,
          delivery_personnel_id,
          severity,
          exception_type,
          description,
      captured_at,
          resolution_status,
          resolved_by,
          is_deleted,
          is_synced,
          time_stamp,
      created_at,
          updated_at
    ) VALUES (
      :exception_id, 
          :manifest_id, 
          :delivery_personnel_id, 
          :severity,
          :exception_type, 
          :description,
      :captured_at, 
          :resolution_status, 
          :resolved_by,
      :is_deleted,
          :is_synced,
          :time_stamp,
      :created_at, 
          :updated_at
    )`

        return sqldb.NamedExecContext(ctx, s.log, s.db, stmt, toDBDeliveryException(f))
}</span>

func (s *Store) Update(ctx context.Context, f delexceptionbus.DeliveryException) error <span class="cov0" title="0">{
        const stmt = `
    UPDATE 
                delivery_exception
        SET 
                manifest_id                           = :manifest_id,
            delivery_personnel_id   = :delivery_personnel_id,
                severity                                = :severity,
            exception_type                 = :exception_type,
                description                         = :description, 
            resolution_status       = :resolution_status,
            resolved_by                         = :resolved_by,
               updated_at                      = :updated_at
    WHERE 
                exception_id = :exception_id`
        return sqldb.NamedExecContext(ctx, s.log, s.db, stmt, toDBDeliveryException(f))
}</span>

func (s *Store) Query(ctx context.Context, filter delexceptionbus.QueryFilter, orderBy order.By, page page.Page) ([]delexceptionbus.DeliveryException, error) <span class="cov0" title="0">{

        data := map[string]any{
                "offset":        (page.Number() - 1) * page.RowsPerPage(),
                "rows_per_page": page.RowsPerPage(),
        }

        const q = `
    SELECT
      exception_id,
          manifest_id,
          delivery_personnel_id,
          severity,
          exception_type,
          description,
      captured_at,
          resolution_status,
          resolved_by,
          is_deleted,
          is_synced,
          time_stamp,
      created_at,
          updated_at
    FROM 
                delivery_exception`

        buf := bytes.NewBufferString(q)
        s.applyFilter(filter, data, buf)

        orderByClause, err := orderByClause(orderBy)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">buf.WriteString(orderByClause)
        buf.WriteString(" OFFSET :offset ROWS FETCH NEXT :rows_per_page ROWS ONLY")

        var dbRecs []deliveryexceptiondb
        if err := sqldb.NamedQuerySlice(ctx, s.log, s.db, buf.String(), data, &amp;dbRecs); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("namedqueryslice: %w", err)
        }</span>
        <span class="cov0" title="0">fmt.Println(dbRecs)
        return toBusDeliveryExceptions(dbRecs)</span>
}

// Count returns the total number of users in the DB.
func (s *Store) Count(ctx context.Context, filter delexceptionbus.QueryFilter) (int, error) <span class="cov0" title="0">{
        data := map[string]any{}

        const q = `
        SELECT
                count(1)
        FROM
                delivery_exception`

        buf := bytes.NewBufferString(q)
        s.applyFilter(filter, data, buf)

        var count struct {
                Count int `db:"count"`
        }
        if err := sqldb.NamedQueryStruct(ctx, s.log, s.db, buf.String(), data, &amp;count); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("db: %w", err)
        }</span>

        <span class="cov0" title="0">return count.Count, nil</span>
}

func (s *Store) QueryByID(ctx context.Context, id uuid.UUID) (delexceptionbus.DeliveryException, error) <span class="cov0" title="0">{
        param := map[string]any{
                "exception_id": id.String(),
        }
        const stmt = `
    SELECT
                exception_id,
                manifest_id,
                delivery_personnel_id,
                severity,
                exception_type,
                description,
                captured_at,
                resolution_status,
                resolved_by,
                is_deleted,
                is_synced,
                time_stamp,
                created_at,
                updated_at
          FROM 
                delivery_exception
          WHERE 
                exception_id = :exception_id`

        var rec deliveryexceptiondb
        if err := sqldb.NamedQueryStruct(ctx, s.log, s.db, stmt, param, &amp;rec); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sqldb.ErrDBNotFound) </span><span class="cov0" title="0">{
                        return delexceptionbus.DeliveryException{}, delexceptionbus.ErrNotFound
                }</span>
                <span class="cov0" title="0">return delexceptionbus.DeliveryException{}, err</span>
        }
        <span class="cov0" title="0">return toBusDeliveryException(rec)</span>
}

func (s *Store) SoftDelete(ctx context.Context, DeliveryExceptionID uuid.UUID) error <span class="cov0" title="0">{

        const q = `
    UPDATE
        delivery_exception
        SET
                is_deleted = :is_deleted
    WHERE
        exception_id = :exception_id`

        dbDeliveryException := deliveryexceptiondb{ExceptionID: DeliveryExceptionID, IsDeleted: true}

        if err := sqldb.NamedExecContext(ctx, s.log, s.db, q, dbDeliveryException); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("namedexeccontext: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *Store) HardDelete(ctx context.Context, DeliveryExceptionID uuid.UUID) error <span class="cov0" title="0">{

        const q = `
    DELETE FROM
        delivery_exception
    WHERE
        exception_id = :exception_id`

        dbDeliveryException := deliveryexceptiondb{ExceptionID: DeliveryExceptionID}

        if err := sqldb.NamedExecContext(ctx, s.log, s.db, q, dbDeliveryException); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("namedexeccontext: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package delexceptiondb

import (
        "bytes"
        "strings"

        "github.com/FITHSCS/backend/business/domain/delexceptionbus"
)

func (s *Store) applyFilter(filter delexceptionbus.QueryFilter, data map[string]any, buf *bytes.Buffer) <span class="cov0" title="0">{

        var wc []string

        if filter.CreatedAt != nil </span><span class="cov0" title="0">{
                data["created_at"] = filter.CreatedAt.UTC()
                wc = append(wc, "created_at &gt;= :created_at")
        }</span>

        <span class="cov0" title="0">if filter.UpdatedAt != nil </span><span class="cov0" title="0">{
                data["updated_at"] = filter.UpdatedAt.UTC()
                wc = append(wc, "updated_at &lt;= :updated_at")
        }</span>

        <span class="cov0" title="0">if len(wc) &gt; 0 </span><span class="cov0" title="0">{
                buf.WriteString(" WHERE ")
                buf.WriteString(strings.Join(wc, " AND "))
        }</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package delexceptiondb

import (
        "fmt"
        "time"

        "github.com/FITHSCS/backend/business/domain/delexceptionbus"
        "github.com/FITHSCS/backend/business/types/genstringtype"
        "github.com/google/uuid"
)

type deliveryexceptiondb struct {
        ExceptionID      uuid.UUID     `db:"exception_id"`
        ManifestID       uuid.UUID     `db:"manifest_id"`
        DeliveryPersonID uuid.UUID     `db:"delivery_personnel_id"`
        Severity         string        `db:"severity"`
        ExceptionType    string        `db:"exception_type"`
        Description      string        `db:"description"`
        CapturedAt       time.Time     `db:"captured_at"`
        ResolutionStatus string        `db:"resolution_status"`
        ResolvedBy       uuid.NullUUID `db:"resolved_by"`
        IsDeleted        bool          `db:"is_deleted"`
        IsSynced         bool          `db:"is_synced"`
        TimeStamp        time.Time     `db:"time_stamp"`
        CreatedAt        time.Time     `db:"created_at"`
        UpdatedAt        time.Time     `db:"updated_at"`
}

func toDBDeliveryException(bus delexceptionbus.DeliveryException) deliveryexceptiondb <span class="cov0" title="0">{

        return deliveryexceptiondb{
                ExceptionID:      bus.ExceptionID,
                ManifestID:       bus.ManifestID,
                DeliveryPersonID: bus.DeliveryPersonID,
                Severity:         bus.Severity.String(),
                ExceptionType:    bus.ExceptionType.String(),
                Description:      bus.Description.String(),
                CapturedAt:       bus.CapturedAt.UTC(),
                ResolutionStatus: bus.ResolutionStatus.String(),
                ResolvedBy:       bus.ResolvedBy,
                IsDeleted:        bus.IsDeleted,
                IsSynced:         bus.IsSynced,
                TimeStamp:        bus.TimeStamp.UTC(),
                CreatedAt:        bus.CreatedAt.UTC(),
                UpdatedAt:        bus.UpdatedAt.UTC(),
        }
}</span>

func toBusDeliveryException(db deliveryexceptiondb) (delexceptionbus.DeliveryException, error) <span class="cov0" title="0">{

        exctype, err := genstringtype.Parse(db.ExceptionType)
        if err != nil </span><span class="cov0" title="0">{
                return delexceptionbus.DeliveryException{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">desc, err := genstringtype.Parse(db.Description)
        if err != nil </span><span class="cov0" title="0">{
                return delexceptionbus.DeliveryException{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">resusts, err := genstringtype.Parse(db.ResolutionStatus)
        if err != nil </span><span class="cov0" title="0">{
                return delexceptionbus.DeliveryException{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">sev, err := genstringtype.Parse(db.Severity)
        if err != nil </span><span class="cov0" title="0">{
                return delexceptionbus.DeliveryException{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">bus := delexceptionbus.DeliveryException{
                ExceptionID:      db.ExceptionID,
                ManifestID:       db.ManifestID,
                DeliveryPersonID: db.DeliveryPersonID,
                Severity:         sev,
                ExceptionType:    exctype,
                Description:      desc,
                CapturedAt:       db.CapturedAt.In(time.Local),
                ResolutionStatus: resusts,
                ResolvedBy:       db.ResolvedBy,
                IsDeleted:        db.IsDeleted,
                IsSynced:         db.IsSynced,
                TimeStamp:        db.TimeStamp.In(time.Local),
                CreatedAt:        db.CreatedAt.In(time.Local),
                UpdatedAt:        db.UpdatedAt.In(time.Local),
        }
        return bus, nil</span>

}

func toBusDeliveryExceptions(dbs []deliveryexceptiondb) ([]delexceptionbus.DeliveryException, error) <span class="cov0" title="0">{
        bus := make([]delexceptionbus.DeliveryException, len(dbs))
        for i, db := range dbs </span><span class="cov0" title="0">{
                var err error
                bus[i], err = toBusDeliveryException(db)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">return bus, nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package delexceptiondb

import (
        "fmt"

        "github.com/FITHSCS/backend/business/domain/delexceptionbus"
        "github.com/FITHSCS/backend/business/sdk/order"
)

var orderByFields = map[string]string{
        delexceptionbus.OrderByExceptionID:      "exception_id",
        delexceptionbus.OrderByManifestID:       "manifest_id",
        delexceptionbus.OrderByExceptionType:    "exception_type",
        delexceptionbus.OrderByResolutionStatus: "resolution_status",
        delexceptionbus.OrderByCreatedAt:        "created_at",
        delexceptionbus.OrderByUpdatedAt:        "updated_at",
}

// orderByClause converts an order.By value into the final
// " ORDER BY  ASC|DESC" fragment the store adds to its SELECT.
func orderByClause(ob order.By) (string, error) <span class="cov0" title="0">{
        col, ok := orderByFields[ob.Field]
        if !ok </span><span class="cov0" title="0">{
                return "", fmt.Errorf("field %q does not exist", ob.Field)
        }</span>
        <span class="cov0" title="0">return " ORDER BY " + col + " " + ob.Direction, nil</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package delexceptionbus

import (
        "context"
        "fmt"
        "math/rand"
        "time"

        "github.com/FITHSCS/backend/business/types/genstringtype"
        "github.com/google/uuid"
)

func TestGenerateNewDeliveryException(n int, manID, delpersID, resBy uuid.UUID) []NewDeliveryException <span class="cov5" title="2">{
        newfs := make([]NewDeliveryException, n)
        svr := []string{"low", "medium", "high"}
        exetype := []string{"damaged", "descripancy", "refused", "no_recipient", "wrong_address", "other"}
        resolsts := []string{"pending", "resolved"}
        resby := []uuid.NullUUID{
                {UUID: resBy, Valid: true},
                {UUID: uuid.UUID{}, Valid: false},
        }

        CapturedAt, _ := time.Parse(time.RFC3339, "2025-06-10T15:59:33+03:00")
        timestamp := CapturedAt.Add(time.Minute + 1)

        idx := rand.Intn(10000)
        for i := range n </span><span class="cov10" title="4">{
                idx++

                nf := NewDeliveryException{
                        ManifestID:       manID,
                        DeliveryPersonID: delpersID,
                        Severity:         genstringtype.MustParse(svr[i%3]),
                        ExceptionType:    genstringtype.MustParse(exetype[i%6]),
                        Description:      genstringtype.MustParse("This is the description for this exception"),
                        CapturedAt:       CapturedAt,
                        ResolutionStatus: genstringtype.MustParse(resolsts[i%2]),
                        ResolvedBy:       resby[i%2],
                        IsSynced:         true,
                        TimeStamp:        timestamp,
                }

                newfs[i] = nf
        }</span>

        <span class="cov5" title="2">return newfs</span>
}

func TestGenerateSeedDeliveryException(ctx context.Context, n int, api *Business, manID, delpersID, resBy uuid.UUID) ([]DeliveryException, error) <span class="cov5" title="2">{
        newfs := TestGenerateNewDeliveryException(n, manID, delpersID, resBy)

        facs := make([]DeliveryException, len(newfs))
        for i, np := range newfs </span><span class="cov10" title="4">{
                prd, err := api.Create(ctx, np)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("seeding deliveryexception: idx: %d : %w", i, err)
                }</span>

                <span class="cov10" title="4">facs[i] = prd</span>
        }

        <span class="cov5" title="2">return facs, nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">// Package facilitybus provides business access to facilities domain.
package facilitybus

import (
        "context"
        "errors"
        "fmt"

        "time"

        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/google/uuid"
)

var (
        ErrNotFound              = errors.New("facility not found")
        ErrAuthenticationFailure = errors.New("authentication failed")
)

type Storer interface {
        Create(ctx context.Context, facility Facility) error
        Update(ctx context.Context, facility Facility) error
        SoftDelete(ctx context.Context, facilityID uuid.UUID) error
        HardDelete(ctx context.Context, facilityID uuid.UUID) error
        Query(ctx context.Context, filter QueryFilter, orderby order.By, page page.Page) ([]Facility, error)
        Count(ctx context.Context, filter QueryFilter) (int, error)
        QueryByID(ctx context.Context, facilityID uuid.UUID) (Facility, error)
}

func (b *Business) GetStorer() Storer <span class="cov0" title="0">{
        return b.storer
}</span>

type Business struct {
        log    *logger.Logger
        storer Storer
}

func NewBusiness(log *logger.Logger, storer Storer) *Business <span class="cov1" title="1">{
        return &amp;Business{
                log:    log,
                storer: storer,
        }
}</span>

func (b *Business) Create(ctx context.Context, nf NewFacility) (Facility, error) <span class="cov10" title="5">{
        now := time.Now().Truncate(time.Microsecond)

        facility := Facility{
                ID:              uuid.New(),
                FacilityName:    nf.FacilityName,
                FacilityType:    nf.FacilityType,
                Address:         nf.Address,
                Region:          nf.Region,
                Latitude:        nf.Latitude,
                Longitude:       nf.Longitude,
                GeofenceRadius:  nf.GeofenceRadius,
                ContactPersonID: nf.ContactPersonID,
                ContactPhone:    nf.ContactPhone,
                IsDeleted:       false,
                CreatedAt:       now,
                UpdatedAt:       now,
        }
        if err := b.storer.Create(ctx, facility); err != nil </span><span class="cov0" title="0">{
                return Facility{}, fmt.Errorf("create: %w", err)
        }</span>
        <span class="cov10" title="5">return facility, nil</span>
}

func (b *Business) Update(ctx context.Context, facilityID uuid.UUID, updtFacility UpdateFacility) (Facility, error) <span class="cov1" title="1">{

        facDBRetrieved, err := b.storer.QueryByID(ctx, facilityID)
        if err != nil </span><span class="cov0" title="0">{
                return Facility{}, fmt.Errorf("Update: %w", err)
        }</span>

        <span class="cov1" title="1">if updtFacility.FacilityName != nil </span><span class="cov1" title="1">{
                facDBRetrieved.FacilityName = *updtFacility.FacilityName
        }</span>

        <span class="cov1" title="1">if updtFacility.FacilityType != nil </span><span class="cov1" title="1">{
                facDBRetrieved.FacilityType = *updtFacility.FacilityType
        }</span>

        <span class="cov1" title="1">if updtFacility.Address != nil </span><span class="cov1" title="1">{
                facDBRetrieved.Address = *updtFacility.Address
        }</span>

        <span class="cov1" title="1">if updtFacility.Region != nil </span><span class="cov1" title="1">{
                facDBRetrieved.Region = *updtFacility.Region
        }</span>

        <span class="cov1" title="1">if updtFacility.Latitude != nil </span><span class="cov1" title="1">{
                facDBRetrieved.Latitude = *updtFacility.Latitude
        }</span>
        <span class="cov1" title="1">if updtFacility.Longitude != nil </span><span class="cov1" title="1">{
                facDBRetrieved.Longitude = *updtFacility.Longitude
        }</span>
        <span class="cov1" title="1">if updtFacility.GeofenceRadius != nil </span><span class="cov1" title="1">{
                facDBRetrieved.GeofenceRadius = *updtFacility.GeofenceRadius
        }</span>

        <span class="cov1" title="1">if updtFacility.ContactPersonID != nil </span><span class="cov1" title="1">{
                facDBRetrieved.ContactPersonID = *updtFacility.ContactPersonID
        }</span>

        <span class="cov1" title="1">if updtFacility.ContactPhone != nil </span><span class="cov1" title="1">{
                facDBRetrieved.ContactPhone = *updtFacility.ContactPhone
        }</span>

        <span class="cov1" title="1">if updtFacility.IsDeleted != nil </span><span class="cov0" title="0">{
                facDBRetrieved.IsDeleted = *updtFacility.IsDeleted
        }</span>

        <span class="cov1" title="1">facDBRetrieved.UpdatedAt = time.Now().Truncate(time.Microsecond)

        if err := b.storer.Update(ctx, facDBRetrieved); err != nil </span><span class="cov0" title="0">{
                return Facility{}, fmt.Errorf("update: %w", err)
        }</span>
        <span class="cov1" title="1">return facDBRetrieved, nil</span>
}

func (b *Business) QueryByID(ctx context.Context, facilityID uuid.UUID) (Facility, error) <span class="cov1" title="1">{

        facility, err := b.storer.QueryByID(ctx, facilityID)
        if err != nil </span><span class="cov0" title="0">{
                return Facility{}, fmt.Errorf("query: facilityID[%s]: %w", facilityID, err)
        }</span>
        <span class="cov1" title="1">return facility, nil</span>
}
func (b *Business) Query(ctx context.Context, filter QueryFilter, orderBy order.By, page page.Page) ([]Facility, error) <span class="cov1" title="1">{

        facilities, err := b.storer.Query(ctx, filter, orderBy, page)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Query: %w", err)
        }</span>
        <span class="cov1" title="1">return facilities, nil</span>
}

func (b *Business) Count(ctx context.Context, filter QueryFilter) (int, error) <span class="cov0" title="0">{
        return b.storer.Count(ctx, filter)
}</span>

func (b *Business) SoftDelete(ctx context.Context, facilityID uuid.UUID) error <span class="cov0" title="0">{

        facility, err := b.storer.QueryByID(ctx, facilityID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("softdeletequery: facilityID[%s]: %w", facilityID, err)
        }</span>

        <span class="cov0" title="0">if facility.IsDeleted </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: already deleted", facilityID)
        }</span>

        <span class="cov0" title="0">if err := b.storer.SoftDelete(ctx, facilityID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("delete: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>

}

func (b *Business) HardDelete(ctx context.Context, facilityID uuid.UUID) error <span class="cov4" title="2">{

        if err := b.storer.HardDelete(ctx, facilityID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("delete: %w", err)
        }</span>
        <span class="cov4" title="2">return nil</span>

}
</pre>
		
		<pre class="file" id="file31" style="display: none">// Package facilitydb contains product related CRUD functionality.
package facilitydb

import (
        "bytes"
        "context"
        "errors"
        "fmt"

        "github.com/FITHSCS/backend/business/domain/facilitybus"
        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/business/sdk/sqldb"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/google/uuid"
        "github.com/jmoiron/sqlx"
)

// -----------------------------------------------------------------------------
// Store
// -----------------------------------------------------------------------------

type Store struct {
        log *logger.Logger
        db  sqlx.ExtContext
}
func NewStore(log *logger.Logger, db *sqlx.DB) *Store <span class="cov0" title="0">{
        return &amp;Store{
                log: log,
                db:  db,
        }
}</span>

func (s *Store) Create(ctx context.Context, f facilitybus.Facility) error <span class="cov0" title="0">{
        const stmt = `
    INSERT INTO facility (
      facility_id,
          facility_name,
          facility_type,
          address,
          region,
      latitude,
          longitude,
          geofence_radius,
      contact_person_id,
          contact_person_phone,
          is_deleted,
      created_at,
          updated_at
    ) VALUES (
      :facility_id, 
          :facility_name, 
          :facility_type, 
          :address, 
          :region,
      :latitude, 
          :longitude, 
          :geofence_radius,
      :contact_person_id, 
          :contact_person_phone,
      :is_deleted,
      :created_at, 
          :updated_at
    )`

        return sqldb.NamedExecContext(ctx, s.log, s.db, stmt, toDBFacility(f))
}</span>

func (s *Store) Update(ctx context.Context, f facilitybus.Facility) error <span class="cov0" title="0">{
        const stmt = `
    UPDATE 
                facility
        SET 
                facility_name           = :facility_name,
            facility_type           = :facility_type,
            address                 = :address,
                region                                 = :region, 
            latitude                = :latitude,
            longitude               = :longitude,
            geofence_radius         = :geofence_radius,
            contact_person_id          = :contact_person_id,
            contact_person_phone   = :contact_person_phone,
               updated_at              = :updated_at
    WHERE 
                facility_id = :facility_id`
        return sqldb.NamedExecContext(ctx, s.log, s.db, stmt, toDBFacility(f))
}</span>

func (s *Store) Query(ctx context.Context, filter facilitybus.QueryFilter, orderBy order.By, page page.Page) ([]facilitybus.Facility, error) <span class="cov0" title="0">{

        data := map[string]any{
                "offset":        (page.Number() - 1) * page.RowsPerPage(),
                "rows_per_page": page.RowsPerPage(),
        }

        const q = `
    SELECT
              facility_id,
                facility_name, 
                facility_type, 
                address,
                region, 
              latitude, 
                longitude, 
                geofence_radius,      
                contact_person_id, 
                contact_person_phone,  
                is_deleted,    
                created_at, 
                updated_at
    FROM 
                facility`

        buf := bytes.NewBufferString(q)
        s.applyFilter(filter, data, buf)

        orderByClause, err := orderByClause(orderBy)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">buf.WriteString(orderByClause)
        buf.WriteString(" OFFSET :offset ROWS FETCH NEXT :rows_per_page ROWS ONLY")

        var dbRecs []facilitydb
        if err := sqldb.NamedQuerySlice(ctx, s.log, s.db, buf.String(), data, &amp;dbRecs); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("namedqueryslice: %w", err)
        }</span>
        <span class="cov0" title="0">fmt.Println(dbRecs)
        return toBusFacilities(dbRecs)</span>
}

// Count returns the total number of users in the DB.
func (s *Store) Count(ctx context.Context, filter facilitybus.QueryFilter) (int, error) <span class="cov0" title="0">{
        data := map[string]any{}

        const q = `
        SELECT
                count(1)
        FROM
                facility`

        buf := bytes.NewBufferString(q)
        s.applyFilter(filter, data, buf)

        var count struct {
                Count int `db:"count"`
        }
        if err := sqldb.NamedQueryStruct(ctx, s.log, s.db, buf.String(), data, &amp;count); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("db: %w", err)
        }</span>

        <span class="cov0" title="0">return count.Count, nil</span>
}

func (s *Store) QueryByID(ctx context.Context, id uuid.UUID) (facilitybus.Facility, error) <span class="cov0" title="0">{
        param := map[string]any{
                "facility_id": id.String(),
        }
        const stmt = `
    SELECT
                facility_id,
                facility_name,
                facility_type,
                address,
                region,
                latitude, longitude,
                geofence_radius,
                contact_person_id,
                contact_person_phone,
                is_deleted,
                created_at, updated_at
          FROM 
                facility
          WHERE 
                facility_id = :facility_id`

        var rec facilitydb
        if err := sqldb.NamedQueryStruct(ctx, s.log, s.db, stmt, param, &amp;rec); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sqldb.ErrDBNotFound) </span><span class="cov0" title="0">{
                        return facilitybus.Facility{}, facilitybus.ErrNotFound
                }</span>
                <span class="cov0" title="0">return facilitybus.Facility{}, err</span>
        }
        <span class="cov0" title="0">return toBusFacility(rec)</span>
}

func (s *Store) SoftDelete(ctx context.Context, facilityID uuid.UUID) error <span class="cov0" title="0">{

        const q = `
    UPDATE
        facility
        SET
                is_deleted = :is_deleted
    WHERE
        facility_id = :facility_id`

        dbFacility := facilitydb{ID: facilityID, IsDeleted: true}

        if err := sqldb.NamedExecContext(ctx, s.log, s.db, q, dbFacility); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("namedexeccontext: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *Store) HardDelete(ctx context.Context, facilityID uuid.UUID) error <span class="cov0" title="0">{

        const q = `
    DELETE FROM
        facility
    WHERE
        facility_id = :facility_id`

        dbFacility := facilitydb{ID: facilityID}

        if err := sqldb.NamedExecContext(ctx, s.log, s.db, q, dbFacility); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("namedexeccontext: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package facilitydb

import (
        "bytes"
        "strings"

        "github.com/FITHSCS/backend/business/domain/facilitybus"
        "github.com/google/uuid"
)

func (s *Store) applyFilter(filter facilitybus.QueryFilter, data map[string]any, buf *bytes.Buffer) <span class="cov0" title="0">{

        var wc []string

        if filter.ID != uuid.Nil </span><span class="cov0" title="0">{
                data["facility_id"] = &amp;filter.ID
                wc = append(wc, "facility_id = :facility_id")
        }</span>

        <span class="cov0" title="0">if filter.FacilityName != nil </span><span class="cov0" title="0">{
                data["facility_name"] = *filter.FacilityName
                wc = append(wc, "facility_name LIKE :facility_name")
        }</span>
        <span class="cov0" title="0">if filter.FacilityType != nil </span><span class="cov0" title="0">{
                data["facility_type"] = *filter.FacilityType
                wc = append(wc, "facility_type = :facility_type")
        }</span>
        <span class="cov0" title="0">if filter.Address != nil </span><span class="cov0" title="0">{
                data["address"] = *filter.Address
                wc = append(wc, "address LIKE :address")
        }</span>

        <span class="cov0" title="0">if filter.Region != nil </span><span class="cov0" title="0">{
                data["region"] = *filter.Region
                wc = append(wc, "region LIKE :region")
        }</span>
        <span class="cov0" title="0">if filter.Latitude != nil </span><span class="cov0" title="0">{
                data["latitude"] = *filter.Latitude
                wc = append(wc, "latitude = :latitude")
        }</span>
        <span class="cov0" title="0">if filter.Longitude != nil </span><span class="cov0" title="0">{
                data["longitude"] = *filter.Longitude
                wc = append(wc, "longitude = :longitude")
        }</span>
        <span class="cov0" title="0">if filter.GeofenceRadius != nil </span><span class="cov0" title="0">{
                data["geofence_radius"] = *filter.GeofenceRadius
                wc = append(wc, "geofence_radius = :geofence_radius")
        }</span>

        <span class="cov0" title="0">if filter.ContactPerson != nil </span><span class="cov0" title="0">{
                data["contact_person"] = *filter.ContactPerson
                wc = append(wc, "contact_person = :contact_person")
        }</span>

        <span class="cov0" title="0">if filter.ContactPhone != nil </span><span class="cov0" title="0">{
                data["contact_phone"] = *filter.ContactPhone
                wc = append(wc, "contact_phone = :contact_phone")
        }</span>
        <span class="cov0" title="0">if filter.CreatedAt != nil </span><span class="cov0" title="0">{
                data["created_at"] = filter.CreatedAt.UTC()
                wc = append(wc, "created_at &gt;= :created_at")
        }</span>
        <span class="cov0" title="0">if filter.UpdatedAt != nil </span><span class="cov0" title="0">{
                data["updated_at"] = filter.UpdatedAt.UTC()
                wc = append(wc, "updated_at &lt;= :updated_at")
        }</span>
  
        <span class="cov0" title="0">if len(wc) &gt; 0 </span><span class="cov0" title="0">{
                buf.WriteString(" WHERE ")
                buf.WriteString(strings.Join(wc, " AND "))
        }</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package facilitydb

import (
        //"database/sql"
        "fmt"
        //"net/mail"
        "time"

        "github.com/FITHSCS/backend/business/domain/facilitybus"

        "github.com/FITHSCS/backend/business/types/facilitytype"
        "github.com/FITHSCS/backend/business/types/genstringtype"
        "github.com/google/uuid"
)

// &lt;============struct that is going to be passed to database schema =&gt; Final =======&gt;

type facilitydb struct {
        ID              uuid.UUID `db:"facility_id"`
        FacilityName    string    `db:"facility_name"`
        FacilityType    string    `db:"facility_type"`
        Address         string    `db:"address"`
        Region          string    `db:"region"`
        Latitude        float64   `db:"latitude"`
        Longitude       float64   `db:"longitude"`
        GeofenceRadius  float64   `db:"geofence_radius"`
        ContactPersonID uuid.UUID `db:"contact_person_id"`
        ContactPhone    string    `db:"contact_person_phone"`
        IsDeleted       bool      `db:"is_deleted"`
        CreatedAt       time.Time `db:"created_at"`
        UpdatedAt       time.Time `db:"updated_at"`
}

//&lt;==========================================================&gt;

// &lt;====================converting it to DB SCHEMA WHICH WILL BE USED =======================&gt;

func toDBFacility(bus facilitybus.Facility) facilitydb <span class="cov0" title="0">{

        return facilitydb{
                ID:              bus.ID,
                FacilityName:    bus.FacilityName.String(),
                FacilityType:    bus.FacilityType.String(),
                Address:         bus.Address.String(),
                Region:          bus.Region.String(),
                Latitude:        bus.Latitude.Float64(),
                Longitude:       bus.Longitude.Float64(),
                GeofenceRadius:  bus.GeofenceRadius.Float64(),
                ContactPersonID: bus.ContactPersonID,
                ContactPhone:    bus.ContactPhone.String(),
                IsDeleted:       bus.IsDeleted,
                CreatedAt:       bus.CreatedAt.UTC(),
                UpdatedAt:       bus.UpdatedAt.UTC(),
        }
}</span>

// =======================================================================
func toBusFacility(db facilitydb) (facilitybus.Facility, error) <span class="cov0" title="0">{

        facName, err := genstringtype.Parse(db.FacilityName)
        if err != nil </span><span class="cov0" title="0">{
                return facilitybus.Facility{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">facType, err := genstringtype.Parse(db.FacilityType)
        if err != nil </span><span class="cov0" title="0">{
                return facilitybus.Facility{}, fmt.Errorf("parse: %w", err)
        }</span>
        <span class="cov0" title="0">facAddress, err := facilitytype.ParseAddress(db.Address)
        if err != nil </span><span class="cov0" title="0">{
                return facilitybus.Facility{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">facRegion, err := genstringtype.Parse(db.Region)
        if err != nil </span><span class="cov0" title="0">{
                return facilitybus.Facility{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">facLongitude, err := facilitytype.ParseLong(db.Longitude)
        if err != nil </span><span class="cov0" title="0">{
                return facilitybus.Facility{}, fmt.Errorf("parse: %w", err)
        }</span>
        <span class="cov0" title="0">facLatitude, err := facilitytype.ParseLat(db.Latitude)
        if err != nil </span><span class="cov0" title="0">{
                return facilitybus.Facility{}, fmt.Errorf("parse: %w", err)
        }</span>
        <span class="cov0" title="0">facGeofence, err := facilitytype.ParseGeofence(db.GeofenceRadius)
        if err != nil </span><span class="cov0" title="0">{
                return facilitybus.Facility{}, fmt.Errorf("parse: %w", err)
        }</span>
        <span class="cov0" title="0">facContPhone, err := facilitytype.ParseCleanPhoneNumber(db.ContactPhone)
        if err != nil </span><span class="cov0" title="0">{
                return facilitybus.Facility{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">bus := facilitybus.Facility{
                ID:              db.ID,
                FacilityName:    facName,
                FacilityType:    facType,
                Address:         facAddress,
                Region:          facRegion,
                Latitude:        facLatitude,
                Longitude:       facLongitude,
                GeofenceRadius:  facGeofence,
                ContactPersonID: db.ContactPersonID,
                ContactPhone:    facContPhone,
                IsDeleted:       db.IsDeleted,
                CreatedAt:       db.CreatedAt.In(time.Local),
                UpdatedAt:       db.UpdatedAt.In(time.Local),
        }
        return bus, nil</span>

}

func toBusFacilities(dbs []facilitydb) ([]facilitybus.Facility, error) <span class="cov0" title="0">{
        bus := make([]facilitybus.Facility, len(dbs))
        for i, db := range dbs </span><span class="cov0" title="0">{
                var err error
                bus[i], err = toBusFacility(db)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">return bus, nil</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package facilitydb

import (
        "fmt"

        "github.com/FITHSCS/backend/business/domain/facilitybus"
        "github.com/FITHSCS/backend/business/sdk/order"
)

var orderByFields = map[string]string{
        facilitybus.OrderByID:        "facility_id",
        facilitybus.OrderByName:      "name",
        facilitybus.OrderByType:      "type",
        facilitybus.OrderByCreatedAt: "created_at",
        facilitybus.OrderByUpdatedAt: "updated_at",
}

// orderByClause converts an order.By value into the final
// " ORDER BY  ASC|DESC" fragment the store adds to its SELECT.
func orderByClause(ob order.By) (string, error) <span class="cov0" title="0">{
        col, ok := orderByFields[ob.Field]
        if !ok </span><span class="cov0" title="0">{
                return "", fmt.Errorf("field %q does not exist", ob.Field)
        }</span>
        <span class="cov0" title="0">return " ORDER BY " + col + " " + ob.Direction, nil</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package facilitybus

import (
        "context"
        "fmt"
        "math/rand"

        "github.com/FITHSCS/backend/business/types/facilitytype"
        "github.com/FITHSCS/backend/business/types/genstringtype"
        "github.com/google/uuid"
)

func TestGenerateNewFacilities(n int, userID uuid.UUID) []NewFacility <span class="cov5" title="2">{
        newfs := make([]NewFacility, n)
        facTypes := []string{"warehouse", "health_facility"}

        idx := rand.Intn(10000)
        for i := range n </span><span class="cov10" title="4">{
                idx++

                nf := NewFacility{
                        FacilityName:    genstringtype.MustParse(fmt.Sprintf("Name%d", idx)),
                        FacilityType:    genstringtype.MustParse(facTypes[i%2]),
                        Address:         facilitytype.MustParseAddress(fmt.Sprintf("FacName%d", idx)),
                        Region:          genstringtype.MustParse(fmt.Sprintf("Region:%d", idx)),
                        Latitude:        facilitytype.MustParseLat(9.019499778747559),
                        Longitude:       facilitytype.MustParseLong(38.739200592041016),
                        GeofenceRadius:  facilitytype.MustParseGeofence(10.0),
                        ContactPersonID: userID,
                        ContactPhone:    facilitytype.MustParsePhoneNumber(fmt.Sprintf("092233%04d", idx)),
                }

                newfs[i] = nf
        }</span>

        <span class="cov5" title="2">return newfs</span>
}

func TestGenerateSeedFacilities(ctx context.Context, n int, api *Business, usrID uuid.UUID) ([]Facility, error) <span class="cov5" title="2">{
        newfs := TestGenerateNewFacilities(n, usrID)

        facs := make([]Facility, len(newfs))
        for i, np := range newfs </span><span class="cov10" title="4">{
                prd, err := api.Create(ctx, np)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("seeding facilities: idx: %d : %w", i, err)
                }</span>

                <span class="cov10" title="4">facs[i] = prd</span>
        }

        <span class="cov5" title="2">return facs, nil</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">// Package gpstrackingbus provides business access to gps tracking bus domain.
package gpstrackingbus

import (
        "context"
        "errors"
        "fmt"
        "time"

        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/google/uuid"
)

// Set of error variables for CRUD operations.
var (
        ErrNotFound     = errors.New("track and trace not found")
        ErrUserDisabled = errors.New("user disabled")
)

// Storer interface declares the behavior this package needs to persist and
// retrieve data.
type Storer interface {
        Create(ctx context.Context, trackTrace TrackTrace) error
        Update(ctx context.Context, trackTrace TrackTrace) error
        QueryByID(ctx context.Context, trackTraceID uuid.UUID) (TrackTrace, error)
        SoftDelete(ctx context.Context, trackTraceID uuid.UUID) error
        HardDelete(ctx context.Context, trackTraceID uuid.UUID) error
        Query(ctx context.Context, filter QueryFilter, orderBy order.By, page page.Page) ([]TrackTrace, error)
        Count(ctx context.Context, filter QueryFilter) (int, error)
}

func (b *Business) GetStorer() Storer <span class="cov0" title="0">{
        return b.storer
}</span>

// Business manages the set of APIs for epickup access.
type Business struct {
        log    *logger.Logger
        storer Storer
}

// NewBusiness constructs a epickup business API for use.
func NewBusiness(log *logger.Logger, storer Storer) *Business <span class="cov1" title="1">{
        return &amp;Business{
                log:    log,
                storer: storer,
        }

}</span>

// Create adds a new tracktrace to the system.
func (b *Business) Create(ctx context.Context, ntt NewTrackTrace) (TrackTrace, error) <span class="cov10" title="5">{

        now := time.Now().Truncate(time.Millisecond)

        tracktrace := TrackTrace{
                TrackTraceID:        uuid.New(),
                RouteID:             ntt.RouteID,
                DeliveryPersonnelID: ntt.DeliveryPersonnelID,
                VehicleID:           ntt.VehicleID,
                Latitude:            ntt.Latitude,
                Longitude:           ntt.Longitude,
                Accuracy:            ntt.Accuracy,
                Speed:               ntt.Speed,
                BatteryLevel:        ntt.BatteryLevel,
                IsSynced:            ntt.IsSynced,
                TimeStamp:           ntt.TimeStamp,
                IsDeleted:           false,
                CreatedAt:           now,
                UpdatedAt:           now,
        }

        if err := b.storer.Create(ctx, tracktrace); err != nil </span><span class="cov0" title="0">{
                return TrackTrace{}, fmt.Errorf("create: %w", err)
        }</span>

        <span class="cov10" title="5">return tracktrace, nil</span>
}

func (b *Business) Update(ctx context.Context, utracktrace UpdateTrackTrace, trackTraceID uuid.UUID) (TrackTrace, error) <span class="cov1" title="1">{

        // Fetch the original pickup data
        origTrackTrace, err := b.storer.QueryByID(ctx, trackTraceID)
        if err != nil </span><span class="cov0" title="0">{
                return TrackTrace{}, fmt.Errorf("user.querybyid: %s: %w", trackTraceID, err)
        }</span>

        <span class="cov1" title="1">if utracktrace.RouteID != nil </span><span class="cov1" title="1">{
                origTrackTrace.RouteID = *utracktrace.RouteID
        }</span>

        <span class="cov1" title="1">if utracktrace.DeliveryPersonnelID != nil </span><span class="cov1" title="1">{
                origTrackTrace.DeliveryPersonnelID = *utracktrace.DeliveryPersonnelID
        }</span>

        <span class="cov1" title="1">if utracktrace.VehicleID != nil </span><span class="cov1" title="1">{
                origTrackTrace.VehicleID = *utracktrace.VehicleID
        }</span>

        <span class="cov1" title="1">if utracktrace.Latitude != nil </span><span class="cov1" title="1">{
                origTrackTrace.Latitude = *utracktrace.Latitude
        }</span>

        <span class="cov1" title="1">if utracktrace.Longitude != nil </span><span class="cov1" title="1">{
                origTrackTrace.Longitude = *utracktrace.Longitude
        }</span>

        // TODO: Decide what to do when the data has already been synced
        <span class="cov1" title="1">if utracktrace.IsSynced != nil </span><span class="cov1" title="1">{
                origTrackTrace.IsSynced = *utracktrace.IsSynced
        }</span>

        <span class="cov1" title="1">if utracktrace.TimeStamp != nil </span><span class="cov1" title="1">{
                origTrackTrace.TimeStamp = *utracktrace.TimeStamp
        }</span>

        <span class="cov1" title="1">origTrackTrace.UpdatedAt = time.Now().Truncate(time.Millisecond)

        if err := b.storer.Update(ctx, origTrackTrace); err != nil </span><span class="cov0" title="0">{
                return TrackTrace{}, fmt.Errorf("update: %w", err)
        }</span>

        <span class="cov1" title="1">return origTrackTrace, nil</span>
}

// QueryByID finds the epickup by the specified ID.
func (b *Business) QueryByID(ctx context.Context, trackTraceID uuid.UUID) (TrackTrace, error) <span class="cov1" title="1">{

        trackTrace, err := b.storer.QueryByID(ctx, trackTraceID)
        if err != nil </span><span class="cov0" title="0">{
                return TrackTrace{}, fmt.Errorf("query: trackTraceID[%s]: %w", trackTraceID, err)
        }</span>

        <span class="cov1" title="1">return trackTrace, nil</span>
}

// Query retrieves a list of existing products.
func (b *Business) Query(ctx context.Context, filter QueryFilter, orderBy order.By, page page.Page) ([]TrackTrace, error) <span class="cov1" title="1">{
        prds, err := b.storer.Query(ctx, filter, orderBy, page)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("query: %w", err)
        }</span>

        <span class="cov1" title="1">return prds, nil</span>
}

// Count returns the total number of pickups.
func (b *Business) Count(ctx context.Context, filter QueryFilter) (int, error) <span class="cov0" title="0">{
        return b.storer.Count(ctx, filter)
}</span>

func (b *Business) HardDelete(ctx context.Context, trackTraceID uuid.UUID) error <span class="cov4" title="2">{

        if err := b.storer.HardDelete(ctx, trackTraceID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("delete: %w", err)
        }</span>

        <span class="cov4" title="2">return nil</span>
}

func (b *Business) SoftDelete(ctx context.Context, trackTraceID uuid.UUID) error <span class="cov4" title="2">{

        if err := b.storer.SoftDelete(ctx, trackTraceID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("delete: %w", err)
        }</span>

        <span class="cov4" title="2">return nil</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package gpstrackingdb

import (
        "bytes"
        "strings"

        "github.com/FITHSCS/backend/business/domain/gpstrackingbus"
)

func (s *Store) applyFilter(filter gpstrackingbus.QueryFilter, data map[string]any, buf *bytes.Buffer) <span class="cov0" title="0">{
        var wc []string

        if filter.TrackTraceID != nil </span><span class="cov0" title="0">{
                data["tracking_id"] = *filter.TrackTraceID
                wc = append(wc, "tracking_id = :tracking_id")
        }</span>

        <span class="cov0" title="0">if filter.RouteID != nil </span><span class="cov0" title="0">{
                data["route_id"] = *filter.RouteID
                wc = append(wc, "route_id = :route_id")
        }</span>

        <span class="cov0" title="0">if filter.PackageDetailID != nil </span><span class="cov0" title="0">{
                data["package_detail_id"] = *filter.PackageDetailID
                wc = append(wc, "package_detail_id = :package_detail_id")
        }</span>

        <span class="cov0" title="0">if filter.VehicleID != nil </span><span class="cov0" title="0">{
                data["vehicle_id"] = *filter.VehicleID
                wc = append(wc, "vehicle_id = :vehicle_id")
        }</span>

        <span class="cov0" title="0">if len(wc) &gt; 0 </span><span class="cov0" title="0">{
                buf.WriteString(" WHERE ")
                buf.WriteString(strings.Join(wc, " AND "))
        }</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">// Package gpstrackingdb contains product related CRUD functionality.
package gpstrackingdb

import (
        "bytes"
        "context"
        "errors"
        "fmt"

        "github.com/FITHSCS/backend/business/domain/gpstrackingbus"
        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/business/sdk/sqldb"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/google/uuid"
        "github.com/jmoiron/sqlx"
)

// Store manages the set of APIs for product database access.
type Store struct {
        log *logger.Logger
        db  sqlx.ExtContext
}

// NewStore constructs the api for data access.
func NewStore(log *logger.Logger, db *sqlx.DB) *Store <span class="cov0" title="0">{
        return &amp;Store{
                log: log,
                db:  db,
        }
}</span>

// Create adds a Product to the sqldb. It returns the created Product with
// fields like ID and DateCreated populated.
func (s *Store) Create(ctx context.Context, trc gpstrackingbus.TrackTrace) error <span class="cov0" title="0">{

        const q = `
        INSERT INTO gps_tracking
                (
                        tracking_id,
                        route_id, 
                        delivery_personnel_id, 
                        vehicle_id, 
                        latitude, 
                        longitude, 
                        accuracy, 
                        speed, 
                        battery_level, 
                        time_stamp, 
                        is_deleted,
                        is_synced,
                        created_at,
                        updated_at
                )
        VALUES
                (
                        :tracking_id, 
                        :route_id, 
                        :delivery_personnel_id, 
                        :vehicle_id, 
                        :latitude, 
                        :longitude, 
                        :accuracy, 
                        :speed, 
                        :battery_level, 
                        :time_stamp,
                        :is_deleted,
                        :is_synced,
                        :created_at,
                        :updated_at
                )
        `

        if err := sqldb.NamedExecContext(ctx, s.log, s.db, q, toDBTrackTrace(trc)); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("namedexeccontext: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// QueryByID finds the epickup identified by a given ID.
func (s *Store) QueryByID(ctx context.Context, trackingID uuid.UUID) (gpstrackingbus.TrackTrace, error) <span class="cov0" title="0">{
        data := struct {
                ID string `db:"tracking_id"`
        }{
                ID: trackingID.String(),
        }

        const q = `
        SELECT
            tracking_id,
                route_id, 
                delivery_personnel_id, 
                vehicle_id, 
                latitude, 
                longitude, 
                accuracy, 
                speed, 
                battery_level, 
                time_stamp,
                is_deleted, 
                is_synced,
                created_at,
                updated_at
        FROM
                gps_tracking
        WHERE
                tracking_id = :tracking_id`

        var trackTraceDB TrackTraceDB
        if err := sqldb.NamedQueryStruct(ctx, s.log, s.db, q, data, &amp;trackTraceDB); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sqldb.ErrDBNotFound) </span><span class="cov0" title="0">{
                        return gpstrackingbus.TrackTrace{}, fmt.Errorf("db: %w", gpstrackingbus.ErrNotFound)
                }</span>
                <span class="cov0" title="0">return gpstrackingbus.TrackTrace{}, fmt.Errorf("db: %w", err)</span>
        }

        <span class="cov0" title="0">return toBusTrackTrace(trackTraceDB)</span>
}

func (s *Store) Update(ctx context.Context, tracktrace gpstrackingbus.TrackTrace) error <span class="cov0" title="0">{
        const q = `
        UPDATE gps_tracking
        SET
                tracking_id = :tracking_id,
                route_id = :route_id,
                delivery_personnel_id = :delivery_personnel_id,
                vehicle_id = :vehicle_id,
                latitude = :latitude,
                longitude = :longitude,
                accuracy = :accuracy,
                speed = :speed,
                battery_level = :battery_level,
                is_synced = :is_synced,
                is_deleted = :is_deleted,
                time_stamp = :time_stamp,
                created_at = :created_at,
                updated_at = :updated_at
        WHERE
                tracking_id = :tracking_id`

        if err := sqldb.NamedExecContext(ctx, s.log, s.db, q, toDBTrackTrace(tracktrace)); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("namedexeccontext: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *Store) HardDelete(ctx context.Context, tracktraceID uuid.UUID) error <span class="cov0" title="0">{

        const q = `
        DELETE FROM
                gps_tracking
        WHERE
                tracking_id = :tracking_id`

        data := TrackTraceDB{TrackTraceID: tracktraceID}

        if err := sqldb.NamedExecContext(ctx, s.log, s.db, q, data); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("namedexeccontext: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *Store) SoftDelete(ctx context.Context, tracktraceID uuid.UUID) error <span class="cov0" title="0">{

        const q = `
        UPDATE gps_tracking
        SET
                is_deleted = :is_deleted
        WHERE
                tracking_id = :tracking_id`

        data := TrackTraceDB{TrackTraceID: tracktraceID, IsDeleted: true}

        if err := sqldb.NamedExecContext(ctx, s.log, s.db, q, data); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("namedexeccontext: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Query gets all epickups from the database.
func (s *Store) Query(ctx context.Context, filter gpstrackingbus.QueryFilter, orderBy order.By, page page.Page) ([]gpstrackingbus.TrackTrace, error) <span class="cov0" title="0">{
        data := map[string]any{
                "offset":        (page.Number() - 1) * page.RowsPerPage(),
                "rows_per_page": page.RowsPerPage(),
        }

        const q = `
        SELECT
            tracking_id,
                route_id, 
                delivery_personnel_id, 
                vehicle_id, 
                latitude, 
                longitude, 
                accuracy, 
                speed, 
                battery_level,
                time_stamp, 
                is_deleted,
                is_synced,
                created_at,
                updated_at
        FROM
                gps_tracking`

        buf := bytes.NewBufferString(q)
        s.applyFilter(filter, data, buf)

        orderByClause, err := orderByClause(orderBy)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">buf.WriteString(orderByClause)
        buf.WriteString(" OFFSET :offset ROWS FETCH NEXT :rows_per_page ROWS ONLY")

        var dbPrds []TrackTraceDB
        if err := sqldb.NamedQuerySlice(ctx, s.log, s.db, buf.String(), data, &amp;dbPrds); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("namedqueryslice: %w", err)
        }</span>

        <span class="cov0" title="0">return toBusTrackTraces(dbPrds)</span>
}

// Count returns the total number of records in the DB.
func (s *Store) Count(ctx context.Context, filter gpstrackingbus.QueryFilter) (int, error) <span class="cov0" title="0">{
        data := map[string]any{}

        const q = `
        SELECT
                count(1)
        FROM
                gps_tracking`

        buf := bytes.NewBufferString(q)
        s.applyFilter(filter, data, buf)

        var count struct {
                Count int `db:"count"`
        }
        if err := sqldb.NamedQueryStruct(ctx, s.log, s.db, buf.String(), data, &amp;count); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("db: %w", err)
        }</span>

        <span class="cov0" title="0">return count.Count, nil</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package gpstrackingdb

import (
        "fmt"
        "time"

        "github.com/FITHSCS/backend/business/domain/gpstrackingbus"
        "github.com/FITHSCS/backend/business/types/facilitytype"
        "github.com/google/uuid"
)

type TrackTraceDB struct {
        TrackTraceID        uuid.UUID `db:"tracking_id"`
        RouteID             uuid.UUID `db:"route_id"`
        DeliveryPersonnelID uuid.UUID `db:"delivery_personnel_id"`
        VehicleID           uuid.UUID `db:"vehicle_id"`
        Latitude            float64   `db:"latitude"`
        Longitude           float64   `db:"longitude"`
        Accuracy            float64   `db:"accuracy"`
        Speed               float64   `db:"speed"`
        BatteryLevel        float64   `db:"battery_level"`
        IsSynced            bool      `db:"is_synced"`
        IsDeleted           bool      `db:"is_deleted"`
        TimeStamp           time.Time `db:"time_stamp"`
        CreatedAt           time.Time `db:"created_at"`
        UpdatedAt           time.Time `db:"updated_at"`
}

func toDBTrackTrace(bus gpstrackingbus.TrackTrace) TrackTraceDB <span class="cov0" title="0">{

        db := TrackTraceDB{
                TrackTraceID:        bus.TrackTraceID,
                RouteID:             bus.RouteID,
                DeliveryPersonnelID: bus.DeliveryPersonnelID,
                VehicleID:           bus.VehicleID,
                Latitude:            bus.Latitude.Float64(),
                Longitude:           bus.Longitude.Float64(),
                Accuracy:            bus.Accuracy,
                Speed:               bus.Speed,
                BatteryLevel:        bus.BatteryLevel,
                IsDeleted:           bus.IsDeleted,
                IsSynced:            bus.IsSynced,
                TimeStamp:           bus.TimeStamp.UTC(),
                CreatedAt:           bus.CreatedAt.UTC(),
                UpdatedAt:           bus.UpdatedAt.UTC(),
        }
        return db
}</span>

// toBusTrackTrace converts an TrackTraceDB (database object) back to an TrackTraceBus (business object).
func toBusTrackTrace(db TrackTraceDB) (gpstrackingbus.TrackTrace, error) <span class="cov0" title="0">{
        // Perform any necessary parsing or validation if complex types were used.
        // In this case, types map directly or only involve time zone conversion.

        lat, err := facilitytype.ParseLat(db.Latitude)
        if err != nil </span><span class="cov0" title="0">{
                return gpstrackingbus.TrackTrace{}, fmt.Errorf("parse: %v", err)
        }</span>

        <span class="cov0" title="0">long, err := facilitytype.ParseLong(db.Longitude)
        if err != nil </span><span class="cov0" title="0">{
                return gpstrackingbus.TrackTrace{}, fmt.Errorf("parse: %v", err)
        }</span>

        <span class="cov0" title="0">bus := gpstrackingbus.TrackTrace{
                TrackTraceID:        db.TrackTraceID,
                RouteID:             db.RouteID,
                DeliveryPersonnelID: db.DeliveryPersonnelID,
                VehicleID:           db.VehicleID,
                Latitude:            lat,
                Longitude:           long,
                Accuracy:            db.Accuracy,
                Speed:               db.Speed,
                BatteryLevel:        db.BatteryLevel,
                IsDeleted:           db.IsDeleted,
                IsSynced:            db.IsSynced,
                TimeStamp:           db.TimeStamp.In(time.Local),
                CreatedAt:           db.CreatedAt.In(time.Local),
                UpdatedAt:           db.UpdatedAt.In(time.Local),
        }

        return bus, nil</span>
}

// toBusEPickups converts a slice of ePickupDB objects to a slice of EPickup objects.
func toBusTrackTraces(dbs []TrackTraceDB) ([]gpstrackingbus.TrackTrace, error) <span class="cov0" title="0">{
        bus := make([]gpstrackingbus.TrackTrace, len(dbs))

        for i, db := range dbs </span><span class="cov0" title="0">{
                var err error
                bus[i], err = toBusTrackTrace(db)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">return bus, nil</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package gpstrackingdb

import (
        "fmt"

        "github.com/FITHSCS/backend/business/domain/gpstrackingbus"
        "github.com/FITHSCS/backend/business/sdk/order"
)

var orderByFields = map[string]string{
        gpstrackingbus.OrderByTrackAndTraceID:     "tracking_id",
        gpstrackingbus.OrderByDeliveryPersonnelID: "delivery_personnel_id",
        gpstrackingbus.OrderByRouteID:             "route_id",
        gpstrackingbus.OrderByCreatedAt:           "created_at",
        gpstrackingbus.OrderByBatteryLevel:        "battery_level",
}

func orderByClause(orderBy order.By) (string, error) <span class="cov0" title="0">{
        by, exists := orderByFields[orderBy.Field]
        if !exists </span><span class="cov0" title="0">{
                return "", fmt.Errorf("field %q does not exist", orderBy.Field)
        }</span>

        <span class="cov0" title="0">return " ORDER BY " + by + " " + orderBy.Direction, nil</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package gpstrackingbus

import (
        "context"
        "fmt"
        "math/rand"
        "time"

        "github.com/FITHSCS/backend/business/types/facilitytype"
        "github.com/google/uuid"
)

func TestGenerateNewGPSTracking(n int, rte, delperID, vehID uuid.UUID) []NewTrackTrace <span class="cov5" title="2">{
        newroute := make([]NewTrackTrace, n)

        tmesmp, _ := time.Parse(time.RFC3339, "2025-06-10T15:59:33+03:00")

        idx := rand.Intn(10000)
        for i := range n </span><span class="cov10" title="4">{
                idx++

                nf := NewTrackTrace{
                        RouteID:             rte,
                        DeliveryPersonnelID: delperID,
                        VehicleID:           vehID,
                        Latitude:            facilitytype.MustParseLat(9.01949999999),
                        Longitude:           facilitytype.MustParseLong(38.7399999999),
                        Accuracy:            10.21,
                        Speed:               32.2,
                        BatteryLevel:        67,
                        IsSynced:            true,
                        TimeStamp:           tmesmp,
                }

                newroute[i] = nf
        }</span>

        <span class="cov5" title="2">return newroute</span>
}

func TestGenerateSeedGPSTracking(ctx context.Context, n int, api *Business, rte, delperID, vehID uuid.UUID) ([]TrackTrace, error) <span class="cov5" title="2">{
        newfs := TestGenerateNewGPSTracking(n, rte, delperID, vehID)

        facs := make([]TrackTrace, len(newfs))
        for i, np := range newfs </span><span class="cov10" title="4">{
                prd, err := api.Create(ctx, np)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("seeding routes: idx: %d : %w", i, err)
                }</span>

                <span class="cov10" title="4">facs[i] = prd</span>
        }

        <span class="cov5" title="2">return facs, nil</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">// Package imagebus provides business access to image domain.
package imagebus

import (
        "context"
        "errors"
        "fmt"
        "time"

        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/google/uuid"
)

var (
        ErrNotFound       = errors.New("iamge not found")
        ErrAuthentication = errors.New("authentication failed")
)

type Storer interface {
        Create(ctx context.Context, image Image) error
        Update(ctx context.Context, image Image) error
        SoftDelete(ctx context.Context, imageID uuid.UUID) error
        HardDelete(ctx context.Context, imageID uuid.UUID) error
        Query(ctx context.Context, filter QueryFilter, orderby order.By, page page.Page) ([]Image, error)
        QueryByID(ctx context.Context, imageID uuid.UUID) (Image, error)
        Count(ctx context.Context, filter QueryFilter) (int, error)
}

type Business struct {
        log    *logger.Logger
        storer Storer
}

func NewBusiness(log *logger.Logger, storer Storer) *Business <span class="cov1" title="1">{

        return &amp;Business{
                log:    log,
                storer: storer,
        }
}</span>

func (b *Business) Create(ctx context.Context, ni NewImage) (Image, error) <span class="cov10" title="6">{

        now := time.Now().Truncate(time.Millisecond)

        image := Image{
                ImageID:     uuid.New(),
                ManifestID:  ni.ManifestID,
                CapturedBy:  ni.CapturedBy,
                ExceptionID: ni.ExceptionID,
                EventType:   ni.EventType,
                ImageType:   ni.ImageType,
                ImageURL:    ni.ImageURL,
                ImageHash:   ni.ImageHash,
                IsSynced:    ni.IsSynced,
                IsDeleted:   false,
                TimeStamp:   now,
                CreatedAt:   now,
                UpdatedAt:   now,
        }

        if err := b.storer.Create(ctx, image); err != nil </span><span class="cov0" title="0">{
                return Image{}, fmt.Errorf("Create: %w", err)
        }</span>
        <span class="cov10" title="6">return image, nil</span>
}

func (b *Business) Update(ctx context.Context, imgID uuid.UUID, updateimg UpdateImage) (Image, error) <span class="cov4" title="2">{

        imgOrgnl, err := b.storer.QueryByID(ctx, imgID)
        if err != nil </span><span class="cov0" title="0">{
                return Image{}, fmt.Errorf("querybyid: %w", err)
        }</span>

        <span class="cov4" title="2">if updateimg.ManifestID != nil </span><span class="cov4" title="2">{
                imgOrgnl.ManifestID = *updateimg.ManifestID
        }</span>

        <span class="cov4" title="2">if updateimg.CapturedBy != nil </span><span class="cov4" title="2">{
                imgOrgnl.CapturedBy = *updateimg.CapturedBy
        }</span>

        <span class="cov4" title="2">if updateimg.ExceptionID != nil </span><span class="cov4" title="2">{
                imgOrgnl.ExceptionID = *updateimg.ExceptionID
        }</span>

        <span class="cov4" title="2">if updateimg.EventType != nil </span><span class="cov4" title="2">{
                imgOrgnl.EventType = *updateimg.EventType
        }</span>

        <span class="cov4" title="2">if updateimg.ImageType != nil </span><span class="cov4" title="2">{
                imgOrgnl.ImageType = *updateimg.ImageType
        }</span>

        <span class="cov4" title="2">if updateimg.ImageURL != nil </span><span class="cov4" title="2">{
                imgOrgnl.ImageURL = updateimg.ImageURL
        }</span>

        <span class="cov4" title="2">if updateimg.ImageHash != nil </span><span class="cov4" title="2">{
                imgOrgnl.ImageHash = *updateimg.ImageHash
        }</span>

        <span class="cov4" title="2">if updateimg.IsSynced != nil </span><span class="cov4" title="2">{
                imgOrgnl.IsSynced = *updateimg.IsSynced
        }</span>

        <span class="cov4" title="2">imgOrgnl.UpdatedAt = time.Now().Truncate(time.Microsecond)

        if err := b.storer.Update(ctx, imgOrgnl); err != nil </span><span class="cov0" title="0">{
                return Image{}, fmt.Errorf("update: %w", err)
        }</span>

        <span class="cov4" title="2">return imgOrgnl, nil</span>
}

func (b *Business) Query(ctx context.Context, filter QueryFilter, orderBy order.By, page page.Page) ([]Image, error) <span class="cov1" title="1">{
        images, err := b.storer.Query(ctx, filter, orderBy, page)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Query: %w", err)
        }</span>
        <span class="cov1" title="1">return images, nil</span>
}
func (b *Business) Count(ctx context.Context, filter QueryFilter) (int, error) <span class="cov0" title="0">{
        return b.storer.Count(ctx, filter)
}</span>

func (b *Business) QueryByID(ctx context.Context, ImageID uuid.UUID) (Image, error) <span class="cov1" title="1">{

        pickupbatch, err := b.storer.QueryByID(ctx, ImageID)
        if err != nil </span><span class="cov0" title="0">{
                return Image{}, fmt.Errorf("query: ImageID[%s]: %w", ImageID, err)
        }</span>
        <span class="cov1" title="1">return pickupbatch, nil</span>
}

func (b *Business) SoftDelete(ctx context.Context, ImageID uuid.UUID) error <span class="cov4" title="2">{
        facility, err := b.storer.QueryByID(ctx, ImageID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("softdeletequery: imageID[%s]: %w", ImageID, err)
        }</span>
        <span class="cov4" title="2">if facility.IsDeleted </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: already deleted", ImageID)
        }</span>

        <span class="cov4" title="2">if err := b.storer.SoftDelete(ctx, ImageID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("delete: %w", err)
        }</span>

        <span class="cov4" title="2">return nil</span>
}

func (b *Business) HardDelete(ctx context.Context, ImageID uuid.UUID) error <span class="cov4" title="2">{

        if err := b.storer.HardDelete(ctx, ImageID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("delete: %w", err)
        }</span>
        <span class="cov4" title="2">return nil</span>

}
</pre>
		
		<pre class="file" id="file43" style="display: none">package imagedb

import (
        "bytes"
        "strings"

        "github.com/FITHSCS/backend/business/domain/imagebus"
)

func applyFilter(filter imagebus.QueryFilter, data map[string]any, buf *bytes.Buffer) <span class="cov0" title="0">{

        var wc []string

        if filter.ID != nil </span><span class="cov0" title="0">{
                data["image_id"] = &amp;filter.ID
                wc = append(wc, "image_id = :image_id")
        }</span>

        <span class="cov0" title="0">if filter.EventType != nil </span><span class="cov0" title="0">{
                data["event_type"] = &amp;filter.ID
                wc = append(wc, "event_type = :event_type")
        }</span>

        <span class="cov0" title="0">if len(wc) &gt; 0 </span><span class="cov0" title="0">{
                buf.WriteString(" WHERE ")
                buf.WriteString(strings.Join(wc, " AND "))
        }</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">// Package imagedb contains product related CRUD functionality.
package imagedb

import (
        "bytes"
        "context"
        "errors"
        "fmt"

        "github.com/FITHSCS/backend/business/domain/imagebus"
        "github.com/FITHSCS/backend/business/domain/pickupbatchbus"
        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/business/sdk/sqldb"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/google/uuid"
        "github.com/jmoiron/sqlx"
)

type Store struct {
        log *logger.Logger
        db  sqlx.ExtContext
}

func NewStore(log *logger.Logger, db *sqlx.DB) *Store <span class="cov0" title="0">{
        return &amp;Store{log: log, db: db}
}</span>

func (s *Store) Create(ctx context.Context, p imagebus.Image) error <span class="cov0" title="0">{
        const stmt = `
    INSERT INTO image (
            image_id, 
                manifest_id,
                captured_by,
                exception_id, 
            event_type,
                image_type,
                image_url,
                image_hash,
            is_synced, 
                is_deleted,
                time_stamp, 
            created_at,
                updated_at 
    ) 
        VALUES (
            :image_id, 
                :manifest_id, 
                :captured_by,
                :exception_id, 
            :event_type, 
                :image_type,
                :image_url,
                :image_hash,
            :is_synced, 
                :is_deleted,
                :time_stamp, 
            :created_at, 
                :updated_at
    )`
        returnedValue, err := toDBImage(p)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return sqldb.NamedExecContext(ctx, s.log, s.db, stmt, returnedValue)</span>
}

func (s *Store) Update(ctx context.Context, p imagebus.Image) error <span class="cov0" title="0">{
        const stmt = `
    UPDATE 
                image
    SET 
                manifest_id       = :manifest_id,
        captured_by       = :captured_by,
        exception_id      = :exception_id,
        event_type        = :event_type,
        image_type        = :image_type,
        image_url         = :image_url,
                image_hash                   = :image_hash,
        is_synced         = :is_synced,
        is_deleted        = :is_deleted,
        time_stamp        = :time_stamp,
        updated_at        = :updated_at
    WHERE 
                image_id          = :image_id`

        returnedValue, err := toDBImage(p)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return sqldb.NamedExecContext(ctx, s.log, s.db, stmt, returnedValue)</span>
}

func (s *Store) Query(ctx context.Context, filter imagebus.QueryFilter, orderBy order.By, page page.Page) ([]imagebus.Image, error) <span class="cov0" title="0">{

        data := map[string]any{
                "offset":        (page.Number() - 1) * page.RowsPerPage(),
                "rows_per_page": page.RowsPerPage(),
        }

        const q = `
    SELECT
            image_id, 
                manifest_id,
                captured_by,
                exception_id, 
            event_type,
                image_type,
                image_url,
                image_hash,
            is_synced, 
                is_deleted,
                time_stamp, 
            created_at,
                updated_at 
    FROM 
                image        `

        var buf bytes.Buffer
        buf.WriteString(q)
        applyFilter(filter, data, &amp;buf)

        clause, err := orderByClause(orderBy)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">buf.WriteString(clause)
        buf.WriteString(" OFFSET :offset ROWS FETCH NEXT :rows_per_page ROWS ONLY")

        var dbRecs []imagedb

        if err := sqldb.NamedQuerySlice(ctx, s.log, s.db, buf.String(), data, &amp;dbRecs); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("namedqueryslice: %w", err)
        }</span>

        <span class="cov0" title="0">return toBusImages(dbRecs)</span>
}

func (s *Store) Count(ctx context.Context, filter imagebus.QueryFilter) (int, error) <span class="cov0" title="0">{
        data := map[string]any{}
        const base = `SELECT count(1) FROM image`

        var buf bytes.Buffer
        buf.WriteString(base)
        applyFilter(filter, data, &amp;buf)

        var out struct {
                Count int `db:"count"`
        }
        if err := sqldb.NamedQueryStruct(ctx, s.log, s.db, buf.String(), data, &amp;out); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("db: %w", err)
        }</span>
        <span class="cov0" title="0">return out.Count, nil</span>
}

func (s *Store) QueryByID(ctx context.Context, imageID uuid.UUID) (imagebus.Image, error) <span class="cov0" title="0">{
        param := map[string]any{
                "image_id": imageID.String(),
        }
        const stmt = `
    SELECT
            image_id, 
                manifest_id,
                captured_by,
                exception_id, 
            event_type,
                image_type,
                image_url,
                image_hash,
            is_synced, 
                is_deleted,
                time_stamp, 
            created_at,
                updated_at 
        FROM 
                  image
        WHERE 
                  image_id = :image_id`

        var rec imagedb
        if err := sqldb.NamedQueryStruct(ctx, s.log, s.db, stmt, param, &amp;rec); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sqldb.ErrDBNotFound) </span><span class="cov0" title="0">{
                        return imagebus.Image{}, fmt.Errorf("db: %w", pickupbatchbus.ErrNotFound)
                }</span>
                <span class="cov0" title="0">return imagebus.Image{}, fmt.Errorf("db: %w", err)</span>
        }
        <span class="cov0" title="0">return toBusImage(rec)</span>
}

func (s *Store) SoftDelete(ctx context.Context, imageID uuid.UUID) error <span class="cov0" title="0">{

        const q = `
    UPDATE
        image
        SET
                is_deleted = :is_deleted
    WHERE
        image_id = :image_id`

        img := imagedb{ImageID: imageID, IsDeleted: true}

        if err := sqldb.NamedExecContext(ctx, s.log, s.db, q, img); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("namedexeccontext: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *Store) HardDelete(ctx context.Context, manifestID uuid.UUID) error <span class="cov0" title="0">{
        const q = `
    DELETE FROM
        image
    WHERE
        image_id = :image_id`

        img := imagedb{ImageID: manifestID}

        if err := sqldb.NamedExecContext(ctx, s.log, s.db, q, img); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("namedexeccontext: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package imagedb

import (
        "fmt"
        "net/url"
        "time"

        "github.com/FITHSCS/backend/business/domain/imagebus"
        "github.com/FITHSCS/backend/business/types/genstringtype"
        "github.com/google/uuid"
)

type imagedb struct {
        ImageID     uuid.UUID     `db:"image_id"`
        ManifestID  uuid.UUID     `db:"manifest_id"`
        CapturedBy  uuid.UUID     `db:"captured_by"`
        ExceptionID uuid.NullUUID `db:"exception_id"`
        EventType   string        `db:"event_type"`
        ImageType   string        `db:"image_type"`
        ImageURL    string        `db:"image_url"`
        ImageHash   string        `db:"image_hash"`
        IsSynced    bool          `db:"is_synced"`
        IsDeleted   bool          `db:"is_deleted"`
        TimeStamp   time.Time     `db:"time_stamp"`
        CreatedAt   time.Time     `db:"created_at"`
        UpdatedAt   time.Time     `db:"updated_at"`
}

func toDBImage(bus imagebus.Image) (imagedb, error) <span class="cov0" title="0">{

        img := imagedb{
                ImageID:     bus.ImageID,
                ManifestID:  bus.ManifestID,
                CapturedBy:  bus.CapturedBy,
                ExceptionID: bus.ExceptionID,
                EventType:   bus.EventType.String(),
                ImageType:   bus.ImageType.String(),
                ImageURL:    bus.ImageURL.String(),
                ImageHash:   bus.ImageHash.String(),
                IsSynced:    bus.IsSynced,
                IsDeleted:   bus.IsDeleted,
                TimeStamp:   bus.TimeStamp.UTC(),
                CreatedAt:   bus.CreatedAt.UTC(),
                UpdatedAt:   bus.UpdatedAt.UTC(),
        }

        return img, nil
}</span>

func toBusImage(db imagedb) (imagebus.Image, error) <span class="cov0" title="0">{

        entyp, err := genstringtype.Parse(db.EventType)
        if err != nil </span><span class="cov0" title="0">{
                return imagebus.Image{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">imgtyp, err := genstringtype.Parse(db.ImageType)
        if err != nil </span><span class="cov0" title="0">{
                return imagebus.Image{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">imgurl, err := url.Parse(db.ImageURL)
        if err != nil </span><span class="cov0" title="0">{
                return imagebus.Image{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">imghsh, err := genstringtype.Parse(db.ImageHash)
        if err != nil </span><span class="cov0" title="0">{
                return imagebus.Image{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">bus := imagebus.Image{
                ImageID:     db.ImageID,
                ManifestID:  db.ManifestID,
                CapturedBy:  db.CapturedBy,
                ExceptionID: db.ExceptionID,
                EventType:   entyp,
                ImageType:   imgtyp,
                ImageURL:    imgurl,
                ImageHash:   imghsh,
                IsSynced:    db.IsSynced,
                IsDeleted:   db.IsDeleted,
                TimeStamp:   db.TimeStamp.In(time.Local),
                CreatedAt:   db.CreatedAt.In(time.Local),
                UpdatedAt:   db.UpdatedAt.In(time.Local),
        }
        return bus, nil</span>

}

func toBusImages(dbs []imagedb) ([]imagebus.Image, error) <span class="cov0" title="0">{
        bus := make([]imagebus.Image, len(dbs))

        for i, db := range dbs </span><span class="cov0" title="0">{
                var err error
                bus[i], err = toBusImage(db)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">return bus, nil</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package imagedb

import (
        "fmt"

        "github.com/FITHSCS/backend/business/domain/imagebus"
        "github.com/FITHSCS/backend/business/sdk/order"
)

var orderByFields = map[string]string{
        imagebus.OrderByID:        "image_id",
        imagebus.OrderByEventType: "event_type",
        imagebus.OrderByImageType: "image_type",
        imagebus.OrderByIsSynced:  "is_synced",
        imagebus.OrderByTimeStamp: "time_stamp",
        imagebus.OrderByCreatedAt: "created_at",
        imagebus.OrderByUpdatedAt: "updated_at",
}

// orderByClause converts an order.By value into the final
// " ORDER BY  ASC|DESC" fragment the store adds to its SELECT.
func orderByClause(ob order.By) (string, error) <span class="cov0" title="0">{
        col, ok := orderByFields[ob.Field]
        if !ok </span><span class="cov0" title="0">{
                return "", fmt.Errorf("field %q does not exist", ob.Field)
        }</span>
        <span class="cov0" title="0">return " ORDER BY " + col + " " + ob.Direction, nil</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package imagebus

import (
        "context"
        "fmt"
        "math/rand"
        "net/url"
        "time"

        "github.com/FITHSCS/backend/business/types/genstringtype"
        "github.com/google/uuid"
)

func TestGenerateNewImage(n int, manID, capbyID uuid.UUID, delexID []uuid.NullUUID) []NewImage <span class="cov5" title="2">{
        newfs := make([]NewImage, n)
        eventype := []string{"pickup", "delivery_exception", "delivery"}
        imgType := []string{"model19", "model19_descripancy", "exception"}

        CapturedAt, _ := time.Parse(time.RFC3339, "2025-06-10T15:59:33+03:00")
        timestamp := CapturedAt.Add(time.Minute + 1)

        u, _ := url.Parse("example.com/imge/url")

        idx := rand.Intn(10000)
        for i := range n </span><span class="cov10" title="4">{
                idx++

                nf := NewImage{
                        ManifestID:  manID,
                        CapturedBy:  capbyID,
                        ExceptionID: delexID[i%2],
                        EventType:   genstringtype.MustParse(eventype[i%6]),
                        ImageType:   genstringtype.MustParse(imgType[i%6]),
                        ImageURL:    u,
                        ImageHash:   genstringtype.MustParse("imagehash3242342gegfqrefviopqruqv8903prv9w"),
                        IsSynced:    true,
                        TimeStamp:   timestamp,
                }

                newfs[i] = nf
        }</span>

        <span class="cov5" title="2">return newfs</span>
}

func TestGenerateSeedImage(ctx context.Context, n int, api *Business, manID, capbyID uuid.UUID, delexID []uuid.NullUUID) ([]Image, error) <span class="cov5" title="2">{
        newfs := TestGenerateNewImage(n, manID, capbyID, delexID)

        facs := make([]Image, len(newfs))
        for i, np := range newfs </span><span class="cov10" title="4">{
                prd, err := api.Create(ctx, np)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("seeding image: idx: %d : %w", i, err)
                }</span>

                <span class="cov10" title="4">facs[i] = prd</span>
        }

        <span class="cov5" title="2">return facs, nil</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">// Package manifestbus provides business access to packagedetail domain.
package manifestbus

import (
        "context"
        "errors"
        "fmt"
        "time"

        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/google/uuid"
)

var (
        ErrNotFound       = errors.New("pickupbatch not found")
        ErrAuthentication = errors.New("authentication failed")
)

type Storer interface {
        Create(ctx context.Context, manifest Manifest) error
        Update(ctx context.Context, manifest Manifest) error
        SoftDelete(ctx context.Context, manifestID uuid.UUID) error
        HardDelete(ctx context.Context, manifestID uuid.UUID) error
        Query(ctx context.Context, filter QueryFilter, orderby order.By, page page.Page) ([]Manifest, error)
        QueryByID(ctx context.Context, manifestID uuid.UUID) (Manifest, error)
        Count(ctx context.Context, filter QueryFilter) (int, error)
}

func (b *Business) GetStorer() Storer <span class="cov0" title="0">{
        return b.storer
}</span>

type Business struct {
        log    *logger.Logger
        storer Storer
}

func NewBusiness(log *logger.Logger, storer Storer) *Business <span class="cov1" title="1">{

        return &amp;Business{
                log:    log,
                storer: storer,
        }
}</span>

func (b *Business) Create(ctx context.Context, nm NewManifest) (Manifest, error) <span class="cov10" title="5">{

        now := time.Now().Truncate(time.Millisecond)

        manifest := Manifest{
                ID:                    uuid.New(),
                PickupBatchID:         nm.PickupBatchID,
                OriginFacilityID:      nm.OriginFacilityID,
                DestinationFacilityID: nm.DestinationFacilityID,
                OrderID:               nm.OrderID,
                DeliveryID:            nm.DeliveryID,
                Status:                nm.Status,
                ItemsSummary:          nm.ItemsSummary,
                PickupTime:            nm.PickupTime,
                DeliveryTime:          nm.DeliveryTime,
                IsDeleted:             false,
                IsSynced:              nm.IsSynced,
                TimeStamp:             now,
                CreatedAt:             now,
                UpdatedAt:             now,
        }

        if err := b.storer.Create(ctx, manifest); err != nil </span><span class="cov0" title="0">{
                return Manifest{}, fmt.Errorf("Create: %w", err)
        }</span>
        <span class="cov10" title="5">return manifest, nil</span>
}

func (b *Business) Update(ctx context.Context, pickupBatchID uuid.UUID, updatemanifest UpdateManifest) (Manifest, error) <span class="cov1" title="1">{

        mnfstOrgnl, err := b.storer.QueryByID(ctx, pickupBatchID)
        if err != nil </span><span class="cov0" title="0">{
                return Manifest{}, fmt.Errorf("querybyid: %w", err)
        }</span>

        <span class="cov1" title="1">if updatemanifest.PickupBatchID != nil </span><span class="cov1" title="1">{
                mnfstOrgnl.PickupBatchID = *updatemanifest.PickupBatchID
        }</span>

        <span class="cov1" title="1">if updatemanifest.OriginFacilityID != nil </span><span class="cov1" title="1">{
                mnfstOrgnl.OriginFacilityID = *updatemanifest.OriginFacilityID
        }</span>

        <span class="cov1" title="1">if updatemanifest.OrderID != nil </span><span class="cov1" title="1">{
                mnfstOrgnl.OrderID = *updatemanifest.OrderID
        }</span>

        <span class="cov1" title="1">if updatemanifest.DeliveryID != nil </span><span class="cov1" title="1">{
                mnfstOrgnl.DeliveryID = *updatemanifest.DeliveryID
        }</span>

        <span class="cov1" title="1">if updatemanifest.Status != nil </span><span class="cov1" title="1">{
                mnfstOrgnl.Status = *updatemanifest.Status
        }</span>

        <span class="cov1" title="1">if updatemanifest.ItemsSummary != nil </span><span class="cov1" title="1">{
                mnfstOrgnl.ItemsSummary = *updatemanifest.ItemsSummary
        }</span>

        <span class="cov1" title="1">if updatemanifest.PickupTime != nil </span><span class="cov1" title="1">{
                mnfstOrgnl.PickupTime = *updatemanifest.PickupTime
        }</span>

        <span class="cov1" title="1">if updatemanifest.DeliveryTime != nil </span><span class="cov1" title="1">{
                mnfstOrgnl.DeliveryTime = *updatemanifest.DeliveryTime
        }</span>

        <span class="cov1" title="1">if updatemanifest.TimeStamp != nil </span><span class="cov1" title="1">{
                mnfstOrgnl.TimeStamp = *updatemanifest.TimeStamp
        }</span>

        <span class="cov1" title="1">if updatemanifest.IsSynced != nil </span><span class="cov1" title="1">{
                mnfstOrgnl.IsSynced = *updatemanifest.IsSynced
        }</span>

        <span class="cov1" title="1">mnfstOrgnl.UpdatedAt = time.Now().Truncate(time.Microsecond)

        if err := b.storer.Update(ctx, mnfstOrgnl); err != nil </span><span class="cov0" title="0">{
                return Manifest{}, fmt.Errorf("update: %w", err)
        }</span>

        <span class="cov1" title="1">return mnfstOrgnl, nil</span>
}

func (b *Business) Query(ctx context.Context, filter QueryFilter, orderBy order.By, page page.Page) ([]Manifest, error) <span class="cov1" title="1">{
        manifests, err := b.storer.Query(ctx, filter, orderBy, page)

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Query: %w", err)
        }</span>
        <span class="cov1" title="1">return manifests, nil</span>
}
func (b *Business) Count(ctx context.Context, filter QueryFilter) (int, error) <span class="cov0" title="0">{
        return b.storer.Count(ctx, filter)
}</span>

func (b *Business) QueryByID(ctx context.Context, pickupBatchID uuid.UUID) (Manifest, error) <span class="cov1" title="1">{

        pickupbatch, err := b.storer.QueryByID(ctx, pickupBatchID)
        if err != nil </span><span class="cov0" title="0">{
                return Manifest{}, fmt.Errorf("query: pickupbatchID[%s]: %w", pickupBatchID, err)
        }</span>
        <span class="cov1" title="1">return pickupbatch, nil</span>
}

func (b *Business) SoftDelete(ctx context.Context, pickupBatchID uuid.UUID) error <span class="cov4" title="2">{
        facility, err := b.storer.QueryByID(ctx, pickupBatchID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("softdeletequery: manifestID[%s]: %w", pickupBatchID, err)
        }</span>
        <span class="cov4" title="2">if facility.IsDeleted </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: already deleted", pickupBatchID)
        }</span>

        <span class="cov4" title="2">if err := b.storer.SoftDelete(ctx, pickupBatchID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("delete: %w", err)
        }</span>

        <span class="cov4" title="2">return nil</span>
}

func (b *Business) HardDelete(ctx context.Context, pickupBatchID uuid.UUID) error <span class="cov4" title="2">{

        if err := b.storer.HardDelete(ctx, pickupBatchID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("delete: %w", err)
        }</span>
        <span class="cov4" title="2">return nil</span>

}
</pre>
		
		<pre class="file" id="file49" style="display: none">package manifestdb

import (
        "bytes"
        "strings"

        "github.com/FITHSCS/backend/business/domain/manifestbus"
)

func applyFilter(filter manifestbus.QueryFilter, data map[string]any, buf *bytes.Buffer) <span class="cov0" title="0">{

        var wc []string

        if filter.ManifestID != nil </span><span class="cov0" title="0">{
                data["manifest_id"] = &amp;filter.ManifestID
                wc = append(wc, "manifest_id = :manifest_id")
        }</span>

        <span class="cov0" title="0">if len(wc) &gt; 0 </span><span class="cov0" title="0">{
                buf.WriteString(" WHERE ")
                buf.WriteString(strings.Join(wc, " AND "))
        }</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">// Package manifestdb contains product related CRUD functionality.
package manifestdb

import (
        "bytes"
        "context"
        "errors"
        "fmt"

        "github.com/FITHSCS/backend/business/domain/manifestbus"
        "github.com/FITHSCS/backend/business/domain/pickupbatchbus"
        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/business/sdk/sqldb"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/google/uuid"
        "github.com/jmoiron/sqlx"
)

type Store struct {
        log *logger.Logger
        db  sqlx.ExtContext
}

func NewStore(log *logger.Logger, db *sqlx.DB) *Store <span class="cov0" title="0">{
        return &amp;Store{log: log, db: db}
}</span>

func (s *Store) Create(ctx context.Context, p manifestbus.Manifest) error <span class="cov0" title="0">{
        const stmt = `
    INSERT INTO manifest (
            manifest_id, 
                pickup_batch_id,
                origin_facility_id,
                destination_facility_id, 
            order_id,
                delivery_id,
                status,
                items_summary,
                pickup_time,
                delivery_time,
            is_synced, 
                is_deleted,
                time_stamp, 
            created_at,
                updated_at 
    ) 
        VALUES (
            :manifest_id, 
                :pickup_batch_id, 
                :origin_facility_id,
                :destination_facility_id, 
            :order_id, 
                :delivery_id,
                :status,
                :items_summary,
                :pickup_time,
                :delivery_time,
            :is_synced, 
                :is_deleted,
                :time_stamp, 
            :created_at, 
                :updated_at
    )`
        returnedValue, err := toDBManifest(p)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return sqldb.NamedExecContext(ctx, s.log, s.db, stmt, returnedValue)</span>
}

func (s *Store) Update(ctx context.Context, p manifestbus.Manifest) error <span class="cov0" title="0">{
        const stmt = `
    UPDATE 
                manifest
    SET 
                pickup_batch_id              = :pickup_batch_id,
        origin_facility_id           = :origin_facility_id,
        destination_facility_id      = :destination_facility_id,
        order_id                                 = :order_id,
        delivery_id                           = :delivery_id,
        status                                    = :status,
                items_summary                                   = :items_summary,
                pickup_time                                   = :pickup_time,
                delivery_time                                   = :delivery_time,
        is_synced                    = :is_synced,
        is_deleted                   = :is_deleted,
        time_stamp                   = :time_stamp,
        updated_at                   = :updated_at
    WHERE 
                manifest_id                             = :manifest_id`

        returnedValue, err := toDBManifest(p)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return sqldb.NamedExecContext(ctx, s.log, s.db, stmt, returnedValue)</span>
}

func (s *Store) Query(ctx context.Context,
        filter manifestbus.QueryFilter, orderBy order.By, page page.Page) ([]manifestbus.Manifest, error) <span class="cov0" title="0">{

        data := map[string]any{
                "offset":        (page.Number() - 1) * page.RowsPerPage(),
                "rows_per_page": page.RowsPerPage(),
        }

        const q = `
    SELECT
                manifest_id,
            pickup_batch_id,
                origin_facility_id,
                destination_facility_id, 
            order_id,
                delivery_id,
                status,
                items_summary,
                pickup_time,
                delivery_time,
            is_synced, 
                is_deleted,
                time_stamp, 
            created_at,
                updated_at 
    FROM 
                manifest        `

        var buf bytes.Buffer
        buf.WriteString(q)
        applyFilter(filter, data, &amp;buf)

        clause, err := orderByClause(orderBy)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">buf.WriteString(clause)
        buf.WriteString(" OFFSET :offset ROWS FETCH NEXT :rows_per_page ROWS ONLY")

        var dbRecs []manifestdb
        if err := sqldb.NamedQuerySlice(ctx, s.log, s.db, buf.String(), data, &amp;dbRecs); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("namedqueryslice: %w", err)
        }</span>
        <span class="cov0" title="0">fmt.Println(dbRecs)
        return toBusManifests(dbRecs)</span>
}

func (s *Store) Count(ctx context.Context, filter manifestbus.QueryFilter) (int, error) <span class="cov0" title="0">{
        data := map[string]any{}
        const base = `SELECT count(1) FROM manifest`

        var buf bytes.Buffer
        buf.WriteString(base)
        applyFilter(filter, data, &amp;buf)

        var out struct {
                Count int `db:"count"`
        }
        if err := sqldb.NamedQueryStruct(ctx, s.log, s.db, buf.String(), data, &amp;out); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("db: %w", err)
        }</span>
        <span class="cov0" title="0">return out.Count, nil</span>
}

func (s *Store) QueryByID(ctx context.Context, manifestID uuid.UUID) (manifestbus.Manifest, error) <span class="cov0" title="0">{
        param := map[string]any{
                "manifest_id": manifestID.String(),
        }
        const stmt = `
    SELECT
            manifest_id,
            pickup_batch_id,
                origin_facility_id,
                destination_facility_id, 
            order_id,
                delivery_id,
                status,
                items_summary,
                pickup_time,
                delivery_time,
            is_synced, 
                is_deleted,
                time_stamp, 
            created_at,
                updated_at 
        FROM 
                  manifest
        WHERE 
                  manifest_id = :manifest_id`

        var rec manifestdb
        if err := sqldb.NamedQueryStruct(ctx, s.log, s.db, stmt, param, &amp;rec); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sqldb.ErrDBNotFound) </span><span class="cov0" title="0">{
                        return manifestbus.Manifest{}, fmt.Errorf("db: %w", pickupbatchbus.ErrNotFound)
                }</span>
                <span class="cov0" title="0">return manifestbus.Manifest{}, fmt.Errorf("db: %w", err)</span>
        }
        <span class="cov0" title="0">return toBusManifest(rec)</span>
}

func (s *Store) SoftDelete(ctx context.Context, manifestID uuid.UUID) error <span class="cov0" title="0">{

        const q = `
    UPDATE
        manifest
        SET
                is_deleted = :is_deleted
    WHERE
        manifest_id = :manifest_id`

        manifest := manifestdb{ID: manifestID, IsDeleted: true}

        if err := sqldb.NamedExecContext(ctx, s.log, s.db, q, manifest); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("namedexeccontext: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *Store) HardDelete(ctx context.Context, manifestID uuid.UUID) error <span class="cov0" title="0">{
        const q = `
    DELETE FROM
        manifest
    WHERE
        manifest_id = :manifest_id`

        manifest := manifestdb{ID: manifestID}

        if err := sqldb.NamedExecContext(ctx, s.log, s.db, q, manifest); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("namedexeccontext: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">package manifestdb

import (
        "encoding/json"
        "fmt"
        "time"

        "github.com/FITHSCS/backend/business/domain/manifestbus"
        "github.com/FITHSCS/backend/business/types/genstringtype"
        "github.com/google/uuid"
        "github.com/jmoiron/sqlx/types"
)

type manifestdb struct {
        ID                    uuid.UUID          `db:"manifest_id"`
        PickupBatchID         uuid.UUID          `db:"pickup_batch_id"`
        OriginFacilityID      uuid.UUID          `db:"origin_facility_id"`
        DestinationFacilityID uuid.UUID          `db:"destination_facility_id"`
        OrderID               string             `db:"order_id"`
        DeliveryID            string             `db:"delivery_id"`
        Status                string             `db:"status"`
        ItemsSummary          types.NullJSONText `db:"items_summary"`
        PickupTime            time.Time          `db:"pickup_time"`
        DeliveryTime          time.Time          `db:"delivery_time"`
        IsSynced              bool               `db:"is_synced"`
        IsDeleted             bool               `db:"is_deleted"`
        TimeStamp             time.Time          `db:"time_stamp"`
        CreatedAt             time.Time          `db:"created_at"`
        UpdatedAt             time.Time          `db:"updated_at"`
}

func toDBManifest(bus manifestbus.Manifest) (manifestdb, error) <span class="cov0" title="0">{

        pkpBatch := manifestdb{
                ID:                    bus.ID,
                PickupBatchID:         bus.PickupBatchID,
                OriginFacilityID:      bus.OriginFacilityID,
                DestinationFacilityID: bus.DestinationFacilityID,
                OrderID:               bus.OrderID.String(),
                DeliveryID:            bus.DeliveryID.String(),
                Status:                bus.Status.String(),
                ItemsSummary:          types.NullJSONText{JSONText: []byte(bus.ItemsSummary), Valid: true},
                PickupTime:            bus.PickupTime.UTC(),
                DeliveryTime:          bus.DeliveryTime.UTC(),
                IsSynced:              bus.IsSynced,
                IsDeleted:             bus.IsDeleted,
                TimeStamp:             bus.TimeStamp.UTC(),
                CreatedAt:             bus.CreatedAt.UTC(),
                UpdatedAt:             bus.UpdatedAt.UTC(),
        }

        return pkpBatch, nil
}</span>

func toBusManifest(db manifestdb) (manifestbus.Manifest, error) <span class="cov0" title="0">{

        OrdrID, err := genstringtype.Parse(db.OrderID)
        if err != nil </span><span class="cov0" title="0">{
                return manifestbus.Manifest{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">dlvryID, err := genstringtype.Parse(db.DeliveryID)
        if err != nil </span><span class="cov0" title="0">{
                return manifestbus.Manifest{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">sts, err := genstringtype.Parse(db.Status)
        if err != nil </span><span class="cov0" title="0">{
                return manifestbus.Manifest{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">bus := manifestbus.Manifest{
                ID:                    db.ID,
                PickupBatchID:         db.PickupBatchID,
                OriginFacilityID:      db.OriginFacilityID,
                DestinationFacilityID: db.DestinationFacilityID,
                OrderID:               OrdrID,
                DeliveryID:            dlvryID,
                Status:                sts,
                ItemsSummary:          json.RawMessage(db.ItemsSummary.JSONText),
                PickupTime:            db.PickupTime.In(time.Local),
                DeliveryTime:          db.DeliveryTime.In(time.Local),
                IsDeleted:             db.IsDeleted,
                IsSynced:              db.IsSynced,
                TimeStamp:             db.TimeStamp.In(time.Local),
                CreatedAt:             db.CreatedAt.In(time.Local),
                UpdatedAt:             db.UpdatedAt.In(time.Local),
        }
        return bus, nil</span>

}

func toBusManifests(dbs []manifestdb) ([]manifestbus.Manifest, error) <span class="cov0" title="0">{
        bus := make([]manifestbus.Manifest, len(dbs))

        for i, db := range dbs </span><span class="cov0" title="0">{
                var err error
                bus[i], err = toBusManifest(db)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">return bus, nil</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">package manifestdb

import (
        "fmt"

        "github.com/FITHSCS/backend/business/domain/manifestbus"
        "github.com/FITHSCS/backend/business/sdk/order"
)

var orderByFields = map[string]string{
        manifestbus.OrderByID:             "manifest_id",
        manifestbus.OrderByRouteID:        "route_id",
        manifestbus.OrderByOriginFacility: "origin_facility_id",
        manifestbus.OrderByIsSynced:       "is_synced",
        manifestbus.OrderByTimeStamp:      "time_stamp",
        manifestbus.OrderByCreatedAt:      "created_at",
        manifestbus.OrderByUpdatedAt:      "updated_at",
}

// orderByClause converts an order.By value into the final
// " ORDER BY  ASC|DESC" fragment the store adds to its SELECT.
func orderByClause(ob order.By) (string, error) <span class="cov0" title="0">{
        col, ok := orderByFields[ob.Field]
        if !ok </span><span class="cov0" title="0">{
                return "", fmt.Errorf("field %q does not exist", ob.Field)
        }</span>
        <span class="cov0" title="0">return " ORDER BY " + col + " " + ob.Direction, nil</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">package manifestbus

import (
        "context"
        "encoding/json"
        "fmt"
        "math/rand"
        "time"

        "github.com/FITHSCS/backend/business/types/genstringtype"
        "github.com/google/uuid"
)

func TestGenerateNewManifest(n int, pickupBatchID, origFacID, destFacID uuid.UUID) []NewManifest <span class="cov5" title="2">{
        newfs := make([]NewManifest, n)
        sts := []string{"pending", "picked_up", "in_transit", "delivered", "exception"}

        pickupTime, _ := time.Parse(time.RFC3339, "2025-06-10T15:59:33+03:00")
        delTime := pickupTime.Add(time.Hour * 10)
        timestamp := pickupTime.Add(time.Minute + 1)

        idx := rand.Intn(10000)
        for i := range n </span><span class="cov10" title="4">{
                idx++

                jsonString := fmt.Sprintf(`{
                            "total_items": %d,
                            "total_weight_kg": %.2f,
                            "items": 
                                        {
                                        "Code": %d,
                                        "Type": %d
                                        },
                            "contains_fragile": %t
                }`, (i+1)*5, rand.Float64()*20, (i+1)*2, (i+1)*3, i%2 == 0)

                itemsSummaryJSON := json.RawMessage(jsonString)

                nf := NewManifest{
                        PickupBatchID:         pickupBatchID,
                        OriginFacilityID:      origFacID,
                        DestinationFacilityID: destFacID,
                        OrderID:               genstringtype.MustParse(fmt.Sprintf("OrderID:%d", idx)),
                        DeliveryID:            genstringtype.MustParse(fmt.Sprintf("DeliveryID:%d", idx)),
                        Status:                genstringtype.MustParse(sts[i%5]),
                        ItemsSummary:          itemsSummaryJSON,
                        PickupTime:            pickupTime,
                        DeliveryTime:          delTime,
                        IsSynced:              false,
                        TimeStamp:             timestamp,
                }

                newfs[i] = nf
        }</span>

        <span class="cov5" title="2">return newfs</span>
}

func TestGenerateSeedManifest(ctx context.Context, n int, api *Business, pickupBatchID, origFacID, destFacID uuid.UUID) ([]Manifest, error) <span class="cov5" title="2">{
        newfs := TestGenerateNewManifest(n, pickupBatchID, origFacID, destFacID)

        facs := make([]Manifest, len(newfs))
        for i, np := range newfs </span><span class="cov10" title="4">{
                prd, err := api.Create(ctx, np)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("seeding pickupbatch: idx: %d : %w", i, err)
                }</span>

                <span class="cov10" title="4">facs[i] = prd</span>
        }

        <span class="cov5" title="2">return facs, nil</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">// Package pickupbatchbus provides business access to packagedetail domain.
package pickupbatchbus

import (
        "context"
        "errors"
        "fmt"

        "time"

        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/google/uuid"
)

var (
        ErrNotFound       = errors.New("pickupbatch not found")
        ErrAuthentication = errors.New("authentication failed")
)

type Storer interface {
        Create(ctx context.Context, pickupbatch PickupBatch) error
        Update(ctx context.Context, pickupbatch PickupBatch) error
        SoftDelete(ctx context.Context, pickupBatchID uuid.UUID) error
        HardDelete(ctx context.Context, pickupBatchID uuid.UUID) error
        Query(ctx context.Context, filter QueryFilter, orderby order.By, page page.Page) ([]PickupBatch, error)
        QueryByID(ctx context.Context, pickupBatchID uuid.UUID) (PickupBatch, error)
        Count(ctx context.Context, filter QueryFilter) (int, error)
}

func (b *Business) GetStorer() Storer <span class="cov0" title="0">{
        return b.storer
}</span>

type Business struct {
        log    *logger.Logger
        storer Storer
}

func NewBusiness(log *logger.Logger, storer Storer) *Business <span class="cov1" title="1">{

        return &amp;Business{
                log:    log,
                storer: storer,
        }
}</span>

func (b *Business) Create(ctx context.Context, pb NewPickupBatch) (PickupBatch, error) <span class="cov10" title="5">{

        now := time.Now()

        pickupbatch := PickupBatch{
                ID:                  uuid.New(),
                RouteID:             pb.RouteID,
                OriginFacilityID:    pb.OriginFacilityID,
                VehicleID:           pb.VehicleID,
                DeliveryPersonnelID: pb.DeliveryPersonnelID,
                BatchName:           pb.BatchName,
                BatchStatus:         pb.BatchStatus,
                PickedStartedAt:     pb.PickedStartedAt,
                PickupCompletedAt:   pb.PickupCompletedAt,
                TimeStamp:           now,
                IsDeleted:           false,
                IsSynced:            pb.IsSynced,
                CreatedAt:           now,
                UpdatedAt:           now,
        }

        if err := b.storer.Create(ctx, pickupbatch); err != nil </span><span class="cov0" title="0">{
                return PickupBatch{}, fmt.Errorf("Create: %w", err)
        }</span>

        <span class="cov10" title="5">return pickupbatch, nil</span>
}

func (b *Business) Update(ctx context.Context, pickupBatchID uuid.UUID, updatePickupbatch UpdatePickupBatch) (PickupBatch, error) <span class="cov1" title="1">{

        pkupBtchOrgnl, err := b.storer.QueryByID(ctx, pickupBatchID)
        if err != nil </span><span class="cov0" title="0">{
                return PickupBatch{}, fmt.Errorf("querybyid: %w", err)
        }</span>

        <span class="cov1" title="1">if updatePickupbatch.RouteID != nil </span><span class="cov1" title="1">{
                pkupBtchOrgnl.RouteID = *updatePickupbatch.RouteID
        }</span>

        <span class="cov1" title="1">if updatePickupbatch.OriginFacilityID != nil </span><span class="cov1" title="1">{
                pkupBtchOrgnl.OriginFacilityID = *updatePickupbatch.OriginFacilityID
        }</span>

        <span class="cov1" title="1">if updatePickupbatch.VehicleID != nil </span><span class="cov1" title="1">{
                pkupBtchOrgnl.VehicleID = *updatePickupbatch.VehicleID
        }</span>

        <span class="cov1" title="1">if updatePickupbatch.DeliveryPersonnelID != nil </span><span class="cov1" title="1">{
                pkupBtchOrgnl.DeliveryPersonnelID = *updatePickupbatch.DeliveryPersonnelID
        }</span>

        <span class="cov1" title="1">if updatePickupbatch.BatchStatus != nil </span><span class="cov1" title="1">{
                pkupBtchOrgnl.BatchStatus = *updatePickupbatch.BatchStatus
        }</span>

        <span class="cov1" title="1">if updatePickupbatch.BatchName != nil </span><span class="cov1" title="1">{
                pkupBtchOrgnl.BatchName = *updatePickupbatch.BatchName
        }</span>

        <span class="cov1" title="1">if updatePickupbatch.PickedStartedAt != nil </span><span class="cov1" title="1">{
                pkupBtchOrgnl.PickedStartedAt = *updatePickupbatch.PickedStartedAt
        }</span>

        <span class="cov1" title="1">if updatePickupbatch.PickupCompletedAt != nil </span><span class="cov1" title="1">{
                pkupBtchOrgnl.PickupCompletedAt = *updatePickupbatch.PickupCompletedAt
        }</span>

        <span class="cov1" title="1">if updatePickupbatch.TimeStamp != nil </span><span class="cov1" title="1">{
                pkupBtchOrgnl.TimeStamp = *updatePickupbatch.TimeStamp
        }</span>

        <span class="cov1" title="1">pkupBtchOrgnl.UpdatedAt = time.Now().Truncate(time.Microsecond)

        if err := b.storer.Update(ctx, pkupBtchOrgnl); err != nil </span><span class="cov0" title="0">{
                return PickupBatch{}, fmt.Errorf("update: %w", err)
        }</span>
        <span class="cov1" title="1">return pkupBtchOrgnl, nil</span>
}

func (b *Business) QueryByID(ctx context.Context, pickupBatchID uuid.UUID) (PickupBatch, error) <span class="cov1" title="1">{

        pickupbatch, err := b.storer.QueryByID(ctx, pickupBatchID)
        if err != nil </span><span class="cov0" title="0">{
                return PickupBatch{}, fmt.Errorf("query: pickupbatchID[%s]: %w", pickupBatchID, err)
        }</span>
        <span class="cov1" title="1">return pickupbatch, nil</span>
}

func (b *Business) Query(ctx context.Context, filter QueryFilter, orderBy order.By, page page.Page) ([]PickupBatch, error) <span class="cov1" title="1">{

        pickupbatches, err := b.storer.Query(ctx, filter, orderBy, page)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Query: %w", err)
        }</span>
        <span class="cov1" title="1">return pickupbatches, nil</span>
}

func (b *Business) Count(ctx context.Context, filter QueryFilter) (int, error) <span class="cov0" title="0">{

        return b.storer.Count(ctx, filter)
}</span>

func (b *Business) SoftDelete(ctx context.Context, pickupBatchID uuid.UUID) error <span class="cov4" title="2">{

        facility, err := b.storer.QueryByID(ctx, pickupBatchID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("softdeletequery: pickupBatch[%s]: %w", pickupBatchID, err)
        }</span>

        <span class="cov4" title="2">if facility.IsDeleted </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: already deleted", pickupBatchID)
        }</span>

        <span class="cov4" title="2">if err := b.storer.SoftDelete(ctx, pickupBatchID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("delete: %w", err)
        }</span>
        <span class="cov4" title="2">return nil</span>

}

func (b *Business) HardDelete(ctx context.Context, pickupBatchID uuid.UUID) error <span class="cov4" title="2">{

        if err := b.storer.HardDelete(ctx, pickupBatchID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("delete: %w", err)
        }</span>
        <span class="cov4" title="2">return nil</span>

}
</pre>
		
		<pre class="file" id="file55" style="display: none">package pickupbatchdb

import (
        "bytes"
        //"fmt"
        "strings"

        "github.com/FITHSCS/backend/business/domain/pickupbatchbus"
        "github.com/google/uuid"
)

func applyFilter(filter pickupbatchbus.QueryFilter, data map[string]any, buf *bytes.Buffer) <span class="cov0" title="0">{

        var wc []string

        if filter.ID != uuid.Nil </span><span class="cov0" title="0">{
                data["pickup_batch_id"] = &amp;filter.ID
                wc = append(wc, "pickupb_batch_id = :pickupb_batch_id")
        }</span>
        <span class="cov0" title="0">if filter.RouteID != nil </span><span class="cov0" title="0">{
                data["route_id"] = *filter.RouteID
                wc = append(wc, "route_id = :route_id")
        }</span>

        <span class="cov0" title="0">if filter.VehicleID != nil </span><span class="cov0" title="0">{
                data["vehicle_id"] = *filter.VehicleID
                wc = append(wc, "vehicle_id = :vehicle_id")
        }</span>
        <span class="cov0" title="0">if filter.OriginFacility != nil </span><span class="cov0" title="0">{
                data["origin_facility_id"] = *filter.OriginFacility
                wc = append(wc, "origin_facility_id = :origin_facility_id")
        }</span>
        <span class="cov0" title="0">if filter.DeliveryPersonnelID != nil </span><span class="cov0" title="0">{
                data["delivery_personnel_id"] = *filter.DeliveryPersonnelID
                wc = append(wc, "deliver_personnel_id = :delivery_personnel_id")
        }</span>

        <span class="cov0" title="0">if filter.DeliveryPersonnelSignature != nil </span><span class="cov0" title="0">{
                data["delivery_personnel_signature"] = *filter.DeliveryPersonnelSignature
                wc = append(wc, "deliver_personnel_signature = :delivery_personnel_signature")
        }</span>
        <span class="cov0" title="0">if filter.IsSynced != nil </span><span class="cov0" title="0">{
                data["is_synced"] = *filter.IsSynced
                wc = append(wc, "is_synced = :is_synced")
        }</span>

        <span class="cov0" title="0">if filter.IsSynced != nil </span><span class="cov0" title="0">{
                data["is_synced"] = *filter.IsSynced
                wc = append(wc, "is_synced = :is_synced")
        }</span>
        <span class="cov0" title="0">if filter.TimeStamp != nil </span><span class="cov0" title="0">{
                data["time_stamp"] = *filter.TimeStamp
                wc = append(wc, "time_stamp = :time_stamp")
        }</span>

        <span class="cov0" title="0">if filter.CreatedAt != nil </span><span class="cov0" title="0">{
                data["created_at"] = filter.CreatedAt.UTC()
                wc = append(wc, "date_created &gt;= :created_at")
        }</span>
        <span class="cov0" title="0">if filter.UpdatedAt != nil </span><span class="cov0" title="0">{
                data["updated_at"] = filter.UpdatedAt.UTC()
                wc = append(wc, "updated_at &lt;= :updated_at")
        }</span>

        <span class="cov0" title="0">if len(wc) &gt; 0 </span><span class="cov0" title="0">{
                buf.WriteString(" WHERE ")
                buf.WriteString(strings.Join(wc, " AND "))
        }</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">package pickupbatchdb

import (
        "fmt"
        "time"

        "github.com/FITHSCS/backend/business/domain/pickupbatchbus"
        "github.com/FITHSCS/backend/business/types/genstringtype"

        "github.com/google/uuid"
)

type pickupbatch struct {
        ID                  uuid.UUID `db:"pickup_batch_id"`
        RouteID             uuid.UUID `db:"route_id"`
        OriginFacilityID    uuid.UUID `db:"origin_facility_id"`
        VehicleID           uuid.UUID `db:"vehicle_id"`
        DeliveryPersonnelID uuid.UUID `db:"delivery_personnel_id"`
        BatchName           string    `db:"batch_name"`
        BatchStatus         string    `db:"batch_status"`
        PickupStartedAt     time.Time `db:"pickup_started_at"`
        PickupCompletedAt   time.Time `db:"pickup_completed_at"`
        IsSynced            bool      `db:"is_synced"`
        IsDeleted           bool      `db:"is_deleted"`
        TimeStamp           time.Time `db:"time_stamp"`
        CreatedAt           time.Time `db:"created_at"`
        UpdatedAt           time.Time `db:"updated_at"`
}

//=============================================================================&gt;

func toDBPickupBatch(bus pickupbatchbus.PickupBatch) (pickupbatch, error) <span class="cov0" title="0">{

        pkpBatch := pickupbatch{
                ID:                  bus.ID,
                RouteID:             bus.RouteID,
                VehicleID:           bus.VehicleID,
                OriginFacilityID:    bus.OriginFacilityID,
                DeliveryPersonnelID: bus.DeliveryPersonnelID,
                BatchName:           bus.BatchName.String(),
                BatchStatus:         bus.BatchStatus.String(),
                PickupStartedAt:     bus.PickedStartedAt.UTC(),
                PickupCompletedAt:   bus.PickupCompletedAt.UTC(),
                IsSynced:            bus.IsSynced,
                IsDeleted:           bus.IsDeleted,
                TimeStamp:           bus.TimeStamp.UTC(),
                CreatedAt:           bus.CreatedAt.UTC(),
                UpdatedAt:           bus.UpdatedAt.UTC(),
        }

        return pkpBatch, nil
}</span>

func toBusPickupBatch(db pickupbatch) (pickupbatchbus.PickupBatch, error) <span class="cov0" title="0">{
        batchSts, err := genstringtype.Parse(db.BatchStatus)
        if err != nil </span><span class="cov0" title="0">{
                return pickupbatchbus.PickupBatch{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">batchName, err := genstringtype.Parse(db.BatchName)
        if err != nil </span><span class="cov0" title="0">{
                return pickupbatchbus.PickupBatch{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">bus := pickupbatchbus.PickupBatch{
                ID:                  db.ID,
                RouteID:             db.RouteID,
                OriginFacilityID:    db.OriginFacilityID,
                VehicleID:           db.VehicleID,
                DeliveryPersonnelID: db.DeliveryPersonnelID,
                BatchName:           batchName,
                BatchStatus:         batchSts,
                PickedStartedAt:     db.PickupStartedAt.In(time.Local),
                PickupCompletedAt:   db.PickupCompletedAt.In(time.Local),
                IsDeleted:           db.IsDeleted,
                IsSynced:            db.IsSynced,
                TimeStamp:           db.TimeStamp.In(time.Local),
                CreatedAt:           db.CreatedAt.In(time.Local),
                UpdatedAt:           db.UpdatedAt.In(time.Local),
        }

        return bus, nil</span>

}

func toBusPickupBatches(dbs []pickupbatch) ([]pickupbatchbus.PickupBatch, error) <span class="cov0" title="0">{

        bus := make([]pickupbatchbus.PickupBatch, len(dbs))

        for i, db := range dbs </span><span class="cov0" title="0">{
                var err error
                bus[i], err = toBusPickupBatch(db)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">return bus, nil</span>
}
</pre>
		
		<pre class="file" id="file57" style="display: none">package pickupbatchdb

import (
        "fmt"

        "github.com/FITHSCS/backend/business/domain/pickupbatchbus"
        "github.com/FITHSCS/backend/business/sdk/order"
)

var orderByFields = map[string]string{
        pickupbatchbus.OrderByID:                  "pickup_batch_id",
        pickupbatchbus.OrderByRouteID:             "route_id",
        pickupbatchbus.OrderByVehicleID:           "vehicle_id",
        pickupbatchbus.OrderByOriginFacility:      "origin_facility_id",
        pickupbatchbus.OrderByDeliveryPersonnelID: "delivery_personnel_id",
        pickupbatchbus.OrderByIsSynced:            "is_synced",
        pickupbatchbus.OrderByTimeStamp:           "time_stamp",
        pickupbatchbus.OrderByCreatedAt:           "created_at",
        pickupbatchbus.OrderByUpdatedAt:           "updated_at",
}

// orderByClause converts an order.By value into the final
// " ORDER BY  ASC|DESC" fragment the store adds to its SELECT.
func orderByClause(ob order.By) (string, error) <span class="cov0" title="0">{
        col, ok := orderByFields[ob.Field]
        if !ok </span><span class="cov0" title="0">{
                return "", fmt.Errorf("field %q does not exist", ob.Field)
        }</span>
        <span class="cov0" title="0">return " ORDER BY " + col + " " + ob.Direction, nil</span>
}
</pre>
		
		<pre class="file" id="file58" style="display: none">// Package pickupbatchdb contains product related CRUD functionality.
package pickupbatchdb

import (
        "bytes"
        "context"
        "errors"
        "fmt"

        "github.com/FITHSCS/backend/business/domain/pickupbatchbus"
        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/business/sdk/sqldb"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/google/uuid"
        "github.com/jmoiron/sqlx"
)

type Store struct {
        log *logger.Logger
        db  sqlx.ExtContext
}

func NewStore(log *logger.Logger, db *sqlx.DB) *Store <span class="cov0" title="0">{
        return &amp;Store{log: log, db: db}
}</span>

func (s *Store) Create(ctx context.Context, p pickupbatchbus.PickupBatch) error <span class="cov0" title="0">{
        const stmt = `
    INSERT INTO pickup_batch (
            pickup_batch_id, 
                route_id,
                origin_facility_id,
                vehicle_id, 
            delivery_personnel_id,
                batch_name,
                batch_status,
                pickup_started_at,
                pickup_completed_at,
            is_synced, 
                is_deleted,
                time_stamp, 
            created_at,
                updated_at 
    ) 
        VALUES (
            :pickup_batch_id, 
                :route_id, 
                :origin_facility_id,
                :vehicle_id, 
            :delivery_personnel_id, 
                :batch_name,
                :batch_status,
                :pickup_started_at,
                :pickup_completed_at,
            :is_synced, 
                :is_deleted,
                :time_stamp, 
            :created_at, 
                :updated_at
    )`
        returnedValue, err := toDBPickupBatch(p)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return sqldb.NamedExecContext(ctx, s.log, s.db, stmt, returnedValue)</span>
}

func (s *Store) Update(ctx context.Context, p pickupbatchbus.PickupBatch) error <span class="cov0" title="0">{
        const stmt = `
    UPDATE 
                pickup_batch
    SET 
                route_id                     = :route_id,
        origin_facility_id           = :origin_facility_id,
        vehicle_id                   = :vehicle_id,
        delivery_personnel_id        = :delivery_personnel_id,
        batch_name                           = :batch_name,
        batch_status                           = :batch_status,
                pickup_started_at                          = :pickup_started_at,
                pickup_completed_at                  = :pickup_completed_at,
        is_synced                    = :is_synced,
        is_deleted                   = :is_deleted,
        time_stamp                   = :time_stamp,
        updated_at                   = :updated_at
    WHERE pickup_batch_id            = :pickup_batch_id`

        returnedValue, err := toDBPickupBatch(p)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return sqldb.NamedExecContext(ctx, s.log, s.db, stmt, returnedValue)</span>
}

func (s *Store) Query(ctx context.Context,
        filter pickupbatchbus.QueryFilter, orderBy order.By, page page.Page) ([]pickupbatchbus.PickupBatch, error) <span class="cov0" title="0">{

        data := map[string]any{
                "offset":        (page.Number() - 1) * page.RowsPerPage(),
                "rows_per_page": page.RowsPerPage(),
        }

        const q = `
    SELECT
      pickup_batch_id,
          route_id, 
          origin_facility_id, 
          vehicle_id,
          delivery_personnel_id,
      batch_name,
          batch_status,
          pickup_started_at,
          pickup_completed_at, 
          is_synced,
          is_deleted,
          time_stamp,
      created_at, 
          updated_at
    FROM pickup_batch`

        var buf bytes.Buffer
        buf.WriteString(q)
        applyFilter(filter, data, &amp;buf)

        clause, err := orderByClause(orderBy)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">buf.WriteString(clause)
        buf.WriteString(" OFFSET :offset ROWS FETCH NEXT :rows_per_page ROWS ONLY")

        var dbRecs []pickupbatch
        if err := sqldb.NamedQuerySlice(ctx, s.log, s.db, buf.String(), data, &amp;dbRecs); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("namedqueryslice: %w", err)
        }</span>
        <span class="cov0" title="0">fmt.Println(dbRecs)
        return toBusPickupBatches(dbRecs)</span>
}

func (s *Store) QueryByID(ctx context.Context, pkupBatchID uuid.UUID) (pickupbatchbus.PickupBatch, error) <span class="cov0" title="0">{
        param := map[string]any{
                "pickup_batch_id": pkupBatchID.String(),
        }
        const stmt = `
    SELECT
            pickup_batch_id,
                  route_id, 
                  origin_facility_id, 
                vehicle_id,
                  delivery_personnel_id,
              batch_name,
                  batch_status,
                  pickup_started_at,
                  pickup_completed_at,
                  is_synced,
                  is_deleted,
                  time_stamp,
              created_at, 
                  updated_at
        FROM 
                  pickup_batch
        WHERE 
                  pickup_batch_id = :pickup_batch_id`

        var rec pickupbatch
        if err := sqldb.NamedQueryStruct(ctx, s.log, s.db, stmt, param, &amp;rec); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sqldb.ErrDBNotFound) </span><span class="cov0" title="0">{
                        return pickupbatchbus.PickupBatch{}, fmt.Errorf("db: %w", pickupbatchbus.ErrNotFound)
                }</span>
                <span class="cov0" title="0">return pickupbatchbus.PickupBatch{}, fmt.Errorf("db: %w", err)</span>
        }
        <span class="cov0" title="0">return toBusPickupBatch(rec)</span>
}

func (s *Store) Count(ctx context.Context, filter pickupbatchbus.QueryFilter) (int, error) <span class="cov0" title="0">{
        data := map[string]any{}
        const base = `SELECT count(1) FROM pickup_batch`

        var buf bytes.Buffer
        buf.WriteString(base)
        applyFilter(filter, data, &amp;buf)

        var out struct {
                Count int `db:"count"`
        }
        if err := sqldb.NamedQueryStruct(ctx, s.log, s.db, buf.String(), data, &amp;out); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("db: %w", err)
        }</span>
        <span class="cov0" title="0">return out.Count, nil</span>
}

func (s *Store) SoftDelete(ctx context.Context, pickupBatchID uuid.UUID) error <span class="cov0" title="0">{

        const q = `
    UPDATE
        pickup_batch
        SET
                is_deleted = :is_deleted
    WHERE
        pickup_batch_id = :pickup_batch_id`

        dbPickupBatch := pickupbatch{ID: pickupBatchID, IsDeleted: true}

        if err := sqldb.NamedExecContext(ctx, s.log, s.db, q, dbPickupBatch); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("namedexeccontext: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *Store) HardDelete(ctx context.Context, pickupBatchID uuid.UUID) error <span class="cov0" title="0">{
        const q = `
    DELETE FROM
        pickup_batch
    WHERE
        pickup_batch_id = :pickup_batch_id`

        dbPickupBatch := pickupbatch{ID: pickupBatchID}

        if err := sqldb.NamedExecContext(ctx, s.log, s.db, q, dbPickupBatch); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("namedexeccontext: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file59" style="display: none">package pickupbatchbus

import (
        "context"
        "fmt"
        "math/rand"
        "time"

        "github.com/FITHSCS/backend/business/types/genstringtype"
        "github.com/google/uuid"
)

func TestGenerateNewPickupBatch(n int, routeID, deliveryPersonnelID, OrigfacID, VehID uuid.UUID) []NewPickupBatch <span class="cov5" title="2">{
        newfs := make([]NewPickupBatch, n)
        sts := []string{"pending", "picked_up", "in_transit", "delivered"}

        pickupTime, _ := time.Parse(time.RFC3339, "2025-06-10T15:59:33+03:00")
        CompTime := pickupTime.Add(time.Hour * 10)
        timestamp := pickupTime.Add(time.Minute + 1)

        idx := rand.Intn(10000)
        for i := range n </span><span class="cov10" title="4">{
                idx++

                nf := NewPickupBatch{
                        RouteID:             routeID,
                        DeliveryPersonnelID: deliveryPersonnelID,
                        OriginFacilityID:    OrigfacID,
                        VehicleID:           VehID,
                        BatchName:           genstringtype.MustParse(fmt.Sprintf("BatchName%d", idx)),
                        BatchStatus:         genstringtype.MustParse(sts[i%2]),
                        PickedStartedAt:     pickupTime,
                        PickupCompletedAt:   CompTime,
                        IsSynced:            true,
                        IsDeleted:           false,
                        TimeStamp:           timestamp,
                }

                newfs[i] = nf
        }</span>

        <span class="cov5" title="2">return newfs</span>
}

func TestGenerateSeedPickupBatch(ctx context.Context, n int, api *Business, routeID, deliveryPersonnelID, OrigfacID, VehID uuid.UUID) ([]PickupBatch, error) <span class="cov5" title="2">{
        newfs := TestGenerateNewPickupBatch(n, routeID, deliveryPersonnelID, OrigfacID, VehID)

        facs := make([]PickupBatch, len(newfs))
        for i, np := range newfs </span><span class="cov10" title="4">{
                prd, err := api.Create(ctx, np)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("seeding pickupbatch: idx: %d : %w", i, err)
                }</span>

                <span class="cov10" title="4">facs[i] = prd</span>
        }

        <span class="cov5" title="2">return facs, nil</span>
}
</pre>
		
		<pre class="file" id="file60" style="display: none">// Package routebus provides business access to route domain.
package routebus

import (
        "context"
        "fmt"
        "time"

        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/google/uuid"
)

type Storer interface {
        Create(ctx context.Context, route Route) error
        Update(ctx context.Context, route Route) error
        Delete(ctx context.Context, routeID uuid.UUID) error
        Query(ctx context.Context, filter QueryFilter, orderby order.By, page page.Page) ([]Route, error)
        QueryByID(ctx context.Context, routeID uuid.UUID) (Route, error)
        Count(ctx context.Context, filter QueryFilter) (int, error)
}

func (b *Business) GetStorer() Storer <span class="cov0" title="0">{
        return b.storer
}</span>

type Business struct {
        log    *logger.Logger
        storer Storer
}

func NewBusiness(log *logger.Logger, storer Storer) *Business <span class="cov1" title="1">{
        return &amp;Business{
                log:    log,
                storer: storer,
        }
}</span>

func (b *Business) Create(ctx context.Context, pb NewRoute) (Route, error) <span class="cov10" title="5">{

        now := time.Now().Truncate(time.Millisecond)

        route := Route{
                RouteID:         uuid.New(),
                StartFacilityID: pb.StartFacilityID,
                EndFacilityID:   pb.EndFacilityID,
                RouteName:       pb.RouteName,
                TotalKM:         pb.TotalKM,
                TotalStops:      pb.TotalStops,
                StartLatitude:   pb.StartLatitude,
                StartLongitude:  pb.StartLongitude,
                EndLatitude:     pb.EndLatitude,
                EndLongitude:    pb.EndLongitude,
                IsActive:        true,
                CreatedAt:       now,
                UpdatedAt:       now,
        }

        if err := b.storer.Create(ctx, route); err != nil </span><span class="cov0" title="0">{
                return Route{}, fmt.Errorf("Create: %w", err)
        }</span>

        <span class="cov10" title="5">return route, nil</span>
}

func (b *Business) Update(ctx context.Context, routeID uuid.UUID, updrte UpdateRoute) (Route, error) <span class="cov1" title="1">{

        rteOrig, err := b.storer.QueryByID(ctx, routeID)
        if err != nil </span><span class="cov0" title="0">{
                return Route{}, fmt.Errorf("querybyid: %w", err)
        }</span>

        <span class="cov1" title="1">if updrte.StartFacilityID != nil </span><span class="cov1" title="1">{
                rteOrig.StartFacilityID = *updrte.StartFacilityID
        }</span>

        <span class="cov1" title="1">if updrte.EndFacilityID != nil </span><span class="cov1" title="1">{
                rteOrig.EndFacilityID = *updrte.EndFacilityID
        }</span>

        <span class="cov1" title="1">if updrte.RouteName != nil </span><span class="cov1" title="1">{
                rteOrig.RouteName = *updrte.RouteName
        }</span>

        <span class="cov1" title="1">if updrte.TotalKM != nil </span><span class="cov1" title="1">{
                rteOrig.TotalKM = *updrte.TotalKM
        }</span>

        <span class="cov1" title="1">if updrte.TotalStops != nil </span><span class="cov1" title="1">{
                rteOrig.TotalStops = *updrte.TotalStops
        }</span>

        <span class="cov1" title="1">if updrte.StartLatitude != nil </span><span class="cov1" title="1">{
                rteOrig.StartLatitude = *updrte.StartLatitude
        }</span>

        <span class="cov1" title="1">if updrte.StartLongitude != nil </span><span class="cov1" title="1">{
                rteOrig.StartLongitude = *updrte.StartLongitude
        }</span>

        <span class="cov1" title="1">if updrte.EndLatitude != nil </span><span class="cov1" title="1">{
                rteOrig.EndLatitude = *updrte.EndLatitude
        }</span>

        <span class="cov1" title="1">if updrte.EndLongitude != nil </span><span class="cov1" title="1">{
                rteOrig.EndLongitude = *updrte.EndLongitude
        }</span>

        <span class="cov1" title="1">rteOrig.UpdatedAt = time.Now().Truncate(time.Microsecond)

        if err := b.storer.Update(ctx, rteOrig); err != nil </span><span class="cov0" title="0">{
                return Route{}, fmt.Errorf("update: %w", err)
        }</span>
        <span class="cov1" title="1">return rteOrig, nil</span>
}

func (b *Business) QueryByID(ctx context.Context, routeID uuid.UUID) (Route, error) <span class="cov1" title="1">{

        rte, err := b.storer.QueryByID(ctx, routeID)
        if err != nil </span><span class="cov0" title="0">{
                return Route{}, fmt.Errorf("query: routeid[%s]: %w", routeID, err)
        }</span>
        <span class="cov1" title="1">return rte, nil</span>
}

func (b *Business) Query(ctx context.Context, filter QueryFilter, orderBy order.By, page page.Page) ([]Route, error) <span class="cov1" title="1">{
        rtebtch, err := b.storer.Query(ctx, filter, orderBy, page)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Query: %w", err)
        }</span>
        <span class="cov1" title="1">return rtebtch, nil</span>
}

func (b *Business) Count(ctx context.Context, filter QueryFilter) (int, error) <span class="cov0" title="0">{
        return b.storer.Count(ctx, filter)
}</span>

func (b *Business) Delete(ctx context.Context, routeID uuid.UUID) error <span class="cov4" title="2">{

        facility, err := b.storer.QueryByID(ctx, routeID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("delete: pickupBatch[%s]: %w", routeID, err)
        }</span>

        <span class="cov4" title="2">if !facility.IsActive </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: already deleted", routeID)
        }</span>

        <span class="cov4" title="2">if err := b.storer.Delete(ctx, routeID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("delete: %w", err)
        }</span>
        <span class="cov4" title="2">return nil</span>

}
</pre>
		
		<pre class="file" id="file61" style="display: none">package routedb

import (
        "bytes"
        "strings"

        "github.com/FITHSCS/backend/business/domain/routebus"
)

func applyFilter(filter routebus.QueryFilter, data map[string]any, buf *bytes.Buffer) <span class="cov0" title="0">{

        var wc []string

        if filter.ID != nil </span><span class="cov0" title="0">{
                data["route_id"] = &amp;filter.ID
                wc = append(wc, "route_id = :route_id")
        }</span>
        <span class="cov0" title="0">if filter.StartFacility != nil </span><span class="cov0" title="0">{
                data["start_facility_id"] = *filter.StartFacility
                wc = append(wc, "start_facility_id = :start_facility_id")
        }</span>

        <span class="cov0" title="0">if filter.EndFacility != nil </span><span class="cov0" title="0">{
                data["end_facility_id"] = *filter.EndFacility
                wc = append(wc, "end_facility_id = :end_facility_id")
        }</span>

        <span class="cov0" title="0">if filter.RouteName != nil </span><span class="cov0" title="0">{
                data["route_name"] = *filter.RouteName
                wc = append(wc, "route_name = :route_name")
        }</span>

        <span class="cov0" title="0">if filter.TotalKM != nil </span><span class="cov0" title="0">{
                data["total_km"] = *filter.TotalKM
                wc = append(wc, "total_km &gt;= :total_km")
        }</span>

        <span class="cov0" title="0">if filter.IsActive != nil </span><span class="cov0" title="0">{
                data["is_active"] = *filter.IsActive
                wc = append(wc, "is_active = :is_active")
        }</span>

        <span class="cov0" title="0">if filter.CreatedAt != nil </span><span class="cov0" title="0">{
                data["created_at"] = filter.CreatedAt.UTC()
                wc = append(wc, "date_created &gt;= :created_at")
        }</span>
        <span class="cov0" title="0">if filter.UpdatedAt != nil </span><span class="cov0" title="0">{
                data["updated_at"] = filter.UpdatedAt.UTC()
                wc = append(wc, "updated_at &lt;= :updated_at")
        }</span>

        <span class="cov0" title="0">if len(wc) &gt; 0 </span><span class="cov0" title="0">{
                buf.WriteString(" WHERE ")
                buf.WriteString(strings.Join(wc, " AND "))
        }</span>
}
</pre>
		
		<pre class="file" id="file62" style="display: none">package routedb

import (
        "fmt"
        "time"

        "github.com/FITHSCS/backend/business/domain/routebus"
        "github.com/FITHSCS/backend/business/types/facilitytype"
        "github.com/FITHSCS/backend/business/types/genstringtype"
        "github.com/google/uuid"
)

type routedb struct {
        ID              uuid.UUID `db:"route_id"`
        StartFacilityID uuid.UUID `db:"start_facility_id"`
        EndFacilityID   uuid.UUID `db:"end_facility_id"`
        RouteName       string    `db:"route_name"`
        TotalKM         float64   `db:"total_km"`
        TotalStops      int       `db:"total_stops"`
        StartLatitude   float64   `db:"start_latitude"`
        EndLatitude     float64   `db:"end_latitude"`
        StartLongitude  float64   `db:"start_longitude"`
        EndLongitude    float64   `db:"end_longitude"`
        IsActive        bool      `db:"is_active"`
        CreatedAt       time.Time `db:"created_at"`
        UpdatedAt       time.Time `db:"updated_at"`
}

func toDBRoutedb(bus routebus.Route) (routedb, error) <span class="cov0" title="0">{

        routedb := routedb{
                ID:              bus.RouteID,
                StartFacilityID: bus.StartFacilityID,
                EndFacilityID:   bus.EndFacilityID,
                RouteName:       bus.RouteName.String(),
                TotalKM:         bus.TotalKM,
                TotalStops:      bus.TotalStops,
                StartLatitude:   bus.StartLatitude.Float64(),
                EndLatitude:     bus.EndLatitude.Float64(),
                StartLongitude:  bus.StartLongitude.Float64(),
                EndLongitude:    bus.EndLongitude.Float64(),
                IsActive:        bus.IsActive,
                CreatedAt:       bus.CreatedAt.UTC(),
                UpdatedAt:       bus.UpdatedAt.UTC(),
        }

        return routedb, nil
}</span>

func toBusRoute(db routedb) (routebus.Route, error) <span class="cov0" title="0">{

        rteName, err := genstringtype.Parse(db.RouteName)
        if err != nil </span><span class="cov0" title="0">{
                return routebus.Route{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">stlat, err := facilitytype.ParseLat(db.StartLatitude)
        if err != nil </span><span class="cov0" title="0">{
                return routebus.Route{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">stlong, err := facilitytype.ParseLong(db.StartLongitude)
        if err != nil </span><span class="cov0" title="0">{
                return routebus.Route{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">endlat, err := facilitytype.ParseLat(db.EndLatitude)
        if err != nil </span><span class="cov0" title="0">{
                return routebus.Route{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">endlong, err := facilitytype.ParseLong(db.EndLongitude)
        if err != nil </span><span class="cov0" title="0">{
                return routebus.Route{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">rtebus := routebus.Route{
                RouteID:         db.ID,
                StartFacilityID: db.StartFacilityID,
                EndFacilityID:   db.EndFacilityID,
                RouteName:       rteName,
                TotalKM:         db.TotalKM,
                TotalStops:      db.TotalStops,
                StartLatitude:   stlat,
                StartLongitude:  stlong,
                EndLatitude:     endlat,
                EndLongitude:    endlong,
                IsActive:        db.IsActive,
                CreatedAt:       db.CreatedAt.In(time.Local),
                UpdatedAt:       db.UpdatedAt.In(time.Local),
        }

        return rtebus, nil</span>
}

func toBusRoutes(dbs []routedb) ([]routebus.Route, error) <span class="cov0" title="0">{

        bus := make([]routebus.Route, len(dbs))

        for i, db := range dbs </span><span class="cov0" title="0">{
                var err error
                bus[i], err = toBusRoute(db)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">return bus, nil</span>
}
</pre>
		
		<pre class="file" id="file63" style="display: none">package routedb

import (
        "fmt"

        "github.com/FITHSCS/backend/business/domain/routebus"
        "github.com/FITHSCS/backend/business/sdk/order"
)

var orderByFields = map[string]string{
        routebus.OrderByID:            "route_id",
        routebus.OrderByStartFacility: "start_facility_id",
        routebus.OrderByEndFacility:   "end_facility_id",
        routebus.OrderByRouteName:     "route_name",
        routebus.OrderByTotalKms:      "total_km",
        routebus.OrderByTotalStops:    "total_stops",
        routebus.OrderByIsActive:      "is_active",
        routebus.OrderByCreatedAt:     "created_at",
        routebus.OrderByUpdatedAt:     "updated_at",
}

// orderByClause converts an order.By value into the final
// " ORDER BY  ASC|DESC" fragment the store adds to its SELECT.
func orderByClause(ob order.By) (string, error) <span class="cov0" title="0">{
        col, ok := orderByFields[ob.Field]
        if !ok </span><span class="cov0" title="0">{
                return "", fmt.Errorf("field %q does not exist", ob.Field)
        }</span>
        <span class="cov0" title="0">return " ORDER BY " + col + " " + ob.Direction, nil</span>
}
</pre>
		
		<pre class="file" id="file64" style="display: none">// Package routedb contains product related CRUD functionality.
package routedb

import (
        "bytes"
        "context"
        "errors"
        "fmt"

        "github.com/FITHSCS/backend/business/domain/pickupbatchbus"
        "github.com/FITHSCS/backend/business/domain/routebus"
        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/business/sdk/sqldb"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/google/uuid"
        "github.com/jmoiron/sqlx"
)

type Store struct {
        log *logger.Logger
        db  sqlx.ExtContext
}

func NewStore(log *logger.Logger, db *sqlx.DB) *Store <span class="cov0" title="0">{
        return &amp;Store{log: log, db: db}
}</span>

func (s *Store) Create(ctx context.Context, r routebus.Route) error <span class="cov0" title="0">{
        const stmt = `
    INSERT INTO route (
            route_id, 
                start_facility_id,
                end_facility_id,
                route_name, 
            total_km,
                total_stops,
                start_latitude,
                start_longitude,
                end_latitude,
            end_longitude, 
                is_active,
            created_at,
                updated_at 
    ) 
        VALUES (
                :route_id, 
            :start_facility_id, 
                :end_facility_id,
                :route_name, 
            :total_km, 
                :total_stops,
                :start_latitude,
                :start_longitude,
                :end_latitude,
            :end_longitude, 
                :is_active,
            :created_at, 
                :updated_at
    )`
        returnedValue, err := toDBRoutedb(r)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return sqldb.NamedExecContext(ctx, s.log, s.db, stmt, returnedValue)</span>
}

func (s *Store) Update(ctx context.Context, r routebus.Route) error <span class="cov0" title="0">{
        const stmt = `
    UPDATE 
                route
    SET 
        start_facility_id   = :start_facility_id,
        end_facility_id     = :end_facility_id,
        route_name                = :route_name,
        total_km                  = :total_km,
        total_stops         = :total_stops,
                start_latitude                 = :start_latitude,
                start_longitude         = :start_longitude,
        end_latitude        = :end_latitude,
        end_longitude       = :end_longitude,
        is_active           = :is_active,
        updated_at          = :updated_at
    WHERE route_id          = :route_id`

        returnedValue, err := toDBRoutedb(r)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return sqldb.NamedExecContext(ctx, s.log, s.db, stmt, returnedValue)</span>
}

func (s *Store) Query(ctx context.Context,
        filter routebus.QueryFilter, orderBy order.By, page page.Page) ([]routebus.Route, error) <span class="cov0" title="0">{

        data := map[string]any{
                "offset":        (page.Number() - 1) * page.RowsPerPage(),
                "rows_per_page": page.RowsPerPage(),
        }

        const q = `
    SELECT
            route_id, 
                start_facility_id,
                end_facility_id,
                route_name, 
            total_km,
                total_stops,
                start_latitude,
                start_longitude,
                end_latitude,
            end_longitude, 
                is_active,
            created_at,
                updated_at 
    FROM 
                route`

        var buf bytes.Buffer
        buf.WriteString(q)
        applyFilter(filter, data, &amp;buf)

        clause, err := orderByClause(orderBy)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">buf.WriteString(clause)
        buf.WriteString(" OFFSET :offset ROWS FETCH NEXT :rows_per_page ROWS ONLY")

        var dbRecs []routedb
        if err := sqldb.NamedQuerySlice(ctx, s.log, s.db, buf.String(), data, &amp;dbRecs); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("namedqueryslice: %w", err)
        }</span>
        <span class="cov0" title="0">return toBusRoutes(dbRecs)</span>
}

func (s *Store) QueryByID(ctx context.Context, routeID uuid.UUID) (routebus.Route, error) <span class="cov0" title="0">{
        param := map[string]any{
                "route_id": routeID.String(),
        }
        const stmt = `
    SELECT
        route_id, 
                start_facility_id,
                end_facility_id,
                route_name, 
            total_km,
                total_stops,
                start_latitude,
                start_longitude,
                end_latitude,
            end_longitude, 
                is_active,
            created_at,
                updated_at 
        FROM 
                  route
        WHERE 
                  route_id = :route_id`

        var rec routedb
        if err := sqldb.NamedQueryStruct(ctx, s.log, s.db, stmt, param, &amp;rec); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sqldb.ErrDBNotFound) </span><span class="cov0" title="0">{
                        return routebus.Route{}, fmt.Errorf("db: %w", pickupbatchbus.ErrNotFound)
                }</span>
                <span class="cov0" title="0">return routebus.Route{}, fmt.Errorf("db: %w", err)</span>
        }
        <span class="cov0" title="0">return toBusRoute(rec)</span>
}

func (s *Store) Count(ctx context.Context, filter routebus.QueryFilter) (int, error) <span class="cov0" title="0">{
        data := map[string]any{}
        const base = `SELECT count(1) FROM route`

        var buf bytes.Buffer
        buf.WriteString(base)
        applyFilter(filter, data, &amp;buf)

        var out struct {
                Count int `db:"count"`
        }
        if err := sqldb.NamedQueryStruct(ctx, s.log, s.db, buf.String(), data, &amp;out); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("db: %w", err)
        }</span>
        <span class="cov0" title="0">return out.Count, nil</span>
}

func (s *Store) Delete(ctx context.Context, routeID uuid.UUID) error <span class="cov0" title="0">{

        const q = `
    UPDATE
        route
        SET
                is_active = :is_active
    WHERE
        route_id = :route_id`

        dbPickupBatch := routedb{ID: routeID, IsActive: false}

        if err := sqldb.NamedExecContext(ctx, s.log, s.db, q, dbPickupBatch); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("namedexeccontext: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file65" style="display: none">package routebus

import (
        "context"
        "fmt"
        "math/rand"

        "github.com/FITHSCS/backend/business/types/facilitytype"
        "github.com/FITHSCS/backend/business/types/genstringtype"
        "github.com/google/uuid"
)

func TestGenerateNewRoutes(n int, stFacID uuid.UUID, endFacID uuid.UUID) []NewRoute <span class="cov5" title="2">{
        newroute := make([]NewRoute, n)

        idx := rand.Intn(10000)
        for i := range n </span><span class="cov10" title="4">{
                idx++

                nf := NewRoute{
                        StartFacilityID: stFacID,
                        EndFacilityID:   endFacID,
                        RouteName:       genstringtype.MustParse(fmt.Sprintf("RouteName%d", idx)),
                        TotalKM:         float64(idx % 1000),
                        TotalStops:      int(idx % 100),
                        StartLatitude:   facilitytype.MustParseLat(9.01949999999),
                        EndLatitude:     facilitytype.MustParseLat(9.069499999999),
                        StartLongitude:  facilitytype.MustParseLong(38.7399999999),
                        EndLongitude:    facilitytype.MustParseLong(38.78929999999),
                        IsActive:        true,
                }

                newroute[i] = nf
        }</span>

        <span class="cov5" title="2">return newroute</span>
}

func TestGenerateSeedRoutes(ctx context.Context, n int, api *Business, stfacid uuid.UUID, endfacid uuid.UUID) ([]Route, error) <span class="cov5" title="2">{
        newfs := TestGenerateNewRoutes(n, stfacid, endfacid)

        facs := make([]Route, len(newfs))
        for i, np := range newfs </span><span class="cov10" title="4">{
                prd, err := api.Create(ctx, np)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("seeding routes: idx: %d : %w", i, err)
                }</span>

                <span class="cov10" title="4">facs[i] = prd</span>
        }

        <span class="cov5" title="2">return facs, nil</span>
}
</pre>
		
		<pre class="file" id="file66" style="display: none">// Package signaturebus provides business access to vehicles bus domain.
package signaturebus

import (
        "context"
        "fmt"
        "time"

        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/google/uuid"
)

type Storer interface {
        Create(ctx context.Context, signature Signature) error
        Update(ctx context.Context, signature Signature) error
        SoftDelete(ctx context.Context, signatureID uuid.UUID) error
        HardDelete(ctx context.Context, signatureID uuid.UUID) error
        Query(ctx context.Context, filter QueryFilter, orderby order.By, page page.Page) ([]Signature, error)
        QueryByID(ctx context.Context, signatureID uuid.UUID) (Signature, error)
        Count(ctx context.Context, filter QueryFilter) (int, error)
}


func (b *Business) GetStorer() Storer <span class="cov0" title="0">{
    return b.storer
}</span>



type Business struct {
        log    *logger.Logger
        storer Storer
}

func NewBusiness(log *logger.Logger, storer Storer) *Business <span class="cov1" title="1">{
        return &amp;Business{
                log:    log,
                storer: storer,
        }
}</span>

func (b *Business) Create(ctx context.Context, ns NewSignature) (Signature, error) <span class="cov10" title="5">{
        now := time.Now()

        signature := Signature{
                SignatureID:    uuid.New(),
                ManifestID:     ns.ManifestID,
                SignedByID:     ns.SignedByID,
                EventType:      ns.EventType,
                SignatureType:  ns.SignatureType,
                SignatureHash:  ns.SignatureHash,
                DeviceID:       ns.DeviceID,
                SignedAt:       ns.SignedAt,
                Longitude:      ns.Longitude,
                Latitude:       ns.Latitude,
                InsideGeofence: ns.InsideGeofence,
                IsVerified:     ns.IsVerified,
                IsDeleted:      false,
                IsSynced:       ns.IsSynced,
                TimeStamp:      now,
                CreatedAt:      now,
                UpdatedAt:      now,
        }

        if err := b.storer.Create(ctx, signature); err != nil </span><span class="cov0" title="0">{
                return Signature{}, fmt.Errorf("Create: %w", err)
        }</span>

        <span class="cov10" title="5">fmt.Printf("\n\n\nsignature: %v\n\n\n", signature)
        return signature, nil</span>
}

func (b *Business) Update(ctx context.Context, singatureID uuid.UUID, updateSignature UpdateSignature) (Signature, error) <span class="cov1" title="1">{

        signOrig, err := b.storer.QueryByID(ctx, singatureID)
        if err != nil </span><span class="cov0" title="0">{
                return Signature{}, fmt.Errorf("querybyid: %w", err)
        }</span>

        <span class="cov1" title="1">if updateSignature.ManifestID != nil </span><span class="cov1" title="1">{
                signOrig.ManifestID = *updateSignature.ManifestID
        }</span>

        <span class="cov1" title="1">if updateSignature.SignedByID != nil </span><span class="cov1" title="1">{
                signOrig.SignedByID = *updateSignature.SignedByID
        }</span>

        <span class="cov1" title="1">if updateSignature.EventType != nil </span><span class="cov1" title="1">{
                signOrig.EventType = *updateSignature.EventType
        }</span>

        <span class="cov1" title="1">if updateSignature.SignatureType != nil </span><span class="cov1" title="1">{
                signOrig.SignatureType = *updateSignature.SignatureType
        }</span>

        <span class="cov1" title="1">if updateSignature.SignatureHash != nil </span><span class="cov1" title="1">{
                signOrig.SignatureHash = *updateSignature.SignatureHash
        }</span>

        <span class="cov1" title="1">if updateSignature.DeviceID != nil </span><span class="cov1" title="1">{
                signOrig.DeviceID = *updateSignature.DeviceID
        }</span>

        <span class="cov1" title="1">if updateSignature.SignedAt != nil </span><span class="cov1" title="1">{
                signOrig.SignedAt = *updateSignature.SignedAt
        }</span>

        <span class="cov1" title="1">if updateSignature.Longitude != nil </span><span class="cov1" title="1">{
                signOrig.Longitude = *updateSignature.Longitude
        }</span>

        <span class="cov1" title="1">if updateSignature.Latitude != nil </span><span class="cov1" title="1">{
                signOrig.Latitude = *updateSignature.Latitude
        }</span>

        <span class="cov1" title="1">if updateSignature.InsideGeofence != nil </span><span class="cov1" title="1">{
                signOrig.InsideGeofence = *updateSignature.InsideGeofence
        }</span>

        <span class="cov1" title="1">if updateSignature.IsVerified != nil </span><span class="cov1" title="1">{
                signOrig.IsVerified = *updateSignature.IsVerified
        }</span>

        <span class="cov1" title="1">if updateSignature.IsSynced != nil </span><span class="cov1" title="1">{
                signOrig.IsSynced = *updateSignature.IsSynced
        }</span>

        <span class="cov1" title="1">if updateSignature.TimeStamp != nil </span><span class="cov1" title="1">{
                signOrig.TimeStamp = *updateSignature.TimeStamp
        }</span>

        <span class="cov1" title="1">signOrig.UpdatedAt = time.Now().Truncate(time.Microsecond)

        if err := b.storer.Update(ctx, signOrig); err != nil </span><span class="cov0" title="0">{
                return Signature{}, fmt.Errorf("update: %w", err)
        }</span>
        <span class="cov1" title="1">return signOrig, nil</span>
}

func (b *Business) QueryByID(ctx context.Context, signatureID uuid.UUID) (Signature, error) <span class="cov1" title="1">{

        signature, err := b.storer.QueryByID(ctx, signatureID)
        if err != nil </span><span class="cov0" title="0">{
                return Signature{}, fmt.Errorf("query: signatureID[%s]: %w", signatureID, err)
        }</span>
        <span class="cov1" title="1">return signature, nil</span>
}

func (b *Business) Query(ctx context.Context, filter QueryFilter, orderBy order.By, page page.Page) ([]Signature, error) <span class="cov1" title="1">{

        signatures, err := b.storer.Query(ctx, filter, orderBy, page)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Query: %w", err)
        }</span>
        <span class="cov1" title="1">return signatures, nil</span>
}

func (b *Business) Count(ctx context.Context, filter QueryFilter) (int, error) <span class="cov0" title="0">{
        return b.storer.Count(ctx, filter)
}</span>

func (b *Business) SoftDelete(ctx context.Context, signatureID uuid.UUID) error <span class="cov4" title="2">{

        facility, err := b.storer.QueryByID(ctx, signatureID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("softdeletequery: signature[%s]: %w", signatureID, err)
        }</span>

        <span class="cov4" title="2">if facility.IsDeleted </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: already deleted", signatureID)
        }</span>

        <span class="cov4" title="2">if err := b.storer.SoftDelete(ctx, signatureID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("delete: %w", err)
        }</span>
        <span class="cov4" title="2">return nil</span>

}

func (b *Business) HardDelete(ctx context.Context, signatureID uuid.UUID) error <span class="cov4" title="2">{
        if err := b.storer.HardDelete(ctx, signatureID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("delete: %w", err)
        }</span>
        <span class="cov4" title="2">return nil</span>

}
</pre>
		
		<pre class="file" id="file67" style="display: none">package signaturedb

import (
        "bytes"
        "strings"

        "github.com/FITHSCS/backend/business/domain/signaturebus"
)

func applyFilter(filter signaturebus.QueryFilter, data map[string]any, buf *bytes.Buffer) <span class="cov0" title="0">{

        var wc []string

        if filter.DeviceID != nil </span><span class="cov0" title="0">{
                data["is_synced"] = *filter.DeviceID
                wc = append(wc, "device_id = :device_id")
        }</span>

        <span class="cov0" title="0">if filter.InsideGeofence != nil </span><span class="cov0" title="0">{
                data["is_synced"] = *filter.InsideGeofence
                wc = append(wc, "inside_geofence = :inside_geofence")
        }</span>

        <span class="cov0" title="0">if filter.IsVerified != nil </span><span class="cov0" title="0">{
                data["is_synced"] = *filter.IsVerified
                wc = append(wc, "is_verified = :is_verified")
        }</span>

        <span class="cov0" title="0">if filter.IsSynced != nil </span><span class="cov0" title="0">{
                data["is_synced"] = *filter.IsSynced
                wc = append(wc, "is_synced = :is_synced")
        }</span>

        <span class="cov0" title="0">if filter.TimeStamp != nil </span><span class="cov0" title="0">{
                data["time_stamp"] = *filter.TimeStamp
                wc = append(wc, "time_stamp = :time_stamp")
        }</span>

        <span class="cov0" title="0">if filter.CreatedAt != nil </span><span class="cov0" title="0">{
                data["created_at"] = filter.CreatedAt.UTC()
                wc = append(wc, "date_created &gt;= :created_at")
        }</span>
        <span class="cov0" title="0">if filter.UpdatedAt != nil </span><span class="cov0" title="0">{
                data["updated_at"] = filter.UpdatedAt.UTC()
                wc = append(wc, "updated_at &lt;= :updated_at")
        }</span>

        <span class="cov0" title="0">if len(wc) &gt; 0 </span><span class="cov0" title="0">{
                buf.WriteString(" WHERE ")
                buf.WriteString(strings.Join(wc, " AND "))
        }</span>
}
</pre>
		
		<pre class="file" id="file68" style="display: none">package signaturedb

import (
        "fmt"
        "time"

        "github.com/FITHSCS/backend/business/domain/signaturebus"
        "github.com/FITHSCS/backend/business/types/facilitytype"
        "github.com/FITHSCS/backend/business/types/genstringtype"
        "github.com/google/uuid"
)

type signaturedb struct {
        SignatureID    uuid.UUID `db:"signature_id"`
        ManifestID     uuid.UUID `db:"manifest_id"`
        SignedByID     uuid.UUID `db:"signed_by_id"`
        EventType      string    `db:"event_type"`
        SignatureType  string    `db:"signature_type"`
        SignatureHash  string    `db:"signature_hash"`
        DeviceID       string    `db:"device_id"`
        SignedAt       time.Time `db:"signed_at"`
        Longitude      float64   `db:"longitude"`
        Latitude       float64   `db:"latitude"`
        InsideGeofence bool      `db:"inside_geofence"`
        IsVerified     bool      `db:"is_verified"`
        IsDeleted      bool      `db:"is_deleted"`
        IsSynced       bool      `db:"is_synced"`
        TimeStamp      time.Time `db:"time_stamp"`
        CreatedAt      time.Time `db:"created_at"`
        UpdatedAt      time.Time `db:"updated_at"`
}

//=============================================================================&gt;

func toDBSignature(bus signaturebus.Signature) (signaturedb, error) <span class="cov0" title="0">{

        siganture := signaturedb{
                SignatureID:    bus.SignatureID,
                ManifestID:     bus.ManifestID,
                SignedByID:     bus.SignedByID,
                EventType:      bus.EventType.String(),
                SignatureType:  bus.SignatureType.String(),
                SignatureHash:  bus.SignatureHash.String(),
                DeviceID:       bus.DeviceID.String(),
                SignedAt:       bus.SignedAt.UTC(),
                Longitude:      bus.Longitude.Float64(),
                Latitude:       bus.Latitude.Float64(),
                InsideGeofence: bus.InsideGeofence,
                IsVerified:     bus.IsVerified,
                IsSynced:       bus.IsSynced,
                IsDeleted:      bus.IsDeleted,
                TimeStamp:      bus.TimeStamp.UTC(),
                CreatedAt:      bus.CreatedAt.UTC(),
                UpdatedAt:      bus.UpdatedAt.UTC(),
        }

        return siganture, nil
}</span>

func toBusSignature(db signaturedb) (signaturebus.Signature, error) <span class="cov0" title="0">{
        snatureid, err := uuid.Parse(db.SignatureID.String())
        if err != nil </span><span class="cov0" title="0">{
                return signaturebus.Signature{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">manid, err := uuid.Parse(db.ManifestID.String())
        if err != nil </span><span class="cov0" title="0">{
                return signaturebus.Signature{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">signdbyid, err := uuid.Parse(db.SignedByID.String())
        if err != nil </span><span class="cov0" title="0">{
                return signaturebus.Signature{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">evntype, err := genstringtype.Parse(db.EventType)
        if err != nil </span><span class="cov0" title="0">{
                return signaturebus.Signature{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">signtype, err := genstringtype.Parse(db.SignatureType)
        if err != nil </span><span class="cov0" title="0">{
                return signaturebus.Signature{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">sgnhash, err := genstringtype.Parse(db.SignatureHash)
        if err != nil </span><span class="cov0" title="0">{
                return signaturebus.Signature{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">dvceid, err := genstringtype.Parse(db.DeviceID)
        if err != nil </span><span class="cov0" title="0">{
                return signaturebus.Signature{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">var sgnat time.Time
        if !db.SignedAt.IsZero() </span><span class="cov0" title="0">{
                sgnat = db.SignedAt.In(time.Local)
        }</span>

        <span class="cov0" title="0">lng, err := facilitytype.ParseLong(db.Longitude)
        if err != nil </span><span class="cov0" title="0">{
                return signaturebus.Signature{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">lat, err := facilitytype.ParseLat(db.Latitude)
        if err != nil </span><span class="cov0" title="0">{
                return signaturebus.Signature{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">bus := signaturebus.Signature{
                SignatureID:    snatureid,
                ManifestID:     manid,
                SignedByID:     signdbyid,
                EventType:      evntype,
                SignatureType:  signtype,
                SignatureHash:  sgnhash,
                DeviceID:       dvceid,
                SignedAt:       sgnat,
                Longitude:      lng,
                Latitude:       lat,
                InsideGeofence: db.InsideGeofence,
                IsVerified:     db.IsVerified,
                IsDeleted:      db.IsDeleted,
                IsSynced:       db.IsSynced,
                TimeStamp:      db.TimeStamp.In(time.Local),
                CreatedAt:      db.CreatedAt.In(time.Local),
                UpdatedAt:      db.UpdatedAt.In(time.Local),
        }

        return bus, nil</span>

}

func toBusSignatures(dbs []signaturedb) ([]signaturebus.Signature, error) <span class="cov0" title="0">{
        bus := make([]signaturebus.Signature, len(dbs))

        for i, db := range dbs </span><span class="cov0" title="0">{
                var err error
                bus[i], err = toBusSignature(db)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">return bus, nil</span>
}
</pre>
		
		<pre class="file" id="file69" style="display: none">package signaturedb

import (
        "fmt"

        "github.com/FITHSCS/backend/business/domain/signaturebus"
        "github.com/FITHSCS/backend/business/sdk/order"
)

var orderByFields = map[string]string{
        signaturebus.OrderBySignatureID: "signature_id",
        signaturebus.OrderByCreatedAt:   "created_at",
        signaturebus.OrderByDeviceID:    "device_id",
        signaturebus.OrderByEventType:   "event_type",
        signaturebus.OrderByTimeStamp:   "timestamp",
        signaturebus.OrderByUpdatedAt:   "updated_at",
}

// orderByClause converts an order.By value into the final
// " ORDER BY  ASC|DESC" fragment the store adds to its SELECT.
func orderByClause(ob order.By) (string, error) <span class="cov0" title="0">{
        col, ok := orderByFields[ob.Field]

        if !ok </span><span class="cov0" title="0">{
                return "", fmt.Errorf("field %q does not exist", ob.Field)
        }</span>
        <span class="cov0" title="0">return " ORDER BY " + col + " " + ob.Direction, nil</span>
}
</pre>
		
		<pre class="file" id="file70" style="display: none">// Package signaturedb contains product related CRUD functionality.
package signaturedb

import (
        "bytes"
        "context"
        "errors"
        "fmt"

        "github.com/FITHSCS/backend/business/domain/pickupbatchbus"
        "github.com/FITHSCS/backend/business/domain/signaturebus"
        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/business/sdk/sqldb"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/google/uuid"
        "github.com/jmoiron/sqlx"
)

type Store struct {
        log *logger.Logger
        db  sqlx.ExtContext
}

func NewStore(log *logger.Logger, db *sqlx.DB) *Store <span class="cov0" title="0">{
        return &amp;Store{log: log, db: db}
}</span>

func (s *Store) Create(ctx context.Context, p signaturebus.Signature) error <span class="cov0" title="0">{
        const stmt = `
    INSERT INTO signature (
            signature_id, 
                manifest_id,
                signed_by_id,
                event_type, 
            signature_type,
                signature_hash,
                device_id,
                signed_at,
                longitude,
                latitude,
                inside_geofence,
                is_verified,
                is_deleted,
            is_synced, 
                time_stamp, 
            created_at,
                updated_at 
    ) 
        VALUES (
            :signature_id, 
                :manifest_id, 
                :signed_by_id,
                :event_type, 
            :signature_type, 
                :signature_hash,
                :device_id,
                :signed_at,
                :longitude,
            :latitude, 
                :inside_geofence,
                :is_verified,
                :is_deleted,
                :is_synced,
                :time_stamp, 
            :created_at, 
                :updated_at
    )`
        returnedValue, err := toDBSignature(p)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return sqldb.NamedExecContext(ctx, s.log, s.db, stmt, returnedValue)</span>
}

func (s *Store) Update(ctx context.Context, p signaturebus.Signature) error <span class="cov0" title="0">{
        const stmt = `
    UPDATE 
                signature
    SET 
        manifest_id       = :manifest_id,
        signed_by_id      = :signed_by_id,
        event_type        = :event_type,
        signature_type    = :signature_type,
        signature_hash    = :signature_hash,
                device_id                   = :device_id,
                signed_at                   = :signed_at,
                longitude                   = :longitude,
                latitude                   = :latitude,
                inside_geofence   = :inside_geofence,
                is_verified           = :is_verified,
        is_synced         = :is_synced,
        time_stamp        = :time_stamp,
        updated_at        = :updated_at
    WHERE 
                signature_id = :signature_id`

        returnedValue, err := toDBSignature(p)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return sqldb.NamedExecContext(ctx, s.log, s.db, stmt, returnedValue)</span>
}

func (s *Store) Query(ctx context.Context,
        filter signaturebus.QueryFilter, orderBy order.By, page page.Page) ([]signaturebus.Signature, error) <span class="cov0" title="0">{
        data := map[string]any{
                "offset":        (page.Number() - 1) * page.RowsPerPage(),
                "rows_per_page": page.RowsPerPage(),
        }

        const q = `
    SELECT
            signature_id, 
                manifest_id,
                signed_by_id,
                event_type, 
            signature_type,
                signature_hash,
                device_id,
                signed_at,
                longitude,
                latitude,
                inside_geofence,
                is_verified,
                is_deleted,
            is_synced, 
                time_stamp, 
            created_at,
                updated_at 
    FROM 
                signature`

        var buf bytes.Buffer
        buf.WriteString(q)
        applyFilter(filter, data, &amp;buf)

        clause, err := orderByClause(orderBy)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">buf.WriteString(clause)
        buf.WriteString(" OFFSET :offset ROWS FETCH NEXT :rows_per_page ROWS ONLY")

        var dbRecs []signaturedb
        if err := sqldb.NamedQuerySlice(ctx, s.log, s.db, buf.String(), data, &amp;dbRecs); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("namedqueryslice: %w", err)
        }</span>
        <span class="cov0" title="0">return toBusSignatures(dbRecs)</span>
}

func (s *Store) QueryByID(ctx context.Context, signatureID uuid.UUID) (signaturebus.Signature, error) <span class="cov0" title="0">{
        param := map[string]any{
                "signature_id": signatureID.String(),
        }
        const stmt = `
    SELECT
            signature_id, 
                manifest_id,
                signed_by_id,
                event_type, 
            signature_type,
                signature_hash,
                device_id,
                signed_at,
                longitude,
                latitude,
                inside_geofence,
                is_verified,
                is_deleted,
            is_synced, 
                time_stamp, 
            created_at,
                updated_at
        FROM 
                  signature
        WHERE 
                  signature_id = :signature_id`

        var rec signaturedb
        if err := sqldb.NamedQueryStruct(ctx, s.log, s.db, stmt, param, &amp;rec); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sqldb.ErrDBNotFound) </span><span class="cov0" title="0">{
                        return signaturebus.Signature{}, fmt.Errorf("db: %w", pickupbatchbus.ErrNotFound)
                }</span>
                <span class="cov0" title="0">return signaturebus.Signature{}, fmt.Errorf("db: %w", err)</span>
        }
        <span class="cov0" title="0">return toBusSignature(rec)</span>
}

func (s *Store) Count(ctx context.Context, filter signaturebus.QueryFilter) (int, error) <span class="cov0" title="0">{
        data := map[string]any{}
        const base = `SELECT count(1) FROM signature`

        var buf bytes.Buffer
        buf.WriteString(base)
        applyFilter(filter, data, &amp;buf)

        var out struct {
                Count int `db:"count"`
        }
        if err := sqldb.NamedQueryStruct(ctx, s.log, s.db, buf.String(), data, &amp;out); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("db: %w", err)
        }</span>
        <span class="cov0" title="0">return out.Count, nil</span>
}

func (s *Store) SoftDelete(ctx context.Context, signatureID uuid.UUID) error <span class="cov0" title="0">{

        const q = `
    UPDATE
        signature
        SET
                is_deleted = :is_deleted
    WHERE
        signature_id = :signature_id`

        dbSignature := signaturedb{SignatureID: signatureID, IsDeleted: true}

        if err := sqldb.NamedExecContext(ctx, s.log, s.db, q, dbSignature); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("namedexeccontext: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *Store) HardDelete(ctx context.Context, signatureID uuid.UUID) error <span class="cov0" title="0">{
        const q = `
    DELETE FROM
        signature
    WHERE
        signature_id = :signature_id`

        dbSignature := signaturedb{SignatureID: signatureID}

        if err := sqldb.NamedExecContext(ctx, s.log, s.db, q, dbSignature); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("namedexeccontext: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file71" style="display: none">package signaturebus

import (
        "context"
        "fmt"
        "math/rand"
        "time"

        "github.com/FITHSCS/backend/business/types/facilitytype"
        "github.com/FITHSCS/backend/business/types/genstringtype"
        "github.com/google/uuid"
)

func TestGenerateNewSignature(n int, manID, sndbyID uuid.UUID) []NewSignature <span class="cov5" title="2">{
        newfs := make([]NewSignature, n)
        ecntype := []string{"pickup", "delivery"}
        signtype := []string{"PIN", "Freehand", "Fingerprint", "FaceID"}
        booleans := []bool{true, false}

        sndat, _ := time.Parse(time.RFC3339, "2025-06-10T15:59:33+03:00")
        timestamp := sndat.Add(time.Minute + 1)

        idx := rand.Intn(10000)
        for i := range n </span><span class="cov10" title="4">{
                idx++

                nf := NewSignature{
                        ManifestID:     manID,
                        SignedByID:     sndbyID,
                        EventType:      genstringtype.MustParse(ecntype[i%2]),
                        SignatureType:  genstringtype.MustParse(signtype[i%2]),
                        SignatureHash:  genstringtype.MustParse("q24cr98mq3vt9m9q4wrm9sdf3112"),
                        DeviceID:       genstringtype.MustParse(fmt.Sprintf("Device:%2d", idx)),
                        SignedAt:       sndat,
                        Longitude:      facilitytype.MustParseLong(38.739200592041016),
                        Latitude:       facilitytype.MustParseLat(9.019499778747559),
                        InsideGeofence: booleans[i%2],
                        IsVerified:     booleans[i%2],
                        IsSynced:       booleans[i%2],
                        TimeStamp:      timestamp,
                }

                newfs[i] = nf
        }</span>

        <span class="cov5" title="2">return newfs</span>
}

func TestGenerateSeedSignature(ctx context.Context, n int, api *Business, manID, sndbyID uuid.UUID) ([]Signature, error) <span class="cov5" title="2">{
        newfs := TestGenerateNewSignature(n, manID, sndbyID)

        facs := make([]Signature, len(newfs))
        for i, np := range newfs </span><span class="cov10" title="4">{
                prd, err := api.Create(ctx, np)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("seeding signature: idx: %d : %w", i, err)
                }</span>

                <span class="cov10" title="4">facs[i] = prd</span>
        }

        <span class="cov5" title="2">return facs, nil</span>
}
</pre>
		
		<pre class="file" id="file72" style="display: none">package syncbatchdb

import (
        //"database/sql"
        "fmt"
        //"net/mail"
        "time"

        "github.com/FITHSCS/backend/business/domain/syncbatchbus"

        //"github.com/FITHSCS/backend/business/sdk/sqldb/dbarray"
        "github.com/FITHSCS/backend/business/types/name"
        //"github.com/FITHSCS/backend/business/types/facilitytype"
        "github.com/google/uuid"
)

// &lt;=================== Struct that is going to be passed to database schema =&gt; //
type syncbatch struct {
        ID        uuid.UUID `db:"syncbatch_id"`
        BatchID   uuid.UUID `db:"batch_id"`
        DeviceID  uuid.UUID `db:"device_id"`
        EventID   uuid.UUID `db:"event_id"`
        TimeStamp time.Time `db:"time_stamp"`
        Status    string    `db:"status"`
        CreatedAt time.Time `db:"created_at"`
}

func toDBSyncBatch(bus syncbatchbus.SyncBatch) (syncbatch, error) <span class="cov0" title="0">{

        batchID, err := uuid.Parse(bus.BatchID.String())

        if err != nil </span><span class="cov0" title="0">{
                return syncbatch{}, err
        }</span>

        <span class="cov0" title="0">deviceID, err := uuid.Parse(bus.DeviceID.String())
        if err != nil </span><span class="cov0" title="0">{
                return syncbatch{}, err
        }</span>

        <span class="cov0" title="0">eventID, err := uuid.Parse(bus.EventID.String())
        if err != nil </span><span class="cov0" title="0">{
                return syncbatch{}, err
        }</span>

        <span class="cov0" title="0">return syncbatch{
                ID:        bus.ID,
                BatchID:   batchID,
                DeviceID:  deviceID,
                EventID:   eventID,
                TimeStamp: bus.TimeStamp.UTC(),
                Status:    bus.Status,
                CreatedAt: bus.CreatedAt.UTC(),
        }, nil</span>

}

func toBusSyncBatch(db syncbatch) (syncbatchbus.SyncBatch, error) <span class="cov0" title="0">{

        batchID, err := name.Parse(db.BatchID.String())
        if err != nil </span><span class="cov0" title="0">{
                return syncbatchbus.SyncBatch{}, fmt.Errorf("parse: %w", err)
        }</span>
        <span class="cov0" title="0">deviceID, err := name.Parse(db.DeviceID.String())
        if err != nil </span><span class="cov0" title="0">{
                return syncbatchbus.SyncBatch{}, fmt.Errorf("parse: %w", err)
        }</span>
        <span class="cov0" title="0">eventID, err := name.Parse(db.EventID.String())
        if err != nil </span><span class="cov0" title="0">{
                return syncbatchbus.SyncBatch{}, fmt.Errorf("parse: %w", err)
        }</span>
        <span class="cov0" title="0">status := db.Status

        bus := syncbatchbus.SyncBatch{

                ID:        db.ID,
                BatchID:   batchID,
                DeviceID:  deviceID,
                EventID:   eventID,
                TimeStamp: db.TimeStamp.In(time.Local),
                Status:    status,
                CreatedAt: db.CreatedAt.In(time.Local),
        }
        return bus, nil</span>
}
</pre>
		
		<pre class="file" id="file73" style="display: none">// Package syncbatchdb contains product related CRUD functionality.
package syncbatchdb

import (
        "context"
        "errors"
        "fmt"

        "github.com/FITHSCS/backend/business/domain/syncbatchbus"
        "github.com/FITHSCS/backend/business/sdk/sqldb"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/google/uuid"
        "github.com/jmoiron/sqlx"
)

type Store struct {
        log *logger.Logger
        db  sqlx.ExtContext
}

func NewStore(log *logger.Logger, db *sqlx.DB) *Store <span class="cov0" title="0">{
        return &amp;Store{log: log, db: db}
}</span>

func (s *Store) Create(ctx context.Context, sb syncbatchbus.SyncBatch) error <span class="cov0" title="0">{
        fmt.Println("YOOOOOOOOOO AM INSIDE HERE")
        fmt.Println(sb)
        fmt.Println("Database Instance: ", s.db)
        const stmt = `
        INSERT INTO syncbatch (
            syncbatch_id, batch_id, device_id, event_id,
            time_stamp, status, created_at
        ) VALUES (
            :syncbatch_id, :batch_id, :device_id,
            :event_id, :time_stamp, :status, :created_at
        )`

        returnedValue, err := toDBSyncBatch(sb)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">fmt.Printf("Final DB Payload: %+v\n", returnedValue)
        return sqldb.NamedExecContext(ctx, s.log, s.db, stmt, returnedValue)</span>
}

func (s *Store) QueryByID(ctx context.Context, id uuid.UUID) (syncbatchbus.SyncBatch, error) <span class="cov0" title="0">{

        param := map[string]any{
                "batch_id": id.String(),
        }
        fmt.Println("I am query ID: ", id)
        const stmt = `
          SELECT
        syncbatch_id,
        batch_id,
        device_id,
        event_id,
        time_stamp,
        status,
        created_at
        FROM syncbatch
        WHERE batch_id = :batch_id
      `
        var rec syncbatch
        if err := sqldb.NamedQueryStruct(ctx, s.log, s.db, stmt, param, &amp;rec); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sqldb.ErrDBNotFound) </span><span class="cov0" title="0">{
                        return syncbatchbus.SyncBatch{}, syncbatchbus.ErrNotFound
                }</span>
                <span class="cov0" title="0">return syncbatchbus.SyncBatch{}, err</span>
        }
        <span class="cov0" title="0">return toBusSyncBatch(rec)</span>
}
</pre>
		
		<pre class="file" id="file74" style="display: none">// Package syncbatchbus provides business access to syncbatch bus domain.
package syncbatchbus

import (
        "context"
        "errors"
        "fmt"
        "time"

        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/google/uuid"
)

var (
        ErrNotFound       = errors.New("packagedetail not found")
        ErrAuthentication = errors.New("authentication failed")
)

type Storer interface {
        Create(ctx context.Context, syncbatch SyncBatch) error
        QueryByID(ctx context.Context, syncbatchID uuid.UUID) (SyncBatch, error)
}

func (b *Business) GetStorer() Storer <span class="cov0" title="0">{
        return b.storer
}</span>

type Business struct {
        log    *logger.Logger
        storer Storer
}

func NewBusiness(log *logger.Logger, storer Storer) *Business <span class="cov0" title="0">{

        return &amp;Business{
                log:    log,
                storer: storer,
        }
}</span>

func (b *Business) Create(ctx context.Context, sb NewSyncBatch) (SyncBatch, error) <span class="cov0" title="0">{

        now := time.Now()

        syncbatch := SyncBatch{
                ID:        uuid.New(),
                BatchID:   sb.BatchID,
                DeviceID:  sb.DeviceID,
                EventID:   sb.EventID,
                TimeStamp: now,
                Status:    sb.Status,
                CreatedAt: now,
        }
        if err := b.storer.Create(ctx, syncbatch); err != nil </span><span class="cov0" title="0">{
                return SyncBatch{}, fmt.Errorf("Create: %w", err)
        }</span>
        <span class="cov0" title="0">return syncbatch, nil</span>
}

func (b *Business) QueryByID(ctx context.Context, syncbatchID uuid.UUID) (SyncBatch, error) <span class="cov0" title="0">{

        syncBatch, err := b.storer.QueryByID(ctx, syncbatchID)
        if err != nil </span><span class="cov0" title="0">{
                return SyncBatch{}, err
        }</span>
        <span class="cov0" title="0">return syncBatch, nil</span>
}
</pre>
		
		<pre class="file" id="file75" style="display: none">// Package useraudit provides an extension for userbus that adds
// auditing functionality.
package useraudit

import (
        "context"
        "net/mail"

        "github.com/FITHSCS/backend/business/domain/auditbus"
        "github.com/FITHSCS/backend/business/domain/userbus"
        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/business/types/domain"
        "github.com/FITHSCS/backend/business/types/facilitytype"
        "github.com/google/uuid"
)

// Extension provides a wrapper for audit functionality around the userbus.
type Extension struct {
        bus      userbus.ExtBusiness
        auditBus *auditbus.Business
}

// NewExtension constructs a new extension that wraps the userbus with audit.
func NewExtension(auditBus *auditbus.Business) userbus.Extension <span class="cov0" title="0">{
        return func(bus userbus.ExtBusiness) userbus.ExtBusiness </span><span class="cov0" title="0">{
                return &amp;Extension{
                        bus:      bus,
                        auditBus: auditBus,
                }
        }</span>
}

// Create applies auditing to the user creation process.
func (ext *Extension) Create(ctx context.Context, actorID uuid.UUID, nu userbus.NewUser) (userbus.User, error) <span class="cov0" title="0">{
        usr, err := ext.bus.Create(ctx, actorID, nu)
        if err != nil </span><span class="cov0" title="0">{
                return userbus.User{}, err
        }</span>

        <span class="cov0" title="0">na := auditbus.NewAudit{
                ObjID:     usr.ID,
                ObjDomain: domain.User,
                ObjName:   usr.Name,
                ActorID:   actorID,
                Action:    "created",
                Data:      nu,
                Message:   "user created",
        }

        if _, err := ext.auditBus.Create(ctx, na); err != nil </span><span class="cov0" title="0">{
                return userbus.User{}, err
        }</span>

        <span class="cov0" title="0">return usr, nil</span>
}

// Update applies auditing to the user update process.
func (ext *Extension) Update(ctx context.Context, actorID uuid.UUID, usr userbus.User, uu userbus.UpdateUser) (userbus.User, error) <span class="cov0" title="0">{
        usr, err := ext.bus.Update(ctx, actorID, usr, uu)
        if err != nil </span><span class="cov0" title="0">{
                return userbus.User{}, err
        }</span>

        <span class="cov0" title="0">na := auditbus.NewAudit{
                ObjID:     usr.ID,
                ObjDomain: domain.User,
                ObjName:   usr.Name,
                ActorID:   actorID,
                Action:    "updated",
                Data:      uu,
                Message:   "user updated",
        }

        if _, err := ext.auditBus.Create(ctx, na); err != nil </span><span class="cov0" title="0">{
                return userbus.User{}, err
        }</span>

        <span class="cov0" title="0">return usr, nil</span>
}

// Delete applies auditing to the user deletion process.
func (ext *Extension) Delete(ctx context.Context, actorID uuid.UUID, usr userbus.User) error <span class="cov0" title="0">{
        if err := ext.bus.Delete(ctx, actorID, usr); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">na := auditbus.NewAudit{
                ObjID:     usr.ID,
                ObjDomain: domain.User,
                ObjName:   usr.Name,
                ActorID:   actorID,
                Action:    "deleted",
                Data:      nil,
                Message:   "user deleted",
        }

        if _, err := ext.auditBus.Create(ctx, na); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Query does not apply auditing.
func (ext *Extension) Query(ctx context.Context, filter userbus.QueryFilter, orderBy order.By, page page.Page) ([]userbus.User, error) <span class="cov0" title="0">{
        return ext.bus.Query(ctx, filter, orderBy, page)
}</span>

// Count does not apply auditing.
func (ext *Extension) Count(ctx context.Context, filter userbus.QueryFilter) (int, error) <span class="cov0" title="0">{
        return ext.bus.Count(ctx, filter)
}</span>

// QueryByID does not apply auditing.
func (ext *Extension) QueryByID(ctx context.Context, userID uuid.UUID) (userbus.User, error) <span class="cov0" title="0">{
        return ext.bus.QueryByID(ctx, userID)
}</span>

// QueryByEmail does not apply auditing.
func (ext *Extension) QueryByEmail(ctx context.Context, email mail.Address) (userbus.User, error) <span class="cov0" title="0">{
        return ext.bus.QueryByEmail(ctx, email)
}</span>

// QueryByPhone does not apply auditing.
func (ext *Extension) QueryByPhone(ctx context.Context, phone facilitytype.PhoneNumber) (userbus.User, error) <span class="cov0" title="0">{
        return ext.bus.QueryByPhone(ctx, phone)
}</span>

// Authenticate does not apply auditing.
func (ext *Extension) Authenticate(ctx context.Context, phone facilitytype.PhoneNumber, password string) (userbus.User, error) <span class="cov0" title="0">{
        return ext.bus.Authenticate(ctx, phone, password)
}</span>
</pre>
		
		<pre class="file" id="file76" style="display: none">// Package usercache contains user related CRUD functionality with caching.
package usercache

import (
        "context"
        "net/mail"
        "time"

        "github.com/FITHSCS/backend/business/domain/userbus"
        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/business/types/facilitytype"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/google/uuid"
        "github.com/viccon/sturdyc"
)

// Store manages the set of APIs for user data and caching.
type Store struct {
        log    *logger.Logger
        storer userbus.Storer
        cache  *sturdyc.Client[userbus.User]
}

// NewStore constructs the api for data and caching access.
func NewStore(log *logger.Logger, storer userbus.Storer, ttl time.Duration) *Store <span class="cov0" title="0">{
        const capacity = 10000
        const numShards = 10
        const evictionPercentage = 10

        return &amp;Store{
                log:    log,
                storer: storer,
                cache:  sturdyc.New[userbus.User](capacity, numShards, ttl, evictionPercentage),
        }
}</span>

// Create inserts a new user into the database.
func (s *Store) Create(ctx context.Context, usr userbus.User) error <span class="cov0" title="0">{
        if err := s.storer.Create(ctx, usr); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">s.writeCache(usr)

        return nil</span>
}

// Update replaces a user document in the database.
func (s *Store) Update(ctx context.Context, usr userbus.User) error <span class="cov0" title="0">{
        if err := s.storer.Update(ctx, usr); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">s.writeCache(usr)

        return nil</span>
}

// Delete removes a user from the database.
func (s *Store) Delete(ctx context.Context, usr userbus.User) error <span class="cov0" title="0">{
        if err := s.storer.Delete(ctx, usr); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">s.deleteCache(usr)

        return nil</span>
}

// Query retrieves a list of existing users from the database.
func (s *Store) Query(ctx context.Context, filter userbus.QueryFilter, orderBy order.By, page page.Page) ([]userbus.User, error) <span class="cov0" title="0">{
        return s.storer.Query(ctx, filter, orderBy, page)
}</span>

// Count returns the total number of cards in the DB.
func (s *Store) Count(ctx context.Context, filter userbus.QueryFilter) (int, error) <span class="cov0" title="0">{
        return s.storer.Count(ctx, filter)
}</span>

// QueryByID gets the specified user from the database.
func (s *Store) QueryByID(ctx context.Context, userID uuid.UUID) (userbus.User, error) <span class="cov0" title="0">{
        cachedUsr, ok := s.readCache(userID.String())
        if ok </span><span class="cov0" title="0">{
                return cachedUsr, nil
        }</span>

        <span class="cov0" title="0">usr, err := s.storer.QueryByID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return userbus.User{}, err
        }</span>

        <span class="cov0" title="0">s.writeCache(usr)

        return usr, nil</span>
}

// QueryByEmail gets the specified user from the database by email.
func (s *Store) QueryByEmail(ctx context.Context, email mail.Address) (userbus.User, error) <span class="cov0" title="0">{
        cachedUsr, ok := s.readCache(email.Address)
        if ok </span><span class="cov0" title="0">{
                return cachedUsr, nil
        }</span>

        <span class="cov0" title="0">usr, err := s.storer.QueryByEmail(ctx, email)
        if err != nil </span><span class="cov0" title="0">{
                return userbus.User{}, err
        }</span>

        <span class="cov0" title="0">s.writeCache(usr)

        return usr, nil</span>
}

// QueryByPhone gets the specified user from the database by email.
func (s *Store) QueryByPhone(ctx context.Context, phone facilitytype.PhoneNumber) (userbus.User, error) <span class="cov0" title="0">{
        cachedUsr, ok := s.readCache(phone.String())
        if ok </span><span class="cov0" title="0">{
                return cachedUsr, nil
        }</span>

        <span class="cov0" title="0">usr, err := s.storer.QueryByPhone(ctx, phone)
        if err != nil </span><span class="cov0" title="0">{
                return userbus.User{}, err
        }</span>

        <span class="cov0" title="0">s.writeCache(usr)

        return usr, nil</span>
}

// readCache performs a safe search in the cache for the specified key.
func (s *Store) readCache(key string) (userbus.User, bool) <span class="cov0" title="0">{
        usr, exists := s.cache.Get(key)
        if !exists </span><span class="cov0" title="0">{
                return userbus.User{}, false
        }</span>

        <span class="cov0" title="0">return usr, true</span>
}

// writeCache performs a safe write to the cache for the specified userbus.
func (s *Store) writeCache(bus userbus.User) <span class="cov0" title="0">{
        s.cache.Set(bus.ID.String(), bus)
        s.cache.Set(bus.Email.Address, bus)
}</span>

// deleteCache performs a safe removal from the cache for the specified userbus.
func (s *Store) deleteCache(bus userbus.User) <span class="cov0" title="0">{
        s.cache.Delete(bus.ID.String())
        s.cache.Delete(bus.Email.Address)
}</span>
</pre>
		
		<pre class="file" id="file77" style="display: none">package userdb

import (
        "bytes"
        "fmt"
        "strings"

        "github.com/FITHSCS/backend/business/domain/userbus"
        "github.com/google/uuid"
)

func applyFilter(filter userbus.QueryFilter, data map[string]any, buf *bytes.Buffer) <span class="cov0" title="0">{
        var wc []string

        if filter.ID != uuid.Nil </span><span class="cov0" title="0">{
                data["user_id"] = &amp;filter.ID
                wc = append(wc, "user_id = :user_id")
        }</span>

        <span class="cov0" title="0">if filter.Name != nil </span><span class="cov0" title="0">{
                data["name"] = fmt.Sprintf("%%%s%%", *filter.Name)
                wc = append(wc, "name LIKE :name")
        }</span>

        <span class="cov0" title="0">if filter.Email != nil </span><span class="cov0" title="0">{
                data["email"] = (*filter.Email).String()
                wc = append(wc, "email = :email")
        }</span>

        <span class="cov0" title="0">if filter.Phone != nil </span><span class="cov0" title="0">{
                data["phone"] = (*filter.Email).String()
                wc = append(wc, "phone = :phone")
        }</span>

        <span class="cov0" title="0">if filter.StartCreatedDate != nil </span><span class="cov0" title="0">{
                data["start_date_created"] = filter.StartCreatedDate.UTC()
                wc = append(wc, "created_at &gt;= :start_date_created")
        }</span>

        <span class="cov0" title="0">if filter.EndCreatedDate != nil </span><span class="cov0" title="0">{
                data["end_date_created"] = filter.EndCreatedDate.UTC()
                wc = append(wc, "created_at &lt;= :end_date_created")
        }</span>

        <span class="cov0" title="0">if len(wc) &gt; 0 </span><span class="cov0" title="0">{
                buf.WriteString(" WHERE ")
                buf.WriteString(strings.Join(wc, " AND "))
        }</span>
}
</pre>
		
		<pre class="file" id="file78" style="display: none">package userdb

import (
        "database/sql"
        "fmt"
        "net/mail"
        "time"

        "github.com/FITHSCS/backend/business/domain/userbus"
        "github.com/FITHSCS/backend/business/sdk/sqldb/dbarray"
        "github.com/FITHSCS/backend/business/types/facilitytype"
        "github.com/FITHSCS/backend/business/types/name"
        "github.com/FITHSCS/backend/business/types/role"
        "github.com/google/uuid"
)

type user struct {
        ID           uuid.UUID      `db:"user_id"`
        Name         string         `db:"name"`
        Email        string         `db:"email"`
        Phone        string         `db:"phone"`
        Roles        dbarray.String `db:"roles"`
        PasswordHash []byte         `db:"password_hash"`
        Department   sql.NullString `db:"department"`
        Enabled      bool           `db:"enabled"`
        DateCreated  time.Time      `db:"created_at"`
        DateUpdated  time.Time      `db:"updated_at"`
}

func toDBUser(bus userbus.User) user <span class="cov0" title="0">{
        return user{
                ID:           bus.ID,
                Name:         bus.Name.String(),
                Email:        bus.Email.Address,
                Phone:        bus.Phone.String(),
                Roles:        role.ParseToString(bus.Roles),
                PasswordHash: bus.PasswordHash,
                Department: sql.NullString{
                        String: bus.Department.String(),
                        Valid:  bus.Department.Valid(),
                },
                Enabled:     bus.Enabled,
                DateCreated: bus.DateCreated.UTC(),
                DateUpdated: bus.DateUpdated.UTC(),
        }
}</span>

func toBusUser(db user) (userbus.User, error) <span class="cov0" title="0">{
        addr := mail.Address{
                Address: db.Email,
        }

        roles, err := role.ParseMany(db.Roles)
        if err != nil </span><span class="cov0" title="0">{
                return userbus.User{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">nme, err := name.Parse(db.Name)
        if err != nil </span><span class="cov0" title="0">{
                return userbus.User{}, fmt.Errorf("parse name: %w", err)
        }</span>

        <span class="cov0" title="0">department, err := name.ParseNull(db.Department.String)
        if err != nil </span><span class="cov0" title="0">{
                return userbus.User{}, fmt.Errorf("parse department: %w", err)
        }</span>

        <span class="cov0" title="0">pne, err := facilitytype.ParsePhoneNumber(db.Phone)
        if err != nil </span><span class="cov0" title="0">{
                return userbus.User{}, fmt.Errorf("parse phonenum: %w", err)
        }</span>

        <span class="cov0" title="0">bus := userbus.User{
                ID:           db.ID,
                Name:         nme,
                Email:        addr,
                Phone:        pne,
                Roles:        roles,
                PasswordHash: db.PasswordHash,
                Enabled:      db.Enabled,
                Department:   department,
                DateCreated:  db.DateCreated.In(time.Local),
                DateUpdated:  db.DateUpdated.In(time.Local),
        }

        return bus, nil</span>
}

func toBusUsers(dbs []user) ([]userbus.User, error) <span class="cov0" title="0">{
        bus := make([]userbus.User, len(dbs))

        for i, db := range dbs </span><span class="cov0" title="0">{
                var err error
                bus[i], err = toBusUser(db)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">return bus, nil</span>
}
</pre>
		
		<pre class="file" id="file79" style="display: none">package userdb

import (
        "fmt"

        "github.com/FITHSCS/backend/business/domain/userbus"
        "github.com/FITHSCS/backend/business/sdk/order"
)

var orderByFields = map[string]string{
        userbus.OrderByID:      "user_id",
        userbus.OrderByName:    "name",
        userbus.OrderByEmail:   "email",
        userbus.OrderByPhone:   "phone",
        userbus.OrderByRoles:   "roles",
        userbus.OrderByEnabled: "enabled",
}

func orderByClause(orderBy order.By) (string, error) <span class="cov0" title="0">{
        by, exists := orderByFields[orderBy.Field]
        if !exists </span><span class="cov0" title="0">{
                return "", fmt.Errorf("field %q does not exist", orderBy.Field)
        }</span>

        <span class="cov0" title="0">return " ORDER BY " + by + " " + orderBy.Direction, nil</span>
}
</pre>
		
		<pre class="file" id="file80" style="display: none">// Package userdb contains product related CRUD functionality.
package userdb

import (
        "bytes"
        "context"
        "errors"
        "fmt"
        "net/mail"

        "github.com/FITHSCS/backend/business/domain/userbus"
        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/business/sdk/sqldb"
        "github.com/FITHSCS/backend/business/types/facilitytype"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/google/uuid"
        "github.com/jmoiron/sqlx"
)

// Store manages the set of APIs for user database access.
type Store struct {
        log *logger.Logger
        db  sqlx.ExtContext
}

// NewStore constructs the api for data access.
func NewStore(log *logger.Logger, db *sqlx.DB) *Store <span class="cov0" title="0">{
        return &amp;Store{
                log: log,
                db:  db,
        }
}</span>

// Create inserts a new user into the database.
func (s *Store) Create(ctx context.Context, usr userbus.User) error <span class="cov0" title="0">{
        const query = `
        INSERT INTO users
                (user_id, name, email, phone, password_hash, roles, department, enabled, created_at, updated_at)
        VALUES
                (:user_id, :name, :email, :phone, :password_hash, :roles, :department, :enabled, :created_at, :updated_at)`

        if err := sqldb.NamedExecContext(ctx, s.log, s.db, query, toDBUser(usr)); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sqldb.ErrDBDuplicatedEntry) </span><span class="cov0" title="0">{
                        return fmt.Errorf("creation Error: %w", userbus.ErrUniqueEmail)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("namedexeccontext: %w", err)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Update replaces a user document in the database.
func (s *Store) Update(ctx context.Context, usr userbus.User) error <span class="cov0" title="0">{
        const q = `
        UPDATE
                users
        SET 
                "name" = :name,
                "email" = :email,
                "phone" = :phone,
                "roles" = :roles,
                "password_hash" = :password_hash,
                "department" = :department,
                "enabled" = :enabled,
                "updated_at" = :updated_at
        WHERE
                user_id = :user_id`

        if err := sqldb.NamedExecContext(ctx, s.log, s.db, q, toDBUser(usr)); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sqldb.ErrDBDuplicatedEntry) </span><span class="cov0" title="0">{
                        return userbus.ErrUniqueEmail
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("namedexeccontext: %w", err)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Delete removes a user from the database.
func (s *Store) Delete(ctx context.Context, usr userbus.User) error <span class="cov0" title="0">{
        const q = `
        DELETE FROM
                users
        WHERE
                user_id = :user_id`

        if err := sqldb.NamedExecContext(ctx, s.log, s.db, q, toDBUser(usr)); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("namedexeccontext: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Query retrieves a list of existing users from the database.
func (s *Store) Query(ctx context.Context, filter userbus.QueryFilter, orderBy order.By, page page.Page) ([]userbus.User, error) <span class="cov0" title="0">{
        data := map[string]any{
                "offset":        (page.Number() - 1) * page.RowsPerPage(),
                "rows_per_page": page.RowsPerPage(),
        }

        const q = `
        SELECT
                user_id, name, email, phone, password_hash, roles, department, enabled, created_at, updated_at
        FROM
                users`

        buf := bytes.NewBufferString(q)
        applyFilter(filter, data, buf)

        orderByClause, err := orderByClause(orderBy)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">buf.WriteString(orderByClause)
        buf.WriteString(" OFFSET :offset ROWS FETCH NEXT :rows_per_page ROWS ONLY")

        var dbUsrs []user
        if err := sqldb.NamedQuerySlice(ctx, s.log, s.db, buf.String(), data, &amp;dbUsrs); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("namedqueryslice: %w", err)
        }</span>

        <span class="cov0" title="0">return toBusUsers(dbUsrs)</span>
}

// Count returns the total number of users in the DB.
func (s *Store) Count(ctx context.Context, filter userbus.QueryFilter) (int, error) <span class="cov0" title="0">{
        data := map[string]any{}

        const q = `
        SELECT
                count(1)
        FROM
                users`

        buf := bytes.NewBufferString(q)
        applyFilter(filter, data, buf)

        var count struct {
                Count int `db:"count"`
        }
        if err := sqldb.NamedQueryStruct(ctx, s.log, s.db, buf.String(), data, &amp;count); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("db: %w", err)
        }</span>

        <span class="cov0" title="0">return count.Count, nil</span>
}

// QueryByID gets the specified user from the database.
func (s *Store) QueryByID(ctx context.Context, userID uuid.UUID) (userbus.User, error) <span class="cov0" title="0">{
        data := struct {
                ID string `db:"user_id"`
        }{
                ID: userID.String(),
        }

        const q = `
        SELECT
        user_id, name, email, phone ,password_hash, roles, department, enabled, created_at, updated_at
        FROM
                users
        WHERE 
                user_id = :user_id`

        var dbUsr user
        if err := sqldb.NamedQueryStruct(ctx, s.log, s.db, q, data, &amp;dbUsr); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sqldb.ErrDBNotFound) </span><span class="cov0" title="0">{
                        return userbus.User{}, fmt.Errorf("db: %w", userbus.ErrNotFound)
                }</span>
                <span class="cov0" title="0">return userbus.User{}, fmt.Errorf("db: %w", err)</span>
        }

        <span class="cov0" title="0">return toBusUser(dbUsr)</span>
}

// QueryByEmail gets the specified user from the database by email.
func (s *Store) QueryByEmail(ctx context.Context, email mail.Address) (userbus.User, error) <span class="cov0" title="0">{
        data := struct {
                Email string `db:"email"`
        }{
                Email: email.Address,
        }

        const q = `
        SELECT
        user_id, name, email, phone, password_hash, roles, department, enabled, created_at, updated_at
        FROM
                users
        WHERE
                email = :email`

        var dbUsr user
        if err := sqldb.NamedQueryStruct(ctx, s.log, s.db, q, data, &amp;dbUsr); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sqldb.ErrDBNotFound) </span><span class="cov0" title="0">{
                        return userbus.User{}, fmt.Errorf("db: %w", userbus.ErrNotFound)
                }</span>
                <span class="cov0" title="0">return userbus.User{}, fmt.Errorf("db: %w", err)</span>
        }

        <span class="cov0" title="0">return toBusUser(dbUsr)</span>
}

// QueryByPhone gets the specified user from the database by email.
func (s *Store) QueryByPhone(ctx context.Context, phone facilitytype.PhoneNumber) (userbus.User, error) <span class="cov0" title="0">{
        data := struct {
                Phone string `db:"phone"`
        }{
                Phone: phone.String(),
        }

        const q = `
        SELECT
        user_id, name, email, phone, password_hash, roles, department, enabled, created_at, updated_at
        FROM
                users
        WHERE
                phone = :phone`

        var dbUsr user
        if err := sqldb.NamedQueryStruct(ctx, s.log, s.db, q, data, &amp;dbUsr); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sqldb.ErrDBNotFound) </span><span class="cov0" title="0">{
                        return userbus.User{}, fmt.Errorf("db: %w", userbus.ErrNotFound)
                }</span>
                <span class="cov0" title="0">return userbus.User{}, fmt.Errorf("db: %w", err)</span>
        }

        <span class="cov0" title="0">return toBusUser(dbUsr)</span>
}
</pre>
		
		<pre class="file" id="file81" style="display: none">package userbus

import (
        "context"
        "fmt"
        "math/rand"
        "net/mail"

        "github.com/FITHSCS/backend/business/types/facilitytype"
        "github.com/FITHSCS/backend/business/types/name"
        "github.com/FITHSCS/backend/business/types/role"
        "github.com/google/uuid"
)

func TestNewUsers(n int, rle role.Role) []NewUser <span class="cov5" title="2">{
        newUsrs := make([]NewUser, n)

        idx := rand.Intn(10000)
        for i := range n </span><span class="cov10" title="4">{
                idx++

                nu := NewUser{
                        Name:       name.MustParse(fmt.Sprintf("Name%d", idx)),
                        Email:      mail.Address{Address: fmt.Sprintf("mail%d@gmail.com", idx)},
                        Phone:      facilitytype.MustParsePhoneNumber(fmt.Sprintf("092233%04d", idx)),
                        Roles:      []role.Role{rle},
                        Department: name.MustParseNull(fmt.Sprintf("Department%d", idx)),
                        Password:   fmt.Sprintf("Password%d", idx),
                }

                newUsrs[i] = nu
        }</span>

        <span class="cov5" title="2">return newUsrs</span>
}

// TestSeedUsers is a helper method for testing.
func TestSeedUsers(ctx context.Context, n int, role role.Role, api ExtBusiness) ([]User, error) <span class="cov5" title="2">{
        newUsrs := TestNewUsers(n, role)

        usrs := make([]User, len(newUsrs))
        for i, nu := range newUsrs </span><span class="cov10" title="4">{
                usr, err := api.Create(ctx, uuid.UUID{}, nu)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("seeding user: idx: %d : %w", i, err)
                }</span>
                <span class="cov10" title="4">usrs[i] = usr</span>
        }

        <span class="cov5" title="2">return usrs, nil</span>
}
</pre>
		
		<pre class="file" id="file82" style="display: none">// Package userbus provides business access to user domain.
package userbus

import (
        "context"
        "errors"
        "fmt"
        "net/mail"
        "time"

        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/business/types/facilitytype"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/google/uuid"
        "golang.org/x/crypto/bcrypt"
)

// Set of error variables for CRUD operations.
var (
        ErrNotFound              = errors.New("user not found")
        ErrUniqueEmail           = errors.New("email is not unique")
        ErrAuthenticationFailure = errors.New("authentication failed")
)

// Storer interface declares the behavior this package needs to persist and
// retrieve data.
type Storer interface {
        Create(ctx context.Context, usr User) error
        Update(ctx context.Context, usr User) error
        Delete(ctx context.Context, usr User) error
        Query(ctx context.Context, filter QueryFilter, orderBy order.By, page page.Page) ([]User, error)
        Count(ctx context.Context, filter QueryFilter) (int, error)
        QueryByID(ctx context.Context, userID uuid.UUID) (User, error)
        QueryByEmail(ctx context.Context, email mail.Address) (User, error)
        QueryByPhone(ctx context.Context, pgone facilitytype.PhoneNumber) (User, error)
}

// ExtBusiness interface provides support for extensions that wrap extra functionality
// around the core busines logic.
type ExtBusiness interface {
        Create(ctx context.Context, actorID uuid.UUID, nu NewUser) (User, error)
        Update(ctx context.Context, actorID uuid.UUID, usr User, uu UpdateUser) (User, error)
        Delete(ctx context.Context, actorID uuid.UUID, usr User) error
        Query(ctx context.Context, filter QueryFilter, orderBy order.By, page page.Page) ([]User, error)
        Count(ctx context.Context, filter QueryFilter) (int, error)
        QueryByID(ctx context.Context, userID uuid.UUID) (User, error)
        QueryByEmail(ctx context.Context, email mail.Address) (User, error)
        QueryByPhone(ctx context.Context, phone facilitytype.PhoneNumber) (User, error)
        Authenticate(ctx context.Context, phone facilitytype.PhoneNumber, password string) (User, error)
}

// Extension is a function that wraps a new layer of business logic
// around the existing business logic.
type Extension func(ExtBusiness) ExtBusiness

// Business manages the set of APIs for user access.
type Business struct {
        log    *logger.Logger
        storer Storer
}

// NewBusiness constructs a user business API for use.
func NewBusiness(log *logger.Logger, storer Storer, extensions ...Extension) ExtBusiness <span class="cov1" title="1">{

        b := ExtBusiness(&amp;Business{
                log:    log,
                storer: storer,
        })

        for i := len(extensions) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                ext := extensions[i]
                if ext != nil </span><span class="cov0" title="0">{
                        b = ext(b)
                }</span>
        }

        <span class="cov1" title="1">return b</span>
}

// Create adds a new user to the system.
func (b *Business) Create(ctx context.Context, actorID uuid.UUID, nu NewUser) (User, error) <span class="cov10" title="5">{
        hash, err := bcrypt.GenerateFromPassword([]byte(nu.Password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return User{}, fmt.Errorf("generatefrompassword: %w", err)
        }</span>
        <span class="cov10" title="5">now := time.Now().Truncate(time.Microsecond)

        usr := User{
                ID:           uuid.New(),
                Name:         nu.Name,
                Email:        nu.Email,
                Phone:        nu.Phone,
                Roles:        nu.Roles,
                PasswordHash: hash,
                Department:   nu.Department,
                Enabled:      true,
                DateCreated:  now,
                DateUpdated:  now,
        }

        if err := b.storer.Create(ctx, usr); err != nil </span><span class="cov0" title="0">{
                return User{}, fmt.Errorf("create: %w", err)
        }</span>

        <span class="cov10" title="5">return usr, nil</span>
}

// Update modifies information about a user.
func (b *Business) Update(ctx context.Context, actorID uuid.UUID, usr User, uu UpdateUser) (User, error) <span class="cov1" title="1">{
        if uu.Name != nil </span><span class="cov1" title="1">{
                usr.Name = *uu.Name
        }</span>

        <span class="cov1" title="1">if uu.Email != nil </span><span class="cov1" title="1">{
                usr.Email = *uu.Email
        }</span>

        <span class="cov1" title="1">if uu.Phone != nil </span><span class="cov0" title="0">{
                usr.Phone = *uu.Phone
        }</span>

        <span class="cov1" title="1">if uu.Roles != nil </span><span class="cov1" title="1">{
                usr.Roles = uu.Roles
        }</span>

        <span class="cov1" title="1">if uu.Password != nil </span><span class="cov1" title="1">{
                pw, err := bcrypt.GenerateFromPassword([]byte(*uu.Password), bcrypt.DefaultCost)
                if err != nil </span><span class="cov0" title="0">{
                        return User{}, fmt.Errorf("generatefrompassword: %w", err)
                }</span>
                <span class="cov1" title="1">usr.PasswordHash = pw</span>
        }

        <span class="cov1" title="1">if uu.Department != nil </span><span class="cov1" title="1">{
                usr.Department = *uu.Department
        }</span>

        <span class="cov1" title="1">if uu.Enabled != nil </span><span class="cov0" title="0">{
                usr.Enabled = *uu.Enabled
        }</span>

        <span class="cov1" title="1">usr.DateUpdated = time.Now().Truncate(time.Microsecond)

        if err := b.storer.Update(ctx, usr); err != nil </span><span class="cov0" title="0">{
                return User{}, fmt.Errorf("update: %w", err)
        }</span>

        <span class="cov1" title="1">return usr, nil</span>
}

// Delete removes the specified user.
func (b *Business) Delete(ctx context.Context, actorID uuid.UUID, usr User) error <span class="cov4" title="2">{
        if err := b.storer.Delete(ctx, usr); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("delete: %w", err)
        }</span>

        <span class="cov4" title="2">return nil</span>
}

// Query retrieves a list of existing users.
func (b *Business) Query(ctx context.Context, filter QueryFilter, orderBy order.By, page page.Page) ([]User, error) <span class="cov1" title="1">{
        users, err := b.storer.Query(ctx, filter, orderBy, page)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("query: %w", err)
        }</span>

        <span class="cov1" title="1">return users, nil</span>
}

// Count returns the total number of users.
func (b *Business) Count(ctx context.Context, filter QueryFilter) (int, error) <span class="cov0" title="0">{
        return b.storer.Count(ctx, filter)
}</span>

// QueryByID finds the user by the specified ID.
func (b *Business) QueryByID(ctx context.Context, userID uuid.UUID) (User, error) <span class="cov0" title="0">{
        user, err := b.storer.QueryByID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return User{}, fmt.Errorf("query: userID[%s]: %w", userID, err)
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}

// QueryByEmail finds the user by a specified user email.
func (b *Business) QueryByEmail(ctx context.Context, email mail.Address) (User, error) <span class="cov0" title="0">{
        user, err := b.storer.QueryByEmail(ctx, email)
        if err != nil </span><span class="cov0" title="0">{
                return User{}, fmt.Errorf("query: email[%s]: %w", email, err)
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}

// QueryByPhone finds the user by a specified user email.
func (b *Business) QueryByPhone(ctx context.Context, pne facilitytype.PhoneNumber) (User, error) <span class="cov0" title="0">{
        user, err := b.storer.QueryByPhone(ctx, pne)
        if err != nil </span><span class="cov0" title="0">{
                return User{}, fmt.Errorf("query: phone number[%s]: %w", pne, err)
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}

// Authenticate finds a user by their email and verifies their password. On
// success it returns a Claims User representing this user. The claims can be
// used to generate a token for future authentication.
func (b *Business) Authenticate(ctx context.Context, phone facilitytype.PhoneNumber, password string) (User, error) <span class="cov0" title="0">{
        usr, err := b.QueryByPhone(ctx, phone)
        if err != nil </span><span class="cov0" title="0">{
                return User{}, fmt.Errorf("query: phone[%s]: %w", phone, err)
        }</span>

        <span class="cov0" title="0">if err := bcrypt.CompareHashAndPassword(usr.PasswordHash, []byte(password)); err != nil </span><span class="cov0" title="0">{
                return User{}, fmt.Errorf("comparehashandpassword: %w", ErrAuthenticationFailure)
        }</span>

        <span class="cov0" title="0">return usr, nil</span>
}
</pre>
		
		<pre class="file" id="file83" style="display: none">package vehicledb


import (
        "bytes"
        "fmt"
        "strings"

        "github.com/FITHSCS/backend/business/domain/vehiclebus"
        "github.com/google/uuid"
)
func applyFilter(filter vehiclebus.QueryFilter, data map[string]any, buf *bytes.Buffer) <span class="cov0" title="0">{

    var wc []string

    if filter.ID != uuid.Nil </span><span class="cov0" title="0">{
        data["vehicle_id"] = &amp;filter.ID
        wc = append(wc, "vehicle_id = :vehicle_id")
    }</span>
    <span class="cov0" title="0">if filter.PlateNumber != nil </span><span class="cov0" title="0">{
                  data["plate_number"] = fmt.Sprintf("%%%s%%", *filter.PlateNumber)
                  wc = append(wc, "plate_number LIKE :plate_number")
          }</span>
          <span class="cov0" title="0">if filter.VehicleType != nil </span><span class="cov0" title="0">{
                  data["vehicle_type"] = *filter.VehicleType
                  wc = append(wc, "vehicle_type = :vehicle_type")
          }</span>
          <span class="cov0" title="0">if filter.WeightCapacity != nil </span><span class="cov0" title="0">{
                  data["weight_capacity"] = fmt.Sprintf("%%%s%%", *filter.WeightCapacity)
                  wc = append(wc, "weight_capacity LIKE :weight_capacity")
          }</span>

          <span class="cov0" title="0">if filter.VolumeCapacity != nil </span><span class="cov0" title="0">{
                  data["volume_capacity"] = fmt.Sprintf("%%%s%%", *filter.VolumeCapacity)
      wc = append(wc, "volume_capacity LIKE :volume_capacity")
          }</span>
 
    
    <span class="cov0" title="0">if filter.CurrentStatus != nil </span><span class="cov0" title="0">{
        data["current_status"] = *filter.CurrentStatus
        wc = append(wc, "current_status = :current_status")
    }</span>
    
    <span class="cov0" title="0">if filter.CreatedAt != nil </span><span class="cov0" title="0">{
      data["created_at"] = filter.CreatedAt.UTC()
      wc = append(wc, "date_created &gt;= :created_at")
    }</span>
    <span class="cov0" title="0">if filter.UpdatedAt != nil </span><span class="cov0" title="0">{
        data["updated_at"] = filter.UpdatedAt.UTC()
        wc = append(wc, "updated_at &lt;= :updated_at")
    }</span>

    <span class="cov0" title="0">if len(wc) &gt; 0 </span><span class="cov0" title="0">{
        buf.WriteString(" WHERE ")
        buf.WriteString(strings.Join(wc, " AND "))
    }</span>
} 

</pre>
		
		<pre class="file" id="file84" style="display: none">package vehicledb

import (
        //"database/sql"
        "fmt"
        //"net/mail"
        "time"

        "github.com/FITHSCS/backend/business/domain/vehiclebus"

        "github.com/FITHSCS/backend/business/types/genstringtype"
        "github.com/google/uuid"
)

//&lt;============struct that is going to be passed to database schema =&gt; Final =======&gt;

type vehicle struct {
        ID             uuid.UUID `db:"vehicle_id"`
        PlateNumber    string    `db:"plate_number"`
        VehicleType    string    `db:"vehicle_type"`
        WeightCapacity int       `db:"weight_capacity"`
        VolumeCapacity int       `db:"volume_capacity"`
        CurrentStatus  string    `db:"current_status"`
        CreatedAt      time.Time `db:"created_at"`
        UpdatedAt      time.Time `db:"updated_at"`
}

//=============================================================================&gt;

func toDBVehicle(bus vehiclebus.Vehicle) vehicle <span class="cov0" title="0">{

        return vehicle{

                ID:             bus.ID,
                PlateNumber:    bus.PlateNumber.String(),
                VehicleType:    bus.VehicleType.String(),
                WeightCapacity: bus.WeightCapacity,
                VolumeCapacity: bus.VolumeCapacity,
                CurrentStatus:  bus.CurrentStatus.String(),
                CreatedAt:      bus.CreatedAt.UTC(),
                UpdatedAt:      bus.UpdatedAt.UTC(),
        }
}</span>

func toBusVehicle(db vehicle) (vehiclebus.Vehicle, error) <span class="cov0" title="0">{

        plteNumber, err := genstringtype.Parse(db.PlateNumber)
        if err != nil </span><span class="cov0" title="0">{
                return vehiclebus.Vehicle{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">vhiclType, err := genstringtype.Parse(db.VehicleType)
        if err != nil </span><span class="cov0" title="0">{
                return vehiclebus.Vehicle{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">currentStatus, err := genstringtype.Parse(db.CurrentStatus)
        if err != nil </span><span class="cov0" title="0">{
                return vehiclebus.Vehicle{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">bus := vehiclebus.Vehicle{

                ID:             db.ID,
                PlateNumber:    plteNumber,
                VehicleType:    vhiclType,
                WeightCapacity: db.WeightCapacity,
                VolumeCapacity: db.VolumeCapacity,
                CurrentStatus:  currentStatus,
                CreatedAt:      db.CreatedAt.In(time.Local),
                UpdatedAt:      db.UpdatedAt.In(time.Local),
        }
        return bus, nil</span>

}

func toBusVehicles(dbs []vehicle) ([]vehiclebus.Vehicle, error) <span class="cov0" title="0">{

        bus := make([]vehiclebus.Vehicle, len(dbs))

        for i, db := range dbs </span><span class="cov0" title="0">{
                var err error
                bus[i], err = toBusVehicle(db)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">return bus, nil</span>
}
</pre>
		
		<pre class="file" id="file85" style="display: none">package vehicledb


import (
  "fmt"

  "github.com/FITHSCS/backend/business/domain/vehiclebus"
  "github.com/FITHSCS/backend/business/sdk/order"
) 

var orderByFields = map[string]string{
    vehiclebus.OrderByID:                   "vehicle_id",
    vehiclebus.OrderByPlateNumber:          "plate_number",
    vehiclebus.OrderByVehicleType:          "vehicle_type",
    vehiclebus.OrderByWeightCapacity:       "weight_capacity",
    vehiclebus.OrderByVolumeCapacity:       "volume_capacity",
    vehiclebus.OrderByCurrentStatus:        "current_status",
    vehiclebus.OrderByCreatedAt:            "created_at",
    vehiclebus.OrderByUpdatedAt:            "updated_at",
}

// orderByClause converts an order.By value into the final
// " ORDER BY  ASC|DESC" fragment the store adds to its SELECT.
func orderByClause(ob order.By) (string, error) <span class="cov0" title="0">{
  col, ok := orderByFields[ob.Field]
  if !ok </span><span class="cov0" title="0">{
    return "", fmt.Errorf("field %q does not exist", ob.Field)
  }</span>
  <span class="cov0" title="0">return " ORDER BY " + col + " " + ob.Direction, nil</span>
}
</pre>
		
		<pre class="file" id="file86" style="display: none">// Package vehicledb contains product related CRUD functionality.
package vehicledb

import (
        "bytes"
        "context"
        "errors"
        "fmt"

        "github.com/FITHSCS/backend/business/domain/vehiclebus"
        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/business/sdk/sqldb"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/google/uuid"
        "github.com/jmoiron/sqlx"
)

type Store struct {
        log *logger.Logger
        db  sqlx.ExtContext
}

func NewStore(log *logger.Logger, db *sqlx.DB) *Store <span class="cov0" title="0">{
        return &amp;Store{log: log, db: db}
}</span>

// -----------------------------------------------------------------------------
// CRUD
// -----------------------------------------------------------------------------

func (s *Store) Create(ctx context.Context, v vehiclebus.Vehicle) error <span class="cov0" title="0">{
        fmt.Println(v)
        const stmt = `
    INSERT INTO vehicle (
            vehicle_id,
                plate_number, 
                vehicle_type, 
                weight_capacity,
            volume_capacity, 
                current_status, 
            created_at, 
                updated_at
    ) VALUES (
            :vehicle_id, 
                :plate_number, 
                :vehicle_type, 
                :weight_capacity,
            :volume_capacity, 
                :current_status,
            :created_at, 
                :updated_at
    )`
        return sqldb.NamedExecContext(ctx, s.log, s.db, stmt, toDBVehicle(v))
}</span>

func (s *Store) Update(ctx context.Context, v vehiclebus.Vehicle) error <span class="cov0" title="0">{
        const stmt = `
    UPDATE 
                vehicle
        SET 
                plate_number      = :plate_number,
            vehicle_type      = :vehicle_type,
            weight_capacity   = :weight_capacity,
            volume_capacity   = :volume_capacity,
            current_status    = :current_status,
            updated_at        = :updated_at
    WHERE 
                vehicle_id        = :vehicle_id`
        return sqldb.NamedExecContext(ctx, s.log, s.db, stmt, toDBVehicle(v))
}</span>

func (s *Store) Query(ctx context.Context,
        filter vehiclebus.QueryFilter, orderBy order.By, page page.Page) ([]vehiclebus.Vehicle, error) <span class="cov0" title="0">{
        //func (s *Store) Query(ctx context.Context) ([]vehiclebus.Vehicle, error) {

        data := map[string]any{
                "offset":        (page.Number() - 1) * page.RowsPerPage(),
                "rows_per_page": page.RowsPerPage(),
        }

        const q = `
    SELECT
            vehicle_id, 
                plate_number, 
                vehicle_type, 
                weight_capacity,
            volume_capacity, 
                current_status,
            created_at, 
                updated_at
    FROM 
                vehicle`

        var buf bytes.Buffer
        buf.WriteString(q)
        applyFilter(filter, data, &amp;buf)

        clause, err := orderByClause(orderBy)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">buf.WriteString(clause)
        buf.WriteString(" OFFSET :offset ROWS FETCH NEXT :rows_per_page ROWS ONLY")

        var dbRecs []vehicle
        if err := sqldb.NamedQuerySlice(ctx, s.log, s.db, buf.String(), data, &amp;dbRecs); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("namedqueryslice: %w", err)
        }</span>
        <span class="cov0" title="0">fmt.Println(dbRecs)
        return toBusVehicles(dbRecs)</span>
}

func (s *Store) Count(ctx context.Context, filter vehiclebus.QueryFilter) (int, error) <span class="cov0" title="0">{
        data := map[string]any{}
        const base = `SELECT count(1) FROM vehicle`

        var buf bytes.Buffer
        buf.WriteString(base)
        applyFilter(filter, data, &amp;buf)

        var out struct {
                Count int `db:"count"`
        }
        if err := sqldb.NamedQueryStruct(ctx, s.log, s.db, buf.String(), data, &amp;out); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("db: %w", err)
        }</span>
        <span class="cov0" title="0">return out.Count, nil</span>
}
func (s *Store) QueryByID(ctx context.Context, id uuid.UUID) (vehiclebus.Vehicle, error) <span class="cov0" title="0">{
        param := map[string]any{
                "vehicle_id": id.String(),
        }
        const stmt = `
    SELECT
                vehicle_id,
                plate_number,
                vehicle_type,
                weight_capacity,
                volume_capacity,
                current_status,
                created_at,
                updated_at
        FROM 
                vehicle
        WHERE 
                vehicle_id = :vehicle_id`

        var rec vehicle
        if err := sqldb.NamedQueryStruct(ctx, s.log, s.db, stmt, param, &amp;rec); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sqldb.ErrDBNotFound) </span><span class="cov0" title="0">{
                        return vehiclebus.Vehicle{}, vehiclebus.ErrNotFound
                }</span>
                <span class="cov0" title="0">return vehiclebus.Vehicle{}, err</span>
        }
        <span class="cov0" title="0">return toBusVehicle(rec)</span>
}

func (s *Store) Delete(ctx context.Context, vehicleID uuid.UUID) error <span class="cov0" title="0">{

        const q = `
    DELETE FROM
        vehicle
    WHERE
        vehicle_id = :vehicle_id`

        dbFacility := vehicle{ID: vehicleID}

        if err := sqldb.NamedExecContext(ctx, s.log, s.db, q, dbFacility); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("namedexeccontext: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file87" style="display: none">package vehiclebus

import (
        "context"
        "fmt"
        "math/rand"

        "github.com/FITHSCS/backend/business/types/genstringtype"
)

func TestGenerateNewVehicles(n int) []NewVehicle <span class="cov5" title="2">{
        newroute := make([]NewVehicle, n)

        idx := rand.Intn(10000)
        for i := range n </span><span class="cov10" title="4">{
                idx++

                nf := NewVehicle{
                        PlateNumber:    genstringtype.MustParse(fmt.Sprintf("03-B-12%2d", idx)),
                        VehicleType:    genstringtype.MustParse("Truck"),
                        WeightCapacity: idx,
                        VolumeCapacity: idx % 100,
                        CurrentStatus:  genstringtype.MustParse("Active"),
                }

                newroute[i] = nf
        }</span>

        <span class="cov5" title="2">return newroute</span>
}

func TestGenerateSeedVehicles(ctx context.Context, n int, api *Business) ([]Vehicle, error) <span class="cov5" title="2">{
        newfs := TestGenerateNewVehicles(n)

        facs := make([]Vehicle, len(newfs))
        for i, np := range newfs </span><span class="cov10" title="4">{
                prd, err := api.Create(ctx, np)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("seeding routes: idx: %d : %w", i, err)
                }</span>

                <span class="cov10" title="4">facs[i] = prd</span>
        }

        <span class="cov5" title="2">return facs, nil</span>
}
</pre>
		
		<pre class="file" id="file88" style="display: none">// Package vehiclebus provides business access to vehicles bus domain.
package vehiclebus

import (
        "context"
        "errors"
        "fmt"

        "time"

        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/google/uuid"
)

var (
        ErrNotFound       = errors.New("vehicle not found")
        ErrAuthentication = errors.New("authentication failed")
)

type Storer interface {
        Create(ctx context.Context, vehicle Vehicle) error
        Update(ctx context.Context, vehicle Vehicle) error
        Query(ctx context.Context, filter QueryFilter, orderby order.By, page page.Page) ([]Vehicle, error)
        QueryByID(ctx context.Context, vehicleID uuid.UUID) (Vehicle, error)
        Count(ctx context.Context, filter QueryFilter) (int, error)
        Delete(ctx context.Context, vehicleID uuid.UUID) error
}

type Business struct {
        log    *logger.Logger
        storer Storer
}

func NewBusiness(log *logger.Logger, storer Storer) *Business <span class="cov1" title="1">{

        return &amp;Business{
                log:    log,
                storer: storer,
        }
}</span>

func (b *Business) Create(ctx context.Context, vf NewVehicle) (Vehicle, error) <span class="cov10" title="5">{

        now := time.Now().Truncate(time.Microsecond)

        vehicle := Vehicle{

                ID:             uuid.New(),
                PlateNumber:    vf.PlateNumber,
                VehicleType:    vf.VehicleType,
                WeightCapacity: vf.WeightCapacity,
                VolumeCapacity: vf.VolumeCapacity,
                CurrentStatus:  vf.CurrentStatus,
                CreatedAt:      now,
                UpdatedAt:      now,
        }

        if err := b.storer.Create(ctx, vehicle); err != nil </span><span class="cov0" title="0">{
                return Vehicle{}, fmt.Errorf("Create: %w", err)
        }</span>
        <span class="cov10" title="5">return vehicle, nil</span>
}

func (b *Business) Update(ctx context.Context, vehicleID uuid.UUID, updateVehicle UpdateVehicle) (Vehicle, error) <span class="cov1" title="1">{

        vehicleDBRetrieved, err := b.storer.QueryByID(ctx, vehicleID)
        if err != nil </span><span class="cov0" title="0">{
                return Vehicle{}, fmt.Errorf("update: %w", err)
        }</span>

        <span class="cov1" title="1">if updateVehicle.PlateNumber != nil </span><span class="cov1" title="1">{
                vehicleDBRetrieved.PlateNumber = *updateVehicle.PlateNumber
        }</span>

        <span class="cov1" title="1">if updateVehicle.VehicleType != nil </span><span class="cov1" title="1">{
                vehicleDBRetrieved.VehicleType = *updateVehicle.VehicleType
        }</span>

        <span class="cov1" title="1">if updateVehicle.WeightCapacity != nil </span><span class="cov1" title="1">{
                vehicleDBRetrieved.WeightCapacity = *updateVehicle.WeightCapacity
        }</span>

        <span class="cov1" title="1">if updateVehicle.VolumeCapacity != nil </span><span class="cov1" title="1">{
                vehicleDBRetrieved.VolumeCapacity = *updateVehicle.VolumeCapacity
        }</span>

        <span class="cov1" title="1">if updateVehicle.CurrentStatus != nil </span><span class="cov1" title="1">{
                vehicleDBRetrieved.CurrentStatus = *updateVehicle.CurrentStatus
        }</span>

        <span class="cov1" title="1">vehicleDBRetrieved.UpdatedAt = time.Now().Truncate(time.Microsecond)

        if err := b.storer.Update(ctx, vehicleDBRetrieved); err != nil </span><span class="cov0" title="0">{
                return Vehicle{}, fmt.Errorf("update: %w", err)
        }</span>
        <span class="cov1" title="1">return vehicleDBRetrieved, nil</span>
}

func (b *Business) QueryByID(ctx context.Context, vehicleID uuid.UUID) (Vehicle, error) <span class="cov1" title="1">{

        vehicle, err := b.storer.QueryByID(ctx, vehicleID)
        if err != nil </span><span class="cov0" title="0">{
                return Vehicle{}, fmt.Errorf("query: vehicleID[%s]: %w", vehicleID, err)
        }</span>
        <span class="cov1" title="1">return vehicle, nil</span>
}

func (b *Business) Query(ctx context.Context, filter QueryFilter, orderBy order.By, page page.Page) ([]Vehicle, error) <span class="cov1" title="1">{
        vehicles, err := b.storer.Query(ctx, filter, orderBy, page)

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Query: %w", err)
        }</span>
        <span class="cov1" title="1">return vehicles, nil</span>
}

func (b *Business) Count(ctx context.Context, filter QueryFilter) (int, error) <span class="cov0" title="0">{
        return b.storer.Count(ctx, filter)
}</span>

func (b *Business) Delete(ctx context.Context, vehicleID uuid.UUID) error <span class="cov4" title="2">{

        if err := b.storer.Delete(ctx, vehicleID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("delete: %w", err)
        }</span>
        <span class="cov4" title="2">return nil</span>
}
</pre>
		
		<pre class="file" id="file89" style="display: none">package dbtest

import (
        "time"

        "github.com/FITHSCS/backend/business/domain/auditbus"
        "github.com/FITHSCS/backend/business/domain/auditbus/stores/auditdb"
        "github.com/FITHSCS/backend/business/domain/delexceptionbus"
        "github.com/FITHSCS/backend/business/domain/delexceptionbus/store/delexceptiondb"
        "github.com/FITHSCS/backend/business/domain/facilitybus"
        "github.com/FITHSCS/backend/business/domain/facilitybus/stores/facilitydb"
        "github.com/FITHSCS/backend/business/domain/gpstrackingbus"
        "github.com/FITHSCS/backend/business/domain/gpstrackingbus/stores/gpstrackingdb"
        "github.com/FITHSCS/backend/business/domain/imagebus"
        "github.com/FITHSCS/backend/business/domain/imagebus/stores/imagedb"
        "github.com/FITHSCS/backend/business/domain/manifestbus"
        "github.com/FITHSCS/backend/business/domain/manifestbus/stores/manifestdb"
        "github.com/FITHSCS/backend/business/domain/pickupbatchbus"
        "github.com/FITHSCS/backend/business/domain/pickupbatchbus/stores/pickupbatchdb"
        "github.com/FITHSCS/backend/business/domain/routebus"
        "github.com/FITHSCS/backend/business/domain/routebus/stores/routedb"
        "github.com/FITHSCS/backend/business/domain/signaturebus"
        "github.com/FITHSCS/backend/business/domain/signaturebus/stores/signaturedb"
        "github.com/FITHSCS/backend/business/domain/userbus"
        "github.com/FITHSCS/backend/business/domain/userbus/stores/usercache"
        "github.com/FITHSCS/backend/business/domain/userbus/stores/userdb"
        "github.com/FITHSCS/backend/business/domain/vehiclebus"
        "github.com/FITHSCS/backend/business/domain/vehiclebus/stores/vehicledb"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/jmoiron/sqlx"
)

// BusDomain represents all the business domain apis needed for testing.
type BusDomain struct {
        User              userbus.ExtBusiness
        Facility          *facilitybus.Business
        Routes            *routebus.Business
        Audit             *auditbus.Business
        Vehicle           *vehiclebus.Business
        PickupBatch       *pickupbatchbus.Business
        Manifest          *manifestbus.Business
        Signature         *signaturebus.Business
        DeliveryException *delexceptionbus.Business
        Image             *imagebus.Business
        GPStrackingbus    *gpstrackingbus.Business
}

func newBusDomains(log *logger.Logger, db *sqlx.DB) BusDomain <span class="cov0" title="0">{
        userBus := userbus.NewBusiness(log, usercache.NewStore(log, userdb.NewStore(log, db), time.Minute))
        facilitybus := facilitybus.NewBusiness(log, facilitydb.NewStore(log, db))
        auditBus := auditbus.NewBusiness(log, auditdb.NewStore(log, db))
        routebus := routebus.NewBusiness(log, routedb.NewStore(log, db))
        vehiclebus := vehiclebus.NewBusiness(log, vehicledb.NewStore(log, db))
        pickupbtch := pickupbatchbus.NewBusiness(log, pickupbatchdb.NewStore(log, db))
        manifestbus := manifestbus.NewBusiness(log, manifestdb.NewStore(log, db))
        signaturebus := signaturebus.NewBusiness(log, signaturedb.NewStore(log, db))
        delexbus := delexceptionbus.NewBusiness(log, delexceptiondb.NewStore(log, db))
        imagebus := imagebus.NewBusiness(log, imagedb.NewStore(log, db))
        gpsbus := gpstrackingbus.NewBusiness(log, gpstrackingdb.NewStore(log, db))

        return BusDomain{
                User:              userBus,
                Audit:             auditBus,
                Facility:          facilitybus,
                Routes:            routebus,
                Vehicle:           vehiclebus,
                PickupBatch:       pickupbtch,
                Manifest:          manifestbus,
                Signature:         signaturebus,
                DeliveryException: delexbus,
                Image:             imagebus,
                GPStrackingbus:    gpsbus,
        }
}</span>
</pre>
		
		<pre class="file" id="file90" style="display: none">// Package dbtest contains supporting code for running tests that hit the DB.
package dbtest

import (
        "bytes"
        "context"
        "math/rand"
        "testing"
        "time"

        "github.com/FITHSCS/backend/business/sdk/migrate"
        "github.com/FITHSCS/backend/business/sdk/sqldb"
        "github.com/FITHSCS/backend/foundation/docker"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/FITHSCS/backend/foundation/otel"
        "github.com/jmoiron/sqlx"
)

// Database owns state for running and shutting down tests.
type Database struct {
        DB        *sqlx.DB
        Log       *logger.Logger
        BusDomain BusDomain
}

// New creates a new test database inside the database that was started
// to handle testing. The database is migrated to the current version and
// a connection pool is provided with business domain packages.
func New(t *testing.T, testName string) *Database <span class="cov0" title="0">{
        image := "postgres:17.4"
        name := "servicetest"
        port := "5432"
        dockerArgs := []string{"-e", "POSTGRES_PASSWORD=postgres"}
        appArgs := []string{"-c", "log_statement=all"}

        c, err := docker.StartContainer(image, name, port, dockerArgs, appArgs)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Starting database: %v", err)
        }</span>

        <span class="cov0" title="0">t.Logf("Name    : %s\n", c.Name)
        t.Logf("HostPort: %s\n", c.HostPort)

        dbM, err := sqldb.Open(sqldb.Config{
                User:       "postgres",
                Password:   "postgres",
                Host:       c.HostPort,
                Name:       "postgres",
                DisableTLS: true,
        })
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Opening database connection: %v", err)
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        if err := sqldb.StatusCheck(ctx, dbM); err != nil </span><span class="cov0" title="0">{
                t.Fatalf("status check database: %v", err)
        }</span>

        // -------------------------------------------------------------------------

        <span class="cov0" title="0">const letterBytes = "abcdefghijklmnopqrstuvwxyz"
        b := make([]byte, 4)
        for i := range b </span><span class="cov0" title="0">{
                b[i] = letterBytes[rand.Intn(len(letterBytes))]
        }</span>
        <span class="cov0" title="0">dbName := string(b)

        t.Logf("Create Database: %s\n", dbName)
        if _, err := dbM.ExecContext(context.Background(), "CREATE DATABASE "+dbName); err != nil </span><span class="cov0" title="0">{
                t.Fatalf("creating database %s: %v", dbName, err)
        }</span>

        // -------------------------------------------------------------------------

        <span class="cov0" title="0">db, err := sqldb.Open(sqldb.Config{
                User:       "postgres",
                Password:   "postgres",
                Host:       c.HostPort,
                Name:       dbName,
                DisableTLS: true,
        })
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Opening database connection: %v", err)
        }</span>

        <span class="cov0" title="0">t.Logf("Migrate Database: %s\n", dbName)
        if err := migrate.Migrate(ctx, db); err != nil </span><span class="cov0" title="0">{
                t.Logf("Logs for %s\n%s:", c.Name, docker.DumpContainerLogs(c.Name))
                t.Fatalf("Migrating error: %s", err)
        }</span>

        // -------------------------------------------------------------------------

        <span class="cov0" title="0">var buf bytes.Buffer
        log := logger.New(&amp;buf, logger.LevelInfo, "TEST", func(context.Context) string </span><span class="cov0" title="0">{ return otel.GetTraceID(ctx) }</span>)

        // -------------------------------------------------------------------------

        <span class="cov0" title="0">t.Cleanup(func() </span><span class="cov0" title="0">{
                t.Helper()

                t.Logf("Drop Database: %s\n", dbName)
                if _, err := dbM.ExecContext(context.Background(), "DROP DATABASE "+dbName); err != nil </span><span class="cov0" title="0">{
                        t.Fatalf("dropping database %s: %v", dbName, err)
                }</span>

                <span class="cov0" title="0">db.Close()
                dbM.Close()

                t.Logf("******************** LOGS (%s) ********************\n\n", testName)
                t.Log(buf.String())
                t.Logf("******************** LOGS (%s) ********************\n", testName)</span>
        })

        <span class="cov0" title="0">return &amp;Database{
                DB:        db,
                Log:       log,
                BusDomain: newBusDomains(log, db),
        }</span>
}
</pre>
		
		<pre class="file" id="file91" style="display: none">package dbtest

import (
        "encoding/json"
        "time"

        "github.com/FITHSCS/backend/business/types/facilitytype"
        "github.com/FITHSCS/backend/business/types/genstringtype"
        "github.com/FITHSCS/backend/business/types/name"
        "github.com/google/uuid"
)

// StringPointer is a helper to get a *string from a string. It is in the tests
// package because we normally don't want to deal with pointers to basic types
// but it's useful in some tests.
func StringPointer(s string) *string <span class="cov0" title="0">{
        return &amp;s
}</span>

// IntPointer is a helper to get a *int from a int. It is in the tests package
// because we normally don't want to deal with pointers to basic types but it's
// useful in some tests.
func IntPointer(i int) *int <span class="cov0" title="0">{
        return &amp;i
}</span>

// FloatPointer is a helper to get a *float64 from a float64. It is in the tests
// package because we normally don't want to deal with pointers to basic types
// but it's useful in some tests.
func FloatPointer(f float64) *float64 <span class="cov0" title="0">{
        return &amp;f
}</span>

// BoolPointer is a helper to get a *bool from a bool. It is in the tests package
// because we normally don't want to deal with pointers to basic types but it's
// useful in some tests.
func BoolPointer(b bool) *bool <span class="cov0" title="0">{
        return &amp;b
}</span>

// NamePointer is a helper to get a *Name from a string. It's in the tests
// package because we normally don't want to deal with pointers to basic types
// but it's useful in some tests.
func NamePointer(value string) *name.Name <span class="cov0" title="0">{
        name := name.MustParse(value)
        return &amp;name
}</span>

// NameNullPointer is a helper to get a *EmptyName from a string. It's in the tests
// package because we normally don't want to deal with pointers to basic types
// but it's useful in some tests.
func NameNullPointer(value string) *name.Null <span class="cov0" title="0">{
        name := name.MustParseNull(value)
        return &amp;name
}</span>

// ==========================================================
// Eyu's implementation for types

func AddressPointer(value string) *facilitytype.Address <span class="cov0" title="0">{
        add := facilitytype.MustParseAddress(value)
        return &amp;add
}</span>

func LatitudePointer(f float64) *facilitytype.Lat <span class="cov0" title="0">{
        lat := facilitytype.MustParseLat(f)
        return &amp;lat
}</span>

func LongitudePointer(f float64) *facilitytype.Long <span class="cov0" title="0">{
        long := facilitytype.MustParseLong(f)
        return &amp;long
}</span>

func GeofencePointer(f float64) *facilitytype.Geofence <span class="cov0" title="0">{
        geofence := facilitytype.MustParseGeofence(f)

        return &amp;geofence
}</span>

func PhoneNumberPointer(str string) *facilitytype.PhoneNumber <span class="cov0" title="0">{
        phonum := facilitytype.MustParsePhoneNumber(str)
        return &amp;phonum
}</span>

func GenStringPointer(str string) *genstringtype.GenString <span class="cov0" title="0">{
        genericString := genstringtype.MustParse(str)
        return &amp;genericString
}</span>

func UUIDStringPointer(str string) *uuid.UUID <span class="cov0" title="0">{
        id := uuid.MustParse(str)
        return &amp;id
}</span>

func NullUUIDStringPointer(id uuid.NullUUID) *uuid.NullUUID <span class="cov0" title="0">{
        return &amp;id
}</span>

func TimePointer(tme time.Time) *time.Time <span class="cov0" title="0">{
        return &amp;tme
}</span>

func RawJSONPointer(rj json.RawMessage) *json.RawMessage <span class="cov0" title="0">{
        return &amp;rj
}</span>
</pre>
		
		<pre class="file" id="file92" style="display: none">// Package delegate provides the ability to make function calls between
// different domain packages when an import is not possible.
package delegate

import (
        "context"

        "github.com/FITHSCS/backend/foundation/logger"
)

// These types are just for documentation so we know what keys go
// where in the map.
type (
        domain string
        action string
)

// Delegate manages the set of functions to be called by domain
// packages when an import is not possible.
type Delegate struct {
        log   *logger.Logger
        funcs map[domain]map[action][]Func
}

// New constructs a delegate for indirect api access.
func New(log *logger.Logger) *Delegate <span class="cov0" title="0">{
        return &amp;Delegate{
                log:   log,
                funcs: make(map[domain]map[action][]Func),
        }
}</span>

// Register adds a function to be called for a specified domain and action.
func (d *Delegate) Register(domainType string, actionType string, fn Func) <span class="cov0" title="0">{
        aMap, ok := d.funcs[domain(domainType)]
        if !ok </span><span class="cov0" title="0">{
                aMap = make(map[action][]Func)
                d.funcs[domain(domainType)] = aMap
        }</span>

        <span class="cov0" title="0">funcs := aMap[action(actionType)]
        funcs = append(funcs, fn)
        aMap[action(actionType)] = funcs</span>
}

// Call executes all functions registered for the specified domain and
// action. These functions are executed synchronously on the G making the call.
func (d *Delegate) Call(ctx context.Context, data Data) error <span class="cov0" title="0">{
        d.log.Info(ctx, "delegate call", "status", "started", "domain", data.Domain, "action", data.Action, "params", data.RawParams)
        defer d.log.Info(ctx, "delegate call", "status", "completed")

        if dMap, ok := d.funcs[domain(data.Domain)]; ok </span><span class="cov0" title="0">{
                if funcs, ok := dMap[action(data.Action)]; ok </span><span class="cov0" title="0">{
                        for _, fn := range funcs </span><span class="cov0" title="0">{
                                d.log.Info(ctx, "delegate call", "status", "sending")

                                if err := fn(ctx, data); err != nil </span><span class="cov0" title="0">{
                                        d.log.Error(ctx, "delegate call", "err", err)
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file93" style="display: none">package delegate

import (
        "context"
        "fmt"
)

// Func represents a function that is registered and called by the system.
type Func func(context.Context, Data) error

// Data represents an event between domains.
type Data struct {
        Domain    string
        Action    string
        RawParams []byte
}

// String implements the Stringer interface.
func (d Data) String() string <span class="cov0" title="0">{
        return fmt.Sprintf(
                "Event{Domain:%#v, Action:%#v, RawParams:%#v}",
                d.Domain, d.Action, string(d.RawParams),
        )
}</span>
</pre>
		
		<pre class="file" id="file94" style="display: none">// Package migrate contains the database schema, migrations and seeding data.
package migrate

import (
        "context"
        "database/sql"
        _ "embed"
        "errors"
        "fmt"

        "github.com/FITHSCS/backend/business/sdk/sqldb"
        "github.com/ardanlabs/darwin/v3"
        "github.com/ardanlabs/darwin/v3/dialects/postgres"
        "github.com/ardanlabs/darwin/v3/drivers/generic"
        "github.com/jmoiron/sqlx"
)

var (
        //go:embed sql/migrate.sql
        migrateDoc string

        //go:embed sql/seed.sql
        seedDoc string
)

// Migrate attempts to bring the database up to date with the migrations
// defined in this package.
func Migrate(ctx context.Context, db *sqlx.DB) error <span class="cov0" title="0">{
        if err := sqldb.StatusCheck(ctx, db); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("status check database: %w", err)
        }</span>

        <span class="cov0" title="0">driver, err := generic.New(db.DB, postgres.Dialect{})
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("construct darwin driver: %w", err)
        }</span>

        <span class="cov0" title="0">d := darwin.New(driver, darwin.ParseMigrations(migrateDoc))
        return d.Migrate()</span>
}

// Seed runs the seed document defined in this package against db. The queries
// are run in a transaction and rolled back if any fail.
func Seed(ctx context.Context, db *sqlx.DB) (err error) <span class="cov0" title="0">{
        if err := sqldb.StatusCheck(ctx, db); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("status check database: %w", err)
        }</span>

        <span class="cov0" title="0">tx, err := db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if errTx := tx.Rollback(); errTx != nil </span><span class="cov0" title="0">{
                        if errors.Is(errTx, sql.ErrTxDone) </span><span class="cov0" title="0">{
                                return
                        }</span>

                        <span class="cov0" title="0">err = fmt.Errorf("rollback: %w", errTx)
                        return</span>
                }
        }()

        <span class="cov0" title="0">if _, err := tx.Exec(seedDoc); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("exec: %w", err)
        }</span>

        <span class="cov0" title="0">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("commit: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file95" style="display: none">// Package order provides support for describing the ordering of data.
package order

import (
        "fmt"
        "strings"
)

// Set of directions for data ordering.
const (
        ASC  = "ASC"
        DESC = "DESC"
)

var directions = map[string]string{
        ASC:  "ASC",
        DESC: "DESC",
}

// By represents a field used to order by and direction.
type By struct {
        Field     string
        Direction string
}

// NewBy constructs a new By value with no checks.
func NewBy(field string, direction string) By <span class="cov0" title="0">{
        if _, exists := directions[direction]; !exists </span><span class="cov0" title="0">{
                return By{
                        Field:     field,
                        Direction: ASC,
                }
        }</span>

        <span class="cov0" title="0">return By{
                Field:     field,
                Direction: direction,
        }</span>
}

// Parse constructs a By value by parsing a string in the form of
// "field,direction" ie "user_id,ASC".
func Parse(fieldMappings map[string]string, orderBy string, defaultOrder By) (By, error) <span class="cov0" title="0">{
        if orderBy == "" </span><span class="cov0" title="0">{
                return defaultOrder, nil
        }</span>

        <span class="cov0" title="0">orderParts := strings.Split(orderBy, ",")

        orgFieldName := strings.TrimSpace(orderParts[0])
        fieldName, exists := fieldMappings[orgFieldName]
        if !exists </span><span class="cov0" title="0">{
                return By{}, fmt.Errorf("unknown order: %s", orgFieldName)
        }</span>

        <span class="cov0" title="0">switch len(orderParts) </span>{
        case 1:<span class="cov0" title="0">
                return NewBy(fieldName, ASC), nil</span>

        case 2:<span class="cov0" title="0">
                direction := strings.TrimSpace(orderParts[1])
                if _, exists := directions[direction]; !exists </span><span class="cov0" title="0">{
                        return By{}, fmt.Errorf("unknown direction: %s", direction)
                }</span>

                <span class="cov0" title="0">return NewBy(fieldName, direction), nil</span>

        default:<span class="cov0" title="0">
                return By{}, fmt.Errorf("unknown order: %s", orderBy)</span>
        }
}
</pre>
		
		<pre class="file" id="file96" style="display: none">// Package page provides support for query paging.
package page

import (
        "fmt"
        "strconv"
)

// Page represents the requested page and rows per page.
type Page struct {
        number int
        rows   int
}

// Parse parses the strings and validates the values are in reason.
func Parse(page string, rowsPerPage string) (Page, error) <span class="cov0" title="0">{
        number := 1
        if page != "" </span><span class="cov0" title="0">{
                var err error
                number, err = strconv.Atoi(page)
                if err != nil </span><span class="cov0" title="0">{
                        return Page{}, fmt.Errorf("page conversion: %w", err)
                }</span>
        }

        <span class="cov0" title="0">rows := 10
        if rowsPerPage != "" </span><span class="cov0" title="0">{
                var err error
                rows, err = strconv.Atoi(rowsPerPage)
                if err != nil </span><span class="cov0" title="0">{
                        return Page{}, fmt.Errorf("rows conversion: %w", err)
                }</span>
        }

        <span class="cov0" title="0">if number &lt;= 0 </span><span class="cov0" title="0">{
                return Page{}, fmt.Errorf("page value too small, must be larger than 0")
        }</span>

        <span class="cov0" title="0">if rows &lt;= 0 </span><span class="cov0" title="0">{
                return Page{}, fmt.Errorf("rows value too small, must be larger than 0")
        }</span>

        <span class="cov0" title="0">if rows &gt; 100 </span><span class="cov0" title="0">{
                return Page{}, fmt.Errorf("rows value too large, must be less than 100")
        }</span>

        <span class="cov0" title="0">p := Page{
                number: number,
                rows:   rows,
        }

        return p, nil</span>
}

// MustParse creates a paging value for testing.
func MustParse(page string, rowsPerPage string) Page <span class="cov0" title="0">{
        pg, err := Parse(page, rowsPerPage)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">return pg</span>
}

// String implements the stringer interface.
func (p Page) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("page: %d rows: %d", p.number, p.rows)
}</span>

// Number returns the page number.
func (p Page) Number() int <span class="cov0" title="0">{
        return p.number
}</span>

// RowsPerPage returns the rows per page.
func (p Page) RowsPerPage() int <span class="cov0" title="0">{
        return p.rows
}</span>
</pre>
		
		<pre class="file" id="file97" style="display: none">/*
Code taken from https://github.com/lib/pq

Copyright (c) 2011-2013, 'pq' Contributors Portions Copyright (C) 2011 Blake Mizerany

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
Software, and to permit persons to whom the Software is furnished to do so, subject
to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

// Package dbarray provides support for database array types.
package dbarray

import (
        "bytes"
        "database/sql"
        "database/sql/driver"
        "encoding/hex"
        "fmt"
        "reflect"
        "strconv"
        "strings"
)

var typeByteSlice = reflect.TypeOf([]byte{})
var typeDriverValuer = reflect.TypeOf((*driver.Valuer)(nil)).Elem()
var typeSQLScanner = reflect.TypeOf((*sql.Scanner)(nil)).Elem()

// Array returns the optimal driver.Valuer and sql.Scanner for an array or
// slice of any dimension.
//
// For example:
//
//        db.Query(`SELECT * FROM t WHERE id = ANY($1)`, pq.Array([]int{235, 401}))
//
//        var x []sql.NullInt64
//        db.QueryRow(`SELECT ARRAY[235, 401]`).Scan(pq.Array(&amp;x))
//
// Scanning multi-dimensional arrays is not supported.  Arrays where the lower
// bound is not one (such as `[0:0]={1}') are not supported.
func Array(a any) interface {
        driver.Valuer
        sql.Scanner
} <span class="cov0" title="0">{
        switch a := a.(type) </span>{
        case []bool:<span class="cov0" title="0">
                return (*Bool)(&amp;a)</span>
        case []float64:<span class="cov0" title="0">
                return (*Float64)(&amp;a)</span>
        case []float32:<span class="cov0" title="0">
                return (*Float32)(&amp;a)</span>
        case []int64:<span class="cov0" title="0">
                return (*Int64)(&amp;a)</span>
        case []int32:<span class="cov0" title="0">
                return (*Int32)(&amp;a)</span>
        case []string:<span class="cov0" title="0">
                return (*String)(&amp;a)</span>
        case [][]byte:<span class="cov0" title="0">
                return (*Bytea)(&amp;a)</span>

        case *[]bool:<span class="cov0" title="0">
                return (*Bool)(a)</span>
        case *[]float64:<span class="cov0" title="0">
                return (*Float64)(a)</span>
        case *[]float32:<span class="cov0" title="0">
                return (*Float32)(a)</span>
        case *[]int64:<span class="cov0" title="0">
                return (*Int64)(a)</span>
        case *[]int32:<span class="cov0" title="0">
                return (*Int32)(a)</span>
        case *[]string:<span class="cov0" title="0">
                return (*String)(a)</span>
        case *[][]byte:<span class="cov0" title="0">
                return (*Bytea)(a)</span>
        }

        <span class="cov0" title="0">return Generic{a}</span>
}

// Delimiter may be optionally implemented by driver.Valuer or sql.Scanner
// to override the array delimiter used by Generic.
type Delimiter interface {
        // Delimiter returns the delimiter character(s) for this element's type.
        Delimiter() string
}

// Bool represents a one-dimensional array of the PostgreSQL boolean type.
type Bool []bool

// Scan implements the sql.Scanner interface.
func (a *Bool) Scan(src any) error <span class="cov0" title="0">{
        switch src := src.(type) </span>{
        case []byte:<span class="cov0" title="0">
                return a.scanBytes(src)</span>
        case string:<span class="cov0" title="0">
                return a.scanBytes([]byte(src))</span>
        case nil:<span class="cov0" title="0">
                *a = nil
                return nil</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("database: cannot convert %T to Bool", src)</span>
}

func (a *Bool) scanBytes(src []byte) error <span class="cov0" title="0">{
        elems, err := scanLinearArray(src, []byte{','}, "Bool")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if *a != nil &amp;&amp; len(elems) == 0 </span><span class="cov0" title="0">{
                *a = (*a)[:0]
        }</span> else<span class="cov0" title="0"> {
                b := make(Bool, len(elems))
                for i, v := range elems </span><span class="cov0" title="0">{
                        if len(v) != 1 </span><span class="cov0" title="0">{
                                return fmt.Errorf("database: could not parse boolean array index %d: invalid boolean %q", i, v)
                        }</span>
                        <span class="cov0" title="0">switch v[0] </span>{
                        case 't':<span class="cov0" title="0">
                                b[i] = true</span>
                        case 'f':<span class="cov0" title="0">
                                b[i] = false</span>
                        default:<span class="cov0" title="0">
                                return fmt.Errorf("database: could not parse boolean array index %d: invalid boolean %q", i, v)</span>
                        }
                }
                <span class="cov0" title="0">*a = b</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// Value implements the driver.Valuer interface.
func (a Bool) Value() (driver.Value, error) <span class="cov0" title="0">{
        if a == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">if n := len(a); n &gt; 0 </span><span class="cov0" title="0">{
                // There will be exactly two curly brackets, N bytes of values,
                // and N-1 bytes of delimiters.
                b := make([]byte, 1+2*n)

                for i := 0; i &lt; n; i++ </span><span class="cov0" title="0">{
                        b[2*i] = ','
                        if a[i] </span><span class="cov0" title="0">{
                                b[1+2*i] = 't'
                        }</span> else<span class="cov0" title="0"> {
                                b[1+2*i] = 'f'
                        }</span>
                }

                <span class="cov0" title="0">b[0] = '{'
                b[2*n] = '}'

                return string(b), nil</span>
        }

        <span class="cov0" title="0">return "{}", nil</span>
}

// Bytea represents a one-dimensional array of the PostgreSQL bytea type.
type Bytea [][]byte

// Scan implements the sql.Scanner interface.
func (a *Bytea) Scan(src any) error <span class="cov0" title="0">{
        switch src := src.(type) </span>{
        case []byte:<span class="cov0" title="0">
                return a.scanBytes(src)</span>
        case string:<span class="cov0" title="0">
                return a.scanBytes([]byte(src))</span>
        case nil:<span class="cov0" title="0">
                *a = nil
                return nil</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("database: cannot convert %T to Bytea", src)</span>
}

func (a *Bytea) scanBytes(src []byte) error <span class="cov0" title="0">{
        elems, err := scanLinearArray(src, []byte{','}, "Bytea")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if *a != nil &amp;&amp; len(elems) == 0 </span><span class="cov0" title="0">{
                *a = (*a)[:0]
        }</span> else<span class="cov0" title="0"> {
                b := make(Bytea, len(elems))
                for i, v := range elems </span><span class="cov0" title="0">{
                        b[i], err = parseBytea(v)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("could not parse bytea array index %d: %s", i, err.Error())
                        }</span>
                }
                <span class="cov0" title="0">*a = b</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// Value implements the driver.Valuer interface. It uses the "hex" format which
// is only supported on PostgreSQL 9.0 or newer.
func (a Bytea) Value() (driver.Value, error) <span class="cov0" title="0">{
        if a == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">if n := len(a); n &gt; 0 </span><span class="cov0" title="0">{
                // There will be at least two curly brackets, 2*N bytes of quotes,
                // 3*N bytes of hex formatting, and N-1 bytes of delimiters.
                size := 1 + 6*n
                for _, x := range a </span><span class="cov0" title="0">{
                        size += hex.EncodedLen(len(x))
                }</span>

                <span class="cov0" title="0">b := make([]byte, size)

                for i, s := 0, b; i &lt; n; i++ </span><span class="cov0" title="0">{
                        o := copy(s, `,"\\x`)
                        o += hex.Encode(s[o:], a[i])
                        s[o] = '"'
                        s = s[o+1:]
                }</span>

                <span class="cov0" title="0">b[0] = '{'
                b[size-1] = '}'

                return string(b), nil</span>
        }

        <span class="cov0" title="0">return "{}", nil</span>
}

// Float64 represents a one-dimensional array of the PostgreSQL double
// precision type.
type Float64 []float64

// Scan implements the sql.Scanner interface.
func (a *Float64) Scan(src any) error <span class="cov0" title="0">{
        switch src := src.(type) </span>{
        case []byte:<span class="cov0" title="0">
                return a.scanBytes(src)</span>
        case string:<span class="cov0" title="0">
                return a.scanBytes([]byte(src))</span>
        case nil:<span class="cov0" title="0">
                *a = nil
                return nil</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("database: cannot convert %T to Float64", src)</span>
}

func (a *Float64) scanBytes(src []byte) error <span class="cov0" title="0">{
        elems, err := scanLinearArray(src, []byte{','}, "Float64")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if *a != nil &amp;&amp; len(elems) == 0 </span><span class="cov0" title="0">{
                *a = (*a)[:0]
        }</span> else<span class="cov0" title="0"> {
                b := make(Float64, len(elems))
                for i, v := range elems </span><span class="cov0" title="0">{
                        if b[i], err = strconv.ParseFloat(string(v), 64); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("database: parsing array element index %d: %v", i, err)
                        }</span>
                }
                <span class="cov0" title="0">*a = b</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// Value implements the driver.Valuer interface.
func (a Float64) Value() (driver.Value, error) <span class="cov0" title="0">{
        if a == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">if n := len(a); n &gt; 0 </span><span class="cov0" title="0">{
                // There will be at least two curly brackets, N bytes of values,
                // and N-1 bytes of delimiters.
                b := make([]byte, 1, 1+2*n)
                b[0] = '{'

                b = strconv.AppendFloat(b, a[0], 'f', -1, 64)
                for i := 1; i &lt; n; i++ </span><span class="cov0" title="0">{
                        b = append(b, ',')
                        b = strconv.AppendFloat(b, a[i], 'f', -1, 64)
                }</span>

                <span class="cov0" title="0">return string(append(b, '}')), nil</span>
        }

        <span class="cov0" title="0">return "{}", nil</span>
}

// Float32 represents a one-dimensional array of the PostgreSQL double
// precision type.
type Float32 []float32

// Scan implements the sql.Scanner interface.
func (a *Float32) Scan(src any) error <span class="cov0" title="0">{
        switch src := src.(type) </span>{
        case []byte:<span class="cov0" title="0">
                return a.scanBytes(src)</span>
        case string:<span class="cov0" title="0">
                return a.scanBytes([]byte(src))</span>
        case nil:<span class="cov0" title="0">
                *a = nil
                return nil</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("database: cannot convert %T to Float32", src)</span>
}

func (a *Float32) scanBytes(src []byte) error <span class="cov0" title="0">{
        elems, err := scanLinearArray(src, []byte{','}, "Float32")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if *a != nil &amp;&amp; len(elems) == 0 </span><span class="cov0" title="0">{
                *a = (*a)[:0]
        }</span> else<span class="cov0" title="0"> {
                b := make(Float32, len(elems))
                for i, v := range elems </span><span class="cov0" title="0">{
                        var x float64
                        if x, err = strconv.ParseFloat(string(v), 32); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("database: parsing array element index %d: %v", i, err)
                        }</span>
                        <span class="cov0" title="0">b[i] = float32(x)</span>
                }
                <span class="cov0" title="0">*a = b</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// Value implements the driver.Valuer interface.
func (a Float32) Value() (driver.Value, error) <span class="cov0" title="0">{
        if a == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">if n := len(a); n &gt; 0 </span><span class="cov0" title="0">{
                // There will be at least two curly brackets, N bytes of values,
                // and N-1 bytes of delimiters.
                b := make([]byte, 1, 1+2*n)
                b[0] = '{'

                b = strconv.AppendFloat(b, float64(a[0]), 'f', -1, 32)
                for i := 1; i &lt; n; i++ </span><span class="cov0" title="0">{
                        b = append(b, ',')
                        b = strconv.AppendFloat(b, float64(a[i]), 'f', -1, 32)
                }</span>

                <span class="cov0" title="0">return string(append(b, '}')), nil</span>
        }

        <span class="cov0" title="0">return "{}", nil</span>
}

// Generic implements the driver.Valuer and sql.Scanner interfaces for
// an array or slice of any dimension.
type Generic struct{ A any }

func (Generic) evaluateDestination(rt reflect.Type) (reflect.Type, func([]byte, reflect.Value) error, string) <span class="cov0" title="0">{
        var assign func([]byte, reflect.Value) error
        var del = ","

        // TODO calculate the assign function for other types
        // TODO repeat this section on the element type of arrays or slices (multidimensional)
        </span><span class="cov0" title="0">{
                if reflect.PointerTo(rt).Implements(typeSQLScanner) </span><span class="cov0" title="0">{
                        // dest is always addressable because it is an element of a slice.
                        assign = func(src []byte, dest reflect.Value) (err error) </span><span class="cov0" title="0">{
                                ss := dest.Addr().Interface().(sql.Scanner)
                                if src == nil </span><span class="cov0" title="0">{
                                        err = ss.Scan(nil)
                                }</span> else<span class="cov0" title="0"> {
                                        err = ss.Scan(src)
                                }</span>
                                <span class="cov0" title="0">return</span>
                        }
                        <span class="cov0" title="0">goto FoundType</span>
                }

                <span class="cov0" title="0">assign = func([]byte, reflect.Value) error </span><span class="cov0" title="0">{
                        return fmt.Errorf("database: scanning to %s is not implemented; only sql.Scanner", rt)
                }</span>
        }

FoundType:

        <span class="cov0" title="0">if ad, ok := reflect.Zero(rt).Interface().(Delimiter); ok </span><span class="cov0" title="0">{
                del = ad.Delimiter()
        }</span>

        <span class="cov0" title="0">return rt, assign, del</span>
}

// Scan implements the sql.Scanner interface.
func (a Generic) Scan(src any) error <span class="cov0" title="0">{
        dpv := reflect.ValueOf(a.A)
        switch </span>{
        case dpv.Kind() != reflect.Ptr:<span class="cov0" title="0">
                return fmt.Errorf("database: destination %T is not a pointer to array or slice", a.A)</span>
        case dpv.IsNil():<span class="cov0" title="0">
                return fmt.Errorf("database: destination %T is nil", a.A)</span>
        }

        <span class="cov0" title="0">dv := dpv.Elem()
        switch dv.Kind() </span>{
        case reflect.Slice:<span class="cov0" title="0"></span>
        case reflect.Array:<span class="cov0" title="0"></span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("database: destination %T is not a pointer to array or slice", a.A)</span>
        }

        <span class="cov0" title="0">switch src := src.(type) </span>{
        case []byte:<span class="cov0" title="0">
                return a.scanBytes(src, dv)</span>
        case string:<span class="cov0" title="0">
                return a.scanBytes([]byte(src), dv)</span>
        case nil:<span class="cov0" title="0">
                if dv.Kind() == reflect.Slice </span><span class="cov0" title="0">{
                        dv.Set(reflect.Zero(dv.Type()))
                        return nil
                }</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("database: cannot convert %T to %s", src, dv.Type())</span>
}

func (a Generic) scanBytes(src []byte, dv reflect.Value) error <span class="cov0" title="0">{
        dtype, assign, del := a.evaluateDestination(dv.Type().Elem())
        dims, elems, err := parseArray(src, []byte(del))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // TODO allow multidimensional

        <span class="cov0" title="0">if len(dims) &gt; 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("database: scanning from multidimensional ARRAY%s is not implemented",
                        strings.Replace(fmt.Sprint(dims), " ", "][", -1))
        }</span>

        // Treat a zero-dimensional array like an array with a single dimension of zero.
        <span class="cov0" title="0">if len(dims) == 0 </span><span class="cov0" title="0">{
                dims = append(dims, 0)
        }</span>

        <span class="cov0" title="0">for i, rt := 0, dv.Type(); i &lt; len(dims); i, rt = i+1, rt.Elem() </span><span class="cov0" title="0">{
                switch rt.Kind() </span>{
                case reflect.Slice:<span class="cov0" title="0"></span>
                case reflect.Array:<span class="cov0" title="0">
                        if rt.Len() != dims[i] </span><span class="cov0" title="0">{
                                return fmt.Errorf("database: cannot convert ARRAY%s to %s",
                                        strings.Replace(fmt.Sprint(dims), " ", "][", -1), dv.Type())
                        }</span>
                default:<span class="cov0" title="0"></span>
                        // TODO handle multidimensional
                }
        }

        <span class="cov0" title="0">values := reflect.MakeSlice(reflect.SliceOf(dtype), len(elems), len(elems))
        for i, e := range elems </span><span class="cov0" title="0">{
                if err := assign(e, values.Index(i)); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("database: parsing array element index %d: %v", i, err)
                }</span>
        }

        // TODO handle multidimensional

        <span class="cov0" title="0">switch dv.Kind() </span>{
        case reflect.Slice:<span class="cov0" title="0">
                dv.Set(values.Slice(0, dims[0]))</span>
        case reflect.Array:<span class="cov0" title="0">
                for i := 0; i &lt; dims[0]; i++ </span><span class="cov0" title="0">{
                        dv.Index(i).Set(values.Index(i))
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Value implements the driver.Valuer interface.
func (a Generic) Value() (driver.Value, error) <span class="cov0" title="0">{
        if a.A == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">rv := reflect.ValueOf(a.A)

        switch rv.Kind() </span>{
        case reflect.Slice:<span class="cov0" title="0">
                if rv.IsNil() </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
        case reflect.Array:<span class="cov0" title="0"></span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("database: Unable to convert %T to array", a.A)</span>
        }

        <span class="cov0" title="0">if n := rv.Len(); n &gt; 0 </span><span class="cov0" title="0">{
                // There will be at least two curly brackets, N bytes of values,
                // and N-1 bytes of delimiters.
                b := make([]byte, 0, 1+2*n)

                b, _, err := appendArray(b, rv, n)
                return string(b), err
        }</span>

        <span class="cov0" title="0">return "{}", nil</span>
}

// Int64 represents a one-dimensional array of the PostgreSQL integer types.
type Int64 []int64

// Scan implements the sql.Scanner interface.
func (a *Int64) Scan(src any) error <span class="cov0" title="0">{
        switch src := src.(type) </span>{
        case []byte:<span class="cov0" title="0">
                return a.scanBytes(src)</span>
        case string:<span class="cov0" title="0">
                return a.scanBytes([]byte(src))</span>
        case nil:<span class="cov0" title="0">
                *a = nil
                return nil</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("database: cannot convert %T to Int64", src)</span>
}

func (a *Int64) scanBytes(src []byte) error <span class="cov0" title="0">{
        elems, err := scanLinearArray(src, []byte{','}, "Int64")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if *a != nil &amp;&amp; len(elems) == 0 </span><span class="cov0" title="0">{
                *a = (*a)[:0]
        }</span> else<span class="cov0" title="0"> {
                b := make(Int64, len(elems))
                for i, v := range elems </span><span class="cov0" title="0">{
                        if b[i], err = strconv.ParseInt(string(v), 10, 64); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("database: parsing array element index %d: %v", i, err)
                        }</span>
                }
                <span class="cov0" title="0">*a = b</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// Value implements the driver.Valuer interface.
func (a Int64) Value() (driver.Value, error) <span class="cov0" title="0">{
        if a == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">if n := len(a); n &gt; 0 </span><span class="cov0" title="0">{
                // There will be at least two curly brackets, N bytes of values,
                // and N-1 bytes of delimiters.
                b := make([]byte, 1, 1+2*n)
                b[0] = '{'

                b = strconv.AppendInt(b, a[0], 10)
                for i := 1; i &lt; n; i++ </span><span class="cov0" title="0">{
                        b = append(b, ',')
                        b = strconv.AppendInt(b, a[i], 10)
                }</span>

                <span class="cov0" title="0">return string(append(b, '}')), nil</span>
        }

        <span class="cov0" title="0">return "{}", nil</span>
}

// Int32 represents a one-dimensional array of the PostgreSQL integer types.
type Int32 []int32

// Scan implements the sql.Scanner interface.
func (a *Int32) Scan(src any) error <span class="cov0" title="0">{
        switch src := src.(type) </span>{
        case []byte:<span class="cov0" title="0">
                return a.scanBytes(src)</span>
        case string:<span class="cov0" title="0">
                return a.scanBytes([]byte(src))</span>
        case nil:<span class="cov0" title="0">
                *a = nil
                return nil</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("database: cannot convert %T to Int32", src)</span>
}

func (a *Int32) scanBytes(src []byte) error <span class="cov0" title="0">{
        elems, err := scanLinearArray(src, []byte{','}, "Int32")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if *a != nil &amp;&amp; len(elems) == 0 </span><span class="cov0" title="0">{
                *a = (*a)[:0]
        }</span> else<span class="cov0" title="0"> {
                b := make(Int32, len(elems))
                for i, v := range elems </span><span class="cov0" title="0">{
                        x, err := strconv.ParseInt(string(v), 10, 32)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("database: parsing array element index %d: %v", i, err)
                        }</span>
                        <span class="cov0" title="0">b[i] = int32(x)</span>
                }
                <span class="cov0" title="0">*a = b</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// Value implements the driver.Valuer interface.
func (a Int32) Value() (driver.Value, error) <span class="cov0" title="0">{
        if a == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">if n := len(a); n &gt; 0 </span><span class="cov0" title="0">{
                // There will be at least two curly brackets, N bytes of values,
                // and N-1 bytes of delimiters.
                b := make([]byte, 1, 1+2*n)
                b[0] = '{'

                b = strconv.AppendInt(b, int64(a[0]), 10)
                for i := 1; i &lt; n; i++ </span><span class="cov0" title="0">{
                        b = append(b, ',')
                        b = strconv.AppendInt(b, int64(a[i]), 10)
                }</span>

                <span class="cov0" title="0">return string(append(b, '}')), nil</span>
        }

        <span class="cov0" title="0">return "{}", nil</span>
}

// String represents a one-dimensional array of the PostgreSQL character types.
type String []string

// Scan implements the sql.Scanner interface.
func (a *String) Scan(src any) error <span class="cov0" title="0">{
        switch src := src.(type) </span>{
        case []byte:<span class="cov0" title="0">
                return a.scanBytes(src)</span>
        case string:<span class="cov0" title="0">
                return a.scanBytes([]byte(src))</span>
        case nil:<span class="cov0" title="0">
                *a = nil
                return nil</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("database: cannot convert %T to String", src)</span>
}

func (a *String) scanBytes(src []byte) error <span class="cov0" title="0">{
        elems, err := scanLinearArray(src, []byte{','}, "String")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if *a != nil &amp;&amp; len(elems) == 0 </span><span class="cov0" title="0">{
                *a = (*a)[:0]
        }</span> else<span class="cov0" title="0"> {
                b := make(String, len(elems))
                for i, v := range elems </span><span class="cov0" title="0">{
                        if b[i] = string(v); v == nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("database: parsing array element index %d: cannot convert nil to string", i)
                        }</span>
                }
                <span class="cov0" title="0">*a = b</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// Value implements the driver.Valuer interface.
func (a String) Value() (driver.Value, error) <span class="cov0" title="0">{
        if a == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">if n := len(a); n &gt; 0 </span><span class="cov0" title="0">{
                // There will be at least two curly brackets, 2*N bytes of quotes,
                // and N-1 bytes of delimiters.
                b := make([]byte, 1, 1+3*n)
                b[0] = '{'

                b = appendArrayQuotedBytes(b, []byte(a[0]))
                for i := 1; i &lt; n; i++ </span><span class="cov0" title="0">{
                        b = append(b, ',')
                        b = appendArrayQuotedBytes(b, []byte(a[i]))
                }</span>

                <span class="cov0" title="0">return string(append(b, '}')), nil</span>
        }

        <span class="cov0" title="0">return "{}", nil</span>
}

// appendArray appends rv to the buffer, returning the extended buffer and
// the delimiter used between elements.
//
// It panics when n &lt;= 0 or rv's Kind is not reflect.Array nor reflect.Slice.
func appendArray(b []byte, rv reflect.Value, n int) ([]byte, string, error) <span class="cov0" title="0">{
        var del string
        var err error

        b = append(b, '{')

        if b, del, err = appendArrayElement(b, rv.Index(0)); err != nil </span><span class="cov0" title="0">{
                return b, del, err
        }</span>

        <span class="cov0" title="0">for i := 1; i &lt; n; i++ </span><span class="cov0" title="0">{
                b = append(b, del...)
                if b, del, err = appendArrayElement(b, rv.Index(i)); err != nil </span><span class="cov0" title="0">{
                        return b, del, err
                }</span>
        }

        <span class="cov0" title="0">return append(b, '}'), del, nil</span>
}

// appendArrayElement appends rv to the buffer, returning the extended buffer
// and the delimiter to use before the next element.
//
// When rv's Kind is neither reflect.Array nor reflect.Slice, it is converted
// using driver.DefaultParameterConverter and the resulting []byte or string
// is double-quoted.
//
// See http://www.postgresql.org/docs/current/static/arrays.html#ARRAYS-IO
func appendArrayElement(b []byte, rv reflect.Value) ([]byte, string, error) <span class="cov0" title="0">{
        if k := rv.Kind(); k == reflect.Array || k == reflect.Slice </span><span class="cov0" title="0">{
                if t := rv.Type(); t != typeByteSlice &amp;&amp; !t.Implements(typeDriverValuer) </span><span class="cov0" title="0">{
                        if n := rv.Len(); n &gt; 0 </span><span class="cov0" title="0">{
                                return appendArray(b, rv, n)
                        }</span>

                        <span class="cov0" title="0">return b, "", nil</span>
                }
        }

        <span class="cov0" title="0">var del = ","
        var err error
        var iv = rv.Interface()

        if ad, ok := iv.(Delimiter); ok </span><span class="cov0" title="0">{
                del = ad.Delimiter()
        }</span>

        <span class="cov0" title="0">if iv, err = driver.DefaultParameterConverter.ConvertValue(iv); err != nil </span><span class="cov0" title="0">{
                return b, del, err
        }</span>

        <span class="cov0" title="0">switch v := iv.(type) </span>{
        case nil:<span class="cov0" title="0">
                return append(b, "NULL"...), del, nil</span>
        case []byte:<span class="cov0" title="0">
                return appendArrayQuotedBytes(b, v), del, nil</span>
        case string:<span class="cov0" title="0">
                return appendArrayQuotedBytes(b, []byte(v)), del, nil</span>
        }

        <span class="cov0" title="0">b, err = appendValue(b, iv)
        return b, del, err</span>
}

func appendArrayQuotedBytes(b, v []byte) []byte <span class="cov0" title="0">{
        b = append(b, '"')
        for </span><span class="cov0" title="0">{
                i := bytes.IndexAny(v, `"\`)
                if i &lt; 0 </span><span class="cov0" title="0">{
                        b = append(b, v...)
                        break</span>
                }
                <span class="cov0" title="0">if i &gt; 0 </span><span class="cov0" title="0">{
                        b = append(b, v[:i]...)
                }</span>
                <span class="cov0" title="0">b = append(b, '\\', v[i])
                v = v[i+1:]</span>
        }
        <span class="cov0" title="0">return append(b, '"')</span>
}

func appendValue(b []byte, v driver.Value) ([]byte, error) <span class="cov0" title="0">{
        return append(b, encode(nil, v, 0)...), nil
}</span>

// parseArray extracts the dimensions and elements of an array represented in
// text format. Only representations emitted by the backend are supported.
// Notably, whitespace around brackets and delimiters is significant, and NULL
// is case-sensitive.
//
// See http://www.postgresql.org/docs/current/static/arrays.html#ARRAYS-IO
func parseArray(src, del []byte) (dims []int, elems [][]byte, err error) <span class="cov0" title="0">{
        var depth, i int

        if len(src) &lt; 1 || src[0] != '{' </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("database: unable to parse array; expected %q at offset %d", '{', 0)
        }</span>

<span class="cov0" title="0">Open:
        for i &lt; len(src) </span><span class="cov0" title="0">{
                switch src[i] </span>{
                case '{':<span class="cov0" title="0">
                        depth++
                        i++</span>
                case '}':<span class="cov0" title="0">
                        elems = make([][]byte, 0)
                        goto Close</span>
                default:<span class="cov0" title="0">
                        break Open</span>
                }
        }
        <span class="cov0" title="0">dims = make([]int, i)

Element:
        for i &lt; len(src) </span><span class="cov0" title="0">{
                switch src[i] </span>{
                case '{':<span class="cov0" title="0">
                        if depth == len(dims) </span><span class="cov0" title="0">{
                                break Element</span>
                        }
                        <span class="cov0" title="0">depth++
                        dims[depth-1] = 0
                        i++</span>
                case '"':<span class="cov0" title="0">
                        var elem = []byte{}
                        var escape bool
                        for i++; i &lt; len(src); i++ </span><span class="cov0" title="0">{
                                if escape </span><span class="cov0" title="0">{
                                        elem = append(elem, src[i])
                                        escape = false
                                }</span> else<span class="cov0" title="0"> {
                                        switch src[i] </span>{
                                        default:<span class="cov0" title="0">
                                                elem = append(elem, src[i])</span>
                                        case '\\':<span class="cov0" title="0">
                                                escape = true</span>
                                        case '"':<span class="cov0" title="0">
                                                elems = append(elems, elem)
                                                i++
                                                break Element</span>
                                        }
                                }
                        }
                default:<span class="cov0" title="0">
                        for start := i; i &lt; len(src); i++ </span><span class="cov0" title="0">{
                                if bytes.HasPrefix(src[i:], del) || src[i] == '}' </span><span class="cov0" title="0">{
                                        elem := src[start:i]
                                        if len(elem) == 0 </span><span class="cov0" title="0">{
                                                return nil, nil, fmt.Errorf("database: unable to parse array; unexpected %q at offset %d", src[i], i)
                                        }</span>
                                        <span class="cov0" title="0">if bytes.Equal(elem, []byte("NULL")) </span><span class="cov0" title="0">{
                                                elem = nil
                                        }</span>
                                        <span class="cov0" title="0">elems = append(elems, elem)
                                        break Element</span>
                                }
                        }
                }
        }

        <span class="cov0" title="0">for i &lt; len(src) </span><span class="cov0" title="0">{
                if bytes.HasPrefix(src[i:], del) &amp;&amp; depth &gt; 0 </span><span class="cov0" title="0">{
                        dims[depth-1]++
                        i += len(del)
                        goto Element</span>
                } else<span class="cov0" title="0"> if src[i] == '}' &amp;&amp; depth &gt; 0 </span><span class="cov0" title="0">{
                        dims[depth-1]++
                        depth--
                        i++
                }</span> else<span class="cov0" title="0"> {
                        return nil, nil, fmt.Errorf("database: unable to parse array; unexpected %q at offset %d", src[i], i)
                }</span>
        }

<span class="cov0" title="0">Close:
        for i &lt; len(src) </span><span class="cov0" title="0">{
                if src[i] == '}' &amp;&amp; depth &gt; 0 </span><span class="cov0" title="0">{
                        depth--
                        i++
                }</span> else<span class="cov0" title="0"> {
                        return nil, nil, fmt.Errorf("database: unable to parse array; unexpected %q at offset %d", src[i], i)
                }</span>
        }
        <span class="cov0" title="0">if depth &gt; 0 </span><span class="cov0" title="0">{
                err = fmt.Errorf("database: unable to parse array; expected %q at offset %d", '}', i)
        }</span>
        <span class="cov0" title="0">if err == nil </span><span class="cov0" title="0">{
                for _, d := range dims </span><span class="cov0" title="0">{
                        if (len(elems) % d) != 0 </span><span class="cov0" title="0">{
                                err = fmt.Errorf("database: multidimensional arrays must have elements with matching dimensions")
                        }</span>
                }
        }
        <span class="cov0" title="0">return</span>
}

func scanLinearArray(src, del []byte, typ string) (elems [][]byte, err error) <span class="cov0" title="0">{
        dims, elems, err := parseArray(src, del)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(dims) &gt; 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("database: cannot convert ARRAY%s to %s", strings.Replace(fmt.Sprint(dims), " ", "][", -1), typ)
        }</span>
        <span class="cov0" title="0">return elems, err</span>
}
</pre>
		
		<pre class="file" id="file98" style="display: none">/*
Code taken from https://github.com/lib/pq

Copyright (c) 2011-2013, 'pq' Contributors Portions Copyright (C) 2011 Blake Mizerany

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
Software, and to permit persons to whom the Software is furnished to do so, subject
to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

package dbarray

import (
        "bytes"
        "encoding/hex"
        "fmt"
        "strconv"
        "time"
)

const (
        infinityTSEnabledAlready        = "database: infinity timestamp enabled already"
        infinityTSNegativeMustBeSmaller = "database: infinity timestamp: negative value must be smaller (before) than positive"
)

var infinityTSEnabled = false
var infinityTSNegative time.Time
var infinityTSPositive time.Time

type parameterStatus struct {
        // server version in the same format as server_version_num, or 0 if unavailable.
        serverVersion int
}

// EnableInfinityTS controls the handling of Postgres' "-infinity" and
// "infinity" "timestamp"s.
//
// If EnableInfinityTS is not called, "-infinity" and "infinity" will return
// []byte("-infinity") and []byte("infinity") respectively, and potentially
// cause error "sql: Scan error on column index 0: unsupported driver -&gt; Scan
// pair: []uint8 -&gt; *time.Time", when scanning into a time.Time value.
//
// Once EnableInfinityTS has been called, all connections created using this
// driver will decode Postgres' "-infinity" and "infinity" for "timestamp",
// "timestamp with time zone" and "date" types to the predefined minimum and
// maximum times, respectively.  When encoding time.Time values, any time which
// equals or precedes the predefined minimum time will be encoded to
// "-infinity".  Any values at or past the maximum time will similarly be
// encoded to "infinity".
//
// If EnableInfinityTS is called with negative &gt;= positive, it will panic.
// Calling EnableInfinityTS after a connection has been established results in
// undefined behavior.  If EnableInfinityTS is called more than once, it will
// panic.
func EnableInfinityTS(negative time.Time, positive time.Time) <span class="cov0" title="0">{
        if infinityTSEnabled </span><span class="cov0" title="0">{
                panic(infinityTSEnabledAlready)</span>
        }
        <span class="cov0" title="0">if !negative.Before(positive) </span><span class="cov0" title="0">{
                panic(infinityTSNegativeMustBeSmaller)</span>
        }
        <span class="cov0" title="0">infinityTSEnabled = true
        infinityTSNegative = negative
        infinityTSPositive = positive</span>
}

func encode(parameterStatus *parameterStatus, x any, oid int) []byte <span class="cov0" title="0">{
        const oidBytea = 17

        switch v := x.(type) </span>{
        case int64:<span class="cov0" title="0">
                return strconv.AppendInt(nil, v, 10)</span>
        case float64:<span class="cov0" title="0">
                return strconv.AppendFloat(nil, v, 'f', -1, 64)</span>
        case []byte:<span class="cov0" title="0">
                if oid == oidBytea </span><span class="cov0" title="0">{
                        return encodeBytea(parameterStatus.serverVersion, v)
                }</span>

                <span class="cov0" title="0">return v</span>
        case string:<span class="cov0" title="0">
                if oid == oidBytea </span><span class="cov0" title="0">{
                        return encodeBytea(parameterStatus.serverVersion, []byte(v))
                }</span>

                <span class="cov0" title="0">return []byte(v)</span>
        case bool:<span class="cov0" title="0">
                return strconv.AppendBool(nil, v)</span>
        case time.Time:<span class="cov0" title="0">
                return formatTS(v)</span>

        default:<span class="cov0" title="0">
                errorf("encode: unknown type for %T", v)</span>
        }

        <span class="cov0" title="0">panic("not reached")</span>
}

// formatTS formats t into a format postgres understands.
func formatTS(t time.Time) []byte <span class="cov0" title="0">{
        if infinityTSEnabled </span><span class="cov0" title="0">{
                // t &lt;= -infinity : ! (t &gt; -infinity)
                if !t.After(infinityTSNegative) </span><span class="cov0" title="0">{
                        return []byte("-infinity")
                }</span>
                // t &gt;= infinity : ! (!t &lt; infinity)
                <span class="cov0" title="0">if !t.Before(infinityTSPositive) </span><span class="cov0" title="0">{
                        return []byte("infinity")
                }</span>
        }
        <span class="cov0" title="0">return formatTimestamp(t)</span>
}

// formatTimestamp formats t into Postgres' text format for timestamps.
func formatTimestamp(t time.Time) []byte <span class="cov0" title="0">{
        // Need to send dates before 0001 A.D. with " BC" suffix, instead of the
        // minus sign preferred by Go.
        // Beware, "0000" in ISO is "1 BC", "-0001" is "2 BC" and so on
        bc := false
        if t.Year() &lt;= 0 </span><span class="cov0" title="0">{
                // flip year sign, and add 1, e.g: "0" will be "1", and "-10" will be "11"
                t = t.AddDate((-t.Year())*2+1, 0, 0)
                bc = true
        }</span>
        <span class="cov0" title="0">b := []byte(t.Format("2006-01-02 15:04:05.999999999Z07:00"))

        _, offset := t.Zone()
        offset %= 60
        if offset != 0 </span><span class="cov0" title="0">{
                // RFC3339Nano already printed the minus sign
                if offset &lt; 0 </span><span class="cov0" title="0">{
                        offset = -offset
                }</span>

                <span class="cov0" title="0">b = append(b, ':')
                if offset &lt; 10 </span><span class="cov0" title="0">{
                        b = append(b, '0')
                }</span>
                <span class="cov0" title="0">b = strconv.AppendInt(b, int64(offset), 10)</span>
        }

        <span class="cov0" title="0">if bc </span><span class="cov0" title="0">{
                b = append(b, " BC"...)
        }</span>
        <span class="cov0" title="0">return b</span>
}

func errorf(s string, args ...any) <span class="cov0" title="0">{
        panic(fmt.Errorf("pq: %s", fmt.Sprintf(s, args...)))</span>
}

// Parse a bytea value received from the server.  Both "hex" and the legacy
// "escape" format are supported.
func parseBytea(s []byte) (result []byte, err error) <span class="cov0" title="0">{
        if len(s) &gt;= 2 &amp;&amp; bytes.Equal(s[:2], []byte("\\x")) </span><span class="cov0" title="0">{
                // bytea_output = hex
                s = s[2:] // trim off leading "\\x"
                result = make([]byte, hex.DecodedLen(len(s)))
                _, err := hex.Decode(result, s)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        } else<span class="cov0" title="0"> {
                // bytea_output = escape
                for len(s) &gt; 0 </span><span class="cov0" title="0">{
                        if s[0] == '\\' </span><span class="cov0" title="0">{
                                // escaped '\\'
                                if len(s) &gt;= 2 &amp;&amp; s[1] == '\\' </span><span class="cov0" title="0">{
                                        result = append(result, '\\')
                                        s = s[2:]
                                        continue</span>
                                }

                                // '\\' followed by an octal number
                                <span class="cov0" title="0">if len(s) &lt; 4 </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("invalid bytea sequence %v", s)
                                }</span>
                                <span class="cov0" title="0">r, err := strconv.ParseUint(string(s[1:4]), 8, 8)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("could not parse bytea value: %s", err.Error())
                                }</span>
                                <span class="cov0" title="0">result = append(result, byte(r))
                                s = s[4:]</span>
                        } else<span class="cov0" title="0"> {
                                // We hit an unescaped, raw byte.  Try to read in as many as
                                // possible in one go.
                                i := bytes.IndexByte(s, '\\')
                                if i == -1 </span><span class="cov0" title="0">{
                                        result = append(result, s...)
                                        break</span>
                                }
                                <span class="cov0" title="0">result = append(result, s[:i]...)
                                s = s[i:]</span>
                        }
                }
        }

        <span class="cov0" title="0">return result, nil</span>
}

func encodeBytea(serverVersion int, v []byte) (result []byte) <span class="cov0" title="0">{
        if serverVersion &gt;= 90000 </span><span class="cov0" title="0">{
                // Use the hex format if we know that the server supports it
                result = make([]byte, 2+hex.EncodedLen(len(v)))
                result[0] = '\\'
                result[1] = 'x'
                hex.Encode(result[2:], v)
        }</span> else<span class="cov0" title="0"> {
                // .. or resort to "escape"
                for _, b := range v </span><span class="cov0" title="0">{
                        if b == '\\' </span><span class="cov0" title="0">{
                                result = append(result, '\\', '\\')
                        }</span> else<span class="cov0" title="0"> if b &lt; 0x20 || b &gt; 0x7e </span><span class="cov0" title="0">{
                                result = append(result, []byte(fmt.Sprintf("\\%03o", b))...)
                        }</span> else<span class="cov0" title="0"> {
                                result = append(result, b)
                        }</span>
                }
        }

        <span class="cov0" title="0">return result</span>
}
</pre>
		
		<pre class="file" id="file99" style="display: none">// Package sqldb provides support for access the database.
package sqldb

import (
        "context"
        "database/sql"
        "errors"
        "fmt"
        "net/url"
        "strings"
        "time"

        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/jackc/pgx/v5/pgconn"
        _ "github.com/jackc/pgx/v5/stdlib"
        "github.com/jmoiron/sqlx"
)

// lib/pq errorCodeNames
// https://github.com/lib/pq/blob/master/error.go#L178
const (
        uniqueViolation = "23505"
        undefinedTable  = "42P01"
)

// Set of error variables for CRUD operations.
var (
        ErrDBNotFound        = sql.ErrNoRows
        ErrDBDuplicatedEntry = errors.New("duplicated entry")
        ErrUndefinedTable    = errors.New("undefined table")
)

// Config is the required properties to use the database.
type Config struct {
        User         string
        Password     string
        Host         string
        Name         string
        Schema       string
        MaxIdleConns int
        MaxOpenConns int
        DisableTLS   bool
}

// Open knows how to open a database connection based on the configuration.
func Open(cfg Config) (*sqlx.DB, error) <span class="cov0" title="0">{
        sslMode := "require"
        if cfg.DisableTLS </span><span class="cov0" title="0">{
                sslMode = "disable"
        }</span>

        <span class="cov0" title="0">q := make(url.Values)
        q.Set("sslmode", sslMode)
        q.Set("timezone", "utc")
        if cfg.Schema != "" </span><span class="cov0" title="0">{
                q.Set("search_path", cfg.Schema)
        }</span>

        <span class="cov0" title="0">u := url.URL{
                Scheme:   "postgres",
                User:     url.UserPassword(cfg.User, cfg.Password),
                Host:     cfg.Host,
                Path:     cfg.Name,
                RawQuery: q.Encode(),
        }

        db, err := sqlx.Open("pgx", u.String())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">db.SetMaxIdleConns(cfg.MaxIdleConns)
        db.SetMaxOpenConns(cfg.MaxOpenConns)

        return db, nil</span>
}

// StatusCheck returns nil if it can successfully talk to the database. It
// returns a non-nil error otherwise.
func StatusCheck(ctx context.Context, db *sqlx.DB) error <span class="cov0" title="0">{

        // If the user doesn't give us a deadline set 1 second.
        if _, ok := ctx.Deadline(); !ok </span><span class="cov0" title="0">{
                var cancel context.CancelFunc
                ctx, cancel = context.WithTimeout(ctx, time.Second)
                defer cancel()
        }</span>

        <span class="cov0" title="0">for attempts := 1; ; attempts++ </span><span class="cov0" title="0">{
                if err := db.Ping(); err == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">time.Sleep(time.Duration(attempts) * 100 * time.Millisecond)

                if ctx.Err() != nil </span><span class="cov0" title="0">{
                        return ctx.Err()
                }</span>
        }

        <span class="cov0" title="0">if ctx.Err() != nil </span><span class="cov0" title="0">{
                return ctx.Err()
        }</span>

        // Run a simple query to determine connectivity.
        // Running this query forces a round trip through the database.
        <span class="cov0" title="0">const q = `SELECT TRUE`
        var tmp bool
        return db.QueryRowContext(ctx, q).Scan(&amp;tmp)</span>
}

// ExecContext is a helper function to execute a CUD operation with
// logging and tracing.
func ExecContext(ctx context.Context, log *logger.Logger, db sqlx.ExtContext, query string) error <span class="cov0" title="0">{
        return NamedExecContext(ctx, log, db, query, struct{}{})
}</span>

// NamedExecContext is a helper function to execute a CUD operation with
// logging and tracing where field replacement is necessary.
func NamedExecContext(ctx context.Context, log *logger.Logger, db sqlx.ExtContext, query string, data any) (err error) <span class="cov0" title="0">{
        q := queryString(query, data)

        defer func() </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        switch data.(type) </span>{
                        case struct{}:<span class="cov0" title="0">
                                log.Infoc(ctx, 6, "database.NamedExecContext", "query", q, "ERROR", err)</span>
                        default:<span class="cov0" title="0">
                                log.Infoc(ctx, 5, "database.NamedExecContext", "query", q, "ERROR", err)</span>
                        }
                }
        }()

        <span class="cov0" title="0">if _, err := sqlx.NamedExecContext(ctx, db, query, data); err != nil </span><span class="cov0" title="0">{
                var pqerr *pgconn.PgError
                if errors.As(err, &amp;pqerr) </span><span class="cov0" title="0">{
                        switch pqerr.Code </span>{
                        case undefinedTable:<span class="cov0" title="0">
                                return ErrUndefinedTable</span>
                        case uniqueViolation:<span class="cov0" title="0">
                                return ErrDBDuplicatedEntry</span>
                        }
                }
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// QuerySlice is a helper function for executing queries that return a
// collection of data to be unmarshalled into a slice.
func QuerySlice[T any](ctx context.Context, log *logger.Logger, db sqlx.ExtContext, query string, dest *[]T) error <span class="cov0" title="0">{
        return namedQuerySlice(ctx, log, db, query, struct{}{}, dest, false)
}</span>

// NamedQuerySlice is a helper function for executing queries that return a
// collection of data to be unmarshalled into a slice where field replacement is
// necessary.
func NamedQuerySlice[T any](ctx context.Context, log *logger.Logger, db sqlx.ExtContext, query string, data any, dest *[]T) error <span class="cov0" title="0">{
        return namedQuerySlice(ctx, log, db, query, data, dest, false)
}</span>

// NamedQuerySliceUsingIn is a helper function for executing queries that return
// a collection of data to be unmarshalled into a slice where field replacement
// is necessary. Use this if the query has an IN clause.
func NamedQuerySliceUsingIn[T any](ctx context.Context, log *logger.Logger, db sqlx.ExtContext, query string, data any, dest *[]T) error <span class="cov0" title="0">{
        return namedQuerySlice(ctx, log, db, query, data, dest, true)
}</span>

func namedQuerySlice[T any](ctx context.Context, log *logger.Logger, db sqlx.ExtContext, query string, data any, dest *[]T, withIn bool) (err error) <span class="cov0" title="0">{
        q := queryString(query, data)

        defer func() </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        log.Infoc(ctx, 6, "database.NamedQuerySlice", "query", q, "ERROR", err)
                }</span>
        }()

        <span class="cov0" title="0">var rows *sqlx.Rows

        switch withIn </span>{
        case true:<span class="cov0" title="0">
                rows, err = func() (*sqlx.Rows, error) </span><span class="cov0" title="0">{
                        named, args, err := sqlx.Named(query, data)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov0" title="0">query, args, err := sqlx.In(named, args...)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov0" title="0">query = db.Rebind(query)
                        return db.QueryxContext(ctx, query, args...)</span>
                }()

        default:<span class="cov0" title="0">
                rows, err = sqlx.NamedQueryContext(ctx, db, query, data)</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                var pqerr *pgconn.PgError
                if errors.As(err, &amp;pqerr) &amp;&amp; pqerr.Code == undefinedTable </span><span class="cov0" title="0">{
                        return ErrUndefinedTable
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov0" title="0">defer rows.Close()

        var slice []T
        for rows.Next() </span><span class="cov0" title="0">{
                v := new(T)
                if err := rows.StructScan(v); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">slice = append(slice, *v)</span>
        }
        <span class="cov0" title="0">*dest = slice

        return nil</span>
}

// QueryStruct is a helper function for executing queries that return a
// single value to be unmarshalled into a struct type where field replacement is necessary.
func QueryStruct(ctx context.Context, log *logger.Logger, db sqlx.ExtContext, query string, dest any) error <span class="cov0" title="0">{
        return namedQueryStruct(ctx, log, db, query, struct{}{}, dest, false)
}</span>

// NamedQueryStruct is a helper function for executing queries that return a
// single value to be unmarshalled into a struct type where field replacement is necessary.
func NamedQueryStruct(ctx context.Context, log *logger.Logger, db sqlx.ExtContext, query string, data any, dest any) error <span class="cov0" title="0">{
        return namedQueryStruct(ctx, log, db, query, data, dest, false)
}</span>

// NamedQueryStructUsingIn is a helper function for executing queries that return
// a single value to be unmarshalled into a struct type where field replacement
// is necessary. Use this if the query has an IN clause.
func NamedQueryStructUsingIn(ctx context.Context, log *logger.Logger, db sqlx.ExtContext, query string, data any, dest any) error <span class="cov0" title="0">{
        return namedQueryStruct(ctx, log, db, query, data, dest, true)
}</span>

func namedQueryStruct(ctx context.Context, log *logger.Logger, db sqlx.ExtContext, query string, data any, dest any, withIn bool) (err error) <span class="cov0" title="0">{
        q := queryString(query, data)

        defer func() </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        log.Infoc(ctx, 6, "database.NamedQuerySlice", "query", q, "ERROR", err)
                }</span>
        }()

        <span class="cov0" title="0">var rows *sqlx.Rows

        switch withIn </span>{
        case true:<span class="cov0" title="0">
                rows, err = func() (*sqlx.Rows, error) </span><span class="cov0" title="0">{
                        named, args, err := sqlx.Named(query, data)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov0" title="0">query, args, err := sqlx.In(named, args...)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov0" title="0">query = db.Rebind(query)
                        return db.QueryxContext(ctx, query, args...)</span>
                }()

        default:<span class="cov0" title="0">
                rows, err = sqlx.NamedQueryContext(ctx, db, query, data)</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                var pqerr *pgconn.PgError
                if errors.As(err, &amp;pqerr) &amp;&amp; pqerr.Code == undefinedTable </span><span class="cov0" title="0">{
                        return ErrUndefinedTable
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov0" title="0">defer rows.Close()

        if !rows.Next() </span><span class="cov0" title="0">{
                return ErrDBNotFound
        }</span>

        <span class="cov0" title="0">if err := rows.StructScan(dest); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// queryString provides a pretty print version of the query and parameters.
func queryString(query string, args any) string <span class="cov0" title="0">{
        query, params, err := sqlx.Named(query, args)
        if err != nil </span><span class="cov0" title="0">{
                return err.Error()
        }</span>

        <span class="cov0" title="0">for _, param := range params </span><span class="cov0" title="0">{
                var value string
                switch v := param.(type) </span>{
                case string:<span class="cov0" title="0">
                        value = fmt.Sprintf("'%s'", v)</span>
                case []byte:<span class="cov0" title="0">
                        value = fmt.Sprintf("'%s'", string(v))</span>
                default:<span class="cov0" title="0">
                        value = fmt.Sprintf("%v", v)</span>
                }
                <span class="cov0" title="0">query = strings.Replace(query, "?", value, 1)</span>
        }

        <span class="cov0" title="0">query = strings.ReplaceAll(query, "\t", "")
        query = strings.ReplaceAll(query, "\n", " ")

        return strings.Trim(query, " ")</span>
}
</pre>
		
		<pre class="file" id="file100" style="display: none">package sqldb

import (
        "fmt"

        "github.com/jmoiron/sqlx"
)

// Beginner represents a value that can begin a transaction.
type Beginner interface {
        Begin() (CommitRollbacker, error)
}

// CommitRollbacker represents a value that can commit or rollback a transaction.
type CommitRollbacker interface {
        Commit() error
        Rollback() error
}

// =============================================================================

// DBBeginner implements the Beginner interface,
type DBBeginner struct {
        sqlxDB *sqlx.DB
}

// NewBeginner constructs a value that implements the beginner interface.
func NewBeginner(sqlxDB *sqlx.DB) *DBBeginner <span class="cov0" title="0">{
        return &amp;DBBeginner{
                sqlxDB: sqlxDB,
        }
}</span>

// Begin implements the Beginner interface and returns a concrete value that
// implements the CommitRollbacker interface.
func (db *DBBeginner) Begin() (CommitRollbacker, error) <span class="cov0" title="0">{
        return db.sqlxDB.Beginx()
}</span>

// GetExtContext is a helper function that extracts the sqlx value
// from the domain transactor interface for transactional use.
func GetExtContext(tx CommitRollbacker) (sqlx.ExtContext, error) <span class="cov0" title="0">{
        ec, ok := tx.(sqlx.ExtContext)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Transactor(%T) not of a type *sql.Tx", tx)
        }</span>

        <span class="cov0" title="0">return ec, nil</span>
}
</pre>
		
		<pre class="file" id="file101" style="display: none">// Package unitest provides support for excuting unit test logic.
package unitest

import (
        "context"
        "testing"
)

// Run performs the actual test logic based on the table data.
func Run(t *testing.T, table []Table, testName string) <span class="cov0" title="0">{
        for _, tt := range table </span><span class="cov0" title="0">{
                f := func(t *testing.T) </span><span class="cov0" title="0">{
                        gotResp := tt.ExcFunc(context.Background())

                        diff := tt.CmpFunc(gotResp, tt.ExpResp)
                        if diff != "" </span><span class="cov0" title="0">{
                                t.Log("DIFF")
                                t.Logf("%s", diff)
                                t.Log("GOT")
                                t.Logf("%#v", gotResp)
                                t.Log("EXP")
                                t.Logf("%#v", tt.ExpResp)
                                t.Fatalf("Should get the expected response")
                        }</span>
                }

                <span class="cov0" title="0">t.Run(testName+"-"+tt.Name, f)</span>
        }
}
</pre>
		
		<pre class="file" id="file102" style="display: none">// Package domain represents the domain type in the system.
package domain

import "fmt"

// The set of roles that can be used.
var (
        User    = newDomain("USER")
        Product = newDomain("FACILITY")
)

// =============================================================================

// Set of known domains.
var domains = make(map[string]Domain)

// Domain represents a domain in the system.
type Domain struct {
        value string
}

func newDomain(domain string) Domain <span class="cov0" title="0">{
        d := Domain{domain}
        domains[domain] = d
        return d
}</span>

// String returns the name of the role.
func (d Domain) String() string <span class="cov0" title="0">{
        return d.value
}</span>

// Equal provides support for the go-cmp package and testing.
func (d Domain) Equal(d2 Domain) bool <span class="cov0" title="0">{
        return d.value == d2.value
}</span>

// MarshalText provides support for logging and any marshal needs.
func (d Domain) MarshalText() ([]byte, error) <span class="cov0" title="0">{
        return []byte(d.value), nil
}</span>

// =============================================================================

// Parse parses the string value and returns a role if one exists.
func Parse(value string) (Domain, error) <span class="cov0" title="0">{
        domain, exists := domains[value]
        if !exists </span><span class="cov0" title="0">{
                return Domain{}, fmt.Errorf("invalid domain %q", value)
        }</span>

        <span class="cov0" title="0">return domain, nil</span>
}

// MustParse parses the string value and returns a role if one exists. If
// an error occurs the function panics.
func MustParse(value string) Domain <span class="cov0" title="0">{
        domain, err := Parse(value)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">return domain</span>
}
</pre>
		
		<pre class="file" id="file103" style="display: none">// Package facilitytype represents a any facilitytype in the system.
package facilitytype

import (
        "fmt"
        "math"
        "regexp"
        "strings"
)

//=============================================================================
// Address Parsing

type Address struct {
        address string
}

func (a Address) String() string <span class="cov0" title="0">{ return a.address }</span>

var re = regexp.MustCompile(`^[A-Za-z0-9 ,./-]{5,80}$`)

func ParseAddress(v string) (Address, error) <span class="cov0" title="0">{
        if !re.MatchString(v) </span><span class="cov0" title="0">{
                return Address{}, fmt.Errorf("invalid address %q", v)
        }</span>
        <span class="cov0" title="0">return Address{address: v}, nil</span>
}

func MustParseAddress(v string) Address <span class="cov0" title="0">{
        ad, err := ParseAddress(v)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return ad</span>
}

func (a Address) Equal(a2 Address) bool <span class="cov0" title="0">{
        return a.address == a2.address
}</span>

//=============================================================================
// Phone-Number Parsing

type PhoneNumber struct{ phonenumber string }

func (p PhoneNumber) String() string <span class="cov0" title="0">{ return p.phonenumber }</span>

var eth = regexp.MustCompile(`^(?:\+251|0)?(9\d{8})$`)

func ParsePhoneNumber(phone string) (PhoneNumber, error) <span class="cov0" title="0">{
        sanPhone := strings.NewReplacer(" ", "", "-", "").Replace(phone)

        if !eth.MatchString(sanPhone) </span><span class="cov0" title="0">{
                return PhoneNumber{}, fmt.Errorf("invalid or unsupported phone number format: %q", phone)
        }</span>

        <span class="cov0" title="0">if strings.HasPrefix(sanPhone, "+251") </span><span class="cov0" title="0">{
                return PhoneNumber{phonenumber: sanPhone[4:]}, nil
        }</span> else<span class="cov0" title="0"> if strings.HasPrefix(sanPhone, "0") </span><span class="cov0" title="0">{
                return PhoneNumber{phonenumber: sanPhone[1:]}, nil
        }</span> else<span class="cov0" title="0"> {
                return PhoneNumber{phonenumber: sanPhone}, nil
        }</span>
}

func ParseCleanPhoneNumber(num string) (PhoneNumber, error) <span class="cov0" title="0">{
        return PhoneNumber{phonenumber: num}, nil
}</span>

func MustParsePhoneNumber(phn string) PhoneNumber <span class="cov0" title="0">{
        phonum, err := ParsePhoneNumber(phn)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return phonum</span>
}

func (p PhoneNumber) Equal(p2 PhoneNumber) bool <span class="cov0" title="0">{
        return p.phonenumber == p2.phonenumber
}</span>

// ====================================================================
// Latitude parsing

type Lat struct{ lat float64 }

func (l Lat) Float64() float64 <span class="cov0" title="0">{ return l.lat }</span>

func ParseLat(lat float64) (Lat, error) <span class="cov0" title="0">{
        if math.IsNaN(lat) || math.IsInf(lat, 0) || lat &lt; -90 || lat &gt; 90 </span><span class="cov0" title="0">{
                return Lat{}, fmt.Errorf("invalid latitude %.6f", lat)
        }</span>
        <span class="cov0" title="0">return Lat{lat: lat}, nil</span>
}

func MustParseLat(lt float64) Lat <span class="cov0" title="0">{
        lat, err := ParseLat(lt)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return lat</span>
}
func (l Lat) Equal(l2 Lat) bool <span class="cov0" title="0">{
        return l.lat == l2.lat
}</span>

// =====================================================================
// Longitude parsing

type Long struct{ long float64 }

func (l Long) Float64() float64 <span class="cov0" title="0">{ return l.long }</span>

func ParseLong(long float64) (Long, error) <span class="cov0" title="0">{
        if math.IsNaN(long) || math.IsInf(long, 0) || long &lt; -180 || long &gt; 180 </span><span class="cov0" title="0">{
                return Long{}, fmt.Errorf("invalid longitude %.6f", long)
        }</span>
        <span class="cov0" title="0">return Long{long: long}, nil</span>
}

func MustParseLong(lg float64) Long <span class="cov0" title="0">{
        lng, err := ParseLong(lg)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return lng</span>
}

func (l Long) Equal(l2 Long) bool <span class="cov0" title="0">{
        return l.long == l2.long
}</span>

// =====================================================================
// Geofence parsing

type Geofence struct{ geofence float64 }

func (g Geofence) Float64() float64 <span class="cov0" title="0">{ return g.geofence }</span>

func ParseGeofence(geofence float64) (Geofence, error) <span class="cov0" title="0">{
        if math.IsNaN(geofence) || math.IsInf(geofence, 0) || geofence &lt;= 0 </span><span class="cov0" title="0">{
                return Geofence{}, fmt.Errorf("invalid geofence %.6f", geofence)
        }</span>
        <span class="cov0" title="0">return Geofence{geofence: geofence}, nil</span>
}

func MustParseGeofence(gf float64) Geofence <span class="cov0" title="0">{
        geofnc, err := ParseGeofence(gf)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return geofnc</span>
}

func (g Geofence) Equal(g2 Geofence) bool <span class="cov0" title="0">{
        return g.geofence == g2.geofence
}</span>
</pre>
		
		<pre class="file" id="file104" style="display: none">// Package genstringtype represents a any strings in the system.
package genstringtype

// GenString represents a generic string in the system.
type GenString struct {
        value string
}

// String returns the value of the generic string.
func (gs GenString) String() string <span class="cov0" title="0">{
        return gs.value
}</span>

// Equal provides support for the go-cmp package and testing.
func (gs GenString) Equal(gs2 GenString) bool <span class="cov0" title="0">{
        return gs.value == gs2.value
}</span>

// MarshalText provides support for logging and any marshal needs.
func (gs GenString) MarshalText() ([]byte, error) <span class="cov0" title="0">{
        return []byte(gs.value), nil
}</span>

// Parse parses the string value and returns a generic string if the value complies
// with the rules for a generic string.
func Parse(value string) (GenString, error) <span class="cov0" title="0">{
        return GenString{value}, nil
}</span>

// MustParse parses the string value and returns a generic string if the value
// complies with the rules for a generic string. If an error occurs the function panics.
func MustParse(value string) GenString <span class="cov0" title="0">{
        genString, err := Parse(value)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">return genString</span>
}

// =============================================================================

// Null represents a generic string in the system that can be empty.
type Null struct {
        value string
        valid bool
}

// String returns the value of the generic string.
func (n Null) String() string <span class="cov0" title="0">{
        if !n.valid </span><span class="cov0" title="0">{
                return "NULL"
        }</span>

        <span class="cov0" title="0">return n.value</span>
}

// Valid tests if the value is null.
func (n Null) Valid() bool <span class="cov0" title="0">{
        return n.valid
}</span>

// Equal provides support for the go-cmp package and testing.
func (n Null) Equal(n2 Null) bool <span class="cov0" title="0">{
        return n.value == n2.value
}</span>

// =============================================================================

// ParseNull parses the string value and returns the generic string if the value complies
// with the rules for a name.
func ParseNull(value string) (Null, error) <span class="cov0" title="0">{
        if value == "" </span><span class="cov0" title="0">{
                return Null{}, nil
        }</span>

        <span class="cov0" title="0">return Null{value, true}, nil</span>
}

// MustParseNull parses the string value and returns the generic string if the value
// complies with the rules for the generic string. If an error occurs the function panics.
func MustParseNull(value string) Null <span class="cov0" title="0">{
        name, err := ParseNull(value)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">return name</span>
}
</pre>
		
		<pre class="file" id="file105" style="display: none">// Package name represents a name in the system.
package name

import (
        "fmt"
        "regexp"
)

// Name represents a name in the system.
type Name struct {
        value string
}

// String returns the value of the name.
func (n Name) String() string <span class="cov0" title="0">{
        return n.value
}</span>

// Equal provides support for the go-cmp package and testing.
func (n Name) Equal(n2 Name) bool <span class="cov0" title="0">{
        return n.value == n2.value
}</span>

// MarshalText provides support for logging and any marshal needs.
func (n Name) MarshalText() ([]byte, error) <span class="cov0" title="0">{
        return []byte(n.value), nil
}</span>

// =============================================================================

var nameRegEx = regexp.MustCompile("^.*$")

// Parse parses the string value and returns a name if the value complies
// with the rules for a name.
func Parse(value string) (Name, error) <span class="cov0" title="0">{
        if !nameRegEx.MatchString(value) </span><span class="cov0" title="0">{
                return Name{}, fmt.Errorf("invalid name %q", value)
        }</span>

        <span class="cov0" title="0">return Name{value}, nil</span>
}

// MustParse parses the string value and returns a name if the value
// complies with the rules for a name. If an error occurs the function panics.
func MustParse(value string) Name <span class="cov0" title="0">{
        name, err := Parse(value)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">return name</span>
}

// =============================================================================

// Null represents a name in the system that can be empty.
type Null struct {
        value string
        valid bool
}

// String returns the value of the name.
func (n Null) String() string <span class="cov0" title="0">{
        if !n.valid </span><span class="cov0" title="0">{
                return "NULL"
        }</span>

        <span class="cov0" title="0">return n.value</span>
}

// Valid tests if the value is null.
func (n Null) Valid() bool <span class="cov0" title="0">{
        return n.valid
}</span>

// Equal provides support for the go-cmp package and testing.
func (n Null) Equal(n2 Null) bool <span class="cov0" title="0">{
        return n.value == n2.value
}</span>

// =============================================================================

// ParseNull parses the string value and returns a name if the value complies
// with the rules for a name.
func ParseNull(value string) (Null, error) <span class="cov0" title="0">{
        if value == "" </span><span class="cov0" title="0">{
                return Null{}, nil
        }</span>

        <span class="cov0" title="0">if !nameRegEx.MatchString(value) </span><span class="cov0" title="0">{
                return Null{}, fmt.Errorf("invalid name %q", value)
        }</span>

        <span class="cov0" title="0">return Null{value, true}, nil</span>
}

// MustParseNull parses the string value and returns a name if the value
// complies with the rules for a name. If an error occurs the function panics.
func MustParseNull(value string) Null <span class="cov0" title="0">{
        name, err := ParseNull(value)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">return name</span>
}
</pre>
		
		<pre class="file" id="file106" style="display: none">// Package role represents the role type in the system.
package role

import "fmt"

// The set of roles that can be used.
var (
        Admin = newRole("ADMIN")
        User  = newRole("USER")
)

// =============================================================================

// Set of known roles.
var roles = make(map[string]Role)

// Role represents a role in the system.
type Role struct {
        value string
}

func newRole(role string) Role <span class="cov0" title="0">{
        r := Role{role}
        roles[role] = r
        return r
}</span>

// String returns the name of the role.
func (r Role) String() string <span class="cov0" title="0">{
        return r.value
}</span>

// Equal provides support for the go-cmp package and testing.
func (r Role) Equal(r2 Role) bool <span class="cov0" title="0">{
        return r.value == r2.value
}</span>

// MarshalText provides support for logging and any marshal needs.
func (r Role) MarshalText() ([]byte, error) <span class="cov0" title="0">{
        return []byte(r.value), nil
}</span>

// =============================================================================

// Parse parses the string value and returns a role if one exists.
func Parse(value string) (Role, error) <span class="cov0" title="0">{
        role, exists := roles[value]
        if !exists </span><span class="cov0" title="0">{
                return Role{}, fmt.Errorf("invalid role %q", value)
        }</span>

        <span class="cov0" title="0">return role, nil</span>
}

// MustParse parses the string value and returns a role if one exists. If
// an error occurs the function panics.
func MustParse(value string) Role <span class="cov0" title="0">{
        role, err := Parse(value)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">return role</span>
}

// ParseToString takes a collection of user roles and converts them to
// a slice of string.
func ParseToString(usrRoles []Role) []string <span class="cov0" title="0">{
        roles := make([]string, len(usrRoles))
        for i, role := range usrRoles </span><span class="cov0" title="0">{
                roles[i] = role.String()
        }</span>

        <span class="cov0" title="0">return roles</span>
}

// ParseMany takes a collection of strings and converts them to a slice
// of roles.
func ParseMany(roles []string) ([]Role, error) <span class="cov0" title="0">{
        usrRoles := make([]Role, len(roles))
        for i, roleStr := range roles </span><span class="cov0" title="0">{
                role, err := Parse(roleStr)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">usrRoles[i] = role</span>
        }

        <span class="cov0" title="0">return usrRoles, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
