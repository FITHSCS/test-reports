
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>build: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/FITHSCS/backend/api/services/auth/build/all.go (0.0%)</option>
				
				<option value="file1">github.com/FITHSCS/backend/api/services/auth/main.go (0.0%)</option>
				
				<option value="file2">github.com/FITHSCS/backend/api/services/core/build/all/all.go (0.0%)</option>
				
				<option value="file3">github.com/FITHSCS/backend/api/services/core/main.go (0.0%)</option>
				
				<option value="file4">github.com/FITHSCS/backend/api/services/metrics/collector/expvar.go (0.0%)</option>
				
				<option value="file5">github.com/FITHSCS/backend/api/services/metrics/main.go (0.0%)</option>
				
				<option value="file6">github.com/FITHSCS/backend/api/services/metrics/publisher/datadog/datadog.go (0.0%)</option>
				
				<option value="file7">github.com/FITHSCS/backend/api/services/metrics/publisher/expvar/expvar.go (0.0%)</option>
				
				<option value="file8">github.com/FITHSCS/backend/api/services/metrics/publisher/prometheus/prometheus.go (0.0%)</option>
				
				<option value="file9">github.com/FITHSCS/backend/api/services/metrics/publisher/publisher.go (0.0%)</option>
				
				<option value="file10">github.com/FITHSCS/backend/api/services/sync/build/all/all.go (0.0%)</option>
				
				<option value="file11">github.com/FITHSCS/backend/api/services/sync/main.go (0.0%)</option>
				
				<option value="file12">github.com/FITHSCS/backend/api/tooling/admin/commands/genkey.go (0.0%)</option>
				
				<option value="file13">github.com/FITHSCS/backend/api/tooling/admin/commands/migrate.go (0.0%)</option>
				
				<option value="file14">github.com/FITHSCS/backend/api/tooling/admin/commands/seed.go (0.0%)</option>
				
				<option value="file15">github.com/FITHSCS/backend/api/tooling/admin/commands/useradd.go (0.0%)</option>
				
				<option value="file16">github.com/FITHSCS/backend/api/tooling/admin/main.go (0.0%)</option>
				
				<option value="file17">github.com/FITHSCS/backend/api/tooling/logfmt/main.go (0.0%)</option>
				
				<option value="file18">github.com/FITHSCS/backend/app/domain/auditapp/auditapp.go (0.0%)</option>
				
				<option value="file19">github.com/FITHSCS/backend/app/domain/auditapp/filter.go (0.0%)</option>
				
				<option value="file20">github.com/FITHSCS/backend/app/domain/auditapp/model.go (0.0%)</option>
				
				<option value="file21">github.com/FITHSCS/backend/app/domain/auditapp/route.go (0.0%)</option>
				
				<option value="file22">github.com/FITHSCS/backend/app/domain/authapp/authapp.go (0.0%)</option>
				
				<option value="file23">github.com/FITHSCS/backend/app/domain/authapp/model.go (0.0%)</option>
				
				<option value="file24">github.com/FITHSCS/backend/app/domain/authapp/route.go (0.0%)</option>
				
				<option value="file25">github.com/FITHSCS/backend/app/domain/consumerapp/consumerapp.go (0.0%)</option>
				
				<option value="file26">github.com/FITHSCS/backend/app/domain/consumerapp/model.go (0.0%)</option>
				
				<option value="file27">github.com/FITHSCS/backend/app/domain/delexceptionapp/delexceptionapp.go (0.0%)</option>
				
				<option value="file28">github.com/FITHSCS/backend/app/domain/delexceptionapp/filter.go (0.0%)</option>
				
				<option value="file29">github.com/FITHSCS/backend/app/domain/delexceptionapp/model.go (0.0%)</option>
				
				<option value="file30">github.com/FITHSCS/backend/app/domain/delexceptionapp/route.go (0.0%)</option>
				
				<option value="file31">github.com/FITHSCS/backend/app/domain/facilityapp/facilityapp.go (0.0%)</option>
				
				<option value="file32">github.com/FITHSCS/backend/app/domain/facilityapp/filter.go (0.0%)</option>
				
				<option value="file33">github.com/FITHSCS/backend/app/domain/facilityapp/model.go (0.0%)</option>
				
				<option value="file34">github.com/FITHSCS/backend/app/domain/facilityapp/route.go (0.0%)</option>
				
				<option value="file35">github.com/FITHSCS/backend/app/domain/gpstrackingapp/filter.go (0.0%)</option>
				
				<option value="file36">github.com/FITHSCS/backend/app/domain/gpstrackingapp/gpstackingapp.go (0.0%)</option>
				
				<option value="file37">github.com/FITHSCS/backend/app/domain/gpstrackingapp/model.go (0.0%)</option>
				
				<option value="file38">github.com/FITHSCS/backend/app/domain/gpstrackingapp/route.go (0.0%)</option>
				
				<option value="file39">github.com/FITHSCS/backend/app/domain/imageapp/filter.go (0.0%)</option>
				
				<option value="file40">github.com/FITHSCS/backend/app/domain/imageapp/imageapp.go (0.0%)</option>
				
				<option value="file41">github.com/FITHSCS/backend/app/domain/imageapp/model.go (0.0%)</option>
				
				<option value="file42">github.com/FITHSCS/backend/app/domain/imageapp/routes.go (0.0%)</option>
				
				<option value="file43">github.com/FITHSCS/backend/app/domain/manifestapp/filter.go (0.0%)</option>
				
				<option value="file44">github.com/FITHSCS/backend/app/domain/manifestapp/manifestapp.go (0.0%)</option>
				
				<option value="file45">github.com/FITHSCS/backend/app/domain/manifestapp/model.go (0.0%)</option>
				
				<option value="file46">github.com/FITHSCS/backend/app/domain/manifestapp/routes.go (0.0%)</option>
				
				<option value="file47">github.com/FITHSCS/backend/app/domain/pickupbatchapp/filter.go (0.0%)</option>
				
				<option value="file48">github.com/FITHSCS/backend/app/domain/pickupbatchapp/model.go (0.0%)</option>
				
				<option value="file49">github.com/FITHSCS/backend/app/domain/pickupbatchapp/pickupbatchapp.go (0.0%)</option>
				
				<option value="file50">github.com/FITHSCS/backend/app/domain/pickupbatchapp/routes.go (0.0%)</option>
				
				<option value="file51">github.com/FITHSCS/backend/app/domain/routeapp/filter.go (0.0%)</option>
				
				<option value="file52">github.com/FITHSCS/backend/app/domain/routeapp/model.go (0.0%)</option>
				
				<option value="file53">github.com/FITHSCS/backend/app/domain/routeapp/routeapp.go (0.0%)</option>
				
				<option value="file54">github.com/FITHSCS/backend/app/domain/routeapp/routes.go (0.0%)</option>
				
				<option value="file55">github.com/FITHSCS/backend/app/domain/signatureapp/filter.go (0.0%)</option>
				
				<option value="file56">github.com/FITHSCS/backend/app/domain/signatureapp/model.go (0.0%)</option>
				
				<option value="file57">github.com/FITHSCS/backend/app/domain/signatureapp/routes.go (0.0%)</option>
				
				<option value="file58">github.com/FITHSCS/backend/app/domain/signatureapp/signatureapp.go (0.0%)</option>
				
				<option value="file59">github.com/FITHSCS/backend/app/domain/statusapp/model.go (0.0%)</option>
				
				<option value="file60">github.com/FITHSCS/backend/app/domain/statusapp/route.go (0.0%)</option>
				
				<option value="file61">github.com/FITHSCS/backend/app/domain/statusapp/statusapp.go (0.0%)</option>
				
				<option value="file62">github.com/FITHSCS/backend/app/domain/syncapp/model.go (0.0%)</option>
				
				<option value="file63">github.com/FITHSCS/backend/app/domain/syncapp/routes.go (0.0%)</option>
				
				<option value="file64">github.com/FITHSCS/backend/app/domain/syncapp/syncapp.go (0.0%)</option>
				
				<option value="file65">github.com/FITHSCS/backend/app/domain/userapp/filter.go (0.0%)</option>
				
				<option value="file66">github.com/FITHSCS/backend/app/domain/userapp/model.go (0.0%)</option>
				
				<option value="file67">github.com/FITHSCS/backend/app/domain/userapp/route.go (0.0%)</option>
				
				<option value="file68">github.com/FITHSCS/backend/app/domain/userapp/userapp.go (0.0%)</option>
				
				<option value="file69">github.com/FITHSCS/backend/app/domain/vehicleapp/filter.go (0.0%)</option>
				
				<option value="file70">github.com/FITHSCS/backend/app/domain/vehicleapp/model.go (0.0%)</option>
				
				<option value="file71">github.com/FITHSCS/backend/app/domain/vehicleapp/route.go (0.0%)</option>
				
				<option value="file72">github.com/FITHSCS/backend/app/domain/vehicleapp/vehicleapp.go (0.0%)</option>
				
				<option value="file73">github.com/FITHSCS/backend/app/sdk/apitest/apitest.go (0.0%)</option>
				
				<option value="file74">github.com/FITHSCS/backend/app/sdk/apitest/keystore.go (0.0%)</option>
				
				<option value="file75">github.com/FITHSCS/backend/app/sdk/apitest/start.go (0.0%)</option>
				
				<option value="file76">github.com/FITHSCS/backend/app/sdk/auth/auth.go (0.0%)</option>
				
				<option value="file77">github.com/FITHSCS/backend/app/sdk/authclient/authclient.go (0.0%)</option>
				
				<option value="file78">github.com/FITHSCS/backend/app/sdk/authclient/model.go (0.0%)</option>
				
				<option value="file79">github.com/FITHSCS/backend/app/sdk/debug/debug.go (0.0%)</option>
				
				<option value="file80">github.com/FITHSCS/backend/app/sdk/errs/errs.go (0.0%)</option>
				
				<option value="file81">github.com/FITHSCS/backend/app/sdk/errs/validate.go (0.0%)</option>
				
				<option value="file82">github.com/FITHSCS/backend/app/sdk/metrics/metrics.go (0.0%)</option>
				
				<option value="file83">github.com/FITHSCS/backend/app/sdk/mid/authen.go (0.0%)</option>
				
				<option value="file84">github.com/FITHSCS/backend/app/sdk/mid/authorize.go (0.0%)</option>
				
				<option value="file85">github.com/FITHSCS/backend/app/sdk/mid/errors.go (0.0%)</option>
				
				<option value="file86">github.com/FITHSCS/backend/app/sdk/mid/logging.go (0.0%)</option>
				
				<option value="file87">github.com/FITHSCS/backend/app/sdk/mid/metrics.go (0.0%)</option>
				
				<option value="file88">github.com/FITHSCS/backend/app/sdk/mid/mid.go (0.0%)</option>
				
				<option value="file89">github.com/FITHSCS/backend/app/sdk/mid/otel.go (0.0%)</option>
				
				<option value="file90">github.com/FITHSCS/backend/app/sdk/mid/panics.go (0.0%)</option>
				
				<option value="file91">github.com/FITHSCS/backend/app/sdk/mux/mux.go (0.0%)</option>
				
				<option value="file92">github.com/FITHSCS/backend/app/sdk/query/query.go (0.0%)</option>
				
				<option value="file93">github.com/FITHSCS/backend/business/domain/auditbus/auditbus.go (69.2%)</option>
				
				<option value="file94">github.com/FITHSCS/backend/business/domain/auditbus/stores/auditdb/auditdb.go (0.0%)</option>
				
				<option value="file95">github.com/FITHSCS/backend/business/domain/auditbus/stores/auditdb/filter.go (0.0%)</option>
				
				<option value="file96">github.com/FITHSCS/backend/business/domain/auditbus/stores/auditdb/model.go (0.0%)</option>
				
				<option value="file97">github.com/FITHSCS/backend/business/domain/auditbus/stores/auditdb/order.go (0.0%)</option>
				
				<option value="file98">github.com/FITHSCS/backend/business/domain/auditbus/testutil.go (93.3%)</option>
				
				<option value="file99">github.com/FITHSCS/backend/business/domain/delexceptionbus/delexceptionbus.go (78.7%)</option>
				
				<option value="file100">github.com/FITHSCS/backend/business/domain/delexceptionbus/store/delexceptiondb/delexceptiondb.go (0.0%)</option>
				
				<option value="file101">github.com/FITHSCS/backend/business/domain/delexceptionbus/store/delexceptiondb/filter.go (0.0%)</option>
				
				<option value="file102">github.com/FITHSCS/backend/business/domain/delexceptionbus/store/delexceptiondb/model.go (0.0%)</option>
				
				<option value="file103">github.com/FITHSCS/backend/business/domain/delexceptionbus/store/delexceptiondb/order.go (0.0%)</option>
				
				<option value="file104">github.com/FITHSCS/backend/business/domain/delexceptionbus/testutil.go (95.2%)</option>
				
				<option value="file105">github.com/FITHSCS/backend/business/domain/facilitybus/facilitybus.go (68.5%)</option>
				
				<option value="file106">github.com/FITHSCS/backend/business/domain/facilitybus/stores/facilitydb/facilitydb.go (0.0%)</option>
				
				<option value="file107">github.com/FITHSCS/backend/business/domain/facilitybus/stores/facilitydb/filter.go (0.0%)</option>
				
				<option value="file108">github.com/FITHSCS/backend/business/domain/facilitybus/stores/facilitydb/model.go (0.0%)</option>
				
				<option value="file109">github.com/FITHSCS/backend/business/domain/facilitybus/stores/facilitydb/order.go (0.0%)</option>
				
				<option value="file110">github.com/FITHSCS/backend/business/domain/facilitybus/testutil.go (93.8%)</option>
				
				<option value="file111">github.com/FITHSCS/backend/business/domain/gpstrackingbus/gpstrackingbus.go (79.1%)</option>
				
				<option value="file112">github.com/FITHSCS/backend/business/domain/gpstrackingbus/stores/gpstrackingdb/filter.go (0.0%)</option>
				
				<option value="file113">github.com/FITHSCS/backend/business/domain/gpstrackingbus/stores/gpstrackingdb/gpstrackingdb.go (0.0%)</option>
				
				<option value="file114">github.com/FITHSCS/backend/business/domain/gpstrackingbus/stores/gpstrackingdb/model.go (0.0%)</option>
				
				<option value="file115">github.com/FITHSCS/backend/business/domain/gpstrackingbus/stores/gpstrackingdb/order.go (0.0%)</option>
				
				<option value="file116">github.com/FITHSCS/backend/business/domain/gpstrackingbus/testutil.go (93.8%)</option>
				
				<option value="file117">github.com/FITHSCS/backend/business/domain/imagebus/imagebus.go (79.6%)</option>
				
				<option value="file118">github.com/FITHSCS/backend/business/domain/imagebus/stores/imagedb/filter.go (0.0%)</option>
				
				<option value="file119">github.com/FITHSCS/backend/business/domain/imagebus/stores/imagedb/imagedb.go (0.0%)</option>
				
				<option value="file120">github.com/FITHSCS/backend/business/domain/imagebus/stores/imagedb/model.go (0.0%)</option>
				
				<option value="file121">github.com/FITHSCS/backend/business/domain/imagebus/stores/imagedb/order.go (0.0%)</option>
				
				<option value="file122">github.com/FITHSCS/backend/business/domain/imagebus/testutil.go (95.0%)</option>
				
				<option value="file123">github.com/FITHSCS/backend/business/domain/manifestbus/manifestbus.go (79.6%)</option>
				
				<option value="file124">github.com/FITHSCS/backend/business/domain/manifestbus/stores/manifestdb/filter.go (0.0%)</option>
				
				<option value="file125">github.com/FITHSCS/backend/business/domain/manifestbus/stores/manifestdb/manifestdb.go (0.0%)</option>
				
				<option value="file126">github.com/FITHSCS/backend/business/domain/manifestbus/stores/manifestdb/model.go (0.0%)</option>
				
				<option value="file127">github.com/FITHSCS/backend/business/domain/manifestbus/stores/manifestdb/order.go (0.0%)</option>
				
				<option value="file128">github.com/FITHSCS/backend/business/domain/manifestbus/testutil.go (95.2%)</option>
				
				<option value="file129">github.com/FITHSCS/backend/business/domain/pickupbatchbus/pickupbatchbus.go (78.8%)</option>
				
				<option value="file130">github.com/FITHSCS/backend/business/domain/pickupbatchbus/stores/pickupbatchdb/filter.go (0.0%)</option>
				
				<option value="file131">github.com/FITHSCS/backend/business/domain/pickupbatchbus/stores/pickupbatchdb/model.go (0.0%)</option>
				
				<option value="file132">github.com/FITHSCS/backend/business/domain/pickupbatchbus/stores/pickupbatchdb/order.go (0.0%)</option>
				
				<option value="file133">github.com/FITHSCS/backend/business/domain/pickupbatchbus/stores/pickupbatchdb/pickupbatchdb.go (0.0%)</option>
				
				<option value="file134">github.com/FITHSCS/backend/business/domain/pickupbatchbus/testutil.go (94.7%)</option>
				
				<option value="file135">github.com/FITHSCS/backend/business/domain/routebus/routebus.go (79.6%)</option>
				
				<option value="file136">github.com/FITHSCS/backend/business/domain/routebus/stores/routedb/filter.go (0.0%)</option>
				
				<option value="file137">github.com/FITHSCS/backend/business/domain/routebus/stores/routedb/model.go (0.0%)</option>
				
				<option value="file138">github.com/FITHSCS/backend/business/domain/routebus/stores/routedb/order.go (0.0%)</option>
				
				<option value="file139">github.com/FITHSCS/backend/business/domain/routebus/stores/routedb/routedb.go (0.0%)</option>
				
				<option value="file140">github.com/FITHSCS/backend/business/domain/routebus/testutil.go (93.3%)</option>
				
				<option value="file141">github.com/FITHSCS/backend/business/domain/signaturebus/signaturebus.go (82.0%)</option>
				
				<option value="file142">github.com/FITHSCS/backend/business/domain/signaturebus/stores/signaturedb/filter.go (0.0%)</option>
				
				<option value="file143">github.com/FITHSCS/backend/business/domain/signaturebus/stores/signaturedb/model.go (0.0%)</option>
				
				<option value="file144">github.com/FITHSCS/backend/business/domain/signaturebus/stores/signaturedb/order.go (0.0%)</option>
				
				<option value="file145">github.com/FITHSCS/backend/business/domain/signaturebus/stores/signaturedb/signaturedb.go (0.0%)</option>
				
				<option value="file146">github.com/FITHSCS/backend/business/domain/signaturebus/testutil.go (95.0%)</option>
				
				<option value="file147">github.com/FITHSCS/backend/business/domain/syncbatchbus/stores/syncbatchdb/model.go (0.0%)</option>
				
				<option value="file148">github.com/FITHSCS/backend/business/domain/syncbatchbus/stores/syncbatchdb/syncbatchdb.go (0.0%)</option>
				
				<option value="file149">github.com/FITHSCS/backend/business/domain/syncbatchbus/syncbatchbus.go (0.0%)</option>
				
				<option value="file150">github.com/FITHSCS/backend/business/domain/userbus/extensions/useraudit/useraudit.go (0.0%)</option>
				
				<option value="file151">github.com/FITHSCS/backend/business/domain/userbus/stores/usercache/usercache.go (0.0%)</option>
				
				<option value="file152">github.com/FITHSCS/backend/business/domain/userbus/stores/userdb/filter.go (0.0%)</option>
				
				<option value="file153">github.com/FITHSCS/backend/business/domain/userbus/stores/userdb/model.go (0.0%)</option>
				
				<option value="file154">github.com/FITHSCS/backend/business/domain/userbus/stores/userdb/order.go (0.0%)</option>
				
				<option value="file155">github.com/FITHSCS/backend/business/domain/userbus/stores/userdb/userdb.go (0.0%)</option>
				
				<option value="file156">github.com/FITHSCS/backend/business/domain/userbus/testutil.go (93.3%)</option>
				
				<option value="file157">github.com/FITHSCS/backend/business/domain/userbus/userbus.go (50.8%)</option>
				
				<option value="file158">github.com/FITHSCS/backend/business/domain/vehiclebus/stores/vehicledb/filter.go (0.0%)</option>
				
				<option value="file159">github.com/FITHSCS/backend/business/domain/vehiclebus/stores/vehicledb/model.go (0.0%)</option>
				
				<option value="file160">github.com/FITHSCS/backend/business/domain/vehiclebus/stores/vehicledb/order.go (0.0%)</option>
				
				<option value="file161">github.com/FITHSCS/backend/business/domain/vehiclebus/stores/vehicledb/vehicledb.go (0.0%)</option>
				
				<option value="file162">github.com/FITHSCS/backend/business/domain/vehiclebus/testutil.go (93.3%)</option>
				
				<option value="file163">github.com/FITHSCS/backend/business/domain/vehiclebus/vehiclebus.go (80.0%)</option>
				
				<option value="file164">github.com/FITHSCS/backend/business/sdk/dbtest/business.go (0.0%)</option>
				
				<option value="file165">github.com/FITHSCS/backend/business/sdk/dbtest/dbtest.go (0.0%)</option>
				
				<option value="file166">github.com/FITHSCS/backend/business/sdk/dbtest/pointer.go (0.0%)</option>
				
				<option value="file167">github.com/FITHSCS/backend/business/sdk/delegate/delegate.go (0.0%)</option>
				
				<option value="file168">github.com/FITHSCS/backend/business/sdk/delegate/model.go (0.0%)</option>
				
				<option value="file169">github.com/FITHSCS/backend/business/sdk/migrate/migrate.go (0.0%)</option>
				
				<option value="file170">github.com/FITHSCS/backend/business/sdk/order/order.go (0.0%)</option>
				
				<option value="file171">github.com/FITHSCS/backend/business/sdk/page/page.go (0.0%)</option>
				
				<option value="file172">github.com/FITHSCS/backend/business/sdk/sqldb/dbarray/dbarray.go (0.0%)</option>
				
				<option value="file173">github.com/FITHSCS/backend/business/sdk/sqldb/dbarray/encode.go (0.0%)</option>
				
				<option value="file174">github.com/FITHSCS/backend/business/sdk/sqldb/sqldb.go (0.0%)</option>
				
				<option value="file175">github.com/FITHSCS/backend/business/sdk/sqldb/tran.go (0.0%)</option>
				
				<option value="file176">github.com/FITHSCS/backend/business/sdk/unitest/unittest.go (0.0%)</option>
				
				<option value="file177">github.com/FITHSCS/backend/business/types/domain/domain.go (0.0%)</option>
				
				<option value="file178">github.com/FITHSCS/backend/business/types/facilitytype/facilitytype.go (0.0%)</option>
				
				<option value="file179">github.com/FITHSCS/backend/business/types/genstringtype/genstringtype.go (0.0%)</option>
				
				<option value="file180">github.com/FITHSCS/backend/business/types/name/name.go (0.0%)</option>
				
				<option value="file181">github.com/FITHSCS/backend/business/types/role/role.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package authall all binds all the routes into the specified app.
package authall

import (
        "github.com/FITHSCS/backend/app/domain/authapp"
        "github.com/FITHSCS/backend/app/domain/statusapp"
        "github.com/FITHSCS/backend/app/sdk/mux"
        "github.com/FITHSCS/backend/foundation/web"
)

// Routes constructs the add value which provides the implementation of
// of RouteAdder for specifying what routes to bind to this instance.
func Routes() add <span class="cov0" title="0">{
        return add{}
}</span>

type add struct{}

// Add implements the RouterAdder interface.
func (add) Add(app *web.App, cfg mux.Config) <span class="cov0" title="0">{
        statusapp.Routes(app, statusapp.Config{
                Log: cfg.Log,
                DB:  cfg.DB,
        })

        authapp.Routes(app, authapp.Config{
                UserBus: cfg.BusConfig.UserBus,
                Auth:    cfg.AuthConfig.Auth,
        })
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "context"
        "errors"
        "expvar"
        "fmt"
        "net/http"
        "os"
        "os/signal"
        "runtime"
        "syscall"
        "time"

        authall "github.com/FITHSCS/backend/api/services/auth/build"
        "github.com/FITHSCS/backend/app/sdk/auth"
        "github.com/FITHSCS/backend/app/sdk/debug"
        "github.com/FITHSCS/backend/app/sdk/mux"

        "github.com/FITHSCS/backend/business/domain/userbus"

        "github.com/FITHSCS/backend/business/domain/userbus/stores/usercache"
        "github.com/FITHSCS/backend/business/domain/userbus/stores/userdb"

        "github.com/FITHSCS/backend/business/sdk/sqldb"
        "github.com/FITHSCS/backend/foundation/keystore"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/FITHSCS/backend/foundation/otel"
        "github.com/ardanlabs/conf/v3"
)

var build = "develop"

func main() <span class="cov0" title="0">{
        var log *logger.Logger

        events := logger.Events{
                Error: func(ctx context.Context, r logger.Record) </span><span class="cov0" title="0">{
                        log.Info(ctx, "******* SEND ALERT *******")
                }</span>,
        }

        <span class="cov0" title="0">traceIDFn := func(ctx context.Context) string </span><span class="cov0" title="0">{
                return otel.GetTraceID(ctx)
        }</span>

        <span class="cov0" title="0">log = logger.NewWithEvents(os.Stdout, logger.LevelInfo, "AUTH", traceIDFn, events)

        // -------------------------------------------------------------------------

        ctx := context.Background()

        if err := run(ctx, log); err != nil </span><span class="cov0" title="0">{
                log.Error(ctx, "startup", "err", err)
                os.Exit(1)
        }</span>
}

func run(ctx context.Context, log *logger.Logger) error <span class="cov0" title="0">{

        // -------------------------------------------------------------------------
        // GOMAXPROCS

        log.Info(ctx, "startup", "GOMAXPROCS", runtime.GOMAXPROCS(0))

        // -------------------------------------------------------------------------
        // Configuration

        cfg := struct {
                conf.Version
                Web struct {
                        ReadTimeout        time.Duration `conf:"default:5s"`
                        WriteTimeout       time.Duration `conf:"default:10s"`
                        IdleTimeout        time.Duration `conf:"default:120s"`
                        ShutdownTimeout    time.Duration `conf:"default:20s"`
                        APIHost            string        `conf:"default:0.0.0.0:6000"`
                        DebugHost          string        `conf:"default:0.0.0.0:6010"`
                        CORSAllowedOrigins []string      `conf:"default:*"`
                }
                Auth struct {
                        KeysEnvVar string
                        KeysFolder string `conf:"default:zarf/keys/"`
                        ActiveKID  string `conf:"default:54bb2165-71e1-41a6-af3e-7da4a0e1e2c1"`
                        Issuer     string `conf:"default:FITHSCS core project"`
                }
                DB struct {
                        User         string `conf:"default:postgres"`
                        Password     string `conf:"default:postgres,mask"`
                        Host         string `conf:"default:database"`
                        Name         string `conf:"default:postgres"`
                        MaxIdleConns int    `conf:"default:0"`
                        MaxOpenConns int    `conf:"default:0"`
                        DisableTLS   bool   `conf:"default:true"`
                }
        }{
                Version: conf.Version{
                        Build: build,
                        Desc:  "Auth",
                },
        }

        const prefix = "AUTH"
        help, err := conf.Parse(prefix, &amp;cfg)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, conf.ErrHelpWanted) </span><span class="cov0" title="0">{
                        fmt.Println(help)
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("parsing config: %w", err)</span>
        }

        // -------------------------------------------------------------------------
        // App Starting

        <span class="cov0" title="0">log.Info(ctx, "starting service", "version", cfg.Build)
        defer log.Info(ctx, "shutdown complete")

        out, err := conf.String(&amp;cfg)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("generating config for output: %w", err)
        }</span>
        <span class="cov0" title="0">log.Info(ctx, "startup", "config", out)

        log.BuildInfo(ctx)

        expvar.NewString("build").Set(cfg.Build)

        // -------------------------------------------------------------------------
        // Database Support

        log.Info(ctx, "startup", "status", "initializing database support", "hostport", cfg.DB.Host)

        db, err := sqldb.Open(sqldb.Config{
                User:         cfg.DB.User,
                Password:     cfg.DB.Password,
                Host:         cfg.DB.Host,
                Name:         cfg.DB.Name,
                MaxIdleConns: cfg.DB.MaxIdleConns,
                MaxOpenConns: cfg.DB.MaxOpenConns,
                DisableTLS:   cfg.DB.DisableTLS,
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("connecting to db: %w", err)
        }</span>

        <span class="cov0" title="0">defer db.Close()

        // -------------------------------------------------------------------------
        // Create Business Packages

        userBus := userbus.NewBusiness(log, usercache.NewStore(log, userdb.NewStore(log, db), time.Minute))

        // -------------------------------------------------------------------------
        // Initialize authentication support

        log.Info(ctx, "startup", "status", "initializing authentication support")

        // Check the enviornment first to see if a key is being provided. Then
        // load any private keys files from disk. We can assume some system like
        // Vault has created these files already. How that happens is not our
        // concern.

        ks := keystore.New()

        n1, err := ks.LoadByJSON(cfg.Auth.KeysEnvVar)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("loading keys by env: %w", err)
        }</span>

        <span class="cov0" title="0">n2, err := ks.LoadByFileSystem(os.DirFS(cfg.Auth.KeysFolder))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("loading keys by fs: %w", err)
        }</span>

        <span class="cov0" title="0">if n1+n2 == 0 </span><span class="cov0" title="0">{
                return errors.New("no keys exist")
        }</span>

        <span class="cov0" title="0">authCfg := auth.Config{
                Log:       log,
                UserBus:   userBus,
                KeyLookup: ks,
                Issuer:    cfg.Auth.Issuer,
        }

        ath, err := auth.New(authCfg)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("constructing auth: %w", err)
        }</span>

        // -------------------------------------------------------------------------
        // Start Debug Service

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                log.Info(ctx, "startup", "status", "debug v1 router started", "host", cfg.Web.DebugHost)

                if err := http.ListenAndServe(cfg.Web.DebugHost, debug.Mux()); err != nil </span><span class="cov0" title="0">{
                        log.Error(ctx, "shutdown", "status", "debug v1 router closed", "host", cfg.Web.DebugHost, "msg", err)
                }</span>
        }()

        // -------------------------------------------------------------------------
        // Start API Service

        <span class="cov0" title="0">log.Info(ctx, "startup", "status", "initializing V1 API support")

        shutdown := make(chan os.Signal, 1)
        signal.Notify(shutdown, syscall.SIGINT, syscall.SIGTERM)

        cfgMux := mux.Config{
                Build: build,
                Log:   log,
                DB:    db,
                BusConfig: mux.BusConfig{
                        UserBus: userBus,
                },
                AuthConfig: mux.AuthConfig{
                        Auth: ath,
                },
        }

        api := http.Server{
                Addr:         cfg.Web.APIHost,
                Handler:      mux.WebAPI(cfgMux, authall.Routes(), mux.WithCORS(cfg.Web.CORSAllowedOrigins)),
                ReadTimeout:  cfg.Web.ReadTimeout,
                WriteTimeout: cfg.Web.WriteTimeout,
                IdleTimeout:  cfg.Web.IdleTimeout,
                ErrorLog:     logger.NewStdLogger(log, logger.LevelError),
        }

        serverErrors := make(chan error, 1)

        go func() </span><span class="cov0" title="0">{
                log.Info(ctx, "startup", "status", "api router started", "host", api.Addr)

                serverErrors &lt;- api.ListenAndServe()
        }</span>()

        // -------------------------------------------------------------------------
        // Shutdown

        <span class="cov0" title="0">select </span>{
        case err := &lt;-serverErrors:<span class="cov0" title="0">
                return fmt.Errorf("server error: %w", err)</span>

        case sig := &lt;-shutdown:<span class="cov0" title="0">
                log.Info(ctx, "shutdown", "status", "shutdown started", "signal", sig)
                defer log.Info(ctx, "shutdown", "status", "shutdown complete", "signal", sig)

                ctx, cancel := context.WithTimeout(ctx, cfg.Web.ShutdownTimeout)
                defer cancel()

                if err := api.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                        api.Close()
                        return fmt.Errorf("could not stop server gracefully: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>

}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Package coreall binds all the routes into the specified app.
package coreall

import (
        "github.com/FITHSCS/backend/app/domain/auditapp"
        "github.com/FITHSCS/backend/app/domain/delexceptionapp"
        "github.com/FITHSCS/backend/app/domain/facilityapp"
        "github.com/FITHSCS/backend/app/domain/gpstrackingapp"
        "github.com/FITHSCS/backend/app/domain/imageapp"
        "github.com/FITHSCS/backend/app/domain/manifestapp"
        "github.com/FITHSCS/backend/app/domain/pickupbatchapp"
        "github.com/FITHSCS/backend/app/domain/routeapp"
        "github.com/FITHSCS/backend/app/domain/signatureapp"
        "github.com/FITHSCS/backend/app/domain/statusapp"
        "github.com/FITHSCS/backend/app/domain/userapp"
        "github.com/FITHSCS/backend/app/domain/vehicleapp"
        "github.com/FITHSCS/backend/app/sdk/mux"
        "github.com/FITHSCS/backend/foundation/web"
)

// Routes constructs the add value which provides the implementation of
// of RouteAdder for specifying what routes to bind to this instance.
func Routes() add <span class="cov0" title="0">{
        return add{}
}</span>

type add struct{}

// Add implements the RouterAdder interface.
func (add) Add(app *web.App, cfg mux.Config) <span class="cov0" title="0">{
        statusapp.Routes(app, statusapp.Config{
                Log: cfg.Log,
                DB:  cfg.DB,
        })

        userapp.Routes(app, userapp.Config{
                Log:        cfg.Log,
                UserBus:    cfg.BusConfig.UserBus,
                AuthClient: cfg.AuthClientConfig.AuthClient,
        })

        auditapp.Routes(app, auditapp.Config{
                Log:        cfg.Log,
                AuditBus:   cfg.BusConfig.AuditBus,
                AuthClient: cfg.AuthClientConfig.AuthClient,
        })

        vehicleapp.Routes(app, vehicleapp.Config{
                Log:        cfg.Log,
                VehicleBus: cfg.BusConfig.VehicleBus,
                AuthClient: cfg.AuthClientConfig.AuthClient,
        })

        gpstrackingapp.Routes(app, gpstrackingapp.Config{
                Log:           cfg.Log,
                TrackTraceBus: cfg.BusConfig.GPSTrackingBus,
                AuthClient:    cfg.AuthClientConfig.AuthClient,
        })

        facilityapp.Routes(app, facilityapp.Config{
                Log:         cfg.Log,
                FacilityBus: cfg.BusConfig.FacilityBus,
                AuthClient:  cfg.AuthClientConfig.AuthClient,
        })

        pickupbatchapp.Routes(app, pickupbatchapp.Config{
                Log:            cfg.Log,
                PickupBatchBus: cfg.BusConfig.PickupBatchBus,
                AuthClient:     cfg.AuthClientConfig.AuthClient,
        })

        manifestapp.Routes(app, manifestapp.Config{
                Log:         cfg.Log,
                ManifestBus: cfg.BusConfig.ManifestBus,
                AuthClient:  cfg.AuthClientConfig.AuthClient,
        })

        signatureapp.Routes(app, signatureapp.Config{
                Log:          cfg.Log,
                SignatureBus: cfg.BusConfig.SignatureBus,
                AuthClient:   cfg.AuthClientConfig.AuthClient,
        })

        delexceptionapp.Routes(app, delexceptionapp.Config{
                Log:          cfg.Log,
                Delexception: cfg.BusConfig.DeliveryExceptionBus,
                AuthClient:   cfg.AuthClientConfig.AuthClient,
        })

        imageapp.Routes(app, imageapp.Config{
                Log:        cfg.Log,
                ImageBus:   cfg.BusConfig.ImageBus,
                AuthClient: cfg.AuthClientConfig.AuthClient,
        })

        routeapp.Routes(app, routeapp.Config{
                Log:        cfg.Log,
                RouteBus:   cfg.BusConfig.RouteBus,
                AuthClient: cfg.AuthClientConfig.AuthClient,
        })

}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "context"
        "errors"
        "expvar"
        "fmt"
        "net/http"
        "os"
        "os/signal"
        "runtime"
        "syscall"
        "time"

        coreall "github.com/FITHSCS/backend/api/services/core/build/all"
        "github.com/FITHSCS/backend/app/domain/consumerapp"
        "github.com/FITHSCS/backend/app/sdk/authclient"
        "github.com/FITHSCS/backend/app/sdk/debug"
        "github.com/FITHSCS/backend/app/sdk/mux"
        "github.com/FITHSCS/backend/business/domain/auditbus"
        "github.com/FITHSCS/backend/business/domain/auditbus/stores/auditdb"
        "github.com/FITHSCS/backend/business/domain/delexceptionbus"
        "github.com/FITHSCS/backend/business/domain/delexceptionbus/store/delexceptiondb"
        "github.com/FITHSCS/backend/business/domain/facilitybus"
        "github.com/FITHSCS/backend/business/domain/facilitybus/stores/facilitydb"
        "github.com/FITHSCS/backend/business/domain/gpstrackingbus"
        "github.com/FITHSCS/backend/business/domain/gpstrackingbus/stores/gpstrackingdb"
        "github.com/FITHSCS/backend/business/domain/imagebus"
        "github.com/FITHSCS/backend/business/domain/imagebus/stores/imagedb"
        "github.com/FITHSCS/backend/business/domain/manifestbus"
        "github.com/FITHSCS/backend/business/domain/manifestbus/stores/manifestdb"
        "github.com/FITHSCS/backend/business/domain/pickupbatchbus"
        "github.com/FITHSCS/backend/business/domain/pickupbatchbus/stores/pickupbatchdb"
        "github.com/FITHSCS/backend/business/domain/routebus"
        "github.com/FITHSCS/backend/business/domain/routebus/stores/routedb"
        "github.com/FITHSCS/backend/business/domain/signaturebus"
        "github.com/FITHSCS/backend/business/domain/signaturebus/stores/signaturedb"
        "github.com/FITHSCS/backend/business/domain/userbus"
        "github.com/FITHSCS/backend/business/domain/userbus/extensions/useraudit"
        "github.com/FITHSCS/backend/business/domain/userbus/stores/usercache"
        "github.com/FITHSCS/backend/business/domain/userbus/stores/userdb"
        "github.com/FITHSCS/backend/business/domain/vehiclebus"
        "github.com/FITHSCS/backend/business/domain/vehiclebus/stores/vehicledb"
        "github.com/FITHSCS/backend/business/sdk/sqldb"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/FITHSCS/backend/foundation/otel"
        "github.com/ardanlabs/conf/v3"
)

var build = "develop"

func main() <span class="cov0" title="0">{
        var log *logger.Logger

        events := logger.Events{
                Error: func(ctx context.Context, r logger.Record) </span><span class="cov0" title="0">{
                        log.Info(ctx, "******* SEND ALERT *******")
                }</span>,
        }

        <span class="cov0" title="0">traceIDFn := func(ctx context.Context) string </span><span class="cov0" title="0">{
                return otel.GetTraceID(ctx)
        }</span>

        <span class="cov0" title="0">log = logger.NewWithEvents(os.Stdout, logger.LevelInfo, "CORE", traceIDFn, events)

        // -------------------------------------------------------------------------

        ctx := context.Background()

        if err := run(ctx, log); err != nil </span><span class="cov0" title="0">{
                log.Error(ctx, "startup", "err", err)
                os.Exit(1)
        }</span>
}

func run(ctx context.Context, log *logger.Logger) error <span class="cov0" title="0">{

        // -------------------------------------------------------------------------
        // GOMAXPROCS

        log.Info(ctx, "startup", "GOMAXPROCS", runtime.GOMAXPROCS(0))

        // -------------------------------------------------------------------------
        // Configuration

        cfg := struct {
                conf.Version
                Web struct {
                        ReadTimeout        time.Duration `conf:"default:5s"`
                        WriteTimeout       time.Duration `conf:"default:10s"`
                        IdleTimeout        time.Duration `conf:"default:120s"`
                        ShutdownTimeout    time.Duration `conf:"default:20s"`
                        APIHost            string        `conf:"default:0.0.0.0:3000"`
                        DebugHost          string        `conf:"default:0.0.0.0:3010"`
                        CORSAllowedOrigins []string      `conf:"default:*"`
                }
                Auth struct {
                        Host string `conf:"default:http://0.0.0.0:6000"`
                }
                DB struct {
                        User         string `conf:"default:postgres"`
                        Password     string `conf:"default:postgres,mask"`
                        Host         string `conf:"default:database"`
                        Name         string `conf:"default:postgres"`
                        MaxIdleConns int    `conf:"default:0"`
                        MaxOpenConns int    `conf:"default:0"`
                        DisableTLS   bool   `conf:"default:true"`
                }
                Consumer struct {
                        Enabled     bool     `conf:"default:true"`
                        Brokers     []string `conf:"default:localhost:9092"`
                        Topic       string   `conf:"default:epod-persist"`
                        GroupID     string   `conf:"default:core-consumer-group"`
                        WorkerCount int      `conf:"default:6"`
                        QueueSize   int      `conf:"default:100"`
                }
                Tempo struct {
                        Host        string  `conf:"default:tempo:4317"`
                        ServiceName string  `conf:"default:core"`
                        Probability float64 `conf:"default:0.05"`
                        // Shouldn't use a high Probability value in non-developer systems.
                        // 0.05 should be enough for most systems. Some might want to have
                        // this even lower.
                }
        }{
                Version: conf.Version{
                        Build: build,
                        Desc:  "core with Kafka consumer",
                },
        }
        const prefix = "CORE"
        help, err := conf.Parse(prefix, &amp;cfg)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, conf.ErrHelpWanted) </span><span class="cov0" title="0">{
                        fmt.Println(help)
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("parsing config: %w", err)</span>
        }

        // -------------------------------------------------------------------------
        // App Starting

        <span class="cov0" title="0">log.Info(ctx, "starting service", "version", cfg.Build)
        defer log.Info(ctx, "shutdown complete")

        out, err := conf.String(&amp;cfg)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("generating config for output: %w", err)
        }</span>
        <span class="cov0" title="0">log.Info(ctx, "startup", "config", out)

        log.BuildInfo(ctx)

        expvar.NewString("build").Set(cfg.Build)

        // -------------------------------------------------------------------------
        // Database Support

        log.Info(ctx, "startup", "status", "initializing database support", "hostport", cfg.DB.Host)
        fmt.Println("Password: ", cfg.DB.Password)
        db, err := sqldb.Open(sqldb.Config{
                User:         cfg.DB.User,
                Password:     cfg.DB.Password,
                Host:         cfg.DB.Host,
                Name:         cfg.DB.Name,
                MaxIdleConns: cfg.DB.MaxIdleConns,
                MaxOpenConns: cfg.DB.MaxOpenConns,
                DisableTLS:   cfg.DB.DisableTLS,
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("connecting to db: %w", err)
        }</span>

        <span class="cov0" title="0">defer db.Close()

        // -------------------------------------------------------------------------
        // Initialize authentication support

        log.Info(ctx, "startup", "status", "initializing authentication support")

        autclint := authclient.New(log, cfg.Auth.Host)

        // -------------------------------------------------------------------------
        // Create Business Packages

        userAuditExt := useraudit.NewExtension(auditbus.NewBusiness(log, auditdb.NewStore(log, db)))
        userStorage := usercache.NewStore(log, userdb.NewStore(log, db), time.Minute)

        auditBus := auditbus.NewBusiness(log, auditdb.NewStore(log, db))
        userBus := userbus.NewBusiness(log, userStorage, userAuditExt)
        facilityBus := facilitybus.NewBusiness(log, facilitydb.NewStore(log, db))
        vehicleBus := vehiclebus.NewBusiness(log, vehicledb.NewStore(log, db))
        gpsTracking := gpstrackingbus.NewBusiness(log, gpstrackingdb.NewStore(log, db))
        pickupbatchBus := pickupbatchbus.NewBusiness(log, pickupbatchdb.NewStore(log, db))
        manifestBus := manifestbus.NewBusiness(log, manifestdb.NewStore(log, db))
        signatureBus := signaturebus.NewBusiness(log, signaturedb.NewStore(log, db))
        delexceptionBus := delexceptionbus.NewBusiness(log, delexceptiondb.NewStore(log, db))
        imageBus := imagebus.NewBusiness(log, imagedb.NewStore(log, db))
        routeBus := routebus.NewBusiness(log, routedb.NewStore(log, db))

        // -----------------------------------------------------------------------
        // create consumer app
        var consumer *consumerapp.App

        if cfg.Consumer.Enabled </span><span class="cov0" title="0">{
                log.Info(ctx, "startup", "status", "intializing kafka consumer",
                        "brokers", cfg.Consumer.Brokers,
                        "topic", cfg.Consumer.Topic,
                        "group_id", cfg.Consumer.GroupID,
                        "worker_count", cfg.Consumer.WorkerCount)

                consumerCfg := consumerapp.Config{
                        Log: log,
                        KafkaConfig: consumerapp.KafkaConfig{
                                Brokers: cfg.Consumer.Brokers,
                                Topic:   cfg.Consumer.Topic,
                                GroupID: cfg.Consumer.GroupID,
                        },
                        WorkerCount:    cfg.Consumer.WorkerCount,
                        QueueSize:      cfg.Consumer.QueueSize,
                        UserBus:        userBus,
                        FacilityBus:    facilityBus,
                        VehicleBus:     vehicleBus,
                        PickupBatchBus: pickupbatchBus,
                        ManifestBus:    manifestBus,
                        GpsTrackingBus: gpsTracking,
                        SignatureBus:   signatureBus,
                }
                consumer = consumerapp.New(consumerCfg)

                if err := consumer.Start(ctx); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to start kafka consumer: %w", err)
                }</span>
                <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                        log.Info(ctx, "shutdown", "status", "stopping kafka consumer")
                        if err := consumer.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                                log.Error(ctx, "graceful shutdown of consumer", "ERROR", err)
                        }</span>
                }()
        }

        // -------------------------------------------------------------------------
        // Start Debug Service

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                log.Info(ctx, "startup", "status", "debug v1 router started", "host", cfg.Web.DebugHost)

                if err := http.ListenAndServe(cfg.Web.DebugHost, debug.Mux()); err != nil </span><span class="cov0" title="0">{
                        log.Error(ctx, "shutdown", "status", "debug v1 router closed", "host", cfg.Web.DebugHost, "msg", err)
                }</span>
        }()

        // -------------------------------------------------------------------------
        // Start API Service

        <span class="cov0" title="0">log.Info(ctx, "startup", "status", "initializing V1 API support")

        shutdown := make(chan os.Signal, 1)
        signal.Notify(shutdown, syscall.SIGINT, syscall.SIGTERM)

        cfgMux := mux.Config{
                Build: build,
                Log:   log,
                DB:    db,
                BusConfig: mux.BusConfig{
                        AuditBus:             auditBus,
                        UserBus:              userBus,
                        FacilityBus:          facilityBus,
                        VehicleBus:           vehicleBus,
                        GPSTrackingBus:       gpsTracking,
                        PickupBatchBus:       pickupbatchBus,
                        ManifestBus:          manifestBus,
                        SignatureBus:         signatureBus,
                        DeliveryExceptionBus: delexceptionBus,
                        ImageBus:             imageBus,
                        RouteBus:             routeBus,
                },
                AuthClientConfig: mux.AuthClientConfig{
                        AuthClient: autclint,
                },
        }

        webAPI := mux.WebAPI(cfgMux, coreall.Routes(), mux.WithCORS(cfg.Web.CORSAllowedOrigins))

        api := http.Server{
                Addr:         cfg.Web.APIHost,
                Handler:      webAPI,
                ReadTimeout:  cfg.Web.ReadTimeout,
                WriteTimeout: cfg.Web.WriteTimeout,
                IdleTimeout:  cfg.Web.IdleTimeout,
                ErrorLog:     logger.NewStdLogger(log, logger.LevelError),
        }

        serverErrors := make(chan error, 1)

        go func() </span><span class="cov0" title="0">{
                log.Info(ctx, "startup", "status", "api router started", "host", api.Addr)

                serverErrors &lt;- api.ListenAndServe()
        }</span>()

        // -------------------------------------------------------------------------
        // Shutdown

        <span class="cov0" title="0">select </span>{
        case err := &lt;-serverErrors:<span class="cov0" title="0">
                return fmt.Errorf("server error: %w", err)</span>

        case sig := &lt;-shutdown:<span class="cov0" title="0">
                log.Info(ctx, "shutdown", "status", "shutdown started", "signal", sig)
                defer log.Info(ctx, "shutdown", "status", "shutdown complete", "signal", sig)

                ctx, cancel := context.WithTimeout(ctx, cfg.Web.ShutdownTimeout)
                defer cancel()

                if err := api.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                        api.Close()
                        return fmt.Errorf("could not stop server gracefully: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Package collector is a simple collector for
package collector

import (
        "errors"
        "io"
        "net"
        "net/http"
        "time"

        "github.com/go-json-experiment/json"
)

// Expvar provides the ability to receive metrics
// from internal services using expvar.
type Expvar struct {
        host   string
        tr     *http.Transport
        client http.Client
}

// New creates a Expvar for collection metrics.
func New(host string) (*Expvar, error) <span class="cov0" title="0">{
        tr := http.Transport{
                Proxy: http.ProxyFromEnvironment,
                DialContext: (&amp;net.Dialer{
                        Timeout:   30 * time.Second,
                        KeepAlive: 30 * time.Second,
                }).DialContext,
                MaxIdleConns:          2,
                IdleConnTimeout:       90 * time.Second,
                TLSHandshakeTimeout:   10 * time.Second,
                ExpectContinueTimeout: 1 * time.Second,
        }

        exp := Expvar{
                host: host,
                tr:   &amp;tr,
                client: http.Client{
                        Transport: &amp;tr,
                        Timeout:   1 * time.Second,
                },
        }

        return &amp;exp, nil
}</span>

// Collect captures metrics on the host configure to this endpoint.
func (exp *Expvar) Collect() (map[string]any, error) <span class="cov0" title="0">{
        req, err := http.NewRequest("GET", exp.host, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">resp, err := exp.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                msg, err := io.ReadAll(resp.Body)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return nil, errors.New(string(msg))</span>
        }

        <span class="cov0" title="0">data := make(map[string]any)
        if err := json.UnmarshalRead(resp.Body, &amp;data); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return data, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package main

import (
        "context"
        "errors"
        "fmt"
        "net/http"
        "os"
        "os/signal"
        "runtime"
        "syscall"
        "time"

        "github.com/FITHSCS/backend/api/services/metrics/collector"
        "github.com/FITHSCS/backend/api/services/metrics/publisher"
        expvarsrv "github.com/FITHSCS/backend/api/services/metrics/publisher/expvar"
        prometheussrv "github.com/FITHSCS/backend/api/services/metrics/publisher/prometheus"
        "github.com/FITHSCS/backend/app/sdk/debug"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/ardanlabs/conf/v3"
)

var build = "develop"

func main() <span class="cov0" title="0">{
        var log *logger.Logger

        events := logger.Events{
                Error: func(ctx context.Context, r logger.Record) </span><span class="cov0" title="0">{ log.Info(ctx, "******* SEND ALERT ******") }</span>,
        }

        <span class="cov0" title="0">traceIDFn := func(ctx context.Context) string </span><span class="cov0" title="0">{
                return "00000000-0000-0000-0000-000000000000"
        }</span>

        <span class="cov0" title="0">log = logger.NewWithEvents(os.Stdout, logger.LevelInfo, "METRICS", traceIDFn, events)

        // -------------------------------------------------------------------------

        ctx := context.Background()

        if err := run(ctx, log); err != nil </span><span class="cov0" title="0">{
                log.Error(ctx, "startup", "err", err)
                os.Exit(1)
        }</span>
}

func run(ctx context.Context, log *logger.Logger) error <span class="cov0" title="0">{

        // -------------------------------------------------------------------------
        // GOMAXPROCS

        log.Info(ctx, "startup", "GOMAXPROCS", runtime.GOMAXPROCS(0))

        // -------------------------------------------------------------------------
        // Configuration

        cfg := struct {
                conf.Version
                Web struct {
                        DebugHost string `conf:"default:0.0.0.0:4010"`
                }
                Expvar struct {
                        Host            string        `conf:"default:0.0.0.0:4000"`
                        Route           string        `conf:"default:/metrics"`
                        ReadTimeout     time.Duration `conf:"default:5s"`
                        WriteTimeout    time.Duration `conf:"default:10s"`
                        IdleTimeout     time.Duration `conf:"default:120s"`
                        ShutdownTimeout time.Duration `conf:"default:5s"`
                }
                Prometheus struct {
                        Host            string        `conf:"default:0.0.0.0:4020"`
                        Route           string        `conf:"default:/metrics"`
                        ReadTimeout     time.Duration `conf:"default:5s"`
                        WriteTimeout    time.Duration `conf:"default:10s"`
                        IdleTimeout     time.Duration `conf:"default:120s"`
                        ShutdownTimeout time.Duration `conf:"default:5s"`
                }
                Collect struct {
                        From string `conf:"default:http://localhost:3010/debug/vars"`
                }
                Publish struct {
                        To       string        `conf:"default:console"`
                        Interval time.Duration `conf:"default:5s"`
                }
        }{
                Version: conf.Version{
                        Build: build,
                        Desc:  "copyright information here",
                },
        }

        const prefix = "METRICS"
        help, err := conf.Parse(prefix, &amp;cfg)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, conf.ErrHelpWanted) </span><span class="cov0" title="0">{
                        fmt.Println(help)
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("parsing config: %w", err)</span>
        }

        // -------------------------------------------------------------------------
        // App Starting

        <span class="cov0" title="0">log.Info(ctx, "starting service", "version", build)
        defer log.Info(ctx, "shutdown complete")

        out, err := conf.String(&amp;cfg)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("generating config for output: %w", err)
        }</span>
        <span class="cov0" title="0">log.Info(ctx, "startup", "config", out)

        log.BuildInfo(ctx)

        // -------------------------------------------------------------------------
        // Start Debug Service

        go func() </span><span class="cov0" title="0">{
                log.Info(ctx, "startup", "status", "debug router started", "host", cfg.Web.DebugHost)

                if err := http.ListenAndServe(cfg.Web.DebugHost, debug.Mux()); err != nil </span><span class="cov0" title="0">{
                        log.Error(ctx, "shutdown", "status", "debug router closed", "host", cfg.Web.DebugHost, "err", err)
                }</span>
        }()

        // -------------------------------------------------------------------------
        // Start Prometheus Service

        <span class="cov0" title="0">prom := prometheussrv.New(log, cfg.Prometheus.Host, cfg.Prometheus.Route, cfg.Prometheus.ReadTimeout, cfg.Prometheus.WriteTimeout, cfg.Prometheus.IdleTimeout)
        defer prom.Stop(cfg.Prometheus.ShutdownTimeout)

        // -------------------------------------------------------------------------
        // Start expvar Service

        exp := expvarsrv.New(log, cfg.Expvar.Host, cfg.Expvar.Route, cfg.Expvar.ReadTimeout, cfg.Expvar.WriteTimeout, cfg.Expvar.IdleTimeout)
        defer exp.Stop(cfg.Expvar.ShutdownTimeout)

        // -------------------------------------------------------------------------
        // Start collectors and publishers

        collector, err := collector.New(cfg.Collect.From)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("starting collector: %w", err)
        }</span>

        <span class="cov0" title="0">stdout := publisher.NewStdout(log)

        publish, err := publisher.New(log, collector, cfg.Publish.Interval, prom.Publish, exp.Publish, stdout.Publish)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("starting publisher: %w", err)
        }</span>
        <span class="cov0" title="0">defer publish.Stop()

        // -------------------------------------------------------------------------
        // Shutdown

        shutdown := make(chan os.Signal, 1)
        signal.Notify(shutdown, syscall.SIGINT, syscall.SIGTERM)
        &lt;-shutdown

        log.Info(ctx, "shutdown", "status", "shutdown started")
        defer log.Info(ctx, "shutdown", "status", "shutdown complete")

        return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Package datadog provides support for publishing metrics to DD.
package datadog

import (
        "bytes"
        "encoding/json"
        "fmt"
        "io"
        "log"
        "net"
        "net/http"
        "time"
)

// Datadog provides the ability to publish metrics to Datadog.
type Datadog struct {
        log    *log.Logger
        apiKey string
        host   string
        tr     *http.Transport
        client http.Client
}

// New initializes Datadog access for publishing metrics.
func New(log *log.Logger, apiKey string, host string) *Datadog <span class="cov0" title="0">{
        tr := http.Transport{
                Proxy: http.ProxyFromEnvironment,
                DialContext: (&amp;net.Dialer{
                        Timeout:   30 * time.Second,
                        KeepAlive: 30 * time.Second,
                }).DialContext,
                MaxIdleConns:          2,
                IdleConnTimeout:       90 * time.Second,
                TLSHandshakeTimeout:   10 * time.Second,
                ExpectContinueTimeout: 1 * time.Second,
        }

        d := Datadog{
                log:    log,
                apiKey: apiKey,
                host:   host,
                tr:     &amp;tr,
                client: http.Client{
                        Transport: &amp;tr,
                        Timeout:   1 * time.Second,
                },
        }

        return &amp;d
}</span>

// Publish handles the processing of metrics for deliver
// to the DataDog.
func (d *Datadog) Publish(data map[string]any) <span class="cov0" title="0">{
        doc, err := marshalDatadog(d.log, data)
        if err != nil </span><span class="cov0" title="0">{
                d.log.Println("datadog.publish :", err)
                return
        }</span>

        <span class="cov0" title="0">if err := sendDatadog(d, doc); err != nil </span><span class="cov0" title="0">{
                d.log.Println("datadog.publish :", err)
                return
        }</span>

        <span class="cov0" title="0">log.Println("datadog.publish : published :", string(doc))</span>
}

// marshalDatadog converts the data map to datadog JSON document.
func marshalDatadog(log *log.Logger, data map[string]any) ([]byte, error) <span class="cov0" title="0">{
        /*
                { "series" : [
                                {
                                        "metric":"test.metric",
                                        "points": [
                                                [
                                                        $currenttime,
                                                        20
                                                ]
                                        ],
                                        "type":"gauge",
                                        "host":"test.example.com",
                                        "tags": [
                                                "environment:test"
                                        ]
                                }
                        ]
                }
        */

        // Extract the base keys/values.
        mType := "gauge"
        host, ok := data["host"].(string)
        if !ok </span><span class="cov0" title="0">{
                host = "unknown"
        }</span>
        <span class="cov0" title="0">env := "dev"
        if host != "localhost" </span><span class="cov0" title="0">{
                env = "prod"
        }</span>
        <span class="cov0" title="0">envTag := "environment:" + env

        // Define the Datadog data format.
        type series struct {
                Metric string   `json:"metric"`
                Points [][]any  `json:"points"`
                Type   string   `json:"type"`
                Host   string   `json:"host"`
                Tags   []string `json:"tags"`
        }

        // Populate the data into the data structure.
        var doc struct {
                Series []series `json:"series"`
        }
        for key, value := range data </span><span class="cov0" title="0">{
                switch value.(type) </span>{
                case int, float64:<span class="cov0" title="0">
                        doc.Series = append(doc.Series, series{
                                Metric: env + "." + key,
                                Points: [][]any{{"$currenttime", value}},
                                Type:   mType,
                                Host:   host,
                                Tags:   []string{envTag},
                        })</span>
                }
        }

        // Convert the data into JSON.
        <span class="cov0" title="0">out, err := json.Marshal(doc)
        if err != nil </span><span class="cov0" title="0">{
                log.Println("datadog.publish : marshaling :", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return out, nil</span>
}

// sendDatadog sends data to the datadog servers.
func sendDatadog(d *Datadog, data []byte) error <span class="cov0" title="0">{
        url := fmt.Sprintf("%s?api_key=%s", d.host, d.apiKey)
        b := bytes.NewBuffer(data)

        r, err := http.NewRequest("POST", url, b)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">resp, err := d.client.Do(r)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusAccepted </span><span class="cov0" title="0">{
                out, err := io.ReadAll(resp.Body)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("status[%d] : %s", resp.StatusCode, out)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("status[%d]", resp.StatusCode)</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Package expvar manages the publishing of metrics to stdout.
package expvar

import (
        "context"
        "encoding/json"
        "fmt"
        "net/http"
        "sync"
        "time"

        "github.com/FITHSCS/backend/foundation/logger"
)

// Expvar provide our basic publishing.
type Expvar struct {
        log    *logger.Logger
        server http.Server
        data   map[string]any
        mu     sync.Mutex
}

// New starts a service for consuming the raw expvar stats.
func New(log *logger.Logger, host string, route string, readTimeout, writeTimeout time.Duration, idleTimeout time.Duration) *Expvar <span class="cov0" title="0">{
        mux := http.NewServeMux()
        exp := Expvar{
                log: log,
                server: http.Server{
                        Addr:         host,
                        Handler:      mux,
                        ReadTimeout:  readTimeout,
                        WriteTimeout: writeTimeout,
                        IdleTimeout:  idleTimeout,
                        ErrorLog:     logger.NewStdLogger(log, logger.LevelError),
                },
        }

        mux.HandleFunc(route, exp.handler)

        go func() </span><span class="cov0" title="0">{
                ctx := context.Background()

                log.Info(ctx, "expvar", "status", "API listening", "host", host)
                if err := exp.server.ListenAndServe(); err != nil </span><span class="cov0" title="0">{
                        log.Error(ctx, "expvar", "err", err)
                }</span>
        }()

        <span class="cov0" title="0">return &amp;exp</span>
}

// Stop shuts down the service.
func (exp *Expvar) Stop(shutdownTimeout time.Duration) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), shutdownTimeout)
        defer cancel()

        exp.log.Info(ctx, "expvar", "status", "start shutdown...")
        defer exp.log.Info(ctx, "expvar: Completed")

        if err := exp.server.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                exp.log.Error(ctx, "expvar", "status", "graceful shutdown did not complete", "err", err, "shutdownTimeout", shutdownTimeout)
                if err := exp.server.Close(); err != nil </span><span class="cov0" title="0">{
                        exp.log.Error(ctx, "expvar", "status", "could not stop http server", "err", err)
                }</span>
        }
}

// Publish is called by the publisher goroutine and saves the raw stats.
func (exp *Expvar) Publish(data map[string]any) <span class="cov0" title="0">{
        exp.mu.Lock()
        </span><span class="cov0" title="0">{
                exp.data = data
        }</span>
        <span class="cov0" title="0">exp.mu.Unlock()</span>
}

// handler is what consumers call to get the raw stats.
func (exp *Expvar) handler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := context.Background()

        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)

        var data map[string]any
        exp.mu.Lock()
        </span><span class="cov0" title="0">{
                data = exp.data
        }</span>
        <span class="cov0" title="0">exp.mu.Unlock()

        if err := json.NewEncoder(w).Encode(data); err != nil </span><span class="cov0" title="0">{
                exp.log.Error(ctx, "expvar", "status", "encoding data", "err", err)
        }</span>

        <span class="cov0" title="0">exp.log.Info(ctx, "expvar", "metrics", fmt.Sprintf("(%d) : %s %s -&gt; %s", http.StatusOK, r.Method, r.URL.Path, r.RemoteAddr))</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// Package prometheus provides suppoert for sending metrics to prometheus.
package prometheus

import (
        "context"
        "fmt"
        "io"
        "net/http"
        "sync"
        "time"

        "github.com/FITHSCS/backend/foundation/logger"
)

// Exporter implements the prometheus exporter support.
type Exporter struct {
        log    *logger.Logger
        server http.Server
        data   map[string]any
        mu     sync.Mutex
}

// New constructs an Exporter for use.
func New(log *logger.Logger, host string, route string, readTimeout, writeTimeout time.Duration, idleTimeout time.Duration) *Exporter <span class="cov0" title="0">{
        mux := http.NewServeMux()

        exp := Exporter{
                log: log,
                server: http.Server{
                        Addr:         host,
                        Handler:      mux,
                        ReadTimeout:  readTimeout,
                        WriteTimeout: writeTimeout,
                        IdleTimeout:  idleTimeout,
                        ErrorLog:     logger.NewStdLogger(log, logger.LevelError),
                },
        }

        mux.HandleFunc(route, exp.handler)

        go func() </span><span class="cov0" title="0">{
                ctx := context.Background()

                log.Info(ctx, "prometheus", "status", "API listening", "host", host)

                if err := exp.server.ListenAndServe(); err != nil </span><span class="cov0" title="0">{
                        log.Error(ctx, "prometheus", "err", err)
                }</span>
        }()

        <span class="cov0" title="0">return &amp;exp</span>
}

// Publish stores a deep copy of the data for publishing.
func (exp *Exporter) Publish(data map[string]any) <span class="cov0" title="0">{
        exp.mu.Lock()
        defer exp.mu.Unlock()

        exp.data = deepCopyMap(data)
}</span>

// Stop turns off all the prometheus support.
func (exp *Exporter) Stop(shutdownTimeout time.Duration) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), shutdownTimeout)
        defer cancel()

        exp.log.Info(ctx, "prometheus", "status", "start shutdown...")
        defer exp.log.Info(ctx, "prometheus: Completed")

        if err := exp.server.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                exp.log.Error(ctx, "prometheus", "status", "graceful shutdown did not complete", "err", err, "shutdownTimeout", shutdownTimeout)

                if err := exp.server.Close(); err != nil </span><span class="cov0" title="0">{
                        exp.log.Error(ctx, "prometheus", "status", "could not stop http server", "err", err)
                }</span>
        }
}

func (exp *Exporter) handler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := context.Background()

        w.Header().Set("Content-Type", "text/plain; version=0.0.4")
        w.WriteHeader(http.StatusOK)

        var data map[string]any
        exp.mu.Lock()
        </span><span class="cov0" title="0">{
                data = deepCopyMap(exp.data)
        }</span>
        <span class="cov0" title="0">exp.mu.Unlock()

        out(w, "", data)

        exp.log.Info(ctx, "prometheus", "metrics", fmt.Sprintf("expvar : (%d) : %s %s -&gt; %s", http.StatusOK, r.Method, r.URL.Path, r.RemoteAddr))</span>
}

func deepCopyMap(source map[string]any) map[string]any <span class="cov0" title="0">{
        result := make(map[string]any)

        for k, v := range source </span><span class="cov0" title="0">{
                switch vm := v.(type) </span>{
                case map[string]any:<span class="cov0" title="0">
                        result[k] = deepCopyMap(vm)</span>

                case int64:<span class="cov0" title="0">
                        result[k] = float64(vm)</span>

                case float64:<span class="cov0" title="0">
                        result[k] = vm</span>

                case bool:<span class="cov0" title="0">
                        result[k] = 0.0
                        if vm </span><span class="cov0" title="0">{
                                result[k] = 1.0
                        }</span>
                }
        }

        <span class="cov0" title="0">return result</span>
}

func out(w io.Writer, prefix string, data map[string]any) <span class="cov0" title="0">{
        if prefix != "" </span><span class="cov0" title="0">{
                prefix += "_"
        }</span>

        <span class="cov0" title="0">for k, v := range data </span><span class="cov0" title="0">{
                writeKey := fmt.Sprintf("%s%s", prefix, k)

                switch vm := v.(type) </span>{
                case float64:<span class="cov0" title="0">
                        fmt.Fprintf(w, "%s %.f\n", writeKey, vm)</span>

                case map[string]any:<span class="cov0" title="0">
                        out(w, writeKey, vm)</span>

                default:<span class="cov0" title="0"></span>
                        // Discard this value.
                }
        }
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// Package publisher manages the publishing of metrics.
package publisher

import (
        "context"
        "encoding/json"
        "sync"
        "time"

        "github.com/FITHSCS/backend/foundation/logger"
)

// Set of possible publisher types.
const (
        TypeStdout  = "stdout"
        TypeDatadog = "datadog"
)

// Collector defines a contract a collector must support
// so a consumer can retrieve metrics.
type Collector interface {
        Collect() (map[string]any, error)
}

// Publisher defines a handler function that will be called
// on each interval.
type Publisher func(map[string]any)

// Publish provides the ability to receive metrics
// on an interval.
type Publish struct {
        log       *logger.Logger
        collector Collector
        publisher []Publisher
        wg        sync.WaitGroup
        timer     *time.Timer
        shutdown  chan struct{}
}

// New creates a Publish for consuming and publishing metrics.
func New(log *logger.Logger, collector Collector, interval time.Duration, publisher ...Publisher) (*Publish, error) <span class="cov0" title="0">{
        p := Publish{
                log:       log,
                collector: collector,
                publisher: publisher,
                timer:     time.NewTimer(interval),
                shutdown:  make(chan struct{}),
        }

        p.wg.Add(1)
        go func() </span><span class="cov0" title="0">{
                defer p.wg.Done()
                for </span><span class="cov0" title="0">{
                        p.timer.Reset(interval)
                        select </span>{
                        case &lt;-p.timer.C:<span class="cov0" title="0">
                                p.update()</span>
                        case &lt;-p.shutdown:<span class="cov0" title="0">
                                return</span>
                        }
                }
        }()

        <span class="cov0" title="0">return &amp;p, nil</span>
}

// Stop is used to shut down the goroutine collecting metrics.
func (p *Publish) Stop() <span class="cov0" title="0">{
        close(p.shutdown)
        p.wg.Wait()
}</span>

// update pulls the metrics and publishes them to the specified system.
func (p *Publish) update() <span class="cov0" title="0">{
        data, err := p.collector.Collect()
        if err != nil </span><span class="cov0" title="0">{
                p.log.Error(context.Background(), "publish", "status", "collect data", "err", err)
                return
        }</span>

        <span class="cov0" title="0">for _, pub := range p.publisher </span><span class="cov0" title="0">{
                pub(data)
        }</span>
}

// Stdout provide our basic publishing.
type Stdout struct {
        log *logger.Logger
}

// NewStdout initializes stdout for publishing metrics.
func NewStdout(log *logger.Logger) *Stdout <span class="cov0" title="0">{
        return &amp;Stdout{log}
}</span>

// Publish publishers for writing to stdout.
func (s *Stdout) Publish(data map[string]any) <span class="cov0" title="0">{
        ctx := context.Background()

        rawJSON, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Error(ctx, "stdout", "status", "marshal data", "err", err)
                return
        }</span>

        <span class="cov0" title="0">var d map[string]any
        if err := json.Unmarshal(rawJSON, &amp;d); err != nil </span><span class="cov0" title="0">{
                s.log.Error(ctx, "stdout", "status", "unmarshal data", "err", err)
                return
        }</span>

        // Add heap value into the data set.
        <span class="cov0" title="0">memStats, ok := (d["memstats"]).(map[string]any)
        if ok </span><span class="cov0" title="0">{
                d["heap"] = memStats["Alloc"]
        }</span>

        // Remove unnecessary keys.
        <span class="cov0" title="0">delete(d, "memstats")
        delete(d, "cmdline")

        out, err := json.Marshal(d)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">s.log.Info(ctx, "stdout", "data", string(out))</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Package syncall binds all the routes into the specified app.
package syncall

import (
        "time"

        "github.com/FITHSCS/backend/app/domain/syncapp"
        "github.com/FITHSCS/backend/app/sdk/mux"
        "github.com/FITHSCS/backend/foundation/web"
        "github.com/segmentio/kafka-go"
)

// Routes constructs the add value which provides the implementation of
// RouteAdder for specifying what routes to bind to this instance.
func Routes() add <span class="cov0" title="0">{
        return add{}
}</span>

type add struct{}

// Add implements the RouterAdder interface.
func (add) Add(app *web.App, cfg mux.Config) <span class="cov0" title="0">{

        syncapp.Routes(app, syncapp.Config{
                Log:          cfg.Log,
                SyncBatchBus: cfg.BusConfig.SyncBatchBus,
                AuthClient:   cfg.AuthClientConfig.AuthClient,
                KafkaConfig: mux.KafkaConfig{
                        Brokers: cfg.KafkaConfig.Brokers,
                        Topic:   cfg.KafkaConfig.Topic,
                },
                KafkaRequiredAcks: kafka.RequireOne, //add default or get from cfg
                KafkaMaxAttempts:  3,                // add default or get from cfg
                KafkaTimeout:      10 * time.Second, // add default or get from cfg
        })
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package main

import (
    "context"
    "errors"
    "expvar"
    "fmt"
    "net/http"
    "os"
    "os/signal"
    "runtime"
    "syscall"
    "time"

    syncall "github.com/FITHSCS/backend/api/services/sync/build/all"
    "github.com/FITHSCS/backend/app/sdk/authclient"
    "github.com/FITHSCS/backend/app/sdk/debug"
    "github.com/FITHSCS/backend/app/sdk/mux"
    "github.com/FITHSCS/backend/foundation/logger"
    //"github.com/FITHSCS/backend/foundation/web"
    "github.com/FITHSCS/backend/business/domain/syncbatchbus"
    "github.com/FITHSCS/backend/business/domain/syncbatchbus/stores/syncbatchdb"
    "github.com/ardanlabs/conf/v3"
    "github.com/FITHSCS/backend/business/sdk/sqldb"
    "github.com/FITHSCS/backend/foundation/otel"
)

var build = "develop"

func main() <span class="cov0" title="0">{
    var log *logger.Logger
    
    events := logger.Events{
      Error: func(ctx context.Context, r logger.Record) </span><span class="cov0" title="0">{
        log.Info(ctx, "******* SEND ALERT *******")
      }</span>,
    }

    <span class="cov0" title="0">traceIDFn := func(ctx context.Context) string </span><span class="cov0" title="0">{
        return otel.GetTraceID(ctx)
    }</span>

    <span class="cov0" title="0">log = logger.NewWithEvents(os.Stdout, logger.LevelInfo, "SYNC", traceIDFn, events)

    ctx := context.Background()

    if err := run(ctx, log); err != nil </span><span class="cov0" title="0">{
        log.Error(ctx, "startup", "err", err)
        os.Exit(1)
    }</span>
}

func run(ctx context.Context, log *logger.Logger) error <span class="cov0" title="0">{
    // GOMAXPROCS
    log.Info(ctx, "startup", "GOMAXPROCS", runtime.GOMAXPROCS(0))

    // Configuration
    cfg := struct {
        conf.Version
        Web struct {
            ReadTimeout        time.Duration `conf:"default:5s"`
            WriteTimeout       time.Duration `conf:"default:10s"`
            IdleTimeout        time.Duration `conf:"default:120s"`
            ShutdownTimeout    time.Duration `conf:"default:20s"`
            APIHost            string        `conf:"default:0.0.0.0:8000"`
            DebugHost          string        `conf:"default:0.0.0.0:8010"`
            CORSAllowedOrigins []string      `conf:"default:*"`
        }
        Auth struct {
            Host string `conf:"default:http://0.0.0.0:6000"`
        }
        DB struct {
          User          string        `conf:"default:postgres"`
          Password      string        `conf:"default:postgres,mask"`
          Host          string        `conf:"default:sync-database"`
          Name          string        `conf:"default:postgres"`
          MaxIdleConns  int           `conf:"default:0"`
          MaxOpenConns  int           `conf:"default:0"`
          DisableTLS    bool          `conf:"default:true"`
        }
        Kafka struct {
            Brokers []string `conf:"default:localhost:9092"`
            Topic   string   `conf:"default:epod-persist"`
        }
    }{
        Version: conf.Version{
            Build: build,
            Desc:  "sync",
        },
    }

    const prefix = "SYNC"
    help, err := conf.Parse(prefix, &amp;cfg)
    if err != nil </span><span class="cov0" title="0">{
        if errors.Is(err, conf.ErrHelpWanted) </span><span class="cov0" title="0">{
            fmt.Println(help)
            return nil
        }</span>
        <span class="cov0" title="0">return fmt.Errorf("parsing config: %w", err)</span>
    }

    // App Starting
    <span class="cov0" title="0">log.Info(ctx, "starting service", "version", cfg.Build)
    defer log.Info(ctx, "shutdown complete")

    out, err := conf.String(&amp;cfg)
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("generating config for output: %w", err)
    }</span>
    <span class="cov0" title="0">log.Info(ctx, "startup", "config", out)

    log.BuildInfo(ctx)

    expvar.NewString("build").Set(cfg.Build)

    //&lt;============= Database ==================&gt;
    log.Info(ctx, "startup", "status", "initializing database support", "hostport", cfg.DB.Host)
    db ,err := sqldb.Open(sqldb.Config {
        User:           cfg.DB.User,
        Password:       cfg.DB.Password,
        Host:           cfg.DB.Host,
        Name:           cfg.DB.Name,
        MaxIdleConns:   cfg.DB.MaxIdleConns,
        MaxOpenConns:   cfg.DB.MaxOpenConns,
        DisableTLS:     cfg.DB.DisableTLS,
    })
    if err != nil </span><span class="cov0" title="0">{
        return fmt.Errorf("connecting to db: %w", err)
    }</span>
    <span class="cov0" title="0">defer db.Close()

    // Initialize authentication support
    log.Info(ctx, "startup", "status", "initializing authentication support")
    au := authclient.New(log, cfg.Auth.Host)
    //&lt;=============================Create the syncbatch bus ======================================&gt;

    syncbatchbus := syncbatchbus.NewBusiness(log, syncbatchdb.NewStore(log, db))

    // Start Debug Service
    go func() </span><span class="cov0" title="0">{
        log.Info(ctx, "startup", "status", "debug v1 router started", "host", cfg.Web.DebugHost)
        if err := http.ListenAndServe(cfg.Web.DebugHost, debug.Mux()); err != nil </span><span class="cov0" title="0">{
            log.Error(ctx, "shutdown", "status", "debug v1 router closed", "host", cfg.Web.DebugHost, "msg", err)
        }</span>
    }()

    // Start API Service
    <span class="cov0" title="0">log.Info(ctx, "startup", "status", "initializing V1 API support")

    shutdown := make(chan os.Signal, 1)
    signal.Notify(shutdown, syscall.SIGINT, syscall.SIGTERM)

    cfgMux := mux.Config{
        Build: build,
        Log:   log,
        BusConfig: mux.BusConfig{
            SyncBatchBus: syncbatchbus,
        },
        AuthClientConfig: mux.AuthClientConfig{
            AuthClient: au,
        },
        KafkaConfig: mux.KafkaConfig{
            Brokers: cfg.Kafka.Brokers,
            Topic:   cfg.Kafka.Topic,
        },
    }
    log.Info(ctx, "KafkaBroker", cfgMux.KafkaConfig.Brokers[0], "Kafka Topic", cfgMux.KafkaConfig.Topic)
    webAPI := mux.WebAPI(cfgMux, syncall.Routes(), mux.WithCORS(cfg.Web.CORSAllowedOrigins))

    api := http.Server{
        Addr:         cfg.Web.APIHost,
        Handler:      webAPI,
        ReadTimeout:  cfg.Web.ReadTimeout,
        WriteTimeout: cfg.Web.WriteTimeout,
        IdleTimeout:  cfg.Web.IdleTimeout,
        ErrorLog:     logger.NewStdLogger(log, logger.LevelError),
    }

    serverErrors := make(chan error, 1)

    go func() </span><span class="cov0" title="0">{
        log.Info(ctx, "startup", "status", "api router started", "host", api.Addr)
        serverErrors &lt;- api.ListenAndServe()
    }</span>()

    // Shutdown
    <span class="cov0" title="0">select </span>{
    case err := &lt;-serverErrors:<span class="cov0" title="0">
        return fmt.Errorf("server error: %w", err)</span>
    case sig := &lt;-shutdown:<span class="cov0" title="0">
        log.Info(ctx, "shutdown", "status", "shutdown started", "signal", sig)
        defer log.Info(ctx, "shutdown", "status", "shutdown complete", "signal", sig)

        ctx, cancel := context.WithTimeout(ctx, cfg.Web.ShutdownTimeout)
        defer cancel()

        if err := api.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
            api.Close()
            return fmt.Errorf("could not stop server gracefully: %w", err)
        }</span>
    }

    <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package commands

import (
        "crypto/rand"
        "crypto/rsa"
        "crypto/x509"
        "encoding/pem"
        "fmt"
        "os"
)

// GenKey creates an x509 private/public key for auth tokens.
func GenKey() error <span class="cov0" title="0">{

        // Generate a new private key.
        privateKey, err := rsa.GenerateKey(rand.Reader, 2048)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("generating key: %w", err)
        }</span>

        // Create a file for the private key information in PEM form.
        <span class="cov0" title="0">privateFile, err := os.Create("private.pem")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("creating private file: %w", err)
        }</span>
        <span class="cov0" title="0">defer privateFile.Close()

        // Construct a PEM block for the private key.
        privateBlock := pem.Block{
                Type:  "PRIVATE KEY",
                Bytes: x509.MarshalPKCS1PrivateKey(privateKey),
        }

        // Write the private key to the private key file.
        if err := pem.Encode(privateFile, &amp;privateBlock); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("encoding to private file: %w", err)
        }</span>

        // Create a file for the public key information in PEM form.
        <span class="cov0" title="0">publicFile, err := os.Create("public.pem")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("creating public file: %w", err)
        }</span>
        <span class="cov0" title="0">defer publicFile.Close()

        // Marshal the public key from the private key to PKIX.
        asn1Bytes, err := x509.MarshalPKIXPublicKey(&amp;privateKey.PublicKey)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("marshaling public key: %w", err)
        }</span>

        // Construct a PEM block for the public key.
        <span class="cov0" title="0">publicBlock := pem.Block{
                Type:  "PUBLIC KEY",
                Bytes: asn1Bytes,
        }

        // Write the public key to the public key file.
        if err := pem.Encode(publicFile, &amp;publicBlock); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("encoding to public file: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Println("private and public key files generated")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package commands

import (
        "context"
        "errors"
        "fmt"
        "time"

        "github.com/FITHSCS/backend/business/sdk/migrate"
        "github.com/FITHSCS/backend/business/sdk/sqldb"
)

// ErrHelp provides context that help was given.
var ErrHelp = errors.New("provided help")

// Migrate creates the schema in the database.
func Migrate(cfg sqldb.Config) error <span class="cov0" title="0">{
        db, err := sqldb.Open(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("connect database: %w", err)
        }</span>
        <span class="cov0" title="0">defer db.Close()

        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        if err := migrate.Migrate(ctx, db); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("migrate database: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Println("migrations complete")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package commands

import (
        "context"
        "fmt"
        "time"

        "github.com/FITHSCS/backend/business/sdk/migrate"
        "github.com/FITHSCS/backend/business/sdk/sqldb"
)

// Seed loads test data into the database.
func Seed(cfg sqldb.Config) error <span class="cov0" title="0">{
        db, err := sqldb.Open(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("connect database: %w", err)
        }</span>
        <span class="cov0" title="0">defer db.Close()

        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        if err := migrate.Seed(ctx, db); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("seed database: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Println("seed data complete")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package commands

import (
        "context"
        "fmt"
        "net/mail"
        "time"

        "github.com/FITHSCS/backend/business/domain/userbus"
        "github.com/FITHSCS/backend/business/domain/userbus/stores/userdb"
        "github.com/FITHSCS/backend/business/sdk/sqldb"
        "github.com/FITHSCS/backend/business/types/name"
        "github.com/FITHSCS/backend/business/types/role"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/google/uuid"
)

// UserAdd adds new users into the database.
func UserAdd(log *logger.Logger, cfg sqldb.Config, nme string, email string, password string) error <span class="cov0" title="0">{
        if nme == "" || email == "" || password == "" </span><span class="cov0" title="0">{
                fmt.Println("help: useradd &lt;name&gt; &lt;email&gt; &lt;password&gt;")
                return ErrHelp
        }</span>

        <span class="cov0" title="0">db, err := sqldb.Open(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("connect database: %w", err)
        }</span>
        <span class="cov0" title="0">defer db.Close()

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        userBus := userbus.NewBusiness(log, userdb.NewStore(log, db))

        addr, err := mail.ParseAddress(email)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("parsing email: %w", err)
        }</span>

        <span class="cov0" title="0">nu := userbus.NewUser{
                Name:     name.MustParse(nme),
                Email:    *addr,
                Password: password,
                Roles:    []role.Role{role.Admin, role.User},
        }

        usr, err := userBus.Create(ctx, uuid.UUID{}, nu)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("create user: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Println("user id:", usr.ID)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package main

import (
        "context"
        "errors"
        "fmt"
        "io"
        "os"

        "github.com/FITHSCS/backend/api/tooling/admin/commands"
        "github.com/FITHSCS/backend/business/sdk/sqldb"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/ardanlabs/conf/v3"
)

var build = "develop"

type config struct {
        conf.Version
        Args conf.Args
        DB   struct {
                User         string `conf:"default:postgres"`
                Password     string `conf:"default:postgres,mask"`
                Host         string `conf:"default:database"`
                Name         string `conf:"default:postgres"`
                MaxIdleConns int    `conf:"default:0"`
                MaxOpenConns int    `conf:"default:0"`
                DisableTLS   bool   `conf:"default:true"`
        }
        Auth struct {
                KeysFolder string `conf:"default:zarf/keys/"`
                DefaultKID string `conf:"default:54bb2165-71e1-41a6-af3e-7da4a0e1e2c1"`
        }
}

func main() <span class="cov0" title="0">{
        log := logger.New(io.Discard, logger.LevelInfo, "ADMIN", func(context.Context) string </span><span class="cov0" title="0">{ return "00000000-0000-0000-0000-000000000000" }</span>)

        <span class="cov0" title="0">if err := run(log); err != nil </span><span class="cov0" title="0">{
                if !errors.Is(err, commands.ErrHelp) </span><span class="cov0" title="0">{
                        fmt.Println("msg", err)
                }</span>
                <span class="cov0" title="0">os.Exit(1)</span>
        }
}

func run(log *logger.Logger) error <span class="cov0" title="0">{
        cfg := config{
                Version: conf.Version{
                        Build: build,
                        Desc:  "copyright information here",
                },
        }

        const prefix = "CORE"
        help, err := conf.Parse(prefix, &amp;cfg)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, conf.ErrHelpWanted) </span><span class="cov0" title="0">{
                        fmt.Println(help)
                        return nil
                }</span>

                <span class="cov0" title="0">out, err := conf.String(&amp;cfg)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("generating config for output: %w", err)
                }</span>
                <span class="cov0" title="0">log.Info(context.Background(), "startup", "config", out)

                return fmt.Errorf("parsing config: %w", err)</span>
        }

        <span class="cov0" title="0">return processCommands(cfg.Args, log, cfg)</span>
}

// processCommands handles the execution of the commands specified on
// the command line.
func processCommands(args conf.Args, log *logger.Logger, cfg config) error <span class="cov0" title="0">{
        dbConfig := sqldb.Config{
                User:         cfg.DB.User,
                Password:     cfg.DB.Password,
                Host:         cfg.DB.Host,
                Name:         cfg.DB.Name,
                MaxIdleConns: cfg.DB.MaxIdleConns,
                MaxOpenConns: cfg.DB.MaxOpenConns,
                DisableTLS:   cfg.DB.DisableTLS,
        }

        switch args.Num(0) </span>{
        case "migrate":<span class="cov0" title="0">
                if err := commands.Migrate(dbConfig); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("migrating database: %w", err)
                }</span>

        case "seed":<span class="cov0" title="0">
                if err := commands.Seed(dbConfig); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("seeding database: %w", err)
                }</span>

        case "migrate-seed":<span class="cov0" title="0">
                if err := commands.Migrate(dbConfig); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("migrating database: %w", err)
                }</span>
                <span class="cov0" title="0">if err := commands.Seed(dbConfig); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("seeding database: %w", err)
                }</span>

        case "useradd":<span class="cov0" title="0">
                name := args.Num(1)
                email := args.Num(2)
                password := args.Num(3)
                if err := commands.UserAdd(log, dbConfig, name, email, password); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("adding user: %w", err)
                }</span>

        default:<span class="cov0" title="0">
                fmt.Println("migrate:    create the schema in the database")
                fmt.Println("seed:       add data to the database")
                fmt.Println("useradd:    add a new user to the database")
                return commands.ErrHelp</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">// This program takes the structured log output and makes it readable.
package main

import (
        "bufio"
        "encoding/json"
        "flag"
        "fmt"
        "log"
        "os"
        "os/signal"
        "strings"
        "syscall"
)

var service string

func init() <span class="cov0" title="0">{
        flag.StringVar(&amp;service, "service", "", "filter which service to see")

        shutdown := make(chan os.Signal, 1)
        signal.Notify(shutdown, syscall.SIGINT)
        syscall.Kill(os.Getppid(), syscall.SIGINT)
}</span>

func main() <span class="cov0" title="0">{
        flag.Parse()
        var b strings.Builder

        service := strings.ToLower(service)

        scanner := bufio.NewScanner(os.Stdin)
        for scanner.Scan() </span><span class="cov0" title="0">{
                s := scanner.Text()

                m := make(map[string]any)
                err := json.Unmarshal([]byte(s), &amp;m)
                if err != nil </span><span class="cov0" title="0">{
                        if service == "" </span><span class="cov0" title="0">{
                                fmt.Println(s)
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                // If a service filter was provided, check.
                <span class="cov0" title="0">if service != "" &amp;&amp; strings.ToLower(m["service"].(string)) != service </span><span class="cov0" title="0">{
                        continue</span>
                }

                // I like always having a traceid present in the logs.
                <span class="cov0" title="0">traceID := "00000000-0000-0000-0000-000000000000"
                if v, ok := m["trace_id"]; ok </span><span class="cov0" title="0">{
                        traceID = fmt.Sprintf("%v", v)
                }</span>

                // {"time":"2023-06-01T17:21:11.13704718Z","level":"INFO","msg":"startup","service":"SALES-API","GOMAXPROCS":1}

                // Build out the know portions of the log in the order
                // I want them in.
                <span class="cov0" title="0">b.Reset()
                b.WriteString(fmt.Sprintf("%s: %s: %s: %s: %s: %s: ",
                        m["service"],
                        m["time"],
                        m["file"],
                        m["level"],
                        traceID,
                        m["msg"],
                ))

                // Add the rest of the keys ignoring the ones we already
                // added for the log.
                for k, v := range m </span><span class="cov0" title="0">{
                        switch k </span>{
                        case "service", "time", "file", "level", "trace_id", "msg":<span class="cov0" title="0">
                                continue</span>
                        }

                        // It's nice to see the key[value] in this format
                        // especially since map ordering is random.
                        <span class="cov0" title="0">b.WriteString(fmt.Sprintf("%s[%v]: ", k, v))</span>
                }

                // Write the new log format, removing the last :
                <span class="cov0" title="0">out := b.String()
                fmt.Println(out[:len(out)-2])</span>
        }

        <span class="cov0" title="0">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                log.Println(err)
        }</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">// Package auditapp maintains the app layer api for the audit domain.
package auditapp

import (
        "context"
        "net/http"

        "github.com/FITHSCS/backend/app/sdk/errs"
        "github.com/FITHSCS/backend/app/sdk/query"
        "github.com/FITHSCS/backend/business/domain/auditbus"
        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/foundation/web"
)

type app struct {
        auditBus *auditbus.Business
}

func newApp(auditBus *auditbus.Business) *app <span class="cov0" title="0">{
        return &amp;app{
                auditBus: auditBus,
        }
}</span>

func (a *app) query(ctx context.Context, r *http.Request) web.Encoder <span class="cov0" title="0">{
        qp, err := parseQueryParams(r)
        if err != nil </span><span class="cov0" title="0">{
                return errs.New(errs.InvalidArgument, err)
        }</span>

        <span class="cov0" title="0">page, err := page.Parse(qp.Page, qp.Rows)
        if err != nil </span><span class="cov0" title="0">{
                return errs.NewFieldErrors("page", err)
        }</span>

        <span class="cov0" title="0">filter, err := parseFilter(qp)
        if err != nil </span><span class="cov0" title="0">{
                return err.(*errs.Error)
        }</span>

        <span class="cov0" title="0">orderBy, err := order.Parse(orderByFields, qp.OrderBy, auditbus.DefaultOrderBy)
        if err != nil </span><span class="cov0" title="0">{
                return errs.NewFieldErrors("order", err)
        }</span>

        <span class="cov0" title="0">adts, err := a.auditBus.Query(ctx, filter, orderBy, page)
        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "query: %s", err)
        }</span>

        <span class="cov0" title="0">total, err := a.auditBus.Count(ctx, filter)
        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "count: %s", err)
        }</span>

        <span class="cov0" title="0">return query.NewResult(toAppAudits(adts), total, page)</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package auditapp

import (
        "net/http"
        "time"

        "github.com/FITHSCS/backend/app/sdk/errs"
        "github.com/FITHSCS/backend/business/domain/auditbus"
        "github.com/FITHSCS/backend/business/types/domain"
        "github.com/FITHSCS/backend/business/types/name"
        "github.com/google/uuid"
)

type queryParams struct {
        Page      string
        Rows      string
        OrderBy   string
        ObjID     string
        ObjDomain string
        ObjName   string
        ActorID   string
        Action    string
        Since     string
        Until     string
}

func parseQueryParams(r *http.Request) (queryParams, error) <span class="cov0" title="0">{
        values := r.URL.Query()

        filter := queryParams{
                Page:      values.Get("page"),
                Rows:      values.Get("rows"),
                OrderBy:   values.Get("orderBy"),
                ObjID:     values.Get("obj_id"),
                ObjDomain: values.Get("obj_domain"),
                ObjName:   values.Get("obj_name"),
                ActorID:   values.Get("actor_id"),
                Action:    values.Get("action"),
                Since:     values.Get("since"),
                Until:     values.Get("until"),
        }

        return filter, nil
}</span>

func parseFilter(qp queryParams) (auditbus.QueryFilter, error) <span class="cov0" title="0">{
        var fieldErrors errs.FieldErrors
        var filter auditbus.QueryFilter

        if qp.ObjID != "" </span><span class="cov0" title="0">{
                id, err := uuid.Parse(qp.ObjID)
                switch err </span>{
                case nil:<span class="cov0" title="0">
                        filter.ObjID = &amp;id</span>
                default:<span class="cov0" title="0">
                        fieldErrors.Add("obj_id", err)</span>
                }
        }

        <span class="cov0" title="0">if qp.ObjDomain != "" </span><span class="cov0" title="0">{
                domain, err := domain.Parse(qp.ObjDomain)
                switch err </span>{
                case nil:<span class="cov0" title="0">
                        filter.ObjDomain = &amp;domain</span>
                default:<span class="cov0" title="0">
                        fieldErrors.Add("obj_domain", err)</span>
                }
        }

        <span class="cov0" title="0">if qp.ObjName != "" </span><span class="cov0" title="0">{
                name, err := name.Parse(qp.ObjName)
                switch err </span>{
                case nil:<span class="cov0" title="0">
                        filter.ObjName = &amp;name</span>
                default:<span class="cov0" title="0">
                        fieldErrors.Add("obj_name", err)</span>
                }
        }

        <span class="cov0" title="0">if qp.ActorID != "" </span><span class="cov0" title="0">{
                id, err := uuid.Parse(qp.ActorID)
                switch err </span>{
                case nil:<span class="cov0" title="0">
                        filter.ActorID = &amp;id</span>
                default:<span class="cov0" title="0">
                        fieldErrors.Add("actor_id", err)</span>
                }
        }

        <span class="cov0" title="0">if qp.Action != "" </span><span class="cov0" title="0">{
                filter.Action = &amp;qp.Action
        }</span>

        <span class="cov0" title="0">if qp.Since != "" </span><span class="cov0" title="0">{
                t, err := time.Parse(time.RFC3339, qp.Since)
                switch err </span>{
                case nil:<span class="cov0" title="0">
                        filter.Since = &amp;t</span>
                default:<span class="cov0" title="0">
                        fieldErrors.Add("since", err)</span>
                }
        }

        <span class="cov0" title="0">if qp.Until != "" </span><span class="cov0" title="0">{
                t, err := time.Parse(time.RFC3339, qp.Until)
                switch err </span>{
                case nil:<span class="cov0" title="0">
                        filter.Until = &amp;t</span>
                default:<span class="cov0" title="0">
                        fieldErrors.Add("until", err)</span>
                }
        }

        <span class="cov0" title="0">if fieldErrors != nil </span><span class="cov0" title="0">{
                return auditbus.QueryFilter{}, fieldErrors.ToError()
        }</span>

        <span class="cov0" title="0">return filter, nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package auditapp

import (
        "encoding/json"
        "time"

        "github.com/FITHSCS/backend/business/domain/auditbus"
)

// Audit represents information about an individual audit record.
type Audit struct {
        ID        string
        ObjID     string
        ObjDomain string
        ObjName   string
        ActorID   string
        Action    string
        Data      string
        Message   string
        Timestamp string
}

// Encode implements the encoder interface.
func (app Audit) Encode() ([]byte, string, error) <span class="cov0" title="0">{
        data, err := json.Marshal(app)
        return data, "application/json", err
}</span>

func toAppAudit(bus auditbus.Audit) Audit <span class="cov0" title="0">{
        return Audit{
                ID:        bus.ID.String(),
                ObjID:     bus.ObjID.String(),
                ObjDomain: bus.ObjDomain.String(),
                ObjName:   bus.ObjName.String(),
                ActorID:   bus.ActorID.String(),
                Action:    bus.Action,
                Data:      string(bus.Data),
                Message:   bus.Message,
                Timestamp: bus.Timestamp.Format(time.RFC3339),
        }
}</span>

func toAppAudits(audits []auditbus.Audit) []Audit <span class="cov0" title="0">{
        app := make([]Audit, len(audits))
        for i, adt := range audits </span><span class="cov0" title="0">{
                app[i] = toAppAudit(adt)
        }</span>

        <span class="cov0" title="0">return app</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package auditapp

import (
        "net/http"

        "github.com/FITHSCS/backend/app/sdk/authclient"
        "github.com/FITHSCS/backend/app/sdk/mid"
        "github.com/FITHSCS/backend/business/domain/auditbus"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/FITHSCS/backend/foundation/web"
)

// Config contains all the mandatory systems required by handlers.
type Config struct {
        Log        *logger.Logger
        AuditBus   *auditbus.Business
        AuthClient *authclient.Client
}

// Routes adds specific routes for this group.
func Routes(app *web.App, cfg Config) <span class="cov0" title="0">{
        const version = "v1"

        authen := mid.Authenticate(cfg.AuthClient)

        api := newApp(cfg.AuditBus)

        app.HandlerFunc(http.MethodGet, version, "/audits", api.query, authen)
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">// Package authapp maintains the web based api for auth access.
package authapp

import (
        "context"
        "errors"
        "net/http"

        "github.com/FITHSCS/backend/app/sdk/auth"
        "github.com/FITHSCS/backend/app/sdk/authclient"
        "github.com/FITHSCS/backend/app/sdk/errs"
        "github.com/FITHSCS/backend/app/sdk/mid"
        "github.com/FITHSCS/backend/foundation/web"
)

type app struct {
        auth *auth.Auth
}

func newApp(ath *auth.Auth) *app <span class="cov0" title="0">{
        return &amp;app{
                auth: ath,
        }
}</span>

func (a *app) token(ctx context.Context, r *http.Request) web.Encoder <span class="cov0" title="0">{
        kid := web.Param(r, "kid")
        if kid == "" </span><span class="cov0" title="0">{
                return errs.NewFieldErrors("kid", errors.New("missing kid"))
        }</span>

        // The BearerBasic middleware function generates the claims.
        <span class="cov0" title="0">claims := mid.GetClaims(ctx)

        tkn, err := a.auth.GenerateToken(kid, claims)
        if err != nil </span><span class="cov0" title="0">{
                return errs.New(errs.Internal, err)
        }</span>

        <span class="cov0" title="0">return token{Token: tkn}</span>
}

func (a *app) authenticate(ctx context.Context, r *http.Request) web.Encoder <span class="cov0" title="0">{
        // The middleware is actually handling the authentication. So if the code
        // gets to this handler, authentication passed.

        userID, err := mid.GetUserID(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return errs.New(errs.Unauthenticated, err)
        }</span>

        <span class="cov0" title="0">resp := authclient.AuthenticateResp{
                UserID: userID,
                Claims: mid.GetClaims(ctx),
        }

        return resp</span>
}

func (a *app) authorize(ctx context.Context, r *http.Request) web.Encoder <span class="cov0" title="0">{
        var auth authclient.Authorize
        if err := web.Decode(r, &amp;auth); err != nil </span><span class="cov0" title="0">{
                return errs.New(errs.InvalidArgument, err)
        }</span>

        <span class="cov0" title="0">if err := a.auth.Authorize(ctx, auth.Claims, auth.UserID, auth.Rule); err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Unauthenticated, "authorize: you are not authorized for that action, claims[%v] rule[%v]: %s", auth.Claims.Roles, auth.Rule, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package authapp

import "encoding/json"

type token struct {
        Token string `json:"token"`
}

// Encode implements the encoder interface.
func (t token) Encode() ([]byte, string, error) <span class="cov0" title="0">{
        data, err := json.Marshal(t)
        return data, "application/json", err
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package authapp

import (
        "net/http"

        "github.com/FITHSCS/backend/app/sdk/auth"
        "github.com/FITHSCS/backend/app/sdk/mid"
        "github.com/FITHSCS/backend/business/domain/userbus"
        "github.com/FITHSCS/backend/foundation/web"
)

type Config struct {
        UserBus userbus.ExtBusiness
        Auth    *auth.Auth
}

// Routes adds specific routes for this group.
func Routes(app *web.App, cfg Config) <span class="cov0" title="0">{
        const version = "v1"

        bearer := mid.Bearer(cfg.Auth)
        basic := mid.Basic(cfg.Auth, cfg.UserBus)

        api := newApp(cfg.Auth)

        app.HandlerFunc(http.MethodGet, version, "/auth/token/{kid}", api.token, basic)
        app.HandlerFunc(http.MethodGet, version, "/auth/authenticate", api.authenticate, bearer)
        app.HandlerFunc(http.MethodPost, version, "/auth/authorize", api.authorize)
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">// Package consumerapp maintains the app layer api for the consumerapp domain.
package consumerapp

import (
        "context"
        "reflect"
        "strings"

        //"encoding/json"
        "fmt"
        "io"
        "sync"
        "time"

        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/segmentio/kafka-go"

        "github.com/FITHSCS/backend/business/domain/facilitybus"
        "github.com/FITHSCS/backend/business/domain/gpstrackingbus"
        "github.com/FITHSCS/backend/business/domain/manifestbus"
        "github.com/FITHSCS/backend/business/domain/pickupbatchbus"
        "github.com/FITHSCS/backend/business/domain/signaturebus"
        "github.com/FITHSCS/backend/business/domain/userbus"
        "github.com/FITHSCS/backend/business/domain/vehiclebus"
)

/*

  Please write the logic that validates those that have been processed
  and are part of the response of the server so that we can use that
  on the mobile side to process and make sure those data are sent back


*/

type Config struct {
        Log         *logger.Logger
        KafkaConfig KafkaConfig
        WorkerCount int
        QueueSize   int

        //Business Layer
        UserBus        userbus.ExtBusiness
        FacilityBus    *facilitybus.Business
        VehicleBus     *vehiclebus.Business
        PickupBatchBus *pickupbatchbus.Business
        ManifestBus    *manifestbus.Business
        GpsTrackingBus *gpstrackingbus.Business
        SignatureBus   *signaturebus.Business
}

type KafkaConfig struct {
        Brokers []string
        Topic   string
        GroupID string
}

type App struct {
        log             *logger.Logger
        kafkaReader     *kafka.Reader
        processingQueue chan NewBatch
        shutdown        chan struct{}
        wg              sync.WaitGroup
        started         bool
        mu              sync.Mutex

        //Business Layer
        UserBus        userbus.ExtBusiness
        FacilityBus    *facilitybus.Business
        VehicleBus     *vehiclebus.Business
        PickupBatchBus *pickupbatchbus.Business
        ManifestBus    *manifestbus.Business
        GpsTrackingBus *gpstrackingbus.Business
        SignatureBus   *signaturebus.Business
}

func New(cfg Config) *App <span class="cov0" title="0">{

        kafkaReader := kafka.NewReader(kafka.ReaderConfig{
                Brokers:        cfg.KafkaConfig.Brokers,
                Topic:          cfg.KafkaConfig.Topic,
                GroupID:        cfg.KafkaConfig.GroupID,
                MinBytes:       1e3,
                MaxBytes:       10e6,
                StartOffset:    kafka.LastOffset,
                MaxWait:        1 * time.Millisecond,
                CommitInterval: 1 * time.Second,
        })

        processingQueue := make(chan NewBatch, cfg.QueueSize)

        app := &amp;App{

                log:             cfg.Log,
                kafkaReader:     kafkaReader,
                processingQueue: processingQueue,
                shutdown:        make(chan struct{}),
                UserBus:         cfg.UserBus,
                FacilityBus:     cfg.FacilityBus,
                VehicleBus:      cfg.VehicleBus,
                PickupBatchBus:  cfg.PickupBatchBus,
                ManifestBus:     cfg.ManifestBus,
                GpsTrackingBus:  cfg.GpsTrackingBus,
                SignatureBus:    cfg.SignatureBus,
        }
        return app
}</span>

func (a *App) Start(ctx context.Context) error <span class="cov0" title="0">{

        a.mu.Lock()
        defer a.mu.Unlock()

        if a.started </span><span class="cov0" title="0">{
                return fmt.Errorf("consumer already started")
        }</span>
        <span class="cov0" title="0">if err := a.waitForKafkaReady(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("kafka not ready: %w", err)
        }</span>
        <span class="cov0" title="0">a.log.Info(ctx, "starting kafka consumer", "workers", len(a.processingQueue))

        //we are starting consumer workers (one per partition, e.g, in our case we are using 6 partitiins)
        workerCount := 6
        for i := 0; i &lt; workerCount; i++ </span><span class="cov0" title="0">{
                a.wg.Add(1) //one additional goroutine created and notfied to wg
                go a.consumeFromKafka(ctx, i)
        }</span>

        //start the processing workers ==&gt; this basically read what the kafka consumers output
        <span class="cov0" title="0">for i := 0; i &lt; workerCount; i++ </span><span class="cov0" title="0">{
                a.wg.Add(1)
                go a.processMessages(ctx)
        }</span>
        <span class="cov0" title="0">a.started = true
        a.log.Info(ctx, "kafka consumer started sucessfully")
        return nil</span>
}

/*
func (a *App) waitForKafkaReady(ctx context.Context) error {

    maxRetries := 60
    retryInterval := 3 * time.Second

    for i := 0; i &lt; maxRetries; i++ {
      conn, err := kafka.Dial("tcp", a.kafkaReader.Config().Brokers[0])
      if err != nil {
          a.log.Warn(ctx, "Kafka connection failed, retrying", "attempt", i+1, "error", err)
        time.Sleep(retryInterval)
        continue
      }
      partitions, err := conn.ReadPartitions(a.kafkaReader.Config().Topic)
      conn.Close()

      if err != nil {
          a.log.Warn(ctx, "kafka topic not ready, retrying", "attempt", i+1, "topic", a.kafkaReader.Config().Topic, "error", err)
          time.Sleep(retryInterval)
          continue
      }
      if len(partitions) &gt; 0 {
        a.log.Info(ctx, "kafka ready", "topic", a.kafkaReader.Config().Topic, "partitions", len(partitions))
        return nil
      }
      time.Sleep(retryInterval)

    }
    return fmt.Errorf("kafka not ready after %d attempts", maxRetries)
}
*/

func (a *App) waitForKafkaReady(ctx context.Context) error <span class="cov0" title="0">{
        maxRetries := 60
        retryInterval := 3 * time.Second

        a.log.Info(ctx, "checking kafka readiness", "brokers", a.kafkaReader.Config().Brokers, "topic", a.kafkaReader.Config().Topic)

        for i := 0; i &lt; maxRetries; i++ </span><span class="cov0" title="0">{
                // Step 1: Check broker connectivity
                conn, err := kafka.Dial("tcp", a.kafkaReader.Config().Brokers[0])
                if err != nil </span><span class="cov0" title="0">{
                        a.log.Warn(ctx, "kafka broker connection failed", "attempt", i+1, "error", err)
                        time.Sleep(retryInterval)
                        continue</span>
                }

                // Step 2: Check topic exists and has partitions
                <span class="cov0" title="0">partitions, err := conn.ReadPartitions(a.kafkaReader.Config().Topic)
                if err != nil </span><span class="cov0" title="0">{
                        conn.Close()
                        a.log.Warn(ctx, "kafka topic not ready", "attempt", i+1, "topic", a.kafkaReader.Config().Topic, "error", err)
                        time.Sleep(retryInterval)
                        continue</span>
                }

                <span class="cov0" title="0">if len(partitions) == 0 </span><span class="cov0" title="0">{
                        conn.Close()
                        a.log.Warn(ctx, "kafka topic has no partitions", "attempt", i+1, "topic", a.kafkaReader.Config().Topic)
                        time.Sleep(retryInterval)
                        continue</span>
                }

                <span class="cov0" title="0">conn.Close()

                // Step 3: Test consumer group coordinator functionality
                if err := a.testConsumerGroupCoordinator(ctx); err != nil </span><span class="cov0" title="0">{
                        a.log.Warn(ctx, "kafka coordinator not ready", "attempt", i+1, "error", err)
                        time.Sleep(retryInterval)
                        continue</span>
                }

                <span class="cov0" title="0">a.log.Info(ctx, "kafka ready", "partitions", len(partitions), "topic", a.kafkaReader.Config().Topic)
                return nil</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("kafka not ready after %d attempts", maxRetries)</span>
}

func (a *App) testConsumerGroupCoordinator(ctx context.Context) error <span class="cov0" title="0">{
        testGroupID := a.kafkaReader.Config().GroupID + "-readiness-test"

        testReader := kafka.NewReader(kafka.ReaderConfig{
                Brokers:        a.kafkaReader.Config().Brokers,
                Topic:          a.kafkaReader.Config().Topic,
                GroupID:        testGroupID,
                MinBytes:       1,
                MaxBytes:       1e3,
                StartOffset:    kafka.LastOffset,
                MaxWait:        1 * time.Second,
                CommitInterval: 1 * time.Second,
        })
        defer testReader.Close()

        // Test with short timeout - we don't expect messages, just testing coordinator
        testCtx, cancel := context.WithTimeout(ctx, 5*time.Second)
        defer cancel()

        _, err := testReader.ReadMessage(testCtx)

        // We expect timeout or no messages - coordinator errors are what we're checking for
        if err != nil &amp;&amp; a.isCoordinatorError(err) </span><span class="cov0" title="0">{
                return fmt.Errorf("coordinator not ready: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// this is concerneed with reading from the kafka broker and as a result of the goroutine we have different consumer
// per partition
func (a *App) consumeFromKafka(ctx context.Context, workerID int) <span class="cov0" title="0">{

        defer a.wg.Done()
        backoff := time.Second
        maxBackoff := 30 * time.Second
        coordinatorRetries := 0
        maxCoordinatorRetries := 15
        consecutiveErrors := 0
        maxConsecutiveErrors := 10
        a.log.Info(ctx, "starting kafka consumer worker", "worker_id", workerID)

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-a.shutdown:<span class="cov0" title="0">
                        a.log.Info(ctx, "kafka consumer worker shutting down", "worker_id", workerID)
                        return</span>
                default:<span class="cov0" title="0">
                        //Reading message from kafka
                        //ctx, cancel := context.WithTimeout(ctx, 10 * time.Second)
                        msg, err := a.kafkaReader.ReadMessage(ctx)
                        if err != nil </span><span class="cov0" title="0">{
                                if err == context.Canceled || err == io.EOF || strings.Contains(err.Error(), "EOF") </span><span class="cov0" title="0">{
                                        a.log.Info(ctx, "Kafka reader closed, stopping consumer")
                                        return
                                }</span>

                                <span class="cov0" title="0">if a.isCoordinatorError(err) </span><span class="cov0" title="0">{
                                        coordinatorRetries++
                                        consecutiveErrors++

                                        if coordinatorRetries &gt; maxCoordinatorRetries </span><span class="cov0" title="0">{
                                                a.log.Error(ctx, "max coordinator retries exceeded, stopping worker",
                                                        "worker_id", workerID, "retries", coordinatorRetries)
                                                return
                                        }</span>

                                        <span class="cov0" title="0">a.log.Warn(ctx, "group coordinator not available, retrying", "worker_id", workerID, "backoff", backoff, "retry", coordinatorRetries)
                                        time.Sleep(backoff)
                                        backoff = min(backoff*2, maxBackoff)
                                        continue</span>
                                }
                                <span class="cov0" title="0">consecutiveErrors++
                                if consecutiveErrors &gt; maxConsecutiveErrors </span><span class="cov0" title="0">{
                                        a.log.Error(ctx, "too many consecutive errors, stopping worker",
                                                "worker_id", workerID, "consecutive_errors", consecutiveErrors)
                                        return
                                }</span>
                                <span class="cov0" title="0">a.log.Error(ctx, "error reading from kafka", "worker_id", workerID, "err", err)
                                time.Sleep(backoff)
                                backoff = min(backoff*2, maxBackoff)
                                continue</span>

                        }
                        //we are going to deseralize the abatch
                        <span class="cov0" title="0">backoff = time.Second
                        consecutiveErrors = 0
                        coordinatorRetries = 0

                        var batch NewBatch
                        if err := batch.Decode(msg.Value); err != nil </span><span class="cov0" title="0">{
                                a.log.Error(ctx, "failed to decode batch", "err", err, "message", string(msg.Value))
                                continue</span>
                        }
                        <span class="cov0" title="0">a.log.Info(ctx, "recieved message", "worker_id", workerID, "partition", msg.Partition, "offset", msg.Offset,
                                "batch_id", batch.BatchID)
                        select </span>{
                        case a.processingQueue &lt;- batch:<span class="cov0" title="0"></span>
                                //successfully queueud
                        case &lt;-a.shutdown:<span class="cov0" title="0">
                                return</span>
                        default:<span class="cov0" title="0">
                                a.log.Warn(ctx, "processing queue full, blocking", "batch_id", batch.BatchID, "worker_id", workerID)
                                select </span>{
                                case a.processingQueue &lt;- batch:<span class="cov0" title="0"></span>
                                case &lt;-a.shutdown:<span class="cov0" title="0">
                                        return</span>
                                }
                        }
                }
        }

}

func (a *App) processMessages(ctx context.Context) <span class="cov0" title="0">{

        defer a.wg.Done()

        //ctx := context.Background()

        for </span><span class="cov0" title="0">{

                select </span>{
                case &lt;-a.shutdown:<span class="cov0" title="0">
                        return</span>
                case batch := &lt;-a.processingQueue:<span class="cov0" title="0">
                        if err := a.processBatch(ctx, batch); err != nil </span><span class="cov0" title="0">{
                                a.log.Error(ctx, "failed to process batch", "batch_id", batch.BatchID, "err", err)
                        }</span>
                }
        }

}

//One batch being sent ==&gt; lets assume the one below
/*


{
  "batch_id": "batch_2025_001",
  "event_id": "event_2025_001",
  "device_id": "device_123",
  "timestamp": "2025-05-30T12:16:00+03:00",
  "record_ids": "staging_001,staging_002,staging_003",
  "records": [
    {
      "table_name": "Package_detail",
      "data": {
        "package_detail_id": "pkg_123",
        "order_id": "ord_456",
        "delivery_id": "del_789",
        "origin_facility": "fac_001",
        "destination_facility": "fac_002",
        "route_id": "rte_101",
        "status": "created",
        "items_summary": {"item_count": 5, "total_weight": 10.5},
        "picked_up_time": "2025-05-30T10:00:00+03:00",
        "delivery_time": null,
        "is_synced": false,
        "time_stamp": "2025-05-30T10:00:00+03:00",
        "created_at": "2025-05-30T10:00:00+03:00",
        "updated_at": "2025-05-30T10:00:00+03:00"
      }
    },
    {
      "table_name": "EPickUp_package",
      "data": {
        "pickup_package_id": "pickup_789",
        "package_detail_id": "pkg_123",
        "route_id": "rte_101",
        "origin_facility": "fac_001",
        "vehicle_id": "veh_201",
        "delivery_personnel_id": "user_456",
        "batch_status": "pending",
        "pickup_started_at": "2025-05-30T10:15:00+03:00",
        "pickup_completed_at": null,
        "delivery_batch_signature_id": null,
        "ware_house_manager_signature_id": null,
        "is_synced": false,
        "created_at": "2025-05-30T10:15:00+03:00",
        "updated_at": "2025-05-30T10:15:00+03:00"
      }
    },
    {
      "table_name": "Images",
      "data": {
        "image_id": "img_001",
        "package_detail_id": "pkg_123",
        "exception_id": null,
        "event_type": "pickup",
        "image_type": "model19",
        "image_url": "https://storage.example.com/img_001.jpg",
        "image_hash": "hash_abc123",
        "captured_by": "user_456",
        "is_synced": false,
        "time_stamp": "2025-05-30T10:20:00+03:00",
        "created_at": "2025-05-30T10:20:00+03:00",
        "updated_at": "2025-05-30T10:20:00+03:00"
      }
    }
  ]
}


*/
func (a *App) processBatch(ctx context.Context, batch NewBatch) error <span class="cov0" title="0">{

        a.log.Info(ctx, "processing batch", "batch_id", batch.BatchID)
        //send the
        if batch.BatchID == "" || batch.DeviceID == "" || batch.EventID == "" || len(batch.Records) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("missing One of Required Fields batchID, DeviceID, or Record of length is zero")
        }</span>

        <span class="cov0" title="0">for _, record := range batch.Records </span><span class="cov0" title="0">{

                switch record.TableName </span>{
                case "pickup_batch":<span class="cov0" title="0">
                        if record.Data == nil </span><span class="cov0" title="0">{
                                a.log.Info(ctx, "Pickup_batch Data empty", record.TableName)
                                return fmt.Errorf("failed to process PickupBatch from record Data")
                        }</span>
                        <span class="cov0" title="0">fmt.Println("First Process PickupBatch")
                        var newPickupBatchSync NewPickupBatchSync
                        if err := newPickupBatchSync.Decode(record.Data); err != nil </span><span class="cov0" title="0">{
                                a.log.Info(ctx, "Failed to Decode NewPickupBatchSync Data ", err)
                                return fmt.Errorf("failed to process pickup_batch")
                        }</span>
                        <span class="cov0" title="0">pickupbatch, err := toPickupBatch(newPickupBatchSync)
                        fmt.Println("PickuPBatch: ", pickupbatch)
                        fmt.Println("RecordData: ", record.Data)
                        fmt.Println("NewPickupBatchSyncData: ", newPickupBatchSync)
                        fmt.Println("Typeof: ", reflect.TypeOf(newPickupBatchSync))

                        if err != nil </span><span class="cov0" title="0">{
                                a.log.Info(ctx, "Failed to convert to pickupbatch to storer: %v ", err)
                                return fmt.Errorf("failed to convert to pickupBatch to storere: %v", err)
                        }</span>
                        <span class="cov0" title="0">err = a.PickupBatchBus.GetStorer().Create(ctx, pickupbatch)

                        if err != nil </span><span class="cov0" title="0">{
                                a.log.Info(ctx, "Failed to send data to Create in db layer: %v ", err)
                                return fmt.Errorf("failed to Send data to Created in db Layer: %v ", err)
                        }</span>

                        //we process pickup_batch

                case "manifest":<span class="cov0" title="0">
                        //we process package detail
                        if record.Data == nil </span><span class="cov0" title="0">{
                                a.log.Info(ctx, "Package detail Data empty", record.TableName)
                                return fmt.Errorf("pakcage detail is Empty")
                        }</span>
                        <span class="cov0" title="0">var newManifestSync NewManifestSync
                        if err := newManifestSync.Decode(record.Data); err != nil </span><span class="cov0" title="0">{
                                a.log.Info(ctx, "Failed to Decode NewManifestSync Data: %v ", err)
                                return fmt.Errorf("failed to process manifest")
                        }</span>
                        <span class="cov0" title="0">manifest, err := toManifest(newManifestSync)
                        if err != nil </span><span class="cov0" title="0">{
                                a.log.Info(ctx, "Failed to convert manifest to storer: %v ", err)
                                return fmt.Errorf("failed to convert manifest to storer: %v ", err)
                        }</span>
                        <span class="cov0" title="0">err = a.ManifestBus.GetStorer().Create(ctx, manifest)
                        if err != nil </span><span class="cov0" title="0">{
                                a.log.Info(ctx, "Failed to send data to create in db layer: %v ", err, "manifest", manifest)
                                return fmt.Errorf("failed to send data to create in db layer: %v ", err)
                        }</span>

                case "signature":<span class="cov0" title="0">
                        if record.Data == nil </span><span class="cov0" title="0">{
                                a.log.Info(ctx, "Signature Data empty: %v ", record.TableName)
                                return fmt.Errorf("signature Data is empty")
                        }</span>
                        <span class="cov0" title="0">var newSignatureSync NewSignatureSync
                        if err := newSignatureSync.Decode(record.Data); err != nil </span><span class="cov0" title="0">{
                                a.log.Info(ctx, "Failed to Decode NewSignatureSync Data ", err)
                                return fmt.Errorf("failed to process NewSignatureSync")
                        }</span>
                        <span class="cov0" title="0">signature, err := toSignature(newSignatureSync)
                        if err != nil </span><span class="cov0" title="0">{
                                a.log.Info(ctx, "Failed to convert Signature up to storer ", err)
                                return fmt.Errorf("failed to convert Signature to storer: %v ", err)
                        }</span>
                        <span class="cov0" title="0">err = a.SignatureBus.GetStorer().Create(ctx, signature)
                        if err != nil </span><span class="cov0" title="0">{
                                a.log.Info(ctx, "Failed to send data to create in db layer ", err)
                                return fmt.Errorf("failed to send data to create in db Layer: %v", err)
                        }</span>
                case "gpstracking":<span class="cov0" title="0">
                        if record.Data == nil </span><span class="cov0" title="0">{
                                a.log.Info(ctx, "GPS tracking Data empty ", record.TableName)
                                return fmt.Errorf("gPS Data is empty")
                        }</span>
                        <span class="cov0" title="0">var newGpsTrackingSync NewGpsTrackingSync
                        if err := newGpsTrackingSync.Decode(record.Data); err != nil </span><span class="cov0" title="0">{
                                a.log.Info(ctx, "Failed to Decode NewGpsSignatureSync Data ", err)
                                return fmt.Errorf("failed to process NewGpsSignatureSync: %v", err)
                        }</span>
                        <span class="cov0" title="0">gpsTracking, err := toGpsTracking(newGpsTrackingSync)
                        if err != nil </span><span class="cov0" title="0">{
                                a.log.Info(ctx, "Failed to convert GPSTracking up to storer", err)
                                return fmt.Errorf("failed to convert GPSTracking to storer: %v", err)
                        }</span>
                        <span class="cov0" title="0">err = a.GpsTrackingBus.GetStorer().Create(ctx, gpsTracking)
                        if err != nil </span><span class="cov0" title="0">{
                                a.log.Info(ctx, "Failed to send data to create in db layer ", err)
                                return fmt.Errorf("failed to send data to create in db Layer: %v ", err)
                        }</span>

                }
        }

        <span class="cov0" title="0">return nil</span>
}

func (a *App) isCoordinatorError(err error) bool <span class="cov0" title="0">{
        /*err.Error() ==&gt; Returns in error as a string because it implements interface
          type error interface {
              Error() string ===&gt; returns string
          }
        */
        errStr := err.Error()

        return strings.Contains(errStr, "Group Coordinator Not Available") ||
                strings.Contains(errStr, "coordinator not available") ||
                strings.Contains(errStr, "NotCoordinatorForGroup")
}</span>

func (a *App) Shutdown(ctx context.Context) error <span class="cov0" title="0">{

        a.mu.Lock()
        defer a.mu.Unlock()

        if !a.started </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">a.log.Info(ctx, "shutting down kafka consumer")

        close(a.shutdown)

        if err := a.kafkaReader.Close(); err != nil </span><span class="cov0" title="0">{
                a.log.Error(ctx, "error closing kafka reader", "err", err)
        }</span>

        <span class="cov0" title="0">done := make(chan struct{})
        go func() </span><span class="cov0" title="0">{
                a.wg.Wait()
                close(done)
        }</span>()

        <span class="cov0" title="0">select </span>{
        case &lt;-done:<span class="cov0" title="0">
                a.log.Info(ctx, "kafka consumer shutdown complete")</span>
        case &lt;-time.After(10 * time.Second):<span class="cov0" title="0">
                a.log.Warn(ctx, "Kafka consumer shutdown timeout")</span>
        }
        <span class="cov0" title="0">a.started = false
        return nil</span>

}

func min(a, b time.Duration) time.Duration <span class="cov0" title="0">{
        if a &lt; b </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov0" title="0">return b</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package consumerapp

import (
        "encoding/json"
        "fmt"
        "time"

        "github.com/FITHSCS/backend/business/domain/gpstrackingbus"
        "github.com/FITHSCS/backend/business/domain/manifestbus"
        "github.com/FITHSCS/backend/business/domain/pickupbatchbus"
        "github.com/FITHSCS/backend/business/domain/signaturebus"
        "github.com/FITHSCS/backend/business/types/facilitytype"
        "github.com/FITHSCS/backend/business/types/genstringtype"
        "github.com/google/uuid"
)

type NewBatch struct {
        BatchID   string        `json:"batch_id"`
        DeviceID  string        `json:"device_id"`
        EventID   string        `json:"event_id"`
        TimeStamp time.Time     `json:"time_stamp"`
        Records   []SyncRecords `json:"records"`
}

type SyncRecords struct {
        StagingID string                 `json:"staging_id"`
        TableName string                 `json:"table_name"`
        Data      map[string]interface{} `json:"data"`
}

type SyncResponse struct {
        Status  string `json:"status"`
        BatchID string `json:"batch_id"`
}

func (b *NewBatch) Decode(data []byte) error <span class="cov0" title="0">{

        return json.Unmarshal(data, b)
}</span>

func (p *NewPickupBatchSync) Decode(data map[string]interface{}) error <span class="cov0" title="0">{
        jsondata, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal NewPickup Batch data: %v ", err)
        }</span>
        <span class="cov0" title="0">return json.Unmarshal(jsondata, p)</span>
}

func (pa *NewManifestSync) Decode(data map[string]interface{}) error <span class="cov0" title="0">{

        jsondata, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal NewManifestSync data: %v ", err)
        }</span>
        <span class="cov0" title="0">return json.Unmarshal(jsondata, pa)</span>
}

func (pa *NewSignatureSync) Decode(data map[string]interface{}) error <span class="cov0" title="0">{

        jsondata, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal NewGpsTrackingSync data: %v ", err)
        }</span>
        <span class="cov0" title="0">return json.Unmarshal(jsondata, pa)</span>
}

func (pa *NewGpsTrackingSync) Decode(data map[string]interface{}) error <span class="cov0" title="0">{

        jsondata, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal NewGpsTrackingSync data: %v ", err)
        }</span>
        <span class="cov0" title="0">return json.Unmarshal(jsondata, pa)</span>
}

type NewGpsTrackingSync struct {
        ID                  string  `json:"gps_tracking_id"`
        RouteID             string  `json:"route_id"`
        DeliveryPersonnelID string  `json:"delivery_personnel_id"`
        VehicleID           string  `json:"vehicle_id"`
        Latitude            float64 `json:"latitude"`
        Longitude           float64 `json:"longitude"`
        Accuracy            float64 `json:"accuracy"`
        Speed               float64 `json:"speed"`
        BatteryLevel        float64 `json:"battery_level"`
        IsDeleted           bool    `json:"is_deleted"`
        IsSynced            bool    `json:"is_synced"`
        TimeStamp           string  `json:"time_stamp"`
        CreatedAt           string  `json:"created_at"`
        UpdatedAt           string  `json:"updated_at"`
}

type NewSignatureSync struct {
        ID             string  `json:"signature_id"`
        ManifestID     string  `json:"manifest_id"`
        SignedByID     string  `json:"signed_by_id"`
        EventType      string  `json:"event_type"`
        SignatureType  string  `json:"signature_type"`
        SignatureHash  string  `json:"signature_hash"`
        DeviceID       string  `json:"device_id"`
        SignedAt       string  `json:"signed_at"`
        Longitude      float64 `json:"longitude"`
        Latitude       float64 `json:"latitude"`
        InsideGeofence bool    `json:"inside_geofence"`
        IsVerified     bool    `json:"is_verified"`
        IsDeleted      bool    `json:"is_deleted"`
        IsSynced       bool    `json:"is_synced"`
        TimeStamp      string  `json:"time_stamp"`
        CreatedAt      string  `json:"created_at"`
        UpdatedAt      string  `json:"updated_at"`
}

type NewManifestSync struct {
        ID                    string         `json:"package_detail_id"`
        PickupBatchID         string         `json:"pickup_batch_id"`
        OriginFacilityID      string         `json:"origin_facility_id"`
        DestinationFacilityID string         `json:"destination_facility_id"`
        OrderID               string         `json:"order_id"`
        DeliveryID            string         `json:"delivery_id"`
        Status                string         `json:"status"`
        ItemsSummary          map[string]any `json:"items_summary"`
        PickupTime            string         `json:"pickup_time"`
        DeliveryTime          string         `json:"delivery_time"`
        IsDeleted             bool           `json:"is_deleted"`
        IsSynced              bool           `json:"is_synced"`
        TimeStamp             string         `json:"time_stamp"`
        CreatedAt             string         `json:"created_at"`
        UpdatedAt             string         `json:"updated_at"`
}

type NewPickupBatchSync struct {
        ID                  string `json:"pickup_batch_id"`
        RouteID             string `json:"route_id"`
        OriginFacilityID    string `json:"origin_facility_id"`
        VehicleID           string `json:"vehicle_id"`
        DeliveryPersonnelID string `json:"delivery_personnel_id"`
        BatchName           string `json:"batch_name"`
        BatchStatus         string `json:"batch_status"`
        PickedStartedAt     string `json:"picked_started_at"`
        PickupCompletedAt   string `json:"pickup_started_at"`
        TimeStamp           string `json:"time_stamp"`
        IsDeleted           bool   `json:"is_deleted"`
        IsSynced            bool   `json:"is_synced"`
        CreatedAt           string `json:"created_at"`
        UpdatedAt           string `json:"updated_at"`
}

func toGpsTracking(newGpsTrackingSync NewGpsTrackingSync) (gpstrackingbus.TrackTrace, error) <span class="cov0" title="0">{

        tracktraceID, err := uuid.Parse(newGpsTrackingSync.ID)
        if err != nil </span><span class="cov0" title="0">{
                return gpstrackingbus.TrackTrace{}, err
        }</span>
        <span class="cov0" title="0">routeID, err := uuid.Parse(newGpsTrackingSync.RouteID)
        if err != nil </span><span class="cov0" title="0">{
                return gpstrackingbus.TrackTrace{}, err
        }</span>
        <span class="cov0" title="0">deliveryPersonnelID, err := uuid.Parse(newGpsTrackingSync.DeliveryPersonnelID)
        if err != nil </span><span class="cov0" title="0">{
                return gpstrackingbus.TrackTrace{}, err
        }</span>
        <span class="cov0" title="0">vehicleID, err := uuid.Parse(newGpsTrackingSync.VehicleID)
        if err != nil </span><span class="cov0" title="0">{
                return gpstrackingbus.TrackTrace{}, err
        }</span>

        //check this implementation later for now we are just taking in the float64
        <span class="cov0" title="0">latitude := newGpsTrackingSync.Latitude
        longitude := newGpsTrackingSync.Longitude
        accuracy := newGpsTrackingSync.Accuracy
        speed := newGpsTrackingSync.Speed
        batteryLevel := newGpsTrackingSync.BatteryLevel
        isSynced := newGpsTrackingSync.IsSynced
        isDeleted := newGpsTrackingSync.IsDeleted

        timeStamp, err := time.Parse(time.RFC3339, newGpsTrackingSync.TimeStamp)
        if err != nil </span><span class="cov0" title="0">{
                return gpstrackingbus.TrackTrace{}, err
        }</span>
        <span class="cov0" title="0">createdAt, err := time.Parse(time.RFC3339, newGpsTrackingSync.CreatedAt)
        if err != nil </span><span class="cov0" title="0">{
                return gpstrackingbus.TrackTrace{}, err
        }</span>

        <span class="cov0" title="0">lat, err := facilitytype.ParseLat(latitude)
        if err != nil </span><span class="cov0" title="0">{
                return gpstrackingbus.TrackTrace{}, err
        }</span>

        <span class="cov0" title="0">long, err := facilitytype.ParseLong(longitude)
        if err != nil </span><span class="cov0" title="0">{
                return gpstrackingbus.TrackTrace{}, err
        }</span>

        <span class="cov0" title="0">updatedAt, err := time.Parse(time.RFC3339, newGpsTrackingSync.UpdatedAt)
        if err != nil </span><span class="cov0" title="0">{
                return gpstrackingbus.TrackTrace{}, err
        }</span>
        <span class="cov0" title="0">return gpstrackingbus.TrackTrace{

                TrackTraceID:        tracktraceID,
                RouteID:             routeID,
                DeliveryPersonnelID: deliveryPersonnelID,
                VehicleID:           vehicleID,
                Latitude:            lat,
                Longitude:           long,
                Accuracy:            accuracy,
                Speed:               speed,
                BatteryLevel:        batteryLevel,
                IsSynced:            isSynced,
                TimeStamp:           timeStamp,
                IsDeleted:           isDeleted,
                CreatedAt:           createdAt,
                UpdatedAt:           updatedAt,
        }, nil</span>

}

func toSignature(newSignatureSync NewSignatureSync) (signaturebus.Signature, error) <span class="cov0" title="0">{

        signatureID, err := uuid.Parse(newSignatureSync.ID)
        if err != nil </span><span class="cov0" title="0">{
                return signaturebus.Signature{}, err
        }</span>

        <span class="cov0" title="0">manifestID, err := uuid.Parse(newSignatureSync.ManifestID)
        if err != nil </span><span class="cov0" title="0">{

                return signaturebus.Signature{}, err
        }</span>
        <span class="cov0" title="0">signedbyID, err := uuid.Parse(newSignatureSync.SignedByID)
        if err != nil </span><span class="cov0" title="0">{
                return signaturebus.Signature{}, err
        }</span>
        <span class="cov0" title="0">eventType, err := genstringtype.Parse(newSignatureSync.EventType)
        if err != nil </span><span class="cov0" title="0">{
                return signaturebus.Signature{}, err
        }</span>
        <span class="cov0" title="0">signatureType, err := genstringtype.Parse(newSignatureSync.SignatureType)
        if err != nil </span><span class="cov0" title="0">{
                return signaturebus.Signature{}, err
        }</span>
        <span class="cov0" title="0">signatureHash, err := genstringtype.Parse(newSignatureSync.SignatureHash)
        if err != nil </span><span class="cov0" title="0">{
                return signaturebus.Signature{}, err
        }</span>
        <span class="cov0" title="0">deviceID, err := genstringtype.Parse(newSignatureSync.DeviceID)
        if err != nil </span><span class="cov0" title="0">{
                return signaturebus.Signature{}, err
        }</span>
        <span class="cov0" title="0">signedAt, err := time.Parse(time.RFC3339, newSignatureSync.SignedAt)
        if err != nil </span><span class="cov0" title="0">{
                return signaturebus.Signature{}, err
        }</span>
        <span class="cov0" title="0">longitude, err := facilitytype.ParseLong(newSignatureSync.Longitude)
        if err != nil </span><span class="cov0" title="0">{
                return signaturebus.Signature{}, err
        }</span>
        <span class="cov0" title="0">latitude, err := facilitytype.ParseLat(newSignatureSync.Latitude)
        if err != nil </span><span class="cov0" title="0">{
                return signaturebus.Signature{}, err
        }</span>
        <span class="cov0" title="0">insideGeofence := newSignatureSync.InsideGeofence
        isVerified := newSignatureSync.IsVerified
        isDeleted := newSignatureSync.IsDeleted
        isSynced := newSignatureSync.IsSynced

        timeStamp, err := time.Parse(time.RFC3339, newSignatureSync.TimeStamp)
        if err != nil </span><span class="cov0" title="0">{
                return signaturebus.Signature{}, err
        }</span>
        <span class="cov0" title="0">createdAt, err := time.Parse(time.RFC3339, newSignatureSync.CreatedAt)
        if err != nil </span><span class="cov0" title="0">{
                return signaturebus.Signature{}, err
        }</span>
        <span class="cov0" title="0">updatedAt, err := time.Parse(time.RFC3339, newSignatureSync.UpdatedAt)
        if err != nil </span><span class="cov0" title="0">{
                return signaturebus.Signature{}, err
        }</span>
        <span class="cov0" title="0">return signaturebus.Signature{
                SignatureID:    signatureID,
                ManifestID:     manifestID,
                SignedByID:     signedbyID,
                EventType:      eventType,
                SignatureType:  signatureType,
                SignatureHash:  signatureHash,
                DeviceID:       deviceID,
                SignedAt:       signedAt,
                Longitude:      longitude,
                Latitude:       latitude,
                InsideGeofence: insideGeofence,
                IsVerified:     isVerified,
                IsDeleted:      isDeleted,
                IsSynced:       isSynced,
                TimeStamp:      timeStamp,
                CreatedAt:      createdAt,
                UpdatedAt:      updatedAt,
        }, nil</span>
}

func toManifest(newManifestSync NewManifestSync) (manifestbus.Manifest, error) <span class="cov0" title="0">{

        manifestID, err := uuid.Parse(newManifestSync.ID)
        if err != nil </span><span class="cov0" title="0">{
                return manifestbus.Manifest{}, err
        }</span>

        <span class="cov0" title="0">pickupbatchID, err := uuid.Parse(newManifestSync.PickupBatchID)
        if err != nil </span><span class="cov0" title="0">{
                return manifestbus.Manifest{}, err
        }</span>

        <span class="cov0" title="0">originfacilityID, err := uuid.Parse(newManifestSync.OriginFacilityID)
        if err != nil </span><span class="cov0" title="0">{
                return manifestbus.Manifest{}, err
        }</span>
        <span class="cov0" title="0">destinationfacilityID, err := uuid.Parse(newManifestSync.DestinationFacilityID)
        if err != nil </span><span class="cov0" title="0">{
                return manifestbus.Manifest{}, err
        }</span>
        <span class="cov0" title="0">orderID, err := genstringtype.Parse(newManifestSync.OrderID)
        if err != nil </span><span class="cov0" title="0">{
                return manifestbus.Manifest{}, err
        }</span>
        <span class="cov0" title="0">deliveryID, err := genstringtype.Parse(newManifestSync.DeliveryID)
        if err != nil </span><span class="cov0" title="0">{
                return manifestbus.Manifest{}, err
        }</span>
        <span class="cov0" title="0">status, err := genstringtype.Parse(newManifestSync.Status)
        if err != nil </span><span class="cov0" title="0">{
                return manifestbus.Manifest{}, err
        }</span>
        <span class="cov0" title="0">itemsSummary, err := json.Marshal(newManifestSync.ItemsSummary)
        if err != nil </span><span class="cov0" title="0">{
                return manifestbus.Manifest{}, err
        }</span>
        <span class="cov0" title="0">pickupTime, err := time.Parse(time.RFC3339, newManifestSync.PickupTime)
        if err != nil </span><span class="cov0" title="0">{
                return manifestbus.Manifest{}, err
        }</span>
        <span class="cov0" title="0">deliveryTime, err := time.Parse(time.RFC3339, newManifestSync.DeliveryTime)
        if err != nil </span><span class="cov0" title="0">{
                return manifestbus.Manifest{}, err
        }</span>
        <span class="cov0" title="0">createdAt, err := time.Parse(time.RFC3339, newManifestSync.CreatedAt)
        if err != nil </span><span class="cov0" title="0">{
                return manifestbus.Manifest{}, err
        }</span>
        <span class="cov0" title="0">updatedAt, err := time.Parse(time.RFC3339, newManifestSync.UpdatedAt)
        if err != nil </span><span class="cov0" title="0">{
                return manifestbus.Manifest{}, err
        }</span>
        <span class="cov0" title="0">timestamp, err := time.Parse(time.RFC3339, newManifestSync.TimeStamp)
        if err != nil </span><span class="cov0" title="0">{
                return manifestbus.Manifest{}, err
        }</span>
        <span class="cov0" title="0">isDeleted := newManifestSync.IsDeleted
        isSynced := newManifestSync.IsSynced

        return manifestbus.Manifest{

                ID:                    manifestID,
                PickupBatchID:         pickupbatchID,
                OriginFacilityID:      originfacilityID,
                DestinationFacilityID: destinationfacilityID,
                OrderID:               orderID,
                DeliveryID:            deliveryID,
                Status:                status,
                ItemsSummary:          itemsSummary,
                PickupTime:            pickupTime,
                DeliveryTime:          deliveryTime,
                TimeStamp:             timestamp,
                IsDeleted:             isDeleted,
                IsSynced:              isSynced,
                CreatedAt:             createdAt,
                UpdatedAt:             updatedAt,
        }, nil</span>

}

func toPickupBatch(newPickupBatchSync NewPickupBatchSync) (pickupbatchbus.PickupBatch, error) <span class="cov0" title="0">{

        pickupBatchID, err := uuid.Parse(newPickupBatchSync.ID)
        if err != nil </span><span class="cov0" title="0">{
                return pickupbatchbus.PickupBatch{}, err
        }</span>

        <span class="cov0" title="0">routeID, err := uuid.Parse(newPickupBatchSync.RouteID)
        if err != nil </span><span class="cov0" title="0">{
                return pickupbatchbus.PickupBatch{}, err
        }</span>
        <span class="cov0" title="0">origfacID, err := uuid.Parse(newPickupBatchSync.OriginFacilityID)
        if err != nil </span><span class="cov0" title="0">{
                return pickupbatchbus.PickupBatch{}, err
        }</span>
        <span class="cov0" title="0">vehicleID, err := uuid.Parse(newPickupBatchSync.VehicleID)
        if err != nil </span><span class="cov0" title="0">{
                return pickupbatchbus.PickupBatch{}, err
        }</span>
        <span class="cov0" title="0">deliveryPersonnelID, err := uuid.Parse(newPickupBatchSync.DeliveryPersonnelID)
        if err != nil </span><span class="cov0" title="0">{
                return pickupbatchbus.PickupBatch{}, err
        }</span>
        <span class="cov0" title="0">batchName, err := genstringtype.Parse(newPickupBatchSync.BatchName)
        if err != nil </span><span class="cov0" title="0">{
                return pickupbatchbus.PickupBatch{}, err
        }</span>
        <span class="cov0" title="0">batchStatus, err := genstringtype.Parse(newPickupBatchSync.BatchStatus)
        if err != nil </span><span class="cov0" title="0">{
                return pickupbatchbus.PickupBatch{}, err
        }</span>
        <span class="cov0" title="0">pickedstartedAt, err := time.Parse(time.RFC3339, newPickupBatchSync.PickedStartedAt)
        if err != nil </span><span class="cov0" title="0">{
                return pickupbatchbus.PickupBatch{}, err
        }</span>
        <span class="cov0" title="0">pickupcompletedAt, err := time.Parse(time.RFC3339, newPickupBatchSync.PickupCompletedAt)
        if err != nil </span><span class="cov0" title="0">{
                return pickupbatchbus.PickupBatch{}, err
        }</span>
        <span class="cov0" title="0">createdAt, err := time.Parse(time.RFC3339, newPickupBatchSync.CreatedAt)
        if err != nil </span><span class="cov0" title="0">{
                return pickupbatchbus.PickupBatch{}, err
        }</span>
        <span class="cov0" title="0">updatedAt, err := time.Parse(time.RFC3339, newPickupBatchSync.UpdatedAt)
        if err != nil </span><span class="cov0" title="0">{
                return pickupbatchbus.PickupBatch{}, err
        }</span>
        <span class="cov0" title="0">timestamp, err := time.Parse(time.RFC3339, newPickupBatchSync.TimeStamp)
        if err != nil </span><span class="cov0" title="0">{
                return pickupbatchbus.PickupBatch{}, err
        }</span>
        <span class="cov0" title="0">isDeleted := newPickupBatchSync.IsDeleted
        isSynced := newPickupBatchSync.IsSynced
        return pickupbatchbus.PickupBatch{
                ID:                  pickupBatchID,
                RouteID:             routeID,
                OriginFacilityID:    origfacID,
                VehicleID:           vehicleID,
                DeliveryPersonnelID: deliveryPersonnelID,
                BatchName:           batchName,
                BatchStatus:         batchStatus,
                PickedStartedAt:     pickedstartedAt,
                PickupCompletedAt:   pickupcompletedAt,
                TimeStamp:           timestamp,
                CreatedAt:           createdAt,
                UpdatedAt:           updatedAt,
                IsDeleted:           isDeleted,
                IsSynced:            isSynced,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">// Package delexceptionapp maintains the app layer api for the track and trace domain.
package delexceptionapp

import (
        "context"
        "net/http"

        "github.com/FITHSCS/backend/app/sdk/errs"
        "github.com/FITHSCS/backend/app/sdk/query"
        "github.com/FITHSCS/backend/business/domain/delexceptionbus"
        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/foundation/web"
        "github.com/google/uuid"
)

type app struct {
        deliveryexception *delexceptionbus.Business
}

func newApp(delexception *delexceptionbus.Business) *app <span class="cov0" title="0">{
        return &amp;app{
                deliveryexception: delexception,
        }
}</span>

func (a *app) create(ctx context.Context, r *http.Request) web.Encoder <span class="cov0" title="0">{
        var newDelException NewDeliveryException
        if err := web.Decode(r, &amp;newDelException); err != nil </span><span class="cov0" title="0">{
                return errs.New(errs.InvalidArgument, err)
        }</span>

        <span class="cov0" title="0">tobusdelex, err := toBusNewDelveryException(ctx, newDelException)
        if err != nil </span><span class="cov0" title="0">{
                return errs.New(errs.InvalidArgument, err)
        }</span>

        <span class="cov0" title="0">epk, err := a.deliveryexception.Create(ctx, tobusdelex)
        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "create: epickup[%+v]: %s", epk, err)
        }</span>

        <span class="cov0" title="0">return toAppDeliveryException(epk)</span>
}

func (a *app) update(ctx context.Context, r *http.Request) web.Encoder <span class="cov0" title="0">{

        exceptionIDStr := web.Param(r, "exception_id")
        exceptionID, err := uuid.Parse(exceptionIDStr)

        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "id error: %s", err)
        }</span>

        <span class="cov0" title="0">var app UpdateDelveryException
        if err := web.Decode(r, &amp;app); err != nil </span><span class="cov0" title="0">{
                return errs.New(errs.InvalidArgument, err)
        }</span>

        <span class="cov0" title="0">upde, err := toBusUpdateEPickup(ctx, app)
        if err != nil </span><span class="cov0" title="0">{
                return errs.New(errs.InvalidArgument, err)
        }</span>

        <span class="cov0" title="0">updPrd, err := a.deliveryexception.Update(ctx, exceptionID, upde)
        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "update: exceptionID[%s] up[%+v]: %s", exceptionID, app, err)
        }</span>

        <span class="cov0" title="0">return toAppDeliveryException(updPrd)</span>
}

func (a *app) queryByID(ctx context.Context, r *http.Request) web.Encoder <span class="cov0" title="0">{
        exceptionIDStr := web.Param(r, "exception_id")
        exceptionID, err := uuid.Parse(exceptionIDStr)

        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "id error: %s", err)
        }</span>

        <span class="cov0" title="0">epickup, err := a.deliveryexception.QueryByID(ctx, exceptionID)
        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "query: exceptionID[%s]: %s", exceptionID, err)
        }</span>

        <span class="cov0" title="0">return toAppDeliveryException(epickup)</span>
}

func (a *app) query(ctx context.Context, r *http.Request) web.Encoder <span class="cov0" title="0">{
        qp := parseQueryParams(r)

        page, err := page.Parse(qp.Page, qp.Rows)
        if err != nil </span><span class="cov0" title="0">{
                return errs.NewFieldErrors("page", err)
        }</span>

        <span class="cov0" title="0">filter, err := parseFilter(qp)
        if err != nil </span><span class="cov0" title="0">{
                return err.(*errs.Error)
        }</span>

        <span class="cov0" title="0">orderBy, err := order.Parse(orderByFields, qp.OrderBy, delexceptionbus.DefaultOrderBy)
        if err != nil </span><span class="cov0" title="0">{
                return errs.NewFieldErrors("order", err)
        }</span>

        <span class="cov0" title="0">trcs, err := a.deliveryexception.Query(ctx, filter, orderBy, page)
        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "query: %s", err)
        }</span>

        <span class="cov0" title="0">total, err := a.deliveryexception.Count(ctx, filter)
        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "count: %s", err)
        }</span>

        <span class="cov0" title="0">return query.NewResult(toAppDeliveryExceptions(trcs), total, page)</span>
}

func (a *app) hardDelete(ctx context.Context, r *http.Request) web.Encoder <span class="cov0" title="0">{
        exceptionIDStr := web.Param(r, "exception_id")
        exceptionID, err := uuid.Parse(exceptionIDStr)

        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "id error: %s", err)
        }</span>

        <span class="cov0" title="0">err = a.deliveryexception.HardDelete(ctx, exceptionID)
        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "delete: exceptionID[%s]: %s", exceptionID, err)
        }</span>

        <span class="cov0" title="0">return DeleteException{
                Message: "Delete successfully",
        }</span>
}

func (a *app) softDelete(ctx context.Context, r *http.Request) web.Encoder <span class="cov0" title="0">{
        exceptionIDStr := web.Param(r, "exception_id")
        exceptionID, err := uuid.Parse(exceptionIDStr)

        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "id error: %s", err)
        }</span>

        <span class="cov0" title="0">err = a.deliveryexception.SoftDelete(ctx, exceptionID)
        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "delete: exceptionID[%s]: %s", exceptionID, err)
        }</span>

        <span class="cov0" title="0">return DeleteException{
                Message: "Delete successfully",
        }</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package delexceptionapp

import (
        "net/http"
        "time"

        "github.com/FITHSCS/backend/app/sdk/errs"
        "github.com/FITHSCS/backend/business/domain/delexceptionbus"
)

type queryParams struct {
        Page      string
        Rows      string
        OrderBy   string
        CreatedAt string
        UpdatedAt string
}

func parseQueryParams(r *http.Request) queryParams <span class="cov0" title="0">{
        values := r.URL.Query()

        filter := queryParams{
                Page:      values.Get("page"),
                Rows:      values.Get("rows"),
                OrderBy:   values.Get("orderBy"),
                CreatedAt: values.Get("created_at"),
                UpdatedAt: values.Get("updated_at"),
        }

        return filter
}</span>

func parseFilter(qp queryParams) (delexceptionbus.QueryFilter, error) <span class="cov0" title="0">{
        var fieldErrors errs.FieldErrors
        var filter delexceptionbus.QueryFilter

        if qp.CreatedAt != "" </span><span class="cov0" title="0">{
                time, err := time.Parse(time.RFC3339, qp.CreatedAt)
                switch err </span>{
                case nil:<span class="cov0" title="0">
                        filter.CreatedAt = &amp;time</span>
                default:<span class="cov0" title="0">
                        fieldErrors.Add("createdAt", err)</span>
                }
        }

        <span class="cov0" title="0">if qp.UpdatedAt != "" </span><span class="cov0" title="0">{
                time, err := time.Parse(time.RFC3339, qp.UpdatedAt)
                switch err </span>{
                case nil:<span class="cov0" title="0">
                        filter.UpdatedAt = &amp;time</span>
                default:<span class="cov0" title="0">
                        fieldErrors.Add("updatedAt", err)</span>
                }
        }

        <span class="cov0" title="0">if fieldErrors != nil </span><span class="cov0" title="0">{
                return delexceptionbus.QueryFilter{}, fieldErrors.ToError()
        }</span>

        <span class="cov0" title="0">return filter, nil</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package delexceptionapp

import (
        "context"
        "encoding/json"
        "fmt"
        "time"

        "github.com/FITHSCS/backend/app/sdk/errs"
        "github.com/FITHSCS/backend/business/domain/delexceptionbus"
        "github.com/FITHSCS/backend/business/types/genstringtype"
        "github.com/google/uuid"
)

type DeliveryException struct {
        ExceptionID      string `json:"exception_id"`
        ManifestID       string `json:"manifest_id"`
        DeliveryPersonID string `json:"delivery_personnel_id"`
        Severity         string `json:"severity"`
        ExceptionType    string `json:"exception_type"`
        Description      string `json:"description"`
        CapturedAt       string `json:"capttured_at"`
        ResolutionStatus string `json:"resolution_status"`
        ResolvedBy       string `json:"resolved_by"`
        IsDeleted        bool   `json:"is_deleted"`
        IsSynced         bool   `json:"is_synced"`
        TimeStamp        string `json:"time_stamp"`
        CreatedAt        string `json:"created_at"`
        UpdatedAt        string `json:"updated_at"`
}

// Encode implements the encoder interface.
func (app DeliveryException) Encode() ([]byte, string, error) <span class="cov0" title="0">{
        data, err := json.Marshal(app)
        return data, "application/json", err
}</span>

func toAppDeliveryException(delex delexceptionbus.DeliveryException) DeliveryException <span class="cov0" title="0">{

        return DeliveryException{
                ExceptionID:      delex.ExceptionID.String(),
                ManifestID:       delex.ManifestID.String(),
                DeliveryPersonID: delex.DeliveryPersonID.String(),
                Severity:         delex.Severity.String(),
                ExceptionType:    delex.ExceptionID.String(),
                Description:      delex.Description.String(),
                CapturedAt:       delex.CapturedAt.Format(time.RFC3339),
                ResolutionStatus: delex.ResolutionStatus.String(),
                ResolvedBy:       delex.ResolvedBy.UUID.String(),
                IsDeleted:        delex.IsDeleted,
                IsSynced:         delex.IsSynced,
                TimeStamp:        delex.TimeStamp.Format(time.RFC3339),
                CreatedAt:        delex.CreatedAt.Format(time.RFC3339),
                UpdatedAt:        delex.UpdatedAt.Format(time.RFC3339),
        }
}</span>

func toAppDeliveryExceptions(delexps []delexceptionbus.DeliveryException) []DeliveryException <span class="cov0" title="0">{
        app := make([]DeliveryException, len(delexps))
        for i, delexp := range delexps </span><span class="cov0" title="0">{
                app[i] = toAppDeliveryException(delexp)
        }</span>

        <span class="cov0" title="0">return app</span>
}

type NewDeliveryException struct {
        ManifestID       string `json:"manifest_id"`
        DeliveryPersonID string `json:"delivery_personnel_id"`
        Severity         string `json:"severity"`
        ExceptionType    string `json:"exception_type"`
        Description      string `json:"description"`
        CapturedAt       string `json:"capttured_at"`
        ResolutionStatus string `json:"resolution_status"`
        ResolvedBy       string `json:"resolved_by"`
        IsSynced         bool   `json:"is_synced"`
        TimeStamp        string `json:"time_stamp"`
}

// Decode implements the decoder interface.
func (app *NewDeliveryException) Decode(data []byte) error <span class="cov0" title="0">{
        return json.Unmarshal(data, app)
}</span>

// Validate checks the data in the model is considered clean.
func (app NewDeliveryException) Validate() error <span class="cov0" title="0">{
        if err := errs.Check(app); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("validate: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func toBusNewDelveryException(_ context.Context, newdelexp NewDeliveryException) (delexceptionbus.NewDeliveryException, error) <span class="cov0" title="0">{

        manID, err := uuid.Parse(newdelexp.ManifestID)
        if err != nil </span><span class="cov0" title="0">{
                return delexceptionbus.NewDeliveryException{}, fmt.Errorf("manifestID: %w", err)
        }</span>

        <span class="cov0" title="0">deliveryPerID, err := uuid.Parse(newdelexp.DeliveryPersonID)
        if err != nil </span><span class="cov0" title="0">{
                return delexceptionbus.NewDeliveryException{}, fmt.Errorf("deliveryPersonnelId: %w", err)
        }</span>

        <span class="cov0" title="0">sev, err := genstringtype.Parse(newdelexp.Severity)
        if err != nil </span><span class="cov0" title="0">{
                return delexceptionbus.NewDeliveryException{}, fmt.Errorf("parseseverity: %w", err)
        }</span>

        <span class="cov0" title="0">excptpe, err := genstringtype.Parse(newdelexp.ExceptionType)
        if err != nil </span><span class="cov0" title="0">{
                return delexceptionbus.NewDeliveryException{}, fmt.Errorf("parseExceptiontype: %w", err)
        }</span>

        <span class="cov0" title="0">descr, err := genstringtype.Parse(newdelexp.Description)
        if err != nil </span><span class="cov0" title="0">{
                return delexceptionbus.NewDeliveryException{}, fmt.Errorf("parsedescription: %w", err)
        }</span>

        <span class="cov0" title="0">capat, err := time.Parse(time.RFC3339, newdelexp.CapturedAt)
        if err != nil </span><span class="cov0" title="0">{
                return delexceptionbus.NewDeliveryException{}, fmt.Errorf("parsecapturedat: %w", err)
        }</span>

        <span class="cov0" title="0">restonsts, err := genstringtype.Parse(newdelexp.ResolutionStatus)
        if err != nil </span><span class="cov0" title="0">{
                return delexceptionbus.NewDeliveryException{}, fmt.Errorf("parsedesc: %w", err)
        }</span>

        <span class="cov0" title="0">var resolvedby uuid.NullUUID
        if newdelexp.ResolvedBy != "" </span><span class="cov0" title="0">{
                resby, err := uuid.Parse(newdelexp.ResolvedBy)
                if err != nil </span><span class="cov0" title="0">{
                        return delexceptionbus.NewDeliveryException{}, fmt.Errorf("parseresolvedby: %w", err)
                }</span>
                <span class="cov0" title="0">resolvedby = uuid.NullUUID{UUID: resby, Valid: true}</span>
        }

        <span class="cov0" title="0">timestamp, err := time.Parse(time.RFC3339, newdelexp.TimeStamp)
        if err != nil </span><span class="cov0" title="0">{
                return delexceptionbus.NewDeliveryException{}, fmt.Errorf("timestamp: %w", err)
        }</span>

        <span class="cov0" title="0">trktrc := delexceptionbus.NewDeliveryException{
                ManifestID:       manID,
                DeliveryPersonID: deliveryPerID,
                Severity:         sev,
                ExceptionType:    excptpe,
                Description:      descr,
                CapturedAt:       capat,
                ResolutionStatus: restonsts,
                ResolvedBy:       resolvedby,
                IsSynced:         newdelexp.IsSynced,
                TimeStamp:        timestamp,
        }

        return trktrc, nil</span>
}

// =============================================================================

type UpdateDelveryException struct {
        ManifestID       *string `json:"manifest_id"`
        DeliveryPersonID *string `json:"delivery_personnel_id"`
        Severity         *string `json:"severity"`
        ExceptionType    *string `json:"exception_type"`
        Description      *string `json:"description"`
        CapturedAt       *string `json:"capttured_at"`
        ResolutionStatus *string `json:"resolution_status"`
        ResolvedBy       *string `json:"resolved_by"`
        IsSynced         *bool   `json:"is_synced"`
        TimeStamp        *string `json:"time_stamp"`
}

// Decode implements the decoder interface.
func (utt *UpdateDelveryException) Decode(data []byte) error <span class="cov0" title="0">{
        return json.Unmarshal(data, utt)
}</span>

// Validate checks the data in the model is considered clean.
func (utt UpdateDelveryException) Validate() error <span class="cov0" title="0">{
        if err := errs.Check(utt); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("validate: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func toBusUpdateEPickup(_ context.Context, uptdelexp UpdateDelveryException) (delexceptionbus.UpdateDeliveryException, error) <span class="cov0" title="0">{

        var manid *uuid.UUID
        if uptdelexp.ManifestID != nil </span><span class="cov0" title="0">{
                routeid, err := uuid.Parse(*uptdelexp.ManifestID)
                if err != nil </span><span class="cov0" title="0">{
                        return delexceptionbus.UpdateDeliveryException{}, fmt.Errorf("parsemanid: %w", err)
                }</span>
                <span class="cov0" title="0">manid = &amp;routeid</span>
        }

        <span class="cov0" title="0">var delvpid *uuid.UUID
        if uptdelexp.DeliveryPersonID != nil </span><span class="cov0" title="0">{
                dpid, err := uuid.Parse(*uptdelexp.DeliveryPersonID)
                if err != nil </span><span class="cov0" title="0">{
                        return delexceptionbus.UpdateDeliveryException{}, fmt.Errorf("parsedeleverypersonnelid: %w", err)
                }</span>
                <span class="cov0" title="0">delvpid = &amp;dpid</span>
        }

        <span class="cov0" title="0">var sev *genstringtype.GenString
        if uptdelexp.Severity != nil </span><span class="cov0" title="0">{
                sevr, err := genstringtype.Parse(*uptdelexp.Severity)
                if err != nil </span><span class="cov0" title="0">{
                        return delexceptionbus.UpdateDeliveryException{}, fmt.Errorf("parseexceptiotype: %w", err)
                }</span>
                <span class="cov0" title="0">sev = &amp;sevr</span>
        }

        <span class="cov0" title="0">var exctype *genstringtype.GenString
        if uptdelexp.ExceptionType != nil </span><span class="cov0" title="0">{
                exctpe, err := genstringtype.Parse(*uptdelexp.ExceptionType)
                if err != nil </span><span class="cov0" title="0">{
                        return delexceptionbus.UpdateDeliveryException{}, fmt.Errorf("parseexceptiotype: %w", err)
                }</span>
                <span class="cov0" title="0">exctype = &amp;exctpe</span>
        }

        <span class="cov0" title="0">var desc *genstringtype.GenString
        if uptdelexp.Description != nil </span><span class="cov0" title="0">{
                dsc, err := genstringtype.Parse(*uptdelexp.Description)
                if err != nil </span><span class="cov0" title="0">{
                        return delexceptionbus.UpdateDeliveryException{}, fmt.Errorf("parsedesc: %w", err)
                }</span>
                <span class="cov0" title="0">desc = &amp;dsc</span>
        }

        <span class="cov0" title="0">var resultnsts *genstringtype.GenString
        if uptdelexp.ResolutionStatus != nil </span><span class="cov0" title="0">{
                rsts, err := genstringtype.Parse(*uptdelexp.ResolutionStatus)
                if err != nil </span><span class="cov0" title="0">{
                        return delexceptionbus.UpdateDeliveryException{}, fmt.Errorf("parsedesc: %w", err)
                }</span>
                <span class="cov0" title="0">resultnsts = &amp;rsts</span>
        }

        <span class="cov0" title="0">var resby *uuid.NullUUID
        if uptdelexp.ResolvedBy != nil </span><span class="cov0" title="0">{
                dpid, err := uuid.Parse(*uptdelexp.ResolvedBy)
                if err != nil </span><span class="cov0" title="0">{
                        return delexceptionbus.UpdateDeliveryException{}, fmt.Errorf("parsedeleverypersonnelid: %w", err)
                }</span>
                <span class="cov0" title="0">resby = &amp;uuid.NullUUID{UUID: dpid, Valid: true}</span>
        }

        <span class="cov0" title="0">var tmstamp *time.Time
        if uptdelexp.TimeStamp != nil </span><span class="cov0" title="0">{
                timestamp, err := time.Parse(time.RFC3339, *uptdelexp.TimeStamp)
                if err != nil </span><span class="cov0" title="0">{
                        return delexceptionbus.UpdateDeliveryException{}, fmt.Errorf("parsetimestamp: %w", err)
                }</span>
                <span class="cov0" title="0">tmstamp = &amp;timestamp</span>
        }

        <span class="cov0" title="0">var sync *bool
        if uptdelexp.IsSynced != nil </span><span class="cov0" title="0">{
                sync = uptdelexp.IsSynced
        }</span>

        <span class="cov0" title="0">newtrackTrace := delexceptionbus.UpdateDeliveryException{
                ManifestID:       manid,
                DeliveryPersonID: delvpid,
                Severity:         sev,
                ExceptionType:    exctype,
                Description:      desc,
                ResolutionStatus: resultnsts,
                ResolvedBy:       resby,
                IsSynced:         sync,
                TimeStamp:        tmstamp,
        }

        return newtrackTrace, nil</span>
}

// =============================================================================

type DeleteException struct {
        Message string `json:"message"`
}

// Encode implements the encoder interface.
func (app DeleteException) Encode() ([]byte, string, error) <span class="cov0" title="0">{
        data, err := json.Marshal(app)
        return data, "application/json", err
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package delexceptionapp

import (
        "net/http"

        "github.com/FITHSCS/backend/app/sdk/authclient"
        "github.com/FITHSCS/backend/app/sdk/mid"
        "github.com/FITHSCS/backend/business/domain/delexceptionbus"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/FITHSCS/backend/foundation/web"
)

type Config struct {
        Log          *logger.Logger
        Delexception *delexceptionbus.Business
        AuthClient   *authclient.Client
}

func Routes(app *web.App, cfg Config) <span class="cov0" title="0">{
        const version = "v1"

        authen := mid.Authenticate(cfg.AuthClient)

        api := newApp(cfg.Delexception)

        app.HandlerFunc(http.MethodGet, version, "/delivery_exception", api.query, authen)
        app.HandlerFunc(http.MethodGet, version, "/delivery_exception/{exception_id}", api.queryByID, authen)
        app.HandlerFunc(http.MethodPost, version, "/delivery_exception", api.create, authen)
        app.HandlerFunc(http.MethodPut, version, "/delivery_exception/{exception_id}", api.update, authen)
        app.HandlerFunc(http.MethodPut, version, "/delivery_exception/sdelete/{exception_id}", api.softDelete, authen)
        app.HandlerFunc(http.MethodDelete, version, "/delivery_exception/hdelete/{exception_id}", api.hardDelete, authen)
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">// Package facilityapp maintains the app layer api for the facilities domain.
package facilityapp

import (
        "context"
        "net/http"

        "github.com/FITHSCS/backend/app/sdk/errs"
        "github.com/FITHSCS/backend/app/sdk/query"

        "github.com/FITHSCS/backend/business/domain/facilitybus"
        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/foundation/web"
        "github.com/google/uuid"
)

type app struct {
        facilityBus *facilitybus.Business
}

func newApp(facilityBus *facilitybus.Business) *app <span class="cov0" title="0">{
        return &amp;app{
                facilityBus: facilityBus,
        }
}</span>

func (a *app) create(ctx context.Context, r *http.Request) web.Encoder <span class="cov0" title="0">{

        var fc NewFacility
        if err := web.Decode(r, &amp;fc); err != nil </span><span class="cov0" title="0">{
                return errs.New(errs.InvalidArgument, err)
        }</span>

        <span class="cov0" title="0">nc, err := toBusNewFacility(fc)

        if err != nil </span><span class="cov0" title="0">{
                return errs.New(errs.InvalidArgument, err)
        }</span>

        <span class="cov0" title="0">facilityCreated, err := a.facilityBus.Create(ctx, nc)
        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "create facility[%+v]: %s", facilityCreated, err)
        }</span>
        <span class="cov0" title="0">return toAppFacility(facilityCreated)</span>
}

func (a *app) query(ctx context.Context, r *http.Request) web.Encoder <span class="cov0" title="0">{
        queryParameters := ParseQueryParams(r)

        page, err := page.Parse(queryParameters.Page, queryParameters.Rows)
        if err != nil </span><span class="cov0" title="0">{
                return errs.NewFieldErrors("page", err)
        }</span>
        <span class="cov0" title="0">filter, err := ParseFilter(queryParameters)
        if err != nil </span><span class="cov0" title="0">{
                return err.(*errs.Error)
        }</span>
        <span class="cov0" title="0">orderBy, err := order.Parse(orderByFields, queryParameters.OrderBy, facilitybus.DefaultOrderBy)
        if err != nil </span><span class="cov0" title="0">{
                return errs.NewFieldErrors("order", err)
        }</span>

        <span class="cov0" title="0">facilities, err := a.facilityBus.Query(ctx, filter, orderBy, page)
        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "query: %s", err)
        }</span>

        <span class="cov0" title="0">total, err := a.facilityBus.Count(ctx, filter)
        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "count: %s", err)
        }</span>

        <span class="cov0" title="0">return query.NewResult(toAppFacilities(facilities), total, page)</span>

}

func (a *app) update(ctx context.Context, r *http.Request) web.Encoder <span class="cov0" title="0">{

        facilityIDStr := web.Param(r, "facility_id")
        facilityID, err := uuid.Parse(facilityIDStr)

        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "id not correctly formatted: %s", err)
        }</span>

        <span class="cov0" title="0">var update UpdateFacility

        if err := web.Decode(r, &amp;update); err != nil </span><span class="cov0" title="0">{
                return errs.New(errs.InvalidArgument, err)
        }</span>
        <span class="cov0" title="0">updateFacilityBus, err := toBusUpdateFacility(update)

        if err != nil </span><span class="cov0" title="0">{
                return errs.New(errs.InvalidArgument, err)
        }</span>

        <span class="cov0" title="0">updatedFacility, err := a.facilityBus.Update(ctx, facilityID, updateFacilityBus)
        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "update: Failed, ID: %s Request: %v", facilityID, update)
        }</span>
        <span class="cov0" title="0">return toAppFacility(updatedFacility)</span>
}

func (a *app) queryByID(ctx context.Context, r *http.Request) web.Encoder <span class="cov0" title="0">{

        facilityIDStr := web.Param(r, "facility_id")
        facilityID, err := uuid.Parse(facilityIDStr)

        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "id not correctly formatted: %s", err)
        }</span>

        <span class="cov0" title="0">facilityRetrieved, err := a.facilityBus.QueryByID(ctx, facilityID)
        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "query: facilityID[%s]: %s", facilityID, err)
        }</span>

        <span class="cov0" title="0">return toAppFacility(facilityRetrieved)</span>
}

func (a *app) softDelete(ctx context.Context, r *http.Request) web.Encoder <span class="cov0" title="0">{

        facilityIDStr := web.Param(r, "facility_id")

        facilityID, err := uuid.Parse(facilityIDStr)

        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "Facility Id missing in context %s", err)
        }</span>
        <span class="cov0" title="0">if err := a.facilityBus.SoftDelete(ctx, facilityID); err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "delete: facilityID[%s]: %s", facilityID, err)
        }</span>
        <span class="cov0" title="0">return FacilityDelete{
                Message: "facility delete successfull",
        }</span>
}

func (a *app) hardDelete(ctx context.Context, r *http.Request) web.Encoder <span class="cov0" title="0">{

        facilityIDStr := web.Param(r, "facility_id")

        facilityID, err := uuid.Parse(facilityIDStr)

        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "Facility Id missing in context %s", err)
        }</span>
        <span class="cov0" title="0">if err := a.facilityBus.HardDelete(ctx, facilityID); err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "delete: facilityID[%s]: %s", facilityID, err)
        }</span>
        <span class="cov0" title="0">return FacilityDelete{
                Message: "facility delete successfull",
        }</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package facilityapp

import (
        "net/http"
        //"net/mail"
        "time"

        "strconv"

        "github.com/FITHSCS/backend/app/sdk/errs"
        "github.com/FITHSCS/backend/business/domain/facilitybus"
        "github.com/FITHSCS/backend/business/types/facilitytype"
        "github.com/FITHSCS/backend/business/types/name"
        "github.com/google/uuid"
)

type queryParams struct {
        Page           string
        Rows           string
        OrderBy        string
        ID             string
        FacilityName   string
        FacilityType   string
        Address        string
        Latitude       string
        Longitude      string
        GeofenceRadius string
        ContactPerson  string
        ContactPhone   string
        CreatedAt      string
        UpdatedAt      string
}

func ParseQueryParams(r *http.Request) queryParams <span class="cov0" title="0">{

        values := r.URL.Query()

        filter := queryParams{

                Page:           values.Get("page"),
                Rows:           values.Get("rows"),
                OrderBy:        values.Get("orderBy"),
                ID:             values.Get("facility_id"),
                FacilityName:   values.Get("facility_name"),
                FacilityType:   values.Get("facility_type"),
                Address:        values.Get("address"),
                Latitude:       values.Get("latitude"),
                Longitude:      values.Get("longitude"),
                GeofenceRadius: values.Get("distance"),
                ContactPerson:  values.Get("contact_person"),
                ContactPhone:   values.Get("contact_phone"),
                CreatedAt:      values.Get("start_created_date"),
                UpdatedAt:      values.Get("end_created_date"),
        }

        return filter
}</span>

func ParseFilter(qp queryParams) (facilitybus.QueryFilter, error) <span class="cov0" title="0">{

        var fieldErrors errs.FieldErrors
        var filter facilitybus.QueryFilter

        if qp.ID != "" </span><span class="cov0" title="0">{
                id, err := uuid.Parse(qp.ID)
                if err != nil </span><span class="cov0" title="0">{
                        fieldErrors.Add("facility_id", err)
                }</span> else<span class="cov0" title="0"> {
                        filter.ID = id
                }</span>
        }

        <span class="cov0" title="0">if qp.FacilityName != "" </span><span class="cov0" title="0">{
                name, err := name.Parse(qp.FacilityName)
                switch err </span>{
                case nil:<span class="cov0" title="0">
                        filter.FacilityName = &amp;name</span>
                default:<span class="cov0" title="0">
                        fieldErrors.Add("Facility name", err)</span>
                }
        }

        <span class="cov0" title="0">if qp.FacilityType != "" </span><span class="cov0" title="0">{

                facType, err := name.Parse(qp.FacilityType)
                switch err </span>{
                case nil:<span class="cov0" title="0">
                        filter.FacilityType = &amp;facType</span>
                default:<span class="cov0" title="0">
                        fieldErrors.Add("Facility type", err)</span>
                }
        }

        <span class="cov0" title="0">if qp.Address != "" </span><span class="cov0" title="0">{
                address, err := facilitytype.ParseAddress(qp.Address)
                switch err </span>{
                case nil:<span class="cov0" title="0">
                        filter.Address = &amp;address</span>
                default:<span class="cov0" title="0">
                        fieldErrors.Add("Facility Address", err)</span>
                }
        }
        <span class="cov0" title="0">if qp.Longitude != "" </span><span class="cov0" title="0">{

                lon, err := strconv.ParseFloat(qp.Longitude, 64)
                if err != nil </span><span class="cov0" title="0">{
                        fieldErrors.Add("Facility Longitude", err)
                }</span>

                <span class="cov0" title="0">longitude, err := facilitytype.ParseLong(lon)
                if err != nil </span><span class="cov0" title="0">{
                        fieldErrors.Add("Facility Longitude", err)
                }</span>
                <span class="cov0" title="0">filter.Longitude = &amp;longitude</span>
        }

        <span class="cov0" title="0">if qp.Latitude != "" </span><span class="cov0" title="0">{
                lat, err := strconv.ParseFloat(qp.Latitude, 64)
                if err != nil </span><span class="cov0" title="0">{
                        fieldErrors.Add("Facility Longitude", err)
                }</span>

                <span class="cov0" title="0">latitude, err := facilitytype.ParseLat(lat)
                if err != nil </span><span class="cov0" title="0">{
                        fieldErrors.Add("Facility Longitude", err)
                }</span>
                <span class="cov0" title="0">filter.Latitude = &amp;latitude</span>
        }
        <span class="cov0" title="0">if qp.GeofenceRadius != "" </span><span class="cov0" title="0">{
                dis, err := strconv.ParseFloat(qp.GeofenceRadius, 64)
                if err != nil </span><span class="cov0" title="0">{
                        fieldErrors.Add("Geofence Radisu", err)
                }</span>

                <span class="cov0" title="0">geofenceRadius, err := facilitytype.ParseGeofence(dis)
                if err != nil </span><span class="cov0" title="0">{
                        fieldErrors.Add("Facility Longitude", err)
                }</span>
                <span class="cov0" title="0">filter.GeofenceRadius = &amp;geofenceRadius</span>

        }
        <span class="cov0" title="0">if qp.ContactPerson != "" </span><span class="cov0" title="0">{
                contPerson, err := name.Parse(qp.ContactPerson)

                switch err </span>{
                case nil:<span class="cov0" title="0">
                        filter.ContactPerson = &amp;contPerson</span>
                default:<span class="cov0" title="0">
                        fieldErrors.Add("Contact Person", err)</span>
                }
        }
        <span class="cov0" title="0">if qp.ContactPhone != "" </span><span class="cov0" title="0">{
                contPhone, err := facilitytype.ParsePhoneNumber(qp.ContactPhone)
                switch err </span>{
                case nil:<span class="cov0" title="0">
                        filter.ContactPhone = &amp;contPhone</span>
                default:<span class="cov0" title="0">
                        fieldErrors.Add("Contact Phone", err)</span>
                }
        }
        <span class="cov0" title="0">if qp.CreatedAt != "" </span><span class="cov0" title="0">{
                t, err := time.Parse(time.RFC3339, qp.CreatedAt)
                switch err </span>{
                case nil:<span class="cov0" title="0">
                        filter.CreatedAt = &amp;t</span>
                default:<span class="cov0" title="0">
                        fieldErrors.Add("Start_created_date", err)</span>
                }
        }
        <span class="cov0" title="0">if qp.UpdatedAt != "" </span><span class="cov0" title="0">{
                t, err := time.Parse(time.RFC3339, qp.UpdatedAt)
                switch err </span>{
                case nil:<span class="cov0" title="0">
                        filter.UpdatedAt = &amp;t</span>
                default:<span class="cov0" title="0">
                        fieldErrors.Add("End created date", err)</span>
                }
        }
        <span class="cov0" title="0">if fieldErrors != nil </span><span class="cov0" title="0">{
                return facilitybus.QueryFilter{}, fieldErrors.ToError()
        }</span>
        <span class="cov0" title="0">return filter, nil</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package facilityapp

import (
        "encoding/json"
        "fmt"

        "github.com/FITHSCS/backend/app/sdk/errs"
        "github.com/FITHSCS/backend/business/domain/facilitybus"
        "github.com/FITHSCS/backend/business/types/facilitytype"
        "github.com/FITHSCS/backend/business/types/genstringtype"
        "github.com/google/uuid"
)

type Facility struct {
        ID              string  `json:"facility_id"`
        FacilityName    string  `json:"facility_name"`
        FacilityType    string  `json:"facility_type"`
        Address         string  `json:"address"`
        Region          string  `json:"region"`
        Latitude        float64 `json:"latitude"`
        Longitude       float64 `json:"longitude"`
        GeofenceRadius  float64 `json:"geofence_radius"`
        ContactPersonID string  `json:"contact_person"`
        ContactPhone    string  `json:"contact_phone"`
        IsDeleted       bool    `json:"is_deleted"`
        TimeStamp       string  `json:"time_stamp"`
        CreatedAt       string  `json:"created_at"`
        UpdatedAt       string  `json:"updated_at"`
}

//=======================================================================

type Facilities []Facility

func (f Facilities) Encode() ([]byte, string, error) <span class="cov0" title="0">{
        data, err := json.Marshal(f)
        return data, "application/json", err
}</span>

func (app Facility) Encode() ([]byte, string, error) <span class="cov0" title="0">{

        data, err := json.Marshal(app)
        return data, "application/json", err
}</span>

//==========================================================

func toAppFacility(facility facilitybus.Facility) Facility <span class="cov0" title="0">{

        return Facility{
                ID:              facility.ID.String(),
                FacilityName:    facility.FacilityName.String(),
                FacilityType:    facility.FacilityType.String(),
                Address:         facility.Address.String(),
                Region:          facility.Region.String(),
                Longitude:       facility.Longitude.Float64(),
                Latitude:        facility.Latitude.Float64(),
                GeofenceRadius:  facility.GeofenceRadius.Float64(),
                ContactPersonID: facility.ContactPersonID.String(),
                ContactPhone:    facility.ContactPhone.String(),
                IsDeleted:       facility.IsDeleted,
                TimeStamp:       facility.TimeStamp.String(),
                CreatedAt:       facility.CreatedAt.String(),
                UpdatedAt:       facility.UpdatedAt.String(),
        }
}</span>

//=======================================================================

func toAppFacilities(facilities []facilitybus.Facility) []Facility <span class="cov0" title="0">{
        app := make([]Facility, len(facilities))
        for i, facility := range facilities </span><span class="cov0" title="0">{
                app[i] = toAppFacility(facility)
        }</span>
        <span class="cov0" title="0">return app</span>
}

// NewFacility struct that holds values from http Request or from user
type NewFacility struct {
        FacilityName   string  `json:"facility_name" validate:"required"`
        FacilityType   string  `json:"facility_type" validate:"required"`
        Address        string  `json:"address" validate:"required"`
        Region         string  `json:"region" validate:"required"`
        Latitude       float64 `json:"latitude" validate:"required"`
        Longitude      float64 `json:"longitude" validate:"required"`
        GeofenceRadius float64 `json:"geofence_radius" validate:"required"`
        ContactPerson  string  `json:"contact_person" validate:"required"`
        ContactPhone   string  `json:"contact_phone" validate:"required"`
}

// Decode implementes the decoder interface
func (app *NewFacility) Decode(data []byte) error <span class="cov0" title="0">{
        return json.Unmarshal(data, app)
}</span>

//=======================================================================

func (app NewFacility) Validate() error <span class="cov0" title="0">{

        if err := errs.Check(app); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("validate: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// =======================================================================

func toBusNewFacility(app NewFacility) (facilitybus.NewFacility, error) <span class="cov0" title="0">{

        facName, err := genstringtype.Parse(app.FacilityName)

        if err != nil </span><span class="cov0" title="0">{
                return facilitybus.NewFacility{}, fmt.Errorf("parse: %w", err)
        }</span>
        <span class="cov0" title="0">facType, err := genstringtype.Parse(app.FacilityType)
        if err != nil </span><span class="cov0" title="0">{
                return facilitybus.NewFacility{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">facAddress, err := facilitytype.ParseAddress(app.Address)
        if err != nil </span><span class="cov0" title="0">{
                return facilitybus.NewFacility{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">facRegion, err := genstringtype.Parse(app.Region)
        if err != nil </span><span class="cov0" title="0">{
                return facilitybus.NewFacility{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">facLatitude, err := facilitytype.ParseLat(app.Latitude)

        if err != nil </span><span class="cov0" title="0">{
                return facilitybus.NewFacility{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">facLongitude, err := facilitytype.ParseLong(app.Longitude)

        if err != nil </span><span class="cov0" title="0">{
                return facilitybus.NewFacility{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">geofnceRadius, err := facilitytype.ParseGeofence(app.GeofenceRadius)

        if err != nil </span><span class="cov0" title="0">{
                return facilitybus.NewFacility{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">contPersonID, err := uuid.Parse(app.ContactPerson)
        if err != nil </span><span class="cov0" title="0">{
                return facilitybus.NewFacility{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">contPhone, err := facilitytype.ParsePhoneNumber(app.ContactPhone)
        if err != nil </span><span class="cov0" title="0">{
                return facilitybus.NewFacility{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">bus := facilitybus.NewFacility{
                FacilityName:    facName,
                FacilityType:    facType,
                Address:         facAddress,
                Region:          facRegion,
                Latitude:        facLatitude,
                Longitude:       facLongitude,
                GeofenceRadius:  geofnceRadius,
                ContactPersonID: contPersonID,
                ContactPhone:    contPhone,
        }
        return bus, nil</span>

}

// =======================================================================

type UpdateFacility struct {
        FacilityName   *string  `json:"facility_name"`
        FacilityType   *string  `json:"facility_type"`
        Address        *string  `json:"address"`
        Latitude       *float64 `json:"latitude"`
        Longitude      *float64 `json:"longitude"`
        GeofenceRadius *float64 `json:"geofence_radius"`
        ContactPerson  *string  `json:"contact_person"`
        ContactPhone   *string  `json:"contact_phone"`
}

//=======================================================================

// Decode implements the decoder interface
func (app *UpdateFacility) Decode(data []byte) error <span class="cov0" title="0">{
        return json.Unmarshal(data, app)
}</span>

func (app UpdateFacility) Validate() error <span class="cov0" title="0">{
        if err := errs.Check(app); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("validate: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func toBusUpdateFacility(app UpdateFacility) (facilitybus.UpdateFacility, error) <span class="cov0" title="0">{

        var facName *genstringtype.GenString
        if app.FacilityName != nil </span><span class="cov0" title="0">{
                name, err := genstringtype.Parse(*app.FacilityName)
                if err != nil </span><span class="cov0" title="0">{
                        return facilitybus.UpdateFacility{}, fmt.Errorf("parse: %w", err)
                }</span>
                <span class="cov0" title="0">facName = &amp;name</span>
        }

        <span class="cov0" title="0">var facType *genstringtype.GenString
        if app.FacilityType != nil </span><span class="cov0" title="0">{
                typeFacility, err := genstringtype.Parse(*app.FacilityType)
                if err != nil </span><span class="cov0" title="0">{
                        return facilitybus.UpdateFacility{}, fmt.Errorf("parse: %w", err)
                }</span>
                <span class="cov0" title="0">facType = &amp;typeFacility</span>
        }

        <span class="cov0" title="0">var facAddress *facilitytype.Address
        if app.Address != nil </span><span class="cov0" title="0">{
                address, err := facilitytype.ParseAddress(*app.Address)

                if err != nil </span><span class="cov0" title="0">{
                        return facilitybus.UpdateFacility{}, fmt.Errorf("parse: %w", err)
                }</span>
                <span class="cov0" title="0">facAddress = &amp;address</span>

        }

        <span class="cov0" title="0">var facLatitude *facilitytype.Lat
        if app.Latitude != nil </span><span class="cov0" title="0">{
                latitude, err := facilitytype.ParseLat(float64(*app.Latitude))
                if err != nil </span><span class="cov0" title="0">{
                        return facilitybus.UpdateFacility{}, fmt.Errorf("parse: %w", err)

                }</span>
                <span class="cov0" title="0">facLatitude = &amp;latitude</span>

        }

        <span class="cov0" title="0">var facLongitude *facilitytype.Long
        if app.Longitude != nil </span><span class="cov0" title="0">{
                longitude, err := facilitytype.ParseLong(float64(*app.Longitude))
                if err != nil </span><span class="cov0" title="0">{
                        return facilitybus.UpdateFacility{}, fmt.Errorf("parse: %w", err)
                }</span>
                <span class="cov0" title="0">facLongitude = &amp;longitude</span>
        }

        <span class="cov0" title="0">var geofncRadius *facilitytype.Geofence
        if app.GeofenceRadius != nil </span><span class="cov0" title="0">{
                geofence, err := facilitytype.ParseGeofence(float64(*app.GeofenceRadius))
                if err != nil </span><span class="cov0" title="0">{
                        return facilitybus.UpdateFacility{}, fmt.Errorf("parse: %w", err)
                }</span>
                <span class="cov0" title="0">geofncRadius = &amp;geofence</span>
        }

        <span class="cov0" title="0">var conPersonID *uuid.UUID
        if app.ContactPerson != nil </span><span class="cov0" title="0">{
                id, err := uuid.Parse(*app.ContactPerson)
                if err != nil </span><span class="cov0" title="0">{
                        return facilitybus.UpdateFacility{}, fmt.Errorf("parse: %w", err)
                }</span>
                <span class="cov0" title="0">conPersonID = &amp;id</span>

        }

        <span class="cov0" title="0">var contPhone *facilitytype.PhoneNumber
        if app.ContactPhone != nil </span><span class="cov0" title="0">{
                phone, err := facilitytype.ParsePhoneNumber(*app.ContactPhone)
                if err != nil </span><span class="cov0" title="0">{
                        return facilitybus.UpdateFacility{}, fmt.Errorf("parse: %w", err)
                }</span>
                <span class="cov0" title="0">contPhone = &amp;phone</span>
        }
        <span class="cov0" title="0">bus := facilitybus.UpdateFacility{
                FacilityName:    facName,
                FacilityType:    facType,
                Address:         facAddress,
                Latitude:        facLatitude,
                Longitude:       facLongitude,
                GeofenceRadius:  geofncRadius,
                ContactPersonID: conPersonID,
                ContactPhone:    contPhone,
        }
        return bus, nil</span>
}

// =============================================================================

type FacilityDelete struct {
        Message string `json:"message"`
}

// Encode implements the encoder interface.
func (app FacilityDelete) Encode() ([]byte, string, error) <span class="cov0" title="0">{
        data, err := json.Marshal(app)
        return data, "application/json", err
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">package facilityapp

import (
        "net/http"
        //"github.com/FITHSCS/backend/app/sdk/auth"
        "github.com/FITHSCS/backend/app/sdk/authclient"
        "github.com/FITHSCS/backend/app/sdk/mid"

        "github.com/FITHSCS/backend/business/domain/facilitybus"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/FITHSCS/backend/foundation/web"
        //"github.com/jmoiron/sqlx"
)

type Config struct {
        Log         *logger.Logger
        FacilityBus *facilitybus.Business
        AuthClient  *authclient.Client
}

func Routes(app *web.App, cfg Config) <span class="cov0" title="0">{

        const version = "v1"

        authen := mid.Authenticate(cfg.AuthClient)

        api := newApp(cfg.FacilityBus)

        app.HandlerFunc(http.MethodPost, version, "/facility", api.create, authen)
        app.HandlerFunc(http.MethodGet, version, "/facility", api.query)
        app.HandlerFunc(http.MethodGet, version, "/facility/{facility_id}", api.queryByID, authen)
        app.HandlerFunc(http.MethodPut, version, "/facility/{facility_id}", api.update, authen)
        app.HandlerFunc(http.MethodPut, version, "/facility/sdelete/{facility_id}", api.softDelete, authen)
        app.HandlerFunc(http.MethodDelete, version, "/facility/hdelete/{facility_id}", api.hardDelete, authen)

}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">package gpstrackingapp

import (
        "net/http"

        "github.com/FITHSCS/backend/app/sdk/errs"
        "github.com/FITHSCS/backend/business/domain/gpstrackingbus"
        "github.com/google/uuid"
)

type queryParams struct {
        Page                string
        Rows                string
        OrderBy             string
        TrackTraceID        string
        RouteID             string
        DeliveryPersonnelID string
        VehicleID           string
        Accuracy            string
}

func parseQueryParams(r *http.Request) queryParams <span class="cov0" title="0">{
        values := r.URL.Query()

        filter := queryParams{
                Page:                values.Get("page"),
                Rows:                values.Get("rows"),
                OrderBy:             values.Get("orderBy"),
                RouteID:             values.Get("routeId"),
                DeliveryPersonnelID: values.Get("deliveryPersonnelId"),
                VehicleID:           values.Get("vehicleId"),
                Accuracy:            values.Get("accuracy"),
        }

        return filter
}</span>

func parseFilter(qp queryParams) (gpstrackingbus.QueryFilter, error) <span class="cov0" title="0">{
        var fieldErrors errs.FieldErrors
        var filter gpstrackingbus.QueryFilter

        if qp.RouteID != "" </span><span class="cov0" title="0">{
                id, err := uuid.Parse(qp.RouteID)
                switch err </span>{
                case nil:<span class="cov0" title="0">
                        filter.RouteID = &amp;id</span>
                default:<span class="cov0" title="0">
                        fieldErrors.Add("routeId", err)</span>
                }
        }

        <span class="cov0" title="0">if qp.TrackTraceID != "" </span><span class="cov0" title="0">{
                id, err := uuid.Parse(qp.TrackTraceID)
                switch err </span>{
                case nil:<span class="cov0" title="0">
                        filter.TrackTraceID = &amp;id</span>
                default:<span class="cov0" title="0">
                        fieldErrors.Add("trackandtraceid", err)</span>
                }
        }

        <span class="cov0" title="0">if qp.RouteID != "" </span><span class="cov0" title="0">{
                id, err := uuid.Parse(qp.RouteID)
                switch err </span>{
                case nil:<span class="cov0" title="0">
                        filter.RouteID = &amp;id</span>
                default:<span class="cov0" title="0">
                        fieldErrors.Add("routeId", err)</span>
                }
        }

        <span class="cov0" title="0">if qp.DeliveryPersonnelID != "" </span><span class="cov0" title="0">{
                id, err := uuid.Parse(qp.DeliveryPersonnelID)
                switch err </span>{
                case nil:<span class="cov0" title="0">
                        filter.PackageDetailID = &amp;id</span>
                default:<span class="cov0" title="0">
                        fieldErrors.Add("deliveryPersonnelId", err)</span>
                }
        }

        <span class="cov0" title="0">if fieldErrors != nil </span><span class="cov0" title="0">{
                return gpstrackingbus.QueryFilter{}, fieldErrors.ToError()
        }</span>

        <span class="cov0" title="0">return filter, nil</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">// Package gpstrackingapp maintains the app layer api for the track and trace domain.
package gpstrackingapp

import (
        "context"
        "net/http"

        "github.com/FITHSCS/backend/app/sdk/errs"
        "github.com/FITHSCS/backend/app/sdk/query"
        "github.com/FITHSCS/backend/business/domain/gpstrackingbus"
        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/foundation/web"
        "github.com/google/uuid"
)

type app struct {
        tracktrace *gpstrackingbus.Business
}

func newApp(tracktrace *gpstrackingbus.Business) *app <span class="cov0" title="0">{
        return &amp;app{
                tracktrace: tracktrace,
        }
}</span>

func (a *app) create(ctx context.Context, r *http.Request) web.Encoder <span class="cov0" title="0">{
        var newTrackTrace NewTrackTrace
        if err := web.Decode(r, &amp;newTrackTrace); err != nil </span><span class="cov0" title="0">{
                return errs.New(errs.InvalidArgument, err)
        }</span>

        <span class="cov0" title="0">newttbus, err := toBusNewTrackTrace(ctx, newTrackTrace)
        if err != nil </span><span class="cov0" title="0">{
                return errs.New(errs.InvalidArgument, err)
        }</span>

        <span class="cov0" title="0">epk, err := a.tracktrace.Create(ctx, newttbus)
        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "create: epickup[%+v]: %s", epk, err)
        }</span>

        <span class="cov0" title="0">return toAppTrackTrace(epk)</span>
}

func (a *app) update(ctx context.Context, r *http.Request) web.Encoder <span class="cov0" title="0">{

        trackTraceIDStr := web.Param(r, "tracking_id")
        trckTraceID, err := uuid.Parse(trackTraceIDStr)

        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "id error: %s", err)
        }</span>

        <span class="cov0" title="0">var app UpdateTrackTrace
        if err := web.Decode(r, &amp;app); err != nil </span><span class="cov0" title="0">{
                return errs.New(errs.InvalidArgument, err)
        }</span>

        <span class="cov0" title="0">uptt, err := toBusUpdateEPickup(ctx, app)
        if err != nil </span><span class="cov0" title="0">{
                return errs.New(errs.InvalidArgument, err)
        }</span>

        <span class="cov0" title="0">updPrd, err := a.tracktrace.Update(ctx, uptt, trckTraceID)
        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "update: trackingID[%s] up[%+v]: %s", trckTraceID, app, err)
        }</span>

        <span class="cov0" title="0">return toAppTrackTrace(updPrd)</span>
}

func (a *app) queryByID(ctx context.Context, r *http.Request) web.Encoder <span class="cov0" title="0">{
        epckupIDStr := web.Param(r, "tracking_id")
        epickupID, err := uuid.Parse(epckupIDStr)

        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "id error: %s", err)
        }</span>

        <span class="cov0" title="0">epickup, err := a.tracktrace.QueryByID(ctx, epickupID)
        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "query: trackingID[%s]: %s", epickupID, err)
        }</span>

        <span class="cov0" title="0">return toAppTrackTrace(epickup)</span>
}

func (a *app) hardDelete(ctx context.Context, r *http.Request) web.Encoder <span class="cov0" title="0">{
        epckupIDStr := web.Param(r, "tracking_id")
        epickupID, err := uuid.Parse(epckupIDStr)

        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "id error: %s", err)
        }</span>

        <span class="cov0" title="0">err = a.tracktrace.HardDelete(ctx, epickupID)
        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "delete: tracking_id[%s]: %s", epickupID, err)
        }</span>

        <span class="cov0" title="0">return TrackTraceDelete{
                Message: "Delete successfully",
        }</span>
}

func (a *app) softDelete(ctx context.Context, r *http.Request) web.Encoder <span class="cov0" title="0">{
        epckupIDStr := web.Param(r, "tracking_id")
        epickupID, err := uuid.Parse(epckupIDStr)

        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "id error: %s", err)
        }</span>

        <span class="cov0" title="0">err = a.tracktrace.SoftDelete(ctx, epickupID)
        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "delete: tracking_id[%s]: %s", epickupID, err)
        }</span>

        <span class="cov0" title="0">return TrackTraceDelete{
                Message: "Delete successfully",
        }</span>
}

func (a *app) query(ctx context.Context, r *http.Request) web.Encoder <span class="cov0" title="0">{
        qp := parseQueryParams(r)

        page, err := page.Parse(qp.Page, qp.Rows)
        if err != nil </span><span class="cov0" title="0">{
                return errs.NewFieldErrors("page", err)
        }</span>

        <span class="cov0" title="0">filter, err := parseFilter(qp)
        if err != nil </span><span class="cov0" title="0">{
                return err.(*errs.Error)
        }</span>

        <span class="cov0" title="0">orderBy, err := order.Parse(orderByFields, qp.OrderBy, gpstrackingbus.DefaultOrderBy)
        if err != nil </span><span class="cov0" title="0">{
                return errs.NewFieldErrors("order", err)
        }</span>

        <span class="cov0" title="0">trcs, err := a.tracktrace.Query(ctx, filter, orderBy, page)
        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "query: %s", err)
        }</span>

        <span class="cov0" title="0">total, err := a.tracktrace.Count(ctx, filter)
        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "count: %s", err)
        }</span>

        <span class="cov0" title="0">return query.NewResult(toAppTrackTraces(trcs), total, page)</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package gpstrackingapp

import (
        "context"
        "encoding/json"
        "fmt"
        "strconv"
        "time"

        "github.com/FITHSCS/backend/app/sdk/errs"
        "github.com/FITHSCS/backend/app/sdk/mid"
        "github.com/FITHSCS/backend/business/domain/gpstrackingbus"
        "github.com/FITHSCS/backend/business/types/facilitytype"
        "github.com/google/uuid"
)

type TrackTrace struct {
        TrackTraceID        string  `json:"track_Trace_id"`
        RouteID             string  `json:"route_id"`
        DeliveryPersonnelID string  `json:"delivery_personnel_id"`
        VehicleID           string  `json:"vehicle_id"`
        Latitude            float64 `json:"latitude"`
        Longitude           float64 `json:"longitude"`
        Accuracy            string  `json:"accuracy"`
        Speed               string  `json:"speed"`
        BatteryLevel        string  `json:"battery_level"`
        IsDeleted           bool    `json:"is_deleted"`
        IsSynced            bool    `json:"is_synced"`
        TimeStamp           string  `json:"timestamp"`
        CreatedAt           string  `json:"created_at"`
        UpdatedAt           string  `json:"updated_at"`
}

// Encode implements the encoder interface.
func (app TrackTrace) Encode() ([]byte, string, error) <span class="cov0" title="0">{
        data, err := json.Marshal(app)
        return data, "application/json", err
}</span>

func toAppTrackTrace(trktrc gpstrackingbus.TrackTrace) TrackTrace <span class="cov0" title="0">{
        // lat := fmt.Sprintf("%f", trktrc.Latitude)
        // long := fmt.Sprintf("%f", trktrc.Longitude)
        return TrackTrace{
                TrackTraceID:        trktrc.TrackTraceID.String(),
                RouteID:             trktrc.RouteID.String(),
                DeliveryPersonnelID: trktrc.DeliveryPersonnelID.String(),
                VehicleID:           trktrc.VehicleID.String(),
                Latitude:            trktrc.Latitude.Float64(),
                Longitude:           trktrc.Latitude.Float64(),
                IsDeleted:           trktrc.IsDeleted,
                IsSynced:            trktrc.IsSynced,
                TimeStamp:           trktrc.TimeStamp.Format(time.RFC3339),
                CreatedAt:           trktrc.CreatedAt.Format(time.RFC3339),
                UpdatedAt:           trktrc.UpdatedAt.Format(time.RFC3339),
        }
}</span>

func toAppTrackTraces(trktrcs []gpstrackingbus.TrackTrace) []TrackTrace <span class="cov0" title="0">{
        app := make([]TrackTrace, len(trktrcs))
        for i, trktrc := range trktrcs </span><span class="cov0" title="0">{
                app[i] = toAppTrackTrace(trktrc)
        }</span>

        <span class="cov0" title="0">return app</span>
}

type NewTrackTrace struct {
        RouteID             string  `json:"route_iD"`
        DeliveryPersonnelID string  `json:"delivery_personnel_id"`
        VehicleID           string  `json:"vehicle_id"`
        Latitude            float64 `json:"latitude"`
        Longitude           float64 `json:"longitude"`
        Accuracy            string  `json:"accuracy"`
        Speed               string  `json:"speed"`
        BatteryLevel        string  `json:"battery_level"`
        IsSynced            bool    `json:"is_synced"`
        TimeStamp           string  `json:"time_stamp"`
}

// Decode implements the decoder interface.
func (app *NewTrackTrace) Decode(data []byte) error <span class="cov0" title="0">{
        return json.Unmarshal(data, app)
}</span>

// Validate checks the data in the model is considered clean.
func (app NewTrackTrace) Validate() error <span class="cov0" title="0">{
        if err := errs.Check(app); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("validate: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func toBusNewTrackTrace(ctx context.Context, newTrkTrc NewTrackTrace) (gpstrackingbus.NewTrackTrace, error) <span class="cov0" title="0">{

        routeID, err := uuid.Parse(newTrkTrc.RouteID)
        if err != nil </span><span class="cov0" title="0">{
                return gpstrackingbus.NewTrackTrace{}, fmt.Errorf("routeID: %w", err)
        }</span>

        <span class="cov0" title="0">deliveryPerID, err := mid.GetUserID(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return gpstrackingbus.NewTrackTrace{}, fmt.Errorf("deliveryPersonnelId: %w", err)
        }</span>

        <span class="cov0" title="0">vehID, err := uuid.Parse(newTrkTrc.VehicleID)
        if err != nil </span><span class="cov0" title="0">{
                return gpstrackingbus.NewTrackTrace{}, fmt.Errorf("VehicleID: %w", err)
        }</span>

        <span class="cov0" title="0">var batterylevel float64
        if newTrkTrc.BatteryLevel != "" </span><span class="cov0" title="0">{
                btlevel, err := strconv.ParseFloat(newTrkTrc.BatteryLevel, 64)
                if err != nil </span><span class="cov0" title="0">{
                        return gpstrackingbus.NewTrackTrace{}, fmt.Errorf("batterylevel: %w", err)
                }</span>
                <span class="cov0" title="0">batterylevel = btlevel</span>
        }

        <span class="cov0" title="0">var speed float64
        if newTrkTrc.Speed != "" </span><span class="cov0" title="0">{
                spd, err := strconv.ParseFloat(newTrkTrc.Speed, 64)
                if err != nil </span><span class="cov0" title="0">{
                        return gpstrackingbus.NewTrackTrace{}, fmt.Errorf("speed: %w", err)
                }</span>
                <span class="cov0" title="0">speed = spd</span>
        }

        <span class="cov0" title="0">lat, err := facilitytype.ParseLat(newTrkTrc.Latitude)
        if err != nil </span><span class="cov0" title="0">{
                return gpstrackingbus.NewTrackTrace{}, fmt.Errorf("latitude: %w", err)
        }</span>

        <span class="cov0" title="0">long, err := facilitytype.ParseLong(newTrkTrc.Longitude)
        if err != nil </span><span class="cov0" title="0">{
                return gpstrackingbus.NewTrackTrace{}, fmt.Errorf("longitude: %w", err)
        }</span>

        <span class="cov0" title="0">var accuracy float64
        if newTrkTrc.Accuracy != "" </span><span class="cov0" title="0">{
                acc, err := strconv.ParseFloat(newTrkTrc.Accuracy, 64)
                if err != nil </span><span class="cov0" title="0">{
                        return gpstrackingbus.NewTrackTrace{}, fmt.Errorf("accuracy: %w", err)
                }</span>
                <span class="cov0" title="0">accuracy = acc</span>
        }

        <span class="cov0" title="0">timestamp, err := time.Parse(time.RFC3339, newTrkTrc.TimeStamp)
        if err != nil </span><span class="cov0" title="0">{
                return gpstrackingbus.NewTrackTrace{}, fmt.Errorf("timestamp: %w", err)
        }</span>

        <span class="cov0" title="0">trktrc := gpstrackingbus.NewTrackTrace{
                RouteID:             routeID,
                DeliveryPersonnelID: deliveryPerID,
                VehicleID:           vehID,
                Latitude:            lat,
                Longitude:           long,
                Accuracy:            accuracy,
                Speed:               speed,
                BatteryLevel:        batterylevel,
                IsSynced:            newTrkTrc.IsSynced,
                TimeStamp:           timestamp,
        }

        return trktrc, nil</span>
}

// =============================================================================

type UpdateTrackTrace struct {
        RouteID             *string  `json:"routeID"`
        VehicleID           *string  `json:"vehicleId"`
        DeliveryPersonnelID *string  `json:"delivery_personnel_id"`
        Latitude            *float64 `json:"latitude"`
        Longitude           *float64 `json:"longitude"`
        Accuracy            *string  `json:"accuracy"`
        Speed               *string  `json:"speed"`
        BatteryLevel        *string  `json:"batteryLevel"`
        IsSynced            *bool    `json:"isSynced"`
        TimeStamp           *string  `json:"timeStamp"`
}

// Decode implements the decoder interface.
func (utt *UpdateTrackTrace) Decode(data []byte) error <span class="cov0" title="0">{
        return json.Unmarshal(data, utt)
}</span>

// Validate checks the data in the model is considered clean.
func (utt UpdateTrackTrace) Validate() error <span class="cov0" title="0">{
        if err := errs.Check(utt); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("validate: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func toBusUpdateEPickup(_ context.Context, uptracktrace UpdateTrackTrace) (gpstrackingbus.UpdateTrackTrace, error) <span class="cov0" title="0">{

        var routeID *uuid.UUID
        if uptracktrace.RouteID != nil </span><span class="cov0" title="0">{
                routeid, err := uuid.Parse(*uptracktrace.RouteID)
                if err != nil </span><span class="cov0" title="0">{
                        return gpstrackingbus.UpdateTrackTrace{}, fmt.Errorf("parseroute: %w", err)
                }</span>
                <span class="cov0" title="0">routeID = &amp;routeid</span>
        }

        <span class="cov0" title="0">var vehicleID *uuid.UUID
        if uptracktrace.VehicleID != nil </span><span class="cov0" title="0">{
                vehID, err := uuid.Parse(*uptracktrace.VehicleID)
                if err != nil </span><span class="cov0" title="0">{
                        return gpstrackingbus.UpdateTrackTrace{}, fmt.Errorf("parsevehicleid: %w", err)
                }</span>
                <span class="cov0" title="0">vehicleID = &amp;vehID</span>
        }

        <span class="cov0" title="0">var delvid *uuid.UUID
        if uptracktrace.DeliveryPersonnelID != nil </span><span class="cov0" title="0">{
                vehID, err := uuid.Parse(*uptracktrace.DeliveryPersonnelID)
                if err != nil </span><span class="cov0" title="0">{
                        return gpstrackingbus.UpdateTrackTrace{}, fmt.Errorf("parsedelvpersid: %w", err)
                }</span>
                <span class="cov0" title="0">vehicleID = &amp;vehID</span>
        }

        <span class="cov0" title="0">var lat *facilitytype.Lat
        if uptracktrace.Latitude != nil </span><span class="cov0" title="0">{
                latidude, err := facilitytype.ParseLat(*uptracktrace.Latitude)
                if err != nil </span><span class="cov0" title="0">{
                        return gpstrackingbus.UpdateTrackTrace{}, fmt.Errorf("latitude: %w", err)
                }</span>
                <span class="cov0" title="0">lat = &amp;latidude</span>
        }

        <span class="cov0" title="0">var long *facilitytype.Long
        if uptracktrace.Longitude != nil </span><span class="cov0" title="0">{
                longitude, err := facilitytype.ParseLong(*uptracktrace.Longitude)
                if err != nil </span><span class="cov0" title="0">{
                        return gpstrackingbus.UpdateTrackTrace{}, fmt.Errorf("longitude: %w", err)
                }</span>
                <span class="cov0" title="0">long = &amp;longitude</span>
        }

        <span class="cov0" title="0">var acc *float64
        if uptracktrace.Accuracy != nil </span><span class="cov0" title="0">{
                accuracy, err := strconv.ParseFloat(*uptracktrace.Accuracy, 64)
                if err != nil </span><span class="cov0" title="0">{
                        return gpstrackingbus.UpdateTrackTrace{}, fmt.Errorf("parseaccuracy: %w", err)
                }</span>
                <span class="cov0" title="0">acc = &amp;accuracy</span>
        }

        <span class="cov0" title="0">var speed *float64
        if uptracktrace.Speed != nil </span><span class="cov0" title="0">{
                spd, err := strconv.ParseFloat(*uptracktrace.Speed, 64)
                if err != nil </span><span class="cov0" title="0">{
                        return gpstrackingbus.UpdateTrackTrace{}, fmt.Errorf("parsespeed: %w", err)
                }</span>
                <span class="cov0" title="0">speed = &amp;spd</span>
        }

        <span class="cov0" title="0">var batteryLevel *float64
        if uptracktrace.BatteryLevel != nil </span><span class="cov0" title="0">{
                btrlevel, err := strconv.ParseFloat(*uptracktrace.BatteryLevel, 64)
                if err != nil </span><span class="cov0" title="0">{
                        return gpstrackingbus.UpdateTrackTrace{}, fmt.Errorf("patsebatterylevel: %w", err)
                }</span>
                <span class="cov0" title="0">batteryLevel = &amp;btrlevel</span>
        }

        <span class="cov0" title="0">var isync *bool
        if uptracktrace.IsSynced != nil </span><span class="cov0" title="0">{
                isync = uptracktrace.IsSynced
        }</span>

        <span class="cov0" title="0">var tmstamp *time.Time
        if uptracktrace.TimeStamp != nil </span><span class="cov0" title="0">{
                timestamp, err := time.Parse(time.RFC3339, *uptracktrace.TimeStamp)
                if err != nil </span><span class="cov0" title="0">{
                        return gpstrackingbus.UpdateTrackTrace{}, fmt.Errorf("parsetimestamp: %w", err)
                }</span>
                <span class="cov0" title="0">tmstamp = &amp;timestamp</span>
        }

        <span class="cov0" title="0">newtrackTrace := gpstrackingbus.UpdateTrackTrace{
                RouteID:             routeID,
                DeliveryPersonnelID: delvid,
                VehicleID:           vehicleID,
                Latitude:            lat,
                Longitude:           long,
                Accuracy:            acc,
                Speed:               speed,
                BatteryLevel:        batteryLevel,
                IsSynced:            isync,
                TimeStamp:           tmstamp,
        }

        return newtrackTrace, nil</span>
}

// =============================================================================

type TrackTraceDelete struct {
        Message string `json:"message"`
}

// Encode implements the encoder interface.
func (app TrackTraceDelete) Encode() ([]byte, string, error) <span class="cov0" title="0">{
        data, err := json.Marshal(app)
        return data, "application/json", err
}</span>
</pre>
		
		<pre class="file" id="file38" style="display: none">package gpstrackingapp

import (
        "net/http"

        "github.com/FITHSCS/backend/app/sdk/authclient"
        "github.com/FITHSCS/backend/app/sdk/mid"
        "github.com/FITHSCS/backend/business/domain/gpstrackingbus"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/FITHSCS/backend/foundation/web"
)

type Config struct {
        Log           *logger.Logger
        TrackTraceBus *gpstrackingbus.Business
        AuthClient    *authclient.Client
}

func Routes(app *web.App, cfg Config) <span class="cov0" title="0">{
        const version = "v1"

        authen := mid.Authenticate(cfg.AuthClient)

        api := newApp(cfg.TrackTraceBus)

        app.HandlerFunc(http.MethodGet, version, "/tracktrace", api.query, authen)
        app.HandlerFunc(http.MethodGet, version, "/tracktrace/{tracking_id}", api.queryByID, authen)
        app.HandlerFunc(http.MethodPost, version, "/tracktrace", api.create, authen)
        app.HandlerFunc(http.MethodPut, version, "/tracktrace/{tracking_id}", api.update, authen)
        app.HandlerFunc(http.MethodPut, version, "/tracktrace/sdelete/{tracking_id}", api.softDelete, authen)
        app.HandlerFunc(http.MethodDelete, version, "/tracktrace/hdelete/{tracking_id}", api.hardDelete, authen)
}</span>
</pre>
		
		<pre class="file" id="file39" style="display: none">package imageapp

import (
        "net/http"
        "time"

        "github.com/FITHSCS/backend/app/sdk/errs"
        "github.com/FITHSCS/backend/business/domain/imagebus"
        "github.com/google/uuid"
)

type queryParams struct {
        Page         string
        Rows         string
        OrderBy      string
        ID           string
        EventType    string
        ImageType    string
        CapturedBy   string
        PickupTime   string
        DeliveryTime string
        TimeStamp    string
        IsSynced     string
        CreatedAt    string
        UpdatedAt    string
}

func ParseQueryParams(r *http.Request) (queryParams, error) <span class="cov0" title="0">{

        values := r.URL.Query()

        filter := queryParams{
                Page:       values.Get("page"),
                Rows:       values.Get("rows"),
                OrderBy:    values.Get("orderBy"),
                ID:         values.Get("manifest_id"),
                EventType:  values.Get("event_type"),
                ImageType:  values.Get("image_type"),
                CapturedBy: values.Get("captured_by"),
                TimeStamp:  values.Get("time_stamp"),
                IsSynced:   values.Get("is_synced"),
                CreatedAt:  values.Get("created_at"),
                UpdatedAt:  values.Get("updated_at"),
        }

        return filter, nil
}</span>

func ParseFilter(qp queryParams) (imagebus.QueryFilter, error) <span class="cov0" title="0">{

        var fieldErrors errs.FieldErrors
        var filter imagebus.QueryFilter

        if qp.ID != "" </span><span class="cov0" title="0">{
                id, err := uuid.Parse(qp.ID)
                if err != nil </span><span class="cov0" title="0">{
                        fieldErrors.Add("image_id", err)
                }</span> else<span class="cov0" title="0"> {
                        filter.ID = &amp;id
                }</span>
        }

        <span class="cov0" title="0">if qp.TimeStamp != "" </span><span class="cov0" title="0">{
                t, err := time.Parse(time.RFC3339, qp.CreatedAt)
                switch err </span>{
                case nil:<span class="cov0" title="0">
                        filter.TimeStamp = &amp;t</span>
                default:<span class="cov0" title="0">
                        fieldErrors.Add("time_stamp", err)</span>
                }
        }

        <span class="cov0" title="0">if qp.CreatedAt != "" </span><span class="cov0" title="0">{
                t, err := time.Parse(time.RFC3339, qp.CreatedAt)
                switch err </span>{
                case nil:<span class="cov0" title="0">
                        filter.CreatedAt = &amp;t</span>
                default:<span class="cov0" title="0">
                        fieldErrors.Add("created_at", err)</span>
                }
        }
        <span class="cov0" title="0">if qp.UpdatedAt != "" </span><span class="cov0" title="0">{
                t, err := time.Parse(time.RFC3339, qp.UpdatedAt)
                switch err </span>{
                case nil:<span class="cov0" title="0">
                        filter.UpdatedAt = &amp;t</span>
                default:<span class="cov0" title="0">
                        fieldErrors.Add("updated_at", err)</span>
                }
        }
        <span class="cov0" title="0">if fieldErrors != nil </span><span class="cov0" title="0">{
                return imagebus.QueryFilter{}, fieldErrors.ToError()
        }</span>
        <span class="cov0" title="0">return filter, nil</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">// Package imageapp maintains the app layer api for the pickupbatch domain.
package imageapp

import (
        "context"
        "net/http"

        "github.com/FITHSCS/backend/app/sdk/errs"
        "github.com/FITHSCS/backend/app/sdk/query"
        "github.com/FITHSCS/backend/business/domain/imagebus"
        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/foundation/web"
        "github.com/google/uuid"
)

type app struct {
        imagebus *imagebus.Business
}

func newApp(imageBus *imagebus.Business) *app <span class="cov0" title="0">{
        return &amp;app{
                imagebus: imageBus,
        }
}</span>

func (a *app) create(ctx context.Context, r *http.Request) web.Encoder <span class="cov0" title="0">{

        var nm NewImage
        if err := web.Decode(r, &amp;nm); err != nil </span><span class="cov0" title="0">{

                return errs.New(errs.InvalidArgument, err)
        }</span>

        <span class="cov0" title="0">ni, err := toBusNewImage(nm)
        if err != nil </span><span class="cov0" title="0">{
                return errs.New(errs.InvalidArgument, err)
        }</span>

        <span class="cov0" title="0">pckpBtchCretd, err := a.imagebus.Create(ctx, ni)
        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "create manifest[%+v]: %s", pckpBtchCretd, err)
        }</span>
        <span class="cov0" title="0">return toAppImage(pckpBtchCretd)</span>
}

func (a *app) update(ctx context.Context, r *http.Request) web.Encoder <span class="cov0" title="0">{
        imageIDStr := web.Param(r, "image_id")

        imageID, err := uuid.Parse(imageIDStr)
        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "id not correctly formatted: %s", err)
        }</span>

        <span class="cov0" title="0">var update UpdateImage
        if err := web.Decode(r, &amp;update); err != nil </span><span class="cov0" title="0">{
                return errs.New(errs.InvalidArgument, err)
        }</span>

        <span class="cov0" title="0">updateManifestBus, err := toBusUpdateImage(update)
        if err != nil </span><span class="cov0" title="0">{
                return errs.New(errs.InvalidArgument, err)
        }</span>

        <span class="cov0" title="0">updatedManifest, err := a.imagebus.Update(ctx, imageID, updateManifestBus)
        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "update: applyr, imageID: [%s] Request: %v", imageID, update)
        }</span>

        <span class="cov0" title="0">return toAppImage(updatedManifest)</span>
}

func (a *app) query(ctx context.Context, r *http.Request) web.Encoder <span class="cov0" title="0">{
        queryParameters, err := ParseQueryParams(r)

        if err != nil </span><span class="cov0" title="0">{
                return errs.New(errs.InvalidArgument, err)
        }</span>

        <span class="cov0" title="0">page, err := page.Parse(queryParameters.Page, queryParameters.Rows)
        if err != nil </span><span class="cov0" title="0">{
                return errs.NewFieldErrors("page", err)
        }</span>
        <span class="cov0" title="0">filter, err := ParseFilter(queryParameters)
        if err != nil </span><span class="cov0" title="0">{
                return err.(*errs.Error)
        }</span>
        <span class="cov0" title="0">orderBy, err := order.Parse(orderByFields, queryParameters.OrderBy, imagebus.DefaultOrderBy)

        if err != nil </span><span class="cov0" title="0">{
                return errs.NewFieldErrors("order", err)
        }</span>
        <span class="cov0" title="0">pickupbatches, err := a.imagebus.Query(ctx, filter, orderBy, page)
        if err != nil </span><span class="cov0" title="0">{
                return errs.NewFieldErrors("query", err)
        }</span>

        <span class="cov0" title="0">total, err := a.imagebus.Count(ctx, filter)
        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "count: %s", err)
        }</span>

        <span class="cov0" title="0">return query.NewResult(toAppImages(pickupbatches), total, page)</span>

}

func (a *app) queryByID(ctx context.Context, r *http.Request) web.Encoder <span class="cov0" title="0">{

        imageIDStr := web.Param(r, "image_id")

        imageID, err := uuid.Parse(imageIDStr)
        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "id not correctly formatted: %s", err)
        }</span>

        <span class="cov0" title="0">pickupbatchRetrieved, err := a.imagebus.QueryByID(ctx, imageID)
        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "queryid: imageapp[%s]: %s", imageID, err)
        }</span>

        <span class="cov0" title="0">return toAppImage(pickupbatchRetrieved)</span>
}

func (a *app) softDelete(ctx context.Context, r *http.Request) web.Encoder <span class="cov0" title="0">{
        imageIDStr := web.Param(r, "image_id")

        imageID, err := uuid.Parse(imageIDStr)
        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "id not correctly formatted: %s", err)
        }</span>

        <span class="cov0" title="0">if err := a.imagebus.SoftDelete(ctx, imageID); err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "delete: imageID[%s]: %s", imageID, err)
        }</span>
        <span class="cov0" title="0">return ImageDelete{
                Message: "manifest delete successfull",
        }</span>
}

func (a *app) hardDelete(ctx context.Context, r *http.Request) web.Encoder <span class="cov0" title="0">{

        imageIDStr := web.Param(r, "image_id")

        imageID, err := uuid.Parse(imageIDStr)
        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "id not correctly formatted: %s", err)
        }</span>

        <span class="cov0" title="0">if err := a.imagebus.HardDelete(ctx, imageID); err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "delete: imageID[%s]: %s", imageID, err)
        }</span>

        <span class="cov0" title="0">return ImageDelete{
                Message: "manifest delete successfull",
        }</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package imageapp

import (
        "encoding/json"
        "fmt"
        "net/url"
        "time"

        "github.com/FITHSCS/backend/app/sdk/errs"
        "github.com/FITHSCS/backend/business/domain/imagebus"
        "github.com/FITHSCS/backend/business/types/genstringtype"
        "github.com/google/uuid"
)

type Image struct {
        ImageID     string `json:"iamge_id"`
        ManifestID  string `json:"manifest_id"`
        CapturedBy  string `json:"captured_by"`
        ExceptionID string `json:"exception_id"`
        EventType   string `json:"event_type"`
        ImageType   string `json:"image_type"`
        ImageURL    string `json:"image_url"`
        ImageHash   string `json:"image_hash"`
        IsSynced    bool   `json:"is_synced"`
        IsDeleted   bool   `json:"is_deleted"`
        TimeStamp   string `json:"time_stamp"`
        CreatedAt   string `json:"created_at"`
        UpdatedAt   string `json:"updated_at"`
}

type Images []Image

func (f Images) Encode() ([]byte, string, error) <span class="cov0" title="0">{
        data, err := json.Marshal(f)
        return data, "application/json", err
}</span>

func (app Image) Encode() ([]byte, string, error) <span class="cov0" title="0">{
        data, err := json.Marshal(app)
        return data, "application/json", err
}</span>

func toAppImage(bus imagebus.Image) Image <span class="cov0" title="0">{

        return Image{
                ImageID:     bus.ImageID.String(),
                ManifestID:  bus.ManifestID.String(),
                CapturedBy:  bus.CapturedBy.String(),
                ExceptionID: bus.ExceptionID.UUID.String(),
                EventType:   bus.EventType.String(),
                ImageType:   bus.ImageType.String(),
                ImageURL:    bus.ImageURL.String(),
                ImageHash:   bus.ImageHash.String(),
                IsDeleted:   bus.IsDeleted,
                IsSynced:    bus.IsSynced,
                TimeStamp:   bus.TimeStamp.Format(time.RFC3339),
                CreatedAt:   bus.CreatedAt.Format(time.RFC3339),
                UpdatedAt:   bus.UpdatedAt.Format(time.RFC3339),
        }

}</span>

func toAppImages(manifests []imagebus.Image) []Image <span class="cov0" title="0">{
        app := make([]Image, len(manifests))
        for i, manifest := range manifests </span><span class="cov0" title="0">{
                app[i] = toAppImage(manifest)
        }</span>
        <span class="cov0" title="0">return app</span>
}

//======================================================================

type NewImage struct {
        ManifestID  string `json:"manifest_id"`
        CapturedBy  string `json:"captured_by"`
        ExceptionID string `json:"exception_id"`
        EventType   string `json:"event_type"`
        ImageType   string `json:"image_type"`
        ImageURL    string `json:"image_url"`
        ImageHash   string `json:"image_hash"`
        IsSynced    bool   `json:"is_synced"`
        TimeStamp   string `json:"time_stamp"`
}

func (app *NewImage) Decode(data []byte) error <span class="cov0" title="0">{
        return json.Unmarshal(data, app)
}</span>

func (app NewImage) Validate() error <span class="cov0" title="0">{
        if err := errs.Check(app); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("validate: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func toBusNewImage(app NewImage) (imagebus.NewImage, error) <span class="cov0" title="0">{

        manid, err := uuid.Parse(app.ManifestID)
        if err != nil </span><span class="cov0" title="0">{
                return imagebus.NewImage{}, fmt.Errorf("parsemanifestid: %w", err)
        }</span>

        <span class="cov0" title="0">capby, err := uuid.Parse(app.CapturedBy)
        if err != nil </span><span class="cov0" title="0">{
                return imagebus.NewImage{}, fmt.Errorf("parsecapturedby: %w", err)
        }</span>

        <span class="cov0" title="0">var excid uuid.NullUUID
        if app.ExceptionID != "" </span><span class="cov0" title="0">{
                resby, err := uuid.Parse(app.ExceptionID)
                if err != nil </span><span class="cov0" title="0">{
                        return imagebus.NewImage{}, fmt.Errorf("parseexceptionid: %w", err)
                }</span>
                <span class="cov0" title="0">excid = uuid.NullUUID{UUID: resby, Valid: true}</span>
        }

        <span class="cov0" title="0">evtpe, err := genstringtype.Parse(app.EventType)
        if err != nil </span><span class="cov0" title="0">{
                return imagebus.NewImage{}, fmt.Errorf("parseEventType: %w", err)
        }</span>

        <span class="cov0" title="0">imgtpe, err := genstringtype.Parse(app.ImageType)
        if err != nil </span><span class="cov0" title="0">{
                return imagebus.NewImage{}, fmt.Errorf("parseEventType: %w", err)
        }</span>

        <span class="cov0" title="0">imgurl, err := url.Parse(app.ImageURL)
        if err != nil </span><span class="cov0" title="0">{
                return imagebus.NewImage{}, fmt.Errorf("parseEventType: %w", err)
        }</span>

        <span class="cov0" title="0">imghsh, err := genstringtype.Parse(app.ImageHash)
        if err != nil </span><span class="cov0" title="0">{
                return imagebus.NewImage{}, fmt.Errorf("parseEventType: %w", err)
        }</span>

        <span class="cov0" title="0">tmstmp, err := time.Parse(time.RFC3339, app.TimeStamp)
        if err != nil </span><span class="cov0" title="0">{
                return imagebus.NewImage{}, fmt.Errorf("parseEventType: %w", err)
        }</span>

        <span class="cov0" title="0">bus := imagebus.NewImage{
                ManifestID:  manid,
                CapturedBy:  capby,
                ExceptionID: excid,
                EventType:   evtpe,
                ImageType:   imgtpe,
                ImageURL:    imgurl,
                ImageHash:   imghsh,
                IsSynced:    app.IsSynced,
                TimeStamp:   tmstmp,
        }

        return bus, nil</span>

}

//===============================================================================

type UpdateImage struct {
        ManifestID  *string `json:"manifest_id"`
        CapturedBy  *string `json:"captured_by"`
        ExceptionID *string `json:"exception_id"`
        EventType   *string `json:"event_type"`
        ImageType   *string `json:"image_type"`
        ImageURL    *string `json:"image_url"`
        ImageHash   *string `json:"image_hash"`
        IsSynced    *bool   `json:"is_synced"`
        TimeStamp   *string `json:"time_stamp"`
}

func (app *UpdateImage) Decode(data []byte) error <span class="cov0" title="0">{
        return json.Unmarshal(data, app)
}</span>

func (app UpdateImage) Validate() error <span class="cov0" title="0">{
        if err := errs.Check(app); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("validate: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func toBusUpdateImage(app UpdateImage) (imagebus.UpdateImage, error) <span class="cov0" title="0">{

        var manid *uuid.UUID
        if app.ManifestID != nil </span><span class="cov0" title="0">{
                mnid, err := uuid.Parse(*app.ManifestID)
                if err != nil </span><span class="cov0" title="0">{
                        return imagebus.UpdateImage{}, fmt.Errorf("parse: %w", err)
                }</span>
                <span class="cov0" title="0">manid = &amp;mnid</span>
        }

        <span class="cov0" title="0">var capby *uuid.UUID
        if app.CapturedBy != nil </span><span class="cov0" title="0">{
                cpby, err := uuid.Parse(*app.CapturedBy)
                if err != nil </span><span class="cov0" title="0">{
                        return imagebus.UpdateImage{}, fmt.Errorf("parse: %w", err)
                }</span>
                <span class="cov0" title="0">capby = &amp;cpby</span>
        }

        <span class="cov0" title="0">var excpid *uuid.NullUUID
        if app.ExceptionID != nil </span><span class="cov0" title="0">{
                ecid, err := uuid.Parse(*app.ExceptionID)
                if err != nil </span><span class="cov0" title="0">{
                        return imagebus.UpdateImage{}, fmt.Errorf("parsedeleverypersonnelid: %w", err)
                }</span>
                <span class="cov0" title="0">excpid = &amp;uuid.NullUUID{UUID: ecid, Valid: true}</span>
        }

        <span class="cov0" title="0">var eventpe *genstringtype.GenString
        if app.EventType != nil </span><span class="cov0" title="0">{
                evtpe, err := genstringtype.Parse(*app.EventType)
                if err != nil </span><span class="cov0" title="0">{
                        return imagebus.UpdateImage{}, fmt.Errorf("parse: %w", err)
                }</span>
                <span class="cov0" title="0">eventpe = &amp;evtpe</span>
        }

        <span class="cov0" title="0">var imgtpe *genstringtype.GenString
        if app.ImageType != nil </span><span class="cov0" title="0">{
                imgt, err := genstringtype.Parse(*app.ImageType)
                if err != nil </span><span class="cov0" title="0">{
                        return imagebus.UpdateImage{}, fmt.Errorf("parse: %w", err)
                }</span>
                <span class="cov0" title="0">imgtpe = &amp;imgt</span>
        }

        <span class="cov0" title="0">var imgurl *url.URL
        if app.ImageURL != nil </span><span class="cov0" title="0">{
                u, err := url.Parse(*app.ImageURL)
                if err != nil </span><span class="cov0" title="0">{
                        return imagebus.UpdateImage{}, fmt.Errorf("parse: %w", err)
                }</span>
                <span class="cov0" title="0">imgurl = u</span>
        }

        <span class="cov0" title="0">var imghsh *genstringtype.GenString
        if app.ImageHash != nil </span><span class="cov0" title="0">{
                par, err := genstringtype.Parse(*app.ImageHash)
                if err != nil </span><span class="cov0" title="0">{
                        return imagebus.UpdateImage{}, fmt.Errorf("parse: %w", err)
                }</span>
                <span class="cov0" title="0">imghsh = &amp;par</span>
        }

        <span class="cov0" title="0">var timestamp *time.Time
        if app.TimeStamp != nil </span><span class="cov0" title="0">{
                ts, err := time.Parse(time.RFC3339, *app.TimeStamp)
                if err != nil </span><span class="cov0" title="0">{
                        return imagebus.UpdateImage{}, fmt.Errorf("parse: %w", err)
                }</span>
                <span class="cov0" title="0">timestamp = &amp;ts</span>
        }

        <span class="cov0" title="0">bus := imagebus.UpdateImage{
                ManifestID:  manid,
                CapturedBy:  capby,
                ExceptionID: excpid,
                EventType:   eventpe,
                ImageType:   imgtpe,
                ImageURL:    imgurl,
                ImageHash:   imghsh,
                IsSynced:    app.IsSynced,
                TimeStamp:   timestamp,
        }

        return bus, nil</span>
}

// ======================================================================

type ImageDelete struct {
        Message string `json:"message"`
}

func (e ImageDelete) Encode() ([]byte, string, error) <span class="cov0" title="0">{
        data, err := json.Marshal(e)
        return data, "application/json", err
}</span>
</pre>
		
		<pre class="file" id="file42" style="display: none">package imageapp

import (
        "net/http"

        "github.com/FITHSCS/backend/app/sdk/authclient"
        "github.com/FITHSCS/backend/app/sdk/mid"
        "github.com/FITHSCS/backend/business/domain/imagebus"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/FITHSCS/backend/foundation/web"
)

type Config struct {
        Log        *logger.Logger
        ImageBus   *imagebus.Business
        AuthClient *authclient.Client
}

func Routes(app *web.App, cfg Config) <span class="cov0" title="0">{

        const version = "v1"

        authen := mid.Authenticate(cfg.AuthClient)

        api := newApp(cfg.ImageBus)

        app.HandlerFunc(http.MethodPost, version, "/image", api.create, authen)
        app.HandlerFunc(http.MethodGet, version, "/image", api.query)
        app.HandlerFunc(http.MethodGet, version, "/image/{image_id}", api.queryByID, authen)
        app.HandlerFunc(http.MethodPut, version, "/image/{image_id}", api.update, authen)
        app.HandlerFunc(http.MethodPut, version, "/image/sdelete/{image_id}", api.softDelete, authen)
        app.HandlerFunc(http.MethodDelete, version, "/image/hdelete/{image_id}", api.hardDelete, authen)

}</span>
</pre>
		
		<pre class="file" id="file43" style="display: none">package manifestapp

import (
        "net/http"
        "time"

        "github.com/FITHSCS/backend/app/sdk/errs"
        "github.com/FITHSCS/backend/business/domain/manifestbus"
        "github.com/google/uuid"
)

type queryParams struct {
        Page                  string
        Rows                  string
        OrderBy               string
        ManifestID            string
        PickupBatchID         string
        OriginFacilityID      string
        DestinationFacilityID string
        PickupTime            string
        DeliveryTime          string
        TimeStamp             string
        IsSynced              string
        CreatedAt             string
        UpdatedAt             string
}

func ParseQueryParams(r *http.Request) (queryParams, error) <span class="cov0" title="0">{

        values := r.URL.Query()

        filter := queryParams{

                Page:                  values.Get("page"),
                Rows:                  values.Get("rows"),
                OrderBy:               values.Get("orderBy"),
                ManifestID:            values.Get("manifest_id"),
                PickupBatchID:         values.Get("pick_up_batch_id"),
                OriginFacilityID:      values.Get("origin_facility_id"),
                DestinationFacilityID: values.Get("destination_facility_id"),
                PickupTime:            values.Get("pickup_time"),
                DeliveryTime:          values.Get("delivery_time"),
                TimeStamp:             values.Get("time_stamp"),
                IsSynced:              values.Get("is_synced"),
                CreatedAt:             values.Get("created_at"),
                UpdatedAt:             values.Get("updated_at"),
        }

        return filter, nil
}</span>

func ParseFilter(qp queryParams) (manifestbus.QueryFilter, error) <span class="cov0" title="0">{

        var fieldErrors errs.FieldErrors
        var filter manifestbus.QueryFilter

        if qp.ManifestID != "" </span><span class="cov0" title="0">{
                id, err := uuid.Parse(qp.ManifestID)
                if err != nil </span><span class="cov0" title="0">{
                        fieldErrors.Add("manifest_id", err)
                }</span> else<span class="cov0" title="0"> {
                        filter.ManifestID = &amp;id
                }</span>
        }

        <span class="cov0" title="0">if qp.PickupBatchID != "" </span><span class="cov0" title="0">{
                pkupbatchID, err := uuid.Parse(qp.PickupBatchID)
                switch err </span>{
                case nil:<span class="cov0" title="0">
                        filter.PickupBatchID = &amp;pkupbatchID</span>
                default:<span class="cov0" title="0">
                        fieldErrors.Add("Route Id", err)</span>
                }
        }

        <span class="cov0" title="0">if qp.TimeStamp != "" </span><span class="cov0" title="0">{
                t, err := time.Parse(time.RFC3339, qp.CreatedAt)
                switch err </span>{
                case nil:<span class="cov0" title="0">
                        filter.TimeStamp = &amp;t</span>
                default:<span class="cov0" title="0">
                        fieldErrors.Add("time_stamp", err)</span>
                }
        }

        <span class="cov0" title="0">if qp.CreatedAt != "" </span><span class="cov0" title="0">{
                t, err := time.Parse(time.RFC3339, qp.CreatedAt)
                switch err </span>{
                case nil:<span class="cov0" title="0">
                        filter.CreatedAt = &amp;t</span>
                default:<span class="cov0" title="0">
                        fieldErrors.Add("created_at", err)</span>
                }
        }
        <span class="cov0" title="0">if qp.UpdatedAt != "" </span><span class="cov0" title="0">{
                t, err := time.Parse(time.RFC3339, qp.UpdatedAt)
                switch err </span>{
                case nil:<span class="cov0" title="0">
                        filter.UpdatedAt = &amp;t</span>
                default:<span class="cov0" title="0">
                        fieldErrors.Add("updated_at", err)</span>
                }
        }
        <span class="cov0" title="0">if fieldErrors != nil </span><span class="cov0" title="0">{
                return manifestbus.QueryFilter{}, fieldErrors.ToError()
        }</span>
        <span class="cov0" title="0">return filter, nil</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">// Package manifestapp maintains the app layer api for the pickupbatch domain.
package manifestapp

import (
        "context"
        "net/http"

        "github.com/FITHSCS/backend/app/sdk/errs"
        "github.com/FITHSCS/backend/app/sdk/query"
        "github.com/FITHSCS/backend/business/domain/manifestbus"
        "github.com/FITHSCS/backend/business/domain/pickupbatchbus"
        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/foundation/web"
        "github.com/google/uuid"
)

type app struct {
        manifestbus *manifestbus.Business
}

func newApp(manifestBus *manifestbus.Business) *app <span class="cov0" title="0">{
        return &amp;app{
                manifestbus: manifestBus,
        }
}</span>

func (a *app) create(ctx context.Context, r *http.Request) web.Encoder <span class="cov0" title="0">{

        var nm NewManifest
        if err := web.Decode(r, &amp;nm); err != nil </span><span class="cov0" title="0">{

                return errs.New(errs.InvalidArgument, err)
        }</span>

        <span class="cov0" title="0">nc, err := toBusNewManifest(nm)
        if err != nil </span><span class="cov0" title="0">{
                return errs.New(errs.InvalidArgument, err)
        }</span>

        <span class="cov0" title="0">pckpBtchCretd, err := a.manifestbus.Create(ctx, nc)
        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "create manifest[%+v]: %s", pckpBtchCretd, err)
        }</span>
        <span class="cov0" title="0">return toAppManifest(pckpBtchCretd)</span>
}

func (a *app) update(ctx context.Context, r *http.Request) web.Encoder <span class="cov0" title="0">{
        manifestIDStr := web.Param(r, "manifest_id")
        manifestID, err := uuid.Parse(manifestIDStr)
        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "id not correctly formatted: %s", err)
        }</span>

        <span class="cov0" title="0">var update UpdateManifest
        if err := web.Decode(r, &amp;update); err != nil </span><span class="cov0" title="0">{
                return errs.New(errs.InvalidArgument, err)
        }</span>

        <span class="cov0" title="0">updateManifestBus, err := toBusUpdateManifest(update)
        if err != nil </span><span class="cov0" title="0">{
                return errs.New(errs.InvalidArgument, err)
        }</span>

        <span class="cov0" title="0">updatedManifest, err := a.manifestbus.Update(ctx, manifestID, updateManifestBus)
        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "update: applyr, ID: [%s] Request: %v", manifestID, update)
        }</span>

        <span class="cov0" title="0">return toAppManifest(updatedManifest)</span>
}

func (a *app) query(ctx context.Context, r *http.Request) web.Encoder <span class="cov0" title="0">{
        queryParameters, err := ParseQueryParams(r)

        if err != nil </span><span class="cov0" title="0">{
                return errs.New(errs.InvalidArgument, err)
        }</span>
        <span class="cov0" title="0">page, err := page.Parse(queryParameters.Page, queryParameters.Rows)
        if err != nil </span><span class="cov0" title="0">{
                return errs.NewFieldErrors("page", err)
        }</span>
        <span class="cov0" title="0">filter, err := ParseFilter(queryParameters)
        if err != nil </span><span class="cov0" title="0">{
                return err.(*errs.Error)
        }</span>
        <span class="cov0" title="0">orderBy, err := order.Parse(orderByFields, queryParameters.OrderBy, pickupbatchbus.DefaultOrderBy)

        if err != nil </span><span class="cov0" title="0">{
                return errs.NewFieldErrors("order", err)
        }</span>
        <span class="cov0" title="0">pickupbatches, err := a.manifestbus.Query(ctx, filter, orderBy, page)
        if err != nil </span><span class="cov0" title="0">{
                return errs.NewFieldErrors("query", err)
        }</span>

        <span class="cov0" title="0">total, err := a.manifestbus.Count(ctx, filter)
        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "count: %s", err)
        }</span>

        <span class="cov0" title="0">return query.NewResult(toAppManifests(pickupbatches), total, page)</span>

}

func (a *app) queryByID(ctx context.Context, r *http.Request) web.Encoder <span class="cov0" title="0">{

        manifestIDStr := web.Param(r, "manifest_id")
        manifestID, err := uuid.Parse(manifestIDStr)

        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "id not correctly formatted: %s", err)
        }</span>

        <span class="cov0" title="0">pickupbatchRetrieved, err := a.manifestbus.QueryByID(ctx, manifestID)
        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "queryid: pickupbatchapp[%s]: %s", manifestID, err)
        }</span>

        <span class="cov0" title="0">return toAppManifest(pickupbatchRetrieved)</span>
}

func (a *app) softDelete(ctx context.Context, r *http.Request) web.Encoder <span class="cov0" title="0">{
        manifestIDStr := web.Param(r, "manifest_id")
        manifestID, err := uuid.Parse(manifestIDStr)

        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "manifestID missing in context %s", err)
        }</span>
        <span class="cov0" title="0">if err := a.manifestbus.SoftDelete(ctx, manifestID); err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "delete: manifestID[%s]: %s", manifestID, err)
        }</span>
        <span class="cov0" title="0">return ManifestDelete{
                Message: "manifest delete successfull",
        }</span>
}

func (a *app) hardDelete(ctx context.Context, r *http.Request) web.Encoder <span class="cov0" title="0">{

        manifestIDStr := web.Param(r, "manifest_id")
        manifestID, err := uuid.Parse(manifestIDStr)

        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "manifestID missing in context %s", err)
        }</span>
        <span class="cov0" title="0">if err := a.manifestbus.HardDelete(ctx, manifestID); err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "delete: manifestID[%s]: %s", manifestID, err)
        }</span>

        <span class="cov0" title="0">return ManifestDelete{
                Message: "manifest delete successfull",
        }</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package manifestapp

import (
        "encoding/json"
        "fmt"
        "time"

        "github.com/FITHSCS/backend/app/sdk/errs"
        "github.com/FITHSCS/backend/business/domain/manifestbus"
        "github.com/FITHSCS/backend/business/types/genstringtype"
        "github.com/google/uuid"
)

type Manifest struct {
        ID                    string `json:"manifest_id"`
        PickupBatchID         string `json:"pickup_batch_id"`
        OriginFacilityID      string `json:"origin_facility_id"`
        DestinationFacilityID string `json:"destination_facility_id"`
        OrderID               string `json:"order_id"`
        DeliveryID            string `json:"delivery_id"`
        Status                string `json:"status"`
        ItemSummary           string `json:"items_summary"`
        PickupTime            string `json:"pickup_time,omitzero"`
        DeliveryTime          string `json:"pick_completed_at,omitzero"`
        IsSynced              bool   `json:"is_synced"`
        IsDeleted             bool   `json:"is_deleted"`
        TimeStamp             string `json:"time_stamp"`
        CreatedAt             string `json:"created_at"`
        UpdatedAt             string `json:"updated_at"`
}

type Manifests []Manifest

func (f Manifests) Encode() ([]byte, string, error) <span class="cov0" title="0">{
        data, err := json.Marshal(f)
        return data, "application/json", err
}</span>

func (app Manifest) Encode() ([]byte, string, error) <span class="cov0" title="0">{
        data, err := json.Marshal(app)
        return data, "application/json", err
}</span>

func toAppManifest(manifest manifestbus.Manifest) Manifest <span class="cov0" title="0">{

        var pickStartedAt string
        if !manifest.PickupTime.IsZero() </span><span class="cov0" title="0">{
                pickStartedAt = manifest.PickupTime.Format(time.RFC3339)
        }</span>

        <span class="cov0" title="0">var pickCompletedAt string
        if !manifest.DeliveryTime.IsZero() </span><span class="cov0" title="0">{
                pickStartedAt = manifest.DeliveryTime.Format(time.RFC3339)
        }</span>

        <span class="cov0" title="0">return Manifest{
                ID:                    manifest.ID.String(),
                PickupBatchID:         manifest.PickupTime.String(),
                OriginFacilityID:      manifest.OriginFacilityID.String(),
                DestinationFacilityID: manifest.DeliveryID.String(),
                OrderID:               manifest.OrderID.String(),
                DeliveryID:            manifest.DeliveryID.String(),
                Status:                manifest.Status.String(),
                ItemSummary:           string(manifest.ItemsSummary),
                PickupTime:            pickStartedAt,
                DeliveryTime:          pickCompletedAt,
                IsSynced:              manifest.IsSynced,
                TimeStamp:             manifest.TimeStamp.Format(time.RFC3339),
                CreatedAt:             manifest.CreatedAt.Format(time.RFC3339),
                UpdatedAt:             manifest.UpdatedAt.Format(time.RFC3339),
        }</span>

}

func toAppManifests(manifests []manifestbus.Manifest) []Manifest <span class="cov0" title="0">{
        app := make([]Manifest, len(manifests))
        for i, manifest := range manifests </span><span class="cov0" title="0">{
                app[i] = toAppManifest(manifest)
        }</span>
        <span class="cov0" title="0">return app</span>
}

//======================================================================

type NewManifest struct {
        PickupBatchID         string         `json:"pickup_batch_id"`
        OriginFacilityID      string         `json:"origin_facility_id"`
        DestinationFacilityID string         `json:"destination_facility_id"`
        OrderID               string         `json:"order_id"`
        DeliveryID            string         `json:"delivery_id"`
        Status                string         `json:"status"`
        ItemSummary           map[string]any `json:"items_summary"`
        PickupTime            string         `json:"pickup_time,omitzero"`
        DeliveryTime          string         `json:"pick_completed_at,omitzero"`
        IsSynced              bool           `json:"is_synced"`
        TimeStamp             string         `json:"time_stamp"`
}

func (app *NewManifest) Decode(data []byte) error <span class="cov0" title="0">{
        return json.Unmarshal(data, app)
}</span>

func (app NewManifest) Validate() error <span class="cov0" title="0">{
        if err := errs.Check(app); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("validate: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func toBusNewManifest(app NewManifest) (manifestbus.NewManifest, error) <span class="cov0" title="0">{
        pkupbtchID, err := uuid.Parse(app.PickupBatchID)
        if err != nil </span><span class="cov0" title="0">{
                return manifestbus.NewManifest{}, fmt.Errorf("parsepkupid: %w", err)
        }</span>

        <span class="cov0" title="0">origFacility, err := uuid.Parse(app.OriginFacilityID)
        if err != nil </span><span class="cov0" title="0">{
                return manifestbus.NewManifest{}, fmt.Errorf("parseorgfacility: %w", err)
        }</span>

        <span class="cov0" title="0">destfacID, err := uuid.Parse(app.DestinationFacilityID)
        if err != nil </span><span class="cov0" title="0">{
                return manifestbus.NewManifest{}, fmt.Errorf("parsedestfacid: %w", err)
        }</span>

        <span class="cov0" title="0">orderID, err := genstringtype.Parse(app.OrderID)
        if err != nil </span><span class="cov0" title="0">{
                return manifestbus.NewManifest{}, fmt.Errorf("parseordrid: %w", err)
        }</span>

        <span class="cov0" title="0">delID, err := genstringtype.Parse(app.DeliveryID)
        if err != nil </span><span class="cov0" title="0">{
                return manifestbus.NewManifest{}, fmt.Errorf("parsedelid: %w", err)
        }</span>

        <span class="cov0" title="0">sts, err := genstringtype.Parse(app.Status)
        if err != nil </span><span class="cov0" title="0">{
                return manifestbus.NewManifest{}, fmt.Errorf("parsestatus: %w", err)
        }</span>

        <span class="cov0" title="0">itmsmr, err := json.Marshal(app.ItemSummary)
        if err != nil </span><span class="cov0" title="0">{
                return manifestbus.NewManifest{}, fmt.Errorf("parseitemsumry: %w", err)
        }</span>

        <span class="cov0" title="0">var tmesmp time.Time
        if app.TimeStamp != "" </span><span class="cov0" title="0">{
                tmesmp, err = time.Parse(time.RFC3339, app.TimeStamp)
                if err != nil </span><span class="cov0" title="0">{
                        return manifestbus.NewManifest{}, fmt.Errorf("parsetimestamp: %w", err)
                }</span>
        }

        <span class="cov0" title="0">var pickstart time.Time
        if app.PickupTime != "" </span><span class="cov0" title="0">{
                pickstart, err = time.Parse(time.RFC3339, app.PickupTime)
                if err != nil </span><span class="cov0" title="0">{
                        return manifestbus.NewManifest{}, fmt.Errorf("parsepickupstart: %w", err)
                }</span>
        }

        <span class="cov0" title="0">var deltime time.Time
        if app.DeliveryTime != "" </span><span class="cov0" title="0">{
                deltime, err = time.Parse(time.RFC3339, app.DeliveryTime)
                if err != nil </span><span class="cov0" title="0">{
                        return manifestbus.NewManifest{}, fmt.Errorf("parsedelivrytme: %w", err)
                }</span>
        }

        <span class="cov0" title="0">bus := manifestbus.NewManifest{
                PickupBatchID:         pkupbtchID,
                OriginFacilityID:      origFacility,
                DestinationFacilityID: destfacID,
                OrderID:               orderID,
                DeliveryID:            delID,
                Status:                sts,
                ItemsSummary:          itmsmr,
                PickupTime:            pickstart,
                DeliveryTime:          deltime,
                IsSynced:              app.IsSynced,
                TimeStamp:             tmesmp,
        }

        return bus, nil</span>

}

//===============================================================================

type UpdateManifest struct {
        PickupBatchID         *string         `json:"pickup_batch_id"`
        OriginFacilityID      *string         `json:"origin_facility_id"`
        DestinationFacilityID *string         `json:"destination_facility_id"`
        OrderID               *string         `json:"order_id"`
        DeliveryID            *string         `json:"delivery_id"`
        Status                *string         `json:"status"`
        ItemSummary           *map[string]any `json:"items_summary"`
        PickupTime            *string         `json:"pickup_time,omitzero"`
        DeliveryTime          *string         `json:"pick_completed_at,omitzero"`
        IsSynced              *bool           `json:"is_synced"`
        TimeStamp             *string         `json:"time_stamp"`
}

func (app *UpdateManifest) Decode(data []byte) error <span class="cov0" title="0">{
        return json.Unmarshal(data, app)
}</span>

func (app UpdateManifest) Validate() error <span class="cov0" title="0">{
        if err := errs.Check(app); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("validate: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func toBusUpdateManifest(app UpdateManifest) (manifestbus.UpdateManifest, error) <span class="cov0" title="0">{
        var pkpbtchID *uuid.UUID
        if app.PickupBatchID != nil </span><span class="cov0" title="0">{
                pkid, err := uuid.Parse(*app.PickupBatchID)
                if err != nil </span><span class="cov0" title="0">{
                        return manifestbus.UpdateManifest{}, fmt.Errorf("parse: %w", err)
                }</span>
                <span class="cov0" title="0">pkpbtchID = &amp;pkid</span>
        }

        <span class="cov0" title="0">var origFac *uuid.UUID
        if app.OriginFacilityID != nil </span><span class="cov0" title="0">{
                facility, err := uuid.Parse(*app.OriginFacilityID)
                if err != nil </span><span class="cov0" title="0">{
                        return manifestbus.UpdateManifest{}, fmt.Errorf("parse: %w", err)
                }</span>
                <span class="cov0" title="0">origFac = &amp;facility</span>
        }

        <span class="cov0" title="0">var destID *uuid.UUID
        if app.DestinationFacilityID != nil </span><span class="cov0" title="0">{
                destid, err := uuid.Parse(*app.DestinationFacilityID)

                if err != nil </span><span class="cov0" title="0">{
                        return manifestbus.UpdateManifest{}, fmt.Errorf("parse: %w", err)
                }</span>
                <span class="cov0" title="0">destID = &amp;destid</span>

        }

        <span class="cov0" title="0">var ordrid *genstringtype.GenString
        if app.OrderID != nil </span><span class="cov0" title="0">{
                oid, err := genstringtype.Parse(*app.OrderID)
                if err != nil </span><span class="cov0" title="0">{
                        return manifestbus.UpdateManifest{}, fmt.Errorf("parse: %w", err)

                }</span>
                <span class="cov0" title="0">ordrid = &amp;oid</span>
        }

        <span class="cov0" title="0">var delID *genstringtype.GenString
        if app.DeliveryID != nil </span><span class="cov0" title="0">{
                did, err := genstringtype.Parse(*app.DeliveryID)
                if err != nil </span><span class="cov0" title="0">{
                        return manifestbus.UpdateManifest{}, fmt.Errorf("parse: %w", err)

                }</span>
                <span class="cov0" title="0">delID = &amp;did</span>
        }

        <span class="cov0" title="0">var sts *genstringtype.GenString
        if app.Status != nil </span><span class="cov0" title="0">{
                batch, err := genstringtype.Parse(*app.Status)
                if err != nil </span><span class="cov0" title="0">{
                        return manifestbus.UpdateManifest{}, fmt.Errorf("parse: %w", err)

                }</span>
                <span class="cov0" title="0">sts = &amp;batch</span>
        }

        <span class="cov0" title="0">var itmsmr *json.RawMessage
        if app.ItemSummary != nil </span><span class="cov0" title="0">{
                itemsmr, err := json.Marshal(app.ItemSummary)
                if err != nil </span><span class="cov0" title="0">{
                        return manifestbus.UpdateManifest{}, fmt.Errorf("parse: %w", err)
                }</span>
                <span class="cov0" title="0">raw := json.RawMessage(itemsmr)
                itmsmr = &amp;raw</span>
        }

        <span class="cov0" title="0">var pickedat *time.Time
        if app.PickupTime != nil </span><span class="cov0" title="0">{
                picked, err := time.Parse(time.RFC3339, *app.PickupTime)
                if err != nil </span><span class="cov0" title="0">{
                        return manifestbus.UpdateManifest{}, fmt.Errorf("parse: %w", err)

                }</span>
                <span class="cov0" title="0">pickedat = &amp;picked</span>
        }

        <span class="cov0" title="0">var delat *time.Time
        if app.DeliveryTime != nil </span><span class="cov0" title="0">{
                complat, err := time.Parse(time.RFC3339, *app.DeliveryTime)
                if err != nil </span><span class="cov0" title="0">{
                        return manifestbus.UpdateManifest{}, fmt.Errorf("parse: %w", err)
                }</span>
                <span class="cov0" title="0">delat = &amp;complat</span>
        }

        <span class="cov0" title="0">var timestamp *time.Time
        if app.TimeStamp != nil </span><span class="cov0" title="0">{
                ts, err := time.Parse(time.RFC3339, *app.TimeStamp)
                if err != nil </span><span class="cov0" title="0">{
                        return manifestbus.UpdateManifest{}, fmt.Errorf("parse: %w", err)
                }</span>
                <span class="cov0" title="0">timestamp = &amp;ts</span>
        }

        <span class="cov0" title="0">bus := manifestbus.UpdateManifest{
                PickupBatchID:         pkpbtchID,
                OriginFacilityID:      origFac,
                DestinationFacilityID: destID,
                OrderID:               ordrid,
                DeliveryID:            delID,
                Status:                sts,
                ItemsSummary:          itmsmr,
                PickupTime:            pickedat,
                DeliveryTime:          delat,
                TimeStamp:             timestamp,
                IsSynced:              app.IsSynced,
        }

        return bus, nil</span>
}

// ======================================================================

type ManifestDelete struct {
        Message string `json:"message"`
}

func (e ManifestDelete) Encode() ([]byte, string, error) <span class="cov0" title="0">{
        data, err := json.Marshal(e)
        return data, "application/json", err
}</span>
</pre>
		
		<pre class="file" id="file46" style="display: none">package manifestapp

import (
        "net/http"

        "github.com/FITHSCS/backend/app/sdk/authclient"
        "github.com/FITHSCS/backend/app/sdk/mid"
        "github.com/FITHSCS/backend/business/domain/manifestbus"

        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/FITHSCS/backend/foundation/web"
)

type Config struct {
        Log         *logger.Logger
        ManifestBus *manifestbus.Business
        AuthClient  *authclient.Client
}

func Routes(app *web.App, cfg Config) <span class="cov0" title="0">{

        const version = "v1"

        authen := mid.Authenticate(cfg.AuthClient)

        api := newApp(cfg.ManifestBus)

        app.HandlerFunc(http.MethodPost, version, "/manifest", api.create, authen)
        app.HandlerFunc(http.MethodGet, version, "/manifest", api.query)
        app.HandlerFunc(http.MethodGet, version, "/manifest/{manifest_id}", api.queryByID, authen)
        app.HandlerFunc(http.MethodPut, version, "/manifest/{manifest_id}", api.update, authen)
        app.HandlerFunc(http.MethodPut, version, "/manifest/sdelete/{manifest_id}", api.softDelete, authen)
        app.HandlerFunc(http.MethodDelete, version, "/manifest/hdelete/{manifest_id}", api.hardDelete, authen)

}</span>
</pre>
		
		<pre class="file" id="file47" style="display: none">package pickupbatchapp

import (
        "net/http"
        "time"

        "github.com/FITHSCS/backend/app/sdk/errs"
        "github.com/FITHSCS/backend/business/domain/pickupbatchbus"
        "github.com/FITHSCS/backend/business/types/name"
        "github.com/google/uuid"
)

type queryParams struct {
        Page                       string
        Rows                       string
        OrderBy                    string
        ID                         string
        RouteID                    string
        OriginFacility             string
        VehicleID                  string
        DeliveryPersonnelID        string
        DeliveryPersonnelSignature string
        TimeStamp                  string
        IsSynced                   string
        CreatedAt                  string
        UpdatedAt                  string
}

func ParseQueryParams(r *http.Request) (queryParams, error) <span class="cov0" title="0">{

        values := r.URL.Query()

        filter := queryParams{

                Page:                       values.Get("page"),
                Rows:                       values.Get("rows"),
                OrderBy:                    values.Get("orderBy"),
                ID:                         values.Get("pickup_batch_id"),
                RouteID:                    values.Get("route_id"),
                OriginFacility:             values.Get("origin_facility_id"),
                VehicleID:                  values.Get("vehicle_id"),
                DeliveryPersonnelID:        values.Get("delivery_personnel_id"),
                DeliveryPersonnelSignature: values.Get("delivery_personnel_signature"),
                TimeStamp:                  values.Get("time_stamp"),
                IsSynced:                   values.Get("is_synced"),
                CreatedAt:                  values.Get("created_at"),
                UpdatedAt:                  values.Get("updated_at"),
        }

        return filter, nil
}</span>

func ParseFilter(qp queryParams) (pickupbatchbus.QueryFilter, error) <span class="cov0" title="0">{

        var fieldErrors errs.FieldErrors
        var filter pickupbatchbus.QueryFilter

        if qp.ID != "" </span><span class="cov0" title="0">{
                id, err := uuid.Parse(qp.ID)
                if err != nil </span><span class="cov0" title="0">{
                        fieldErrors.Add("pickup_batch_id", err)
                }</span> else<span class="cov0" title="0"> {
                        filter.ID = id
                }</span>
        }

        <span class="cov0" title="0">if qp.RouteID != "" </span><span class="cov0" title="0">{
                routeID, err := name.Parse(qp.RouteID)
                switch err </span>{
                case nil:<span class="cov0" title="0">
                        filter.RouteID = &amp;routeID</span>
                default:<span class="cov0" title="0">
                        fieldErrors.Add("Route Id", err)</span>
                }
        }

        <span class="cov0" title="0">if qp.OriginFacility != "" </span><span class="cov0" title="0">{

                origFacility, err := name.Parse(qp.OriginFacility)
                switch err </span>{
                case nil:<span class="cov0" title="0">
                        filter.OriginFacility = &amp;origFacility</span>
                default:<span class="cov0" title="0">
                        fieldErrors.Add("Origin Facility", err)</span>
                }
        }

        <span class="cov0" title="0">if qp.VehicleID != "" </span><span class="cov0" title="0">{
                vehID, err := name.Parse(qp.VehicleID)
                switch err </span>{
                case nil:<span class="cov0" title="0">
                        filter.VehicleID = &amp;vehID</span>
                default:<span class="cov0" title="0">
                        fieldErrors.Add("Vehicle ID", err)</span>
                }
        }
        <span class="cov0" title="0">if qp.DeliveryPersonnelID != "" </span><span class="cov0" title="0">{
                delPersonnelID, err := name.Parse(qp.DeliveryPersonnelID)
                switch err </span>{
                case nil:<span class="cov0" title="0">
                        filter.DeliveryPersonnelID = &amp;delPersonnelID</span>
                default:<span class="cov0" title="0">
                        fieldErrors.Add("Delivery personnel ID", err)</span>
                }
        }

        <span class="cov0" title="0">if qp.DeliveryPersonnelSignature != "" </span><span class="cov0" title="0">{
                delPersonnelSign, err := name.Parse(qp.DeliveryPersonnelSignature)
                switch err </span>{
                case nil:<span class="cov0" title="0">
                        filter.DeliveryPersonnelSignature = &amp;delPersonnelSign</span>
                default:<span class="cov0" title="0">
                        fieldErrors.Add("Delivery personnel Signature", err)</span>
                }
        }
        <span class="cov0" title="0">if qp.TimeStamp != "" </span><span class="cov0" title="0">{
                t, err := time.Parse(time.RFC3339, qp.CreatedAt)
                switch err </span>{
                case nil:<span class="cov0" title="0">
                        filter.TimeStamp = &amp;t</span>
                default:<span class="cov0" title="0">
                        fieldErrors.Add("time_stamp", err)</span>
                }
        }

        <span class="cov0" title="0">if qp.CreatedAt != "" </span><span class="cov0" title="0">{
                t, err := time.Parse(time.RFC3339, qp.CreatedAt)
                switch err </span>{
                case nil:<span class="cov0" title="0">
                        filter.CreatedAt = &amp;t</span>
                default:<span class="cov0" title="0">
                        fieldErrors.Add("created_at", err)</span>
                }
        }
        <span class="cov0" title="0">if qp.UpdatedAt != "" </span><span class="cov0" title="0">{
                t, err := time.Parse(time.RFC3339, qp.UpdatedAt)
                switch err </span>{
                case nil:<span class="cov0" title="0">
                        filter.UpdatedAt = &amp;t</span>
                default:<span class="cov0" title="0">
                        fieldErrors.Add("updated_at", err)</span>
                }
        }
        <span class="cov0" title="0">if fieldErrors != nil </span><span class="cov0" title="0">{
                return pickupbatchbus.QueryFilter{}, fieldErrors.ToError()
        }</span>
        <span class="cov0" title="0">return filter, nil</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package pickupbatchapp

import (
        "encoding/json"
        "fmt"
        "time"

        "github.com/FITHSCS/backend/app/sdk/errs"
        "github.com/FITHSCS/backend/business/domain/pickupbatchbus"
        "github.com/FITHSCS/backend/business/types/genstringtype"
        "github.com/google/uuid"
)

type PickupBatch struct {
        ID                  string `json:"pickup_batch_id"`
        RouteID             string `json:"route_id"`
        OriginFacilityID    string `json:"origin_facility_id"`
        VehicleID           string `json:"vehicle_id"`
        DeliveryPersonnelID string `json:"delivery_personnel_id"`
        BatchName           string `json:"batch_name"`
        BatchStatus         string `json:"batch_status"`
        PickedStartedAt     string `json:"pickup_started_at"`
        PickupCompletedAt   string `json:"pickup_completed_at"`
        IsSynced            bool   `json:"is_synced"`
        TimeStamp           string `json:"time_stamp"`
        CreatedAt           string `json:"created_at"`
        UpdatedAt           string `json:"updated_at"`
}

type PickupBatches []PickupBatch

func (e PickupBatches) Encode() ([]byte, string, error) <span class="cov0" title="0">{
        data, err := json.Marshal(e)
        return data, "application/json", err
}</span>

// Encode implements the encoder interface
func (app PickupBatch) Encode() ([]byte, string, error) <span class="cov0" title="0">{

        data, err := json.Marshal(app)
        return data, "application/json", err
}</span>

//==================================================================

func toAppPickupBatch(pickupbatch pickupbatchbus.PickupBatch) PickupBatch <span class="cov0" title="0">{

        var pickStartedAt string
        if !pickupbatch.PickedStartedAt.IsZero() </span><span class="cov0" title="0">{
                pickStartedAt = pickupbatch.PickedStartedAt.Format(time.RFC3339)
        }</span>

        <span class="cov0" title="0">var pickCompletedAt string
        if !pickupbatch.PickupCompletedAt.IsZero() </span><span class="cov0" title="0">{
                pickCompletedAt = pickupbatch.PickupCompletedAt.Format(time.RFC3339)
        }</span>

        <span class="cov0" title="0">return PickupBatch{
                ID:                  pickupbatch.ID.String(),
                RouteID:             pickupbatch.RouteID.String(),
                OriginFacilityID:    pickupbatch.OriginFacilityID.String(),
                VehicleID:           pickupbatch.VehicleID.String(),
                DeliveryPersonnelID: pickupbatch.DeliveryPersonnelID.String(),
                BatchName:           pickupbatch.BatchName.String(),
                BatchStatus:         pickupbatch.BatchStatus.String(),
                PickedStartedAt:     pickStartedAt,
                PickupCompletedAt:   pickCompletedAt,
                IsSynced:            pickupbatch.IsSynced,
                TimeStamp:           pickupbatch.TimeStamp.String(),
                CreatedAt:           pickupbatch.CreatedAt.Format(time.RFC3339),
                UpdatedAt:           pickupbatch.UpdatedAt.Format(time.RFC3339),
        }</span>

}

func toAppPickupBatches(pickupbatches []pickupbatchbus.PickupBatch) []PickupBatch <span class="cov0" title="0">{
        app := make([]PickupBatch, len(pickupbatches))
        for i, pickupbatch := range pickupbatches </span><span class="cov0" title="0">{
                app[i] = toAppPickupBatch(pickupbatch)
        }</span>
        <span class="cov0" title="0">return app</span>
}

//==============================================================================&gt;

type NewPickupBatch struct {
        RouteID             string `json:"route_id"`
        OriginFacilityID    string `json:"origin_facility_id"`
        VehicleID           string `json:"vehicle_id"`
        DeliveryPersonnelID string `json:"delivery_personnel_id"`
        BatchName           string `json:"batch_name"`
        BatchStatus         string `json:"batch_status"`
        PickedStartedAt     string `json:"pickup_started_at"`
        PickupCompletedAt   string `json:"pickup_completed_at"`
        IsSynced            bool   `json:"is_synced"`
        TimeStamp           string `json:"time_stamp"`
}

func (app *NewPickupBatch) Decode(data []byte) error <span class="cov0" title="0">{
        return json.Unmarshal(data, app)
}</span>

func (app NewPickupBatch) Validate() error <span class="cov0" title="0">{
        if err := errs.Check(app); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("validate: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func toBusNewPickupBatch(app NewPickupBatch) (pickupbatchbus.NewPickupBatch, error) <span class="cov0" title="0">{
        routeID, err := uuid.Parse(app.RouteID)
        if err != nil </span><span class="cov0" title="0">{
                return pickupbatchbus.NewPickupBatch{}, fmt.Errorf("parserouteid: %w", err)
        }</span>

        <span class="cov0" title="0">origFacility, err := uuid.Parse(app.OriginFacilityID)
        if err != nil </span><span class="cov0" title="0">{
                return pickupbatchbus.NewPickupBatch{}, fmt.Errorf("parseorgfacility: %w", err)
        }</span>

        <span class="cov0" title="0">vehID, err := uuid.Parse(app.VehicleID)
        if err != nil </span><span class="cov0" title="0">{
                return pickupbatchbus.NewPickupBatch{}, fmt.Errorf("parsevehid: %w", err)
        }</span>

        <span class="cov0" title="0">delPersID, err := uuid.Parse(app.DeliveryPersonnelID)
        if err != nil </span><span class="cov0" title="0">{
                return pickupbatchbus.NewPickupBatch{}, fmt.Errorf("parsedelpersid: %w", err)
        }</span>

        <span class="cov0" title="0">batchName, err := genstringtype.Parse(app.BatchName)
        if err != nil </span><span class="cov0" title="0">{
                return pickupbatchbus.NewPickupBatch{}, fmt.Errorf("parsebatchname: %w", err)
        }</span>

        <span class="cov0" title="0">batchSts, err := genstringtype.Parse(app.BatchStatus)
        if err != nil </span><span class="cov0" title="0">{
                return pickupbatchbus.NewPickupBatch{}, fmt.Errorf("parsebatchstats: %w", err)
        }</span>

        <span class="cov0" title="0">var tmestmp time.Time
        if app.TimeStamp != "" </span><span class="cov0" title="0">{
                tstmp, err := time.Parse(time.RFC3339, app.TimeStamp)
                if err != nil </span><span class="cov0" title="0">{
                        return pickupbatchbus.NewPickupBatch{}, fmt.Errorf("parsetmestmp: %w", err)
                }</span>
                <span class="cov0" title="0">tmestmp = tstmp</span>
        }

        <span class="cov0" title="0">var pickedat time.Time
        if app.PickedStartedAt != "" </span><span class="cov0" title="0">{
                picked, err := time.Parse(time.RFC3339, app.PickedStartedAt)
                if err != nil </span><span class="cov0" title="0">{
                        return pickupbatchbus.NewPickupBatch{}, fmt.Errorf("parsepickedat: %w", err)
                }</span>
                <span class="cov0" title="0">pickedat = picked</span>
        }

        <span class="cov0" title="0">var compat time.Time
        if app.PickupCompletedAt != "" </span><span class="cov0" title="0">{
                complat, err := time.Parse(time.RFC3339, app.PickupCompletedAt)
                if err != nil </span><span class="cov0" title="0">{
                        return pickupbatchbus.NewPickupBatch{}, fmt.Errorf("parsecompat: %w", err)

                }</span>
                <span class="cov0" title="0">compat = complat</span>
        }

        <span class="cov0" title="0">bus := pickupbatchbus.NewPickupBatch{
                RouteID:             routeID,
                OriginFacilityID:    origFacility,
                VehicleID:           vehID,
                DeliveryPersonnelID: delPersID,
                BatchName:           batchName,
                BatchStatus:         batchSts,
                PickedStartedAt:     pickedat,
                PickupCompletedAt:   compat,
                IsSynced:            app.IsSynced,
                TimeStamp:           tmestmp,
        }

        fmt.Printf("\n\n\ntoBus from APP layer: %v\n\n\n", bus)
        return bus, nil</span>

}

type UpdatePickupBatch struct {
        RouteID             *string `json:"route_id"`
        OriginFacility      *string `json:"origin_facility_id"`
        VehicleID           *string `json:"vehicle_id"`
        DeliveryPersonnelID *string `json:"delivery_personnel_id"`
        BatchName           *string `json:"batch_name"`
        BatchStatus         *string `json:"batch_status"`
        PickedStartedAt     *string `json:"pickup_started_at"`
        PickupCompletedAt   *string `json:"pickup_completed_at"`
        IsSynced            *bool   `json:"is_synced"`
        IsDeleted           *bool   `json:"is_deleted"`
        TimeStamp           *string `json:"time_stamp"`
}

func (app *UpdatePickupBatch) Decode(data []byte) error <span class="cov0" title="0">{
        return json.Unmarshal(data, app)
}</span>

func (app UpdatePickupBatch) Validate() error <span class="cov0" title="0">{
        if err := errs.Check(app); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("validate: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func toBusUpdatePickupBatch(app UpdatePickupBatch) (pickupbatchbus.UpdatePickupBatch, error) <span class="cov0" title="0">{
        var routeID *uuid.UUID
        if app.RouteID != nil </span><span class="cov0" title="0">{
                route, err := uuid.Parse(*app.RouteID)
                if err != nil </span><span class="cov0" title="0">{
                        return pickupbatchbus.UpdatePickupBatch{}, fmt.Errorf("parse: %w", err)
                }</span>
                <span class="cov0" title="0">routeID = &amp;route</span>
        }

        <span class="cov0" title="0">var origFac *uuid.UUID
        if app.OriginFacility != nil </span><span class="cov0" title="0">{
                facility, err := uuid.Parse(*app.OriginFacility)
                if err != nil </span><span class="cov0" title="0">{
                        return pickupbatchbus.UpdatePickupBatch{}, fmt.Errorf("parse: %w", err)
                }</span>
                <span class="cov0" title="0">origFac = &amp;facility</span>
        }

        <span class="cov0" title="0">var vehID *uuid.UUID
        if app.VehicleID != nil </span><span class="cov0" title="0">{
                vehicle, err := uuid.Parse(*app.VehicleID)

                if err != nil </span><span class="cov0" title="0">{
                        return pickupbatchbus.UpdatePickupBatch{}, fmt.Errorf("parse: %w", err)
                }</span>
                <span class="cov0" title="0">vehID = &amp;vehicle</span>

        }

        <span class="cov0" title="0">var delPersnlID *uuid.UUID
        if app.DeliveryPersonnelID != nil </span><span class="cov0" title="0">{
                delivery, err := uuid.Parse(*app.DeliveryPersonnelID)
                if err != nil </span><span class="cov0" title="0">{
                        return pickupbatchbus.UpdatePickupBatch{}, fmt.Errorf("parse: %w", err)

                }</span>
                <span class="cov0" title="0">delPersnlID = &amp;delivery</span>
        }

        <span class="cov0" title="0">var batchNme *genstringtype.GenString
        if app.BatchName != nil </span><span class="cov0" title="0">{
                batchName, err := genstringtype.Parse(*app.BatchName)
                if err != nil </span><span class="cov0" title="0">{
                        return pickupbatchbus.UpdatePickupBatch{}, fmt.Errorf("parse: %w", err)

                }</span>
                <span class="cov0" title="0">batchNme = &amp;batchName</span>
        }

        <span class="cov0" title="0">var batchSts *genstringtype.GenString
        if app.BatchStatus != nil </span><span class="cov0" title="0">{
                batch, err := genstringtype.Parse(*app.BatchStatus)
                if err != nil </span><span class="cov0" title="0">{
                        return pickupbatchbus.UpdatePickupBatch{}, fmt.Errorf("parse: %w", err)

                }</span>
                <span class="cov0" title="0">batchSts = &amp;batch</span>
        }

        <span class="cov0" title="0">var pickedat *time.Time
        if app.PickedStartedAt != nil </span><span class="cov0" title="0">{
                picked, err := time.Parse(time.RFC3339, *app.PickedStartedAt)
                if err != nil </span><span class="cov0" title="0">{
                        return pickupbatchbus.UpdatePickupBatch{}, fmt.Errorf("parse: %w", err)

                }</span>
                <span class="cov0" title="0">pickedat = &amp;picked</span>
        }

        <span class="cov0" title="0">var compat *time.Time
        if app.PickupCompletedAt != nil </span><span class="cov0" title="0">{
                complat, err := time.Parse(time.RFC3339, *app.PickupCompletedAt)
                if err != nil </span><span class="cov0" title="0">{
                        return pickupbatchbus.UpdatePickupBatch{}, fmt.Errorf("parse: %w", err)

                }</span>
                <span class="cov0" title="0">compat = &amp;complat</span>
        }

        <span class="cov0" title="0">var timestamp *time.Time
        if app.TimeStamp != nil </span><span class="cov0" title="0">{
                ts, err := time.Parse(time.RFC3339, *app.TimeStamp)
                if err != nil </span><span class="cov0" title="0">{
                        return pickupbatchbus.UpdatePickupBatch{}, fmt.Errorf("parse: %w", err)

                }</span>
                <span class="cov0" title="0">timestamp = &amp;ts</span>
        }

        <span class="cov0" title="0">bus := pickupbatchbus.UpdatePickupBatch{
                RouteID:             routeID,
                OriginFacilityID:    origFac,
                VehicleID:           vehID,
                DeliveryPersonnelID: delPersnlID,
                BatchName:           batchNme,
                BatchStatus:         batchSts,
                PickedStartedAt:     pickedat,
                PickupCompletedAt:   compat,
                TimeStamp:           timestamp,
                IsSynced:            app.IsSynced,
        }

        return bus, nil</span>
}

type PickupBatchDelete struct {
        Message string `json:"message"`
}

func (e PickupBatchDelete) Encode() ([]byte, string, error) <span class="cov0" title="0">{
        data, err := json.Marshal(e)
        return data, "application/json", err
}</span>
</pre>
		
		<pre class="file" id="file49" style="display: none">// Package pickupbatchapp maintains the app layer api for the pickupbatch domain.
package pickupbatchapp

import (
        "context"
        "net/http"

        "github.com/FITHSCS/backend/app/sdk/errs"
        "github.com/FITHSCS/backend/app/sdk/query"
        "github.com/FITHSCS/backend/business/domain/pickupbatchbus"
        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/foundation/web"
        "github.com/google/uuid"
)

type app struct {
        pickupbatchBus *pickupbatchbus.Business
}

func newApp(pickupbatchBus *pickupbatchbus.Business) *app <span class="cov0" title="0">{
        return &amp;app{
                pickupbatchBus: pickupbatchBus,
        }
}</span>

func (a *app) create(ctx context.Context, r *http.Request) web.Encoder <span class="cov0" title="0">{

        var pb NewPickupBatch
        if err := web.Decode(r, &amp;pb); err != nil </span><span class="cov0" title="0">{

                return errs.New(errs.InvalidArgument, err)
        }</span>

        <span class="cov0" title="0">nc, err := toBusNewPickupBatch(pb)
        if err != nil </span><span class="cov0" title="0">{
                return errs.New(errs.InvalidArgument, err)
        }</span>

        <span class="cov0" title="0">pckpBtchCretd, err := a.pickupbatchBus.Create(ctx, nc)
        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "create pickupbatch[%+v]: %s", pckpBtchCretd, err)
        }</span>
        <span class="cov0" title="0">return toAppPickupBatch(pckpBtchCretd)</span>
}

func (a *app) update(ctx context.Context, r *http.Request) web.Encoder <span class="cov0" title="0">{
        pickupbatchIDStr := web.Param(r, "pickup_batch_id")
        pickupbatchID, err := uuid.Parse(pickupbatchIDStr)

        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "id not correctly formatted: %s", err)
        }</span>

        <span class="cov0" title="0">var update UpdatePickupBatch
        if err := web.Decode(r, &amp;update); err != nil </span><span class="cov0" title="0">{
                return errs.New(errs.InvalidArgument, err)
        }</span>

        <span class="cov0" title="0">updatePickupBatchBus, err := toBusUpdatePickupBatch(update)
        if err != nil </span><span class="cov0" title="0">{
                return errs.New(errs.InvalidArgument, err)
        }</span>

        <span class="cov0" title="0">updatedPickupBatch, err := a.pickupbatchBus.Update(ctx, pickupbatchID, updatePickupBatchBus)
        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "update: applyr, ID: [%s] Request: %v", pickupbatchID, update)
        }</span>

        <span class="cov0" title="0">return toAppPickupBatch(updatedPickupBatch)</span>
}

func (a *app) query(ctx context.Context, r *http.Request) web.Encoder <span class="cov0" title="0">{
        queryParameters, err := ParseQueryParams(r)

        if err != nil </span><span class="cov0" title="0">{
                return errs.New(errs.InvalidArgument, err)
        }</span>
        <span class="cov0" title="0">page, err := page.Parse(queryParameters.Page, queryParameters.Rows)
        if err != nil </span><span class="cov0" title="0">{
                return errs.NewFieldErrors("page", err)
        }</span>
        <span class="cov0" title="0">filter, err := ParseFilter(queryParameters)
        if err != nil </span><span class="cov0" title="0">{
                return err.(*errs.Error)
        }</span>
        <span class="cov0" title="0">orderBy, err := order.Parse(orderByFields, queryParameters.OrderBy, pickupbatchbus.DefaultOrderBy)

        if err != nil </span><span class="cov0" title="0">{
                return errs.NewFieldErrors("order", err)
        }</span>
        <span class="cov0" title="0">pickupbatches, err := a.pickupbatchBus.Query(ctx, filter, orderBy, page)
        if err != nil </span><span class="cov0" title="0">{
                return errs.NewFieldErrors("query", err)
        }</span>

        <span class="cov0" title="0">total, err := a.pickupbatchBus.Count(ctx, filter)
        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "count: %s", err)
        }</span>

        <span class="cov0" title="0">return query.NewResult(toAppPickupBatches(pickupbatches), total, page)</span>

}

func (a *app) queryByID(ctx context.Context, r *http.Request) web.Encoder <span class="cov0" title="0">{

        pickupbatchIDStr := web.Param(r, "pickup_batch_id")
        pickupbatchID, err := uuid.Parse(pickupbatchIDStr)

        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "id not correctly formatted: %s", err)
        }</span>

        <span class="cov0" title="0">pickupbatchRetrieved, err := a.pickupbatchBus.QueryByID(ctx, pickupbatchID)
        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "queryid: pickupbatchapp[%s]: %s", pickupbatchID, err)
        }</span>

        <span class="cov0" title="0">return toAppPickupBatch(pickupbatchRetrieved)</span>
}

func (a *app) softDelete(ctx context.Context, r *http.Request) web.Encoder <span class="cov0" title="0">{

        pickupbatchIDStr := web.Param(r, "pickup_batch_id")

        pickupbatchID, err := uuid.Parse(pickupbatchIDStr)

        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "Pickup batch Id missing in context %s", err)
        }</span>
        <span class="cov0" title="0">if err := a.pickupbatchBus.SoftDelete(ctx, pickupbatchID); err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "delete: pickupBatchID[%s]: %s", pickupbatchID, err)
        }</span>
        <span class="cov0" title="0">return PickupBatchDelete{
                Message: "pickupBatch delete successfull",
        }</span>
}

func (a *app) hardDelete(ctx context.Context, r *http.Request) web.Encoder <span class="cov0" title="0">{

        pickupbatchIDStr := web.Param(r, "pickup_batch_id")

        pickupbatchID, err := uuid.Parse(pickupbatchIDStr)

        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "pickupBatchID missing in context %s", err)
        }</span>
        <span class="cov0" title="0">if err := a.pickupbatchBus.HardDelete(ctx, pickupbatchID); err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "delete: pickupBatchID[%s]: %s", pickupbatchID, err)
        }</span>
        <span class="cov0" title="0">return PickupBatchDelete{
                Message: "pickupBatch delete successfull",
        }</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package pickupbatchapp

import (
        "net/http"

        "github.com/FITHSCS/backend/app/sdk/authclient"
        "github.com/FITHSCS/backend/app/sdk/mid"

        "github.com/FITHSCS/backend/business/domain/pickupbatchbus"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/FITHSCS/backend/foundation/web"
)

type Config struct {
        Log            *logger.Logger
        PickupBatchBus *pickupbatchbus.Business
        AuthClient     *authclient.Client
}

func Routes(app *web.App, cfg Config) <span class="cov0" title="0">{

        const version = "v1"

        authen := mid.Authenticate(cfg.AuthClient)

        api := newApp(cfg.PickupBatchBus)

        app.HandlerFunc(http.MethodPost, version, "/pickupbatch", api.create, authen)
        app.HandlerFunc(http.MethodGet, version, "/pickupbatch", api.query)
        app.HandlerFunc(http.MethodGet, version, "/pickupbatch/{pickup_batch_id}", api.queryByID, authen)
        app.HandlerFunc(http.MethodPut, version, "/pickupbatch/{pickup_batch_id}", api.update, authen)
        app.HandlerFunc(http.MethodPut, version, "/pickupbatch/sdelete/{pickup_batch_id}", api.softDelete, authen)
        app.HandlerFunc(http.MethodDelete, version, "/pickupbatch/hdelete/{pickup_batch_id}", api.hardDelete, authen)

}</span>
</pre>
		
		<pre class="file" id="file51" style="display: none">package routeapp

import (
        "net/http"
        "strconv"
        "time"

        "github.com/FITHSCS/backend/app/sdk/errs"
        "github.com/FITHSCS/backend/business/domain/routebus"
        "github.com/FITHSCS/backend/business/types/genstringtype"
        "github.com/google/uuid"
)

type queryParams struct {
        Page            string
        Rows            string
        OrderBy         string
        ID              string
        StartFacilityID string
        EndFacilityID   string
        RouteName       string
        TotalKM         string
        TotalStops      string
        CreatedAt       string
        UpdatedAt       string
}

func ParseQueryParams(r *http.Request) (queryParams, error) <span class="cov0" title="0">{

        values := r.URL.Query()

        filter := queryParams{

                Page:            values.Get("page"),
                Rows:            values.Get("rows"),
                OrderBy:         values.Get("orderBy"),
                ID:              values.Get("route_id"),
                StartFacilityID: values.Get("start_facility_id"),
                EndFacilityID:   values.Get("end_facility_id"),
                RouteName:       values.Get("route_name"),
                TotalKM:         values.Get("total_km"),
                TotalStops:      values.Get("total_stops"),
                CreatedAt:       values.Get("created_at"),
                UpdatedAt:       values.Get("updated_at"),
        }

        return filter, nil
}</span>

func ParseFilter(qp queryParams) (routebus.QueryFilter, error) <span class="cov0" title="0">{

        var fieldErrors errs.FieldErrors
        var filter routebus.QueryFilter

        if qp.ID != "" </span><span class="cov0" title="0">{
                id, err := uuid.Parse(qp.ID)
                if err != nil </span><span class="cov0" title="0">{
                        fieldErrors.Add("route_id", err)
                }</span> else<span class="cov0" title="0"> {
                        filter.ID = &amp;id
                }</span>
        }

        <span class="cov0" title="0">if qp.StartFacilityID != "" </span><span class="cov0" title="0">{
                stfacID, err := uuid.Parse(qp.StartFacilityID)
                switch err </span>{
                case nil:<span class="cov0" title="0">
                        filter.StartFacility = &amp;stfacID</span>
                default:<span class="cov0" title="0">
                        fieldErrors.Add("Route Id", err)</span>
                }
        }

        <span class="cov0" title="0">if qp.EndFacilityID != "" </span><span class="cov0" title="0">{
                endfac, err := uuid.Parse(qp.EndFacilityID)
                switch err </span>{
                case nil:<span class="cov0" title="0">
                        filter.EndFacility = &amp;endfac</span>
                default:<span class="cov0" title="0">
                        fieldErrors.Add("End Facility", err)</span>
                }
        }

        <span class="cov0" title="0">if qp.RouteName != "" </span><span class="cov0" title="0">{
                rnme, err := genstringtype.Parse(qp.RouteName)
                switch err </span>{
                case nil:<span class="cov0" title="0">
                        ptrRname := rnme.String()
                        filter.RouteName = &amp;ptrRname</span>
                default:<span class="cov0" title="0">
                        fieldErrors.Add("Vehicle ID", err)</span>
                }
        }
        <span class="cov0" title="0">if qp.TotalKM != "" </span><span class="cov0" title="0">{
                totkm, err := strconv.ParseFloat(qp.TotalKM, 64)
                switch err </span>{
                case nil:<span class="cov0" title="0">
                        filter.TotalKM = &amp;totkm</span>
                default:<span class="cov0" title="0">
                        fieldErrors.Add("Delivery personnel ID", err)</span>
                }
        }

        <span class="cov0" title="0">if qp.TotalStops != "" </span><span class="cov0" title="0">{
                totstops, err := strconv.Atoi(qp.TotalStops)
                switch err </span>{
                case nil:<span class="cov0" title="0">
                        totstops64 := int64(totstops)
                        filter.TotalStops = &amp;totstops64</span>
                default:<span class="cov0" title="0">
                        fieldErrors.Add("Delivery personnel Signature", err)</span>
                }
        }

        <span class="cov0" title="0">if qp.CreatedAt != "" </span><span class="cov0" title="0">{
                t, err := time.Parse(time.RFC3339, qp.CreatedAt)
                switch err </span>{
                case nil:<span class="cov0" title="0">
                        filter.CreatedAt = &amp;t</span>
                default:<span class="cov0" title="0">
                        fieldErrors.Add("created_at", err)</span>
                }
        }
        <span class="cov0" title="0">if qp.UpdatedAt != "" </span><span class="cov0" title="0">{
                t, err := time.Parse(time.RFC3339, qp.UpdatedAt)
                switch err </span>{
                case nil:<span class="cov0" title="0">
                        filter.UpdatedAt = &amp;t</span>
                default:<span class="cov0" title="0">
                        fieldErrors.Add("updated_at", err)</span>
                }
        }
        <span class="cov0" title="0">if fieldErrors != nil </span><span class="cov0" title="0">{
                return routebus.QueryFilter{}, fieldErrors.ToError()
        }</span>
        <span class="cov0" title="0">return filter, nil</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">package routeapp

import (
        "encoding/json"
        "fmt"
        "time"

        "github.com/FITHSCS/backend/app/sdk/errs"
        "github.com/FITHSCS/backend/business/domain/routebus"
        "github.com/FITHSCS/backend/business/types/facilitytype"
        "github.com/FITHSCS/backend/business/types/genstringtype"
        "github.com/google/uuid"
)

type Route struct {
        ID              string  `json:"route_id"`
        StartFacilityID string  `json:"start_facility_id"`
        EndFacilityID   string  `json:"end_facility_id"`
        RouteName       string  `json:"route_name"`
        TotalKM         float64 `json:"total_km"`
        TotalStops      int     `json:"total_stops"`
        StartLatitude   float64 `json:"start_latitude"`
        EndLatitude     float64 `json:"end_latitude"`
        StartLongitude  float64 `json:"start_longitude"`
        EndLongitude    float64 `json:"end_longitude"`
        IsActive        bool    `json:"is_active"`
        CreatedAt       string  `json:"created_at"`
        UpdatedAt       string  `json:"updated_at"`
}

type MultipleRoutes []Route

func (e MultipleRoutes) Encode() ([]byte, string, error) <span class="cov0" title="0">{
        data, err := json.Marshal(e)
        return data, "application/json", err
}</span>

// Encode implements the encoder interface
func (app Route) Encode() ([]byte, string, error) <span class="cov0" title="0">{

        data, err := json.Marshal(app)
        return data, "application/json", err
}</span>

//==================================================================

func toAppRoute(bus routebus.Route) Route <span class="cov0" title="0">{

        return Route{
                ID:              bus.RouteID.String(),
                StartFacilityID: bus.StartFacilityID.String(),
                EndFacilityID:   bus.EndFacilityID.String(),
                RouteName:       bus.RouteName.String(),
                TotalKM:         bus.TotalKM,
                TotalStops:      bus.TotalStops,
                StartLatitude:   bus.StartLatitude.Float64(),
                EndLatitude:     bus.EndLatitude.Float64(),
                StartLongitude:  bus.StartLongitude.Float64(),
                EndLongitude:    bus.EndLongitude.Float64(),
                IsActive:        bus.IsActive,
                CreatedAt:       bus.CreatedAt.Format(time.RFC3339),
                UpdatedAt:       bus.UpdatedAt.Format(time.RFC3339),
        }

}</span>

func toAppRoutes(pickupbatches []routebus.Route) []Route <span class="cov0" title="0">{
        app := make([]Route, len(pickupbatches))
        for i, pickupbatch := range pickupbatches </span><span class="cov0" title="0">{
                app[i] = toAppRoute(pickupbatch)
        }</span>
        <span class="cov0" title="0">return app</span>
}

// ==============================================================

type NewRoute struct {
        StartFacilityID string  `json:"start_facility_id"`
        EndFacilityID   string  `json:"end_facility_id"`
        RouteName       string  `json:"route_name"`
        TotalKM         float64 `json:"total_km"`
        TotalStops      int     `json:"total_stops"`
        StartLatitude   float64 `json:"start_latitude"`
        EndLatitude     float64 `json:"end_latitude"`
        StartLongitude  float64 `json:"start_longitude"`
        EndLongitude    float64 `json:"end_longitude"`
        IsActive        bool    `json:"is_active"`
}

func (app *NewRoute) Decode(data []byte) error <span class="cov0" title="0">{
        return json.Unmarshal(data, app)
}</span>

func (app NewRoute) Validate() error <span class="cov0" title="0">{
        if err := errs.Check(app); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("validate: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func toBusNewRoute(app NewRoute) (routebus.NewRoute, error) <span class="cov0" title="0">{
        stfacID, err := uuid.Parse(app.StartFacilityID)
        if err != nil </span><span class="cov0" title="0">{
                return routebus.NewRoute{}, fmt.Errorf("parsestartfacilityid: %w", err)
        }</span>

        <span class="cov0" title="0">endfacID, err := uuid.Parse(app.EndFacilityID)
        if err != nil </span><span class="cov0" title="0">{
                return routebus.NewRoute{}, fmt.Errorf("parseendfacilityid: %w", err)
        }</span>

        <span class="cov0" title="0">roteNme, err := genstringtype.Parse(app.RouteName)
        if err != nil </span><span class="cov0" title="0">{
                return routebus.NewRoute{}, fmt.Errorf("parseroutename: %w", err)
        }</span>

        <span class="cov0" title="0">stLat, err := facilitytype.ParseLat(app.StartLatitude)
        if err != nil </span><span class="cov0" title="0">{
                return routebus.NewRoute{}, fmt.Errorf("parselatitude: %w", err)
        }</span>

        <span class="cov0" title="0">stLong, err := facilitytype.ParseLong(app.StartLongitude)
        if err != nil </span><span class="cov0" title="0">{
                return routebus.NewRoute{}, fmt.Errorf("parselongitude: %w", err)
        }</span>

        <span class="cov0" title="0">endLong, err := facilitytype.ParseLong(app.EndLongitude)
        if err != nil </span><span class="cov0" title="0">{
                return routebus.NewRoute{}, fmt.Errorf("parseendlongitude: %w", err)
        }</span>

        <span class="cov0" title="0">endLat, err := facilitytype.ParseLat(app.EndLatitude)
        if err != nil </span><span class="cov0" title="0">{
                return routebus.NewRoute{}, fmt.Errorf("parseendlatitude: %w", err)
        }</span>

        <span class="cov0" title="0">tobus := routebus.NewRoute{
                StartFacilityID: stfacID,
                EndFacilityID:   endfacID,
                RouteName:       roteNme,
                TotalKM:         app.TotalKM,
                TotalStops:      app.TotalStops,
                StartLatitude:   stLat,
                StartLongitude:  stLong,
                EndLatitude:     endLat,
                EndLongitude:    endLong,
                IsActive:        app.IsActive,
        }

        return tobus, nil</span>
}

type UpdateRoute struct {
        StartFacilityID *string  `json:"start_facility_id"`
        EndFacilityID   *string  `json:"end_facility_id"`
        RouteName       *string  `json:"route_name"`
        TotalKM         *float64 `json:"total_km"`
        TotalStops      *int     `json:"total_stops"`
        StartLatitude   *float64 `json:"start_latitude"`
        EndLatitude     *float64 `json:"end_latitude"`
        StartLongitude  *float64 `json:"start_longitude"`
        EndLongitude    *float64 `json:"end_longitude"`
        IsActive        *bool    `json:"is_active"`
        UpdatedAt       *string  `json:"updated_at"`
}

func (app *UpdateRoute) Decode(data []byte) error <span class="cov0" title="0">{
        return json.Unmarshal(data, app)
}</span>

func (app UpdateRoute) Validate() error <span class="cov0" title="0">{
        if err := errs.Check(app); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("validate: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func toBusUpdateRoute(app UpdateRoute) (routebus.UpdateRoute, error) <span class="cov0" title="0">{
        var strFacID *uuid.UUID
        if app.StartFacilityID != nil </span><span class="cov0" title="0">{
                stfac, err := uuid.Parse(*app.StartFacilityID)
                if err != nil </span><span class="cov0" title="0">{
                        return routebus.UpdateRoute{}, fmt.Errorf("parse: %w", err)
                }</span>
                <span class="cov0" title="0">strFacID = &amp;stfac</span>
        }

        <span class="cov0" title="0">var endFacID *uuid.UUID
        if app.EndFacilityID != nil </span><span class="cov0" title="0">{
                enfac, err := uuid.Parse(*app.EndFacilityID)
                if err != nil </span><span class="cov0" title="0">{
                        return routebus.UpdateRoute{}, fmt.Errorf("parse: %w", err)
                }</span>
                <span class="cov0" title="0">endFacID = &amp;enfac</span>
        }

        <span class="cov0" title="0">var rutNme *genstringtype.GenString
        if app.EndFacilityID != nil </span><span class="cov0" title="0">{
                rn, err := genstringtype.Parse(*app.RouteName)
                if err != nil </span><span class="cov0" title="0">{
                        return routebus.UpdateRoute{}, fmt.Errorf("parse: %w", err)
                }</span>
                <span class="cov0" title="0">rutNme = &amp;rn</span>
        }

        <span class="cov0" title="0">var stLat *facilitytype.Lat
        if app.StartLatitude != nil </span><span class="cov0" title="0">{
                rn, err := facilitytype.ParseLat(*app.StartLatitude)
                if err != nil </span><span class="cov0" title="0">{
                        return routebus.UpdateRoute{}, fmt.Errorf("parse: %w", err)
                }</span>
                <span class="cov0" title="0">stLat = &amp;rn</span>
        }

        <span class="cov0" title="0">var stLng *facilitytype.Long
        if app.StartLongitude != nil </span><span class="cov0" title="0">{
                stlong, err := facilitytype.ParseLong(*app.StartLongitude)
                if err != nil </span><span class="cov0" title="0">{
                        return routebus.UpdateRoute{}, fmt.Errorf("parse: %w", err)
                }</span>
                <span class="cov0" title="0">stLng = &amp;stlong</span>
        }

        <span class="cov0" title="0">var endLng *facilitytype.Long
        if app.EndLongitude != nil </span><span class="cov0" title="0">{
                edlg, err := facilitytype.ParseLong(*app.EndLongitude)
                if err != nil </span><span class="cov0" title="0">{
                        return routebus.UpdateRoute{}, fmt.Errorf("parse: %w", err)
                }</span>
                <span class="cov0" title="0">endLng = &amp;edlg</span>
        }

        <span class="cov0" title="0">var endLat *facilitytype.Lat
        if app.EndLatitude != nil </span><span class="cov0" title="0">{
                edlg, err := facilitytype.ParseLat(*app.EndLatitude)
                if err != nil </span><span class="cov0" title="0">{
                        return routebus.UpdateRoute{}, fmt.Errorf("parse: %w", err)
                }</span>
                <span class="cov0" title="0">endLat = &amp;edlg</span>
        }

        <span class="cov0" title="0">bus := routebus.UpdateRoute{
                StartFacilityID: strFacID,
                EndFacilityID:   endFacID,
                RouteName:       rutNme,
                TotalKM:         app.TotalKM,
                TotalStops:      app.TotalStops,
                StartLatitude:   stLat,
                StartLongitude:  stLng,
                EndLatitude:     endLat,
                EndLongitude:    endLng,
                IsActive:        app.IsActive,
        }

        return bus, nil</span>
}

type RouteDelete struct {
        Message string `json:"message"`
}

func (e RouteDelete) Encode() ([]byte, string, error) <span class="cov0" title="0">{
        data, err := json.Marshal(e)
        return data, "application/json", err
}</span>
</pre>
		
		<pre class="file" id="file53" style="display: none">// Package routeapp maintains the app layer api for the routeapp domain.
package routeapp

import (
        "context"
        "net/http"

        "github.com/FITHSCS/backend/app/sdk/errs"
        "github.com/FITHSCS/backend/app/sdk/query"
        "github.com/FITHSCS/backend/business/domain/routebus"
        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/foundation/web"
        "github.com/google/uuid"
)

type app struct {
        routebus *routebus.Business
}

func newApp(routeBus *routebus.Business) *app <span class="cov0" title="0">{
        return &amp;app{
                routebus: routeBus,
        }
}</span>

func (a *app) create(ctx context.Context, r *http.Request) web.Encoder <span class="cov0" title="0">{

        var pb NewRoute
        if err := web.Decode(r, &amp;pb); err != nil </span><span class="cov0" title="0">{

                return errs.New(errs.InvalidArgument, err)
        }</span>

        <span class="cov0" title="0">nc, err := toBusNewRoute(pb)
        if err != nil </span><span class="cov0" title="0">{
                return errs.New(errs.InvalidArgument, err)
        }</span>

        <span class="cov0" title="0">routecrtd, err := a.routebus.Create(ctx, nc)
        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "create pickupbatch[%+v]: %s", routecrtd, err)
        }</span>
        <span class="cov0" title="0">return toAppRoute(routecrtd)</span>
}

func (a *app) update(ctx context.Context, r *http.Request) web.Encoder <span class="cov0" title="0">{
        routeIDStr := web.Param(r, "route_id")
        routeID, err := uuid.Parse(routeIDStr)
        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "id not correctly formatted: %s", err)
        }</span>

        <span class="cov0" title="0">var update UpdateRoute
        if err := web.Decode(r, &amp;update); err != nil </span><span class="cov0" title="0">{
                return errs.New(errs.InvalidArgument, err)
        }</span>

        <span class="cov0" title="0">updaterte, err := toBusUpdateRoute(update)
        if err != nil </span><span class="cov0" title="0">{
                return errs.New(errs.InvalidArgument, err)
        }</span>

        <span class="cov0" title="0">updtroute, err := a.routebus.Update(ctx, routeID, updaterte)
        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "update: applayer, ID: [%s] Request: %v", routeID, update)
        }</span>

        <span class="cov0" title="0">return toAppRoute(updtroute)</span>
}

func (a *app) query(ctx context.Context, r *http.Request) web.Encoder <span class="cov0" title="0">{
        queryParameters, err := ParseQueryParams(r)
        if err != nil </span><span class="cov0" title="0">{
                return errs.New(errs.InvalidArgument, err)
        }</span>

        <span class="cov0" title="0">page, err := page.Parse(queryParameters.Page, queryParameters.Rows)
        if err != nil </span><span class="cov0" title="0">{
                return errs.NewFieldErrors("page", err)
        }</span>

        <span class="cov0" title="0">filter, err := ParseFilter(queryParameters)
        if err != nil </span><span class="cov0" title="0">{
                return err.(*errs.Error)
        }</span>

        <span class="cov0" title="0">orderBy, err := order.Parse(orderByFields, queryParameters.OrderBy, routebus.DefaultOrderBy)
        if err != nil </span><span class="cov0" title="0">{
                return errs.NewFieldErrors("order", err)
        }</span>

        <span class="cov0" title="0">routes, err := a.routebus.Query(ctx, filter, orderBy, page)
        if err != nil </span><span class="cov0" title="0">{
                return errs.NewFieldErrors("query", err)
        }</span>

        <span class="cov0" title="0">total, err := a.routebus.Count(ctx, filter)
        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "count: %s", err)
        }</span>

        <span class="cov0" title="0">return query.NewResult(toAppRoutes(routes), total, page)</span>

}

func (a *app) queryByID(ctx context.Context, r *http.Request) web.Encoder <span class="cov0" title="0">{

        routeIDStr := web.Param(r, "route_id")
        routeID, err := uuid.Parse(routeIDStr)
        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "id not correctly formatted: %s", err)
        }</span>

        <span class="cov0" title="0">pickupbatchRetrieved, err := a.routebus.QueryByID(ctx, routeID)
        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "queryid: pickupbatchapp[%s]: %s", routeID, err)
        }</span>

        <span class="cov0" title="0">return toAppRoute(pickupbatchRetrieved)</span>
}

func (a *app) delete(ctx context.Context, r *http.Request) web.Encoder <span class="cov0" title="0">{

        routeIDStr := web.Param(r, "route_id")
        routeID, err := uuid.Parse(routeIDStr)
        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "id not correctly formatted: %s", err)
        }</span>

        <span class="cov0" title="0">if err := a.routebus.Delete(ctx, routeID); err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "delete: pickupBatchID[%s]: %s", routeID, err)
        }</span>
        <span class="cov0" title="0">return RouteDelete{
                Message: "route disabled successfull",
        }</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package routeapp

import (
        "net/http"

        "github.com/FITHSCS/backend/app/sdk/authclient"
        "github.com/FITHSCS/backend/app/sdk/mid"
        "github.com/FITHSCS/backend/business/domain/routebus"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/FITHSCS/backend/foundation/web"
)

type Config struct {
        Log        *logger.Logger
        RouteBus   *routebus.Business
        AuthClient *authclient.Client
}

func Routes(app *web.App, cfg Config) <span class="cov0" title="0">{

        const version = "v1"

        authen := mid.Authenticate(cfg.AuthClient)

        api := newApp(cfg.RouteBus)

        app.HandlerFunc(http.MethodPost, version, "/route", api.create, authen)
        app.HandlerFunc(http.MethodGet, version, "/route", api.query)
        app.HandlerFunc(http.MethodGet, version, "/route/{route_id}", api.queryByID, authen)
        app.HandlerFunc(http.MethodPut, version, "/route/{route_id}", api.update, authen)
        app.HandlerFunc(http.MethodDelete, version, "/route/{route_id}", api.delete, authen)

}</span>
</pre>
		
		<pre class="file" id="file55" style="display: none">package signatureapp

import (
        "net/http"
        "time"

        "github.com/FITHSCS/backend/app/sdk/errs"
        "github.com/FITHSCS/backend/business/domain/signaturebus"
        "github.com/google/uuid"
)

type queryParams struct {
        Page        string
        Rows        string
        OrderBy     string
        SignatureID string
        ManifestID  string
        TimeStamp   string
        IsSynced    string
        CreatedAt   string
        UpdatedAt   string
}

func ParseQueryParams(r *http.Request) (queryParams, error) <span class="cov0" title="0">{

        values := r.URL.Query()

        filter := queryParams{

                Page:      values.Get("page"),
                Rows:      values.Get("rows"),
                OrderBy:   values.Get("orderBy"),
                TimeStamp: values.Get("time_stamp"),
                IsSynced:  values.Get("is_synced"),
                CreatedAt: values.Get("created_at"),
                UpdatedAt: values.Get("updated_at"),
        }

        return filter, nil
}</span>

func ParseFilter(qp queryParams) (signaturebus.QueryFilter, error) <span class="cov0" title="0">{

        var fieldErrors errs.FieldErrors
        var filter signaturebus.QueryFilter

        if qp.SignatureID != "" </span><span class="cov0" title="0">{
                signid, err := uuid.Parse(qp.SignatureID)
                if err != nil </span><span class="cov0" title="0">{
                        fieldErrors.Add("signature_id", err)
                }</span> else<span class="cov0" title="0"> {
                        filter.SignatureID = &amp;signid
                }</span>
        }

        <span class="cov0" title="0">if qp.ManifestID != "" </span><span class="cov0" title="0">{
                manid, err := uuid.Parse(qp.ManifestID)
                switch err </span>{
                case nil:<span class="cov0" title="0">
                        filter.ManifestID = &amp;manid</span>
                default:<span class="cov0" title="0">
                        fieldErrors.Add("manifest_id", err)</span>
                }
        }

        <span class="cov0" title="0">if qp.TimeStamp != "" </span><span class="cov0" title="0">{
                t, err := time.Parse(time.RFC3339, qp.CreatedAt)
                switch err </span>{
                case nil:<span class="cov0" title="0">
                        filter.TimeStamp = &amp;t</span>
                default:<span class="cov0" title="0">
                        fieldErrors.Add("time_stamp", err)</span>
                }
        }

        <span class="cov0" title="0">if qp.CreatedAt != "" </span><span class="cov0" title="0">{
                t, err := time.Parse(time.RFC3339, qp.CreatedAt)
                switch err </span>{
                case nil:<span class="cov0" title="0">
                        filter.CreatedAt = &amp;t</span>
                default:<span class="cov0" title="0">
                        fieldErrors.Add("created_at", err)</span>
                }
        }
        <span class="cov0" title="0">if qp.UpdatedAt != "" </span><span class="cov0" title="0">{
                t, err := time.Parse(time.RFC3339, qp.UpdatedAt)
                switch err </span>{
                case nil:<span class="cov0" title="0">
                        filter.UpdatedAt = &amp;t</span>
                default:<span class="cov0" title="0">
                        fieldErrors.Add("updated_at", err)</span>
                }
        }
        <span class="cov0" title="0">if fieldErrors != nil </span><span class="cov0" title="0">{
                return signaturebus.QueryFilter{}, fieldErrors.ToError()
        }</span>
        <span class="cov0" title="0">return filter, nil</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">package signatureapp

import (
        "encoding/json"
        "fmt"
        "time"

        "github.com/FITHSCS/backend/app/sdk/errs"
        "github.com/FITHSCS/backend/business/domain/signaturebus"
        "github.com/FITHSCS/backend/business/types/facilitytype"
        "github.com/FITHSCS/backend/business/types/genstringtype"
        "github.com/google/uuid"
)

type Signature struct {
        SignatureID    string  `json:"signature_id"`
        ManifestID     string  `json:"manifest_id"`
        SignedByID     string  `json:"signed_by_id"`
        EventType      string  `json:"event_type"`
        SignatureType  string  `json:"signature_type"`
        SignatureHash  string  `json:"signature_hash"`
        DeviceID       string  `json:"device_id"`
        SignedAt       string  `json:"signed_at"`
        Longitude      float64 `json:"longitude"`
        Latitude       float64 `json:"latitude"`
        InsideGeofence bool    `json:"inside_geofence"`
        IsVerified     bool    `json:"is_verified"`
        IsDeleted      bool    `json:"is_deleted"`
        IsSynced       bool    `json:"is_synced"`
        TimeStamp      string  `json:"time_stamp"`
        CreatedAt      string  `json:"created_at"`
        UpdatedAt      string  `json:"updated_at"`
}

// Encode implements the encoder interface
func (app Signature) Encode() ([]byte, string, error) <span class="cov0" title="0">{
        data, err := json.Marshal(app)
        return data, "application/json", err
}</span>

type Signatures []Signature

func (e Signatures) Encode() ([]byte, string, error) <span class="cov0" title="0">{
        data, err := json.Marshal(e)
        return data, "application/json", err
}</span>

//==================================================================

func toAppSingature(signature signaturebus.Signature) Signature <span class="cov0" title="0">{

        var signadAt string
        if !signature.SignedAt.IsZero() </span><span class="cov0" title="0">{
                signadAt = signature.SignedAt.Format(time.RFC3339)
        }</span>

        <span class="cov0" title="0">return Signature{
                SignatureID:    signature.SignatureID.String(),
                ManifestID:     signature.ManifestID.String(),
                SignedByID:     signature.SignedByID.String(),
                EventType:      signature.EventType.String(),
                SignatureType:  signature.SignatureType.String(),
                SignatureHash:  signature.SignatureHash.String(),
                DeviceID:       signature.DeviceID.String(),
                SignedAt:       signadAt,
                Longitude:      signature.Longitude.Float64(),
                Latitude:       signature.Latitude.Float64(),
                InsideGeofence: signature.InsideGeofence,
                IsVerified:     signature.IsVerified,
                IsDeleted:      signature.IsDeleted,
                IsSynced:       signature.IsSynced,
                TimeStamp:      signature.TimeStamp.String(),
                CreatedAt:      signature.CreatedAt.Format(time.RFC3339),
                UpdatedAt:      signature.UpdatedAt.Format(time.RFC3339),
        }</span>

}

func toAppSignatures(signatures []signaturebus.Signature) []Signature <span class="cov0" title="0">{
        app := make([]Signature, len(signatures))
        for i, signature := range signatures </span><span class="cov0" title="0">{
                app[i] = toAppSingature(signature)
        }</span>
        <span class="cov0" title="0">return app</span>
}

//==============================================================================&gt;

type NewSignature struct {
        ManifestID     string  `json:"manifest_id"`
        SignedByID     string  `json:"signed_by_id"`
        EventType      string  `json:"event_type"`
        SignatureType  string  `json:"signature_type"`
        SignatureHash  string  `json:"signature_hash"`
        DeviceID       string  `json:"device_id"`
        SignedAt       string  `json:"signed_at"`
        Longitude      float64 `json:"longitude"`
        Latitude       float64 `json:"latitude"`
        InsideGeofence bool    `json:"inside_geofence"`
        IsVerified     bool    `json:"is_verified"`
        IsSynced       bool    `json:"is_synced"`
        TimeStamp      string  `json:"time_stamp"`
        UpdatedAt      string  `json:"updated_at"`
}

func (app *NewSignature) Decode(data []byte) error <span class="cov0" title="0">{
        return json.Unmarshal(data, app)
}</span>

func (app NewSignature) Validate() error <span class="cov0" title="0">{
        if err := errs.Check(app); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("validate: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func toBusNewSignature(app NewSignature) (signaturebus.NewSignature, error) <span class="cov0" title="0">{
        manID, err := uuid.Parse(app.ManifestID)
        if err != nil </span><span class="cov0" title="0">{
                return signaturebus.NewSignature{}, fmt.Errorf("parsemanifestid: %w", err)
        }</span>

        <span class="cov0" title="0">sndbyid, err := uuid.Parse(app.SignedByID)
        if err != nil </span><span class="cov0" title="0">{
                return signaturebus.NewSignature{}, fmt.Errorf("parseorgfacility: %w", err)
        }</span>

        <span class="cov0" title="0">evnttpe, err := genstringtype.Parse(app.EventType)
        if err != nil </span><span class="cov0" title="0">{
                return signaturebus.NewSignature{}, fmt.Errorf("parseventtype: %w", err)
        }</span>

        <span class="cov0" title="0">sgntpe, err := genstringtype.Parse(app.SignatureType)
        if err != nil </span><span class="cov0" title="0">{
                return signaturebus.NewSignature{}, fmt.Errorf("parseventtype: %w", err)
        }</span>

        <span class="cov0" title="0">signhash, err := genstringtype.Parse(app.SignatureHash)
        if err != nil </span><span class="cov0" title="0">{
                return signaturebus.NewSignature{}, fmt.Errorf("parsesignhash: %w", err)
        }</span>

        <span class="cov0" title="0">deviceID, err := genstringtype.Parse(app.DeviceID)
        if err != nil </span><span class="cov0" title="0">{
                return signaturebus.NewSignature{}, fmt.Errorf("parsedeviceid: %w", err)
        }</span>

        <span class="cov0" title="0">var signedat time.Time
        if app.TimeStamp != "" </span><span class="cov0" title="0">{
                tstmp, err := time.Parse(time.RFC3339, app.SignedAt)
                if err != nil </span><span class="cov0" title="0">{
                        return signaturebus.NewSignature{}, fmt.Errorf("parsesignedat: %w", err)
                }</span>
                <span class="cov0" title="0">signedat = tstmp</span>
        }

        <span class="cov0" title="0">long, err := facilitytype.ParseLong(app.Longitude)
        if err != nil </span><span class="cov0" title="0">{
                return signaturebus.NewSignature{}, fmt.Errorf("parsedeviceid: %w", err)
        }</span>

        <span class="cov0" title="0">lat, err := facilitytype.ParseLat(app.Latitude)
        if err != nil </span><span class="cov0" title="0">{
                return signaturebus.NewSignature{}, fmt.Errorf("parselat: %w", err)
        }</span>

        <span class="cov0" title="0">var tmestmp time.Time
        if app.TimeStamp != "" </span><span class="cov0" title="0">{
                tstmp, err := time.Parse(time.RFC3339, app.TimeStamp)
                if err != nil </span><span class="cov0" title="0">{
                        return signaturebus.NewSignature{}, fmt.Errorf("parsetimestamp: %w", err)
                }</span>
                <span class="cov0" title="0">tmestmp = tstmp</span>
        }

        <span class="cov0" title="0">bus := signaturebus.NewSignature{
                ManifestID:     manID,
                SignedByID:     sndbyid,
                EventType:      evnttpe,
                SignatureType:  sgntpe,
                SignatureHash:  signhash,
                DeviceID:       deviceID,
                SignedAt:       signedat,
                Longitude:      long,
                Latitude:       lat,
                InsideGeofence: app.InsideGeofence,
                IsVerified:     app.IsVerified,
                IsSynced:       app.IsSynced,
                TimeStamp:      tmestmp,
        }

        return bus, nil</span>

}

//=================================================================

type UpdateSignature struct {
        ManifestID     *string  `json:"manifest_id"`
        SignedByID     *string  `json:"signed_by_id"`
        EventType      *string  `json:"event_type"`
        SignatureType  *string  `json:"signature_type"`
        SignatureHash  *string  `json:"signature_hash"`
        DeviceID       *string  `json:"device_id"`
        SignedAt       *string  `json:"signed_at"`
        Longitude      *float64 `json:"longitude"`
        Latitude       *float64 `json:"latitude"`
        InsideGeofence *bool    `json:"inside_geofence"`
        IsVerified     *bool    `json:"is_verified"`
        IsSynced       *bool    `json:"is_synced"`
        TimeStamp      *string  `json:"time_stamp"`
}

func (app *UpdateSignature) Decode(data []byte) error <span class="cov0" title="0">{
        return json.Unmarshal(data, app)
}</span>

func (app UpdateSignature) Validate() error <span class="cov0" title="0">{
        if err := errs.Check(app); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("validate: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func toBusUpdateSignature(app UpdateSignature) (signaturebus.UpdateSignature, error) <span class="cov0" title="0">{
        var mnfid *uuid.UUID
        if app.ManifestID != nil </span><span class="cov0" title="0">{
                manifest, err := uuid.Parse(*app.ManifestID)
                if err != nil </span><span class="cov0" title="0">{
                        return signaturebus.UpdateSignature{}, fmt.Errorf("parse: %w", err)
                }</span>
                <span class="cov0" title="0">mnfid = &amp;manifest</span>
        }

        <span class="cov0" title="0">var snby *uuid.UUID
        if app.SignedByID != nil </span><span class="cov0" title="0">{
                signedby, err := uuid.Parse(*app.SignedByID)
                if err != nil </span><span class="cov0" title="0">{
                        return signaturebus.UpdateSignature{}, fmt.Errorf("parse: %w", err)
                }</span>
                <span class="cov0" title="0">snby = &amp;signedby</span>
        }

        <span class="cov0" title="0">var evntype *genstringtype.GenString
        if app.EventType != nil </span><span class="cov0" title="0">{
                envtype, err := genstringtype.Parse(*app.EventType)
                if err != nil </span><span class="cov0" title="0">{
                        return signaturebus.UpdateSignature{}, fmt.Errorf("parse: %w", err)
                }</span>
                <span class="cov0" title="0">evntype = &amp;envtype</span>
        }

        <span class="cov0" title="0">var signtype *genstringtype.GenString
        if app.SignatureType != nil </span><span class="cov0" title="0">{
                snt, err := genstringtype.Parse(*app.SignatureType)
                if err != nil </span><span class="cov0" title="0">{
                        return signaturebus.UpdateSignature{}, fmt.Errorf("parse: %w", err)
                }</span>
                <span class="cov0" title="0">signtype = &amp;snt</span>
        }

        <span class="cov0" title="0">var signhsh *genstringtype.GenString
        if app.SignatureHash != nil </span><span class="cov0" title="0">{
                ssh, err := genstringtype.Parse(*app.SignatureHash)
                if err != nil </span><span class="cov0" title="0">{
                        return signaturebus.UpdateSignature{}, fmt.Errorf("parse: %w", err)
                }</span>
                <span class="cov0" title="0">signhsh = &amp;ssh</span>
        }

        <span class="cov0" title="0">var devid *genstringtype.GenString
        if app.DeviceID != nil </span><span class="cov0" title="0">{
                did, err := genstringtype.Parse(*app.DeviceID)
                if err != nil </span><span class="cov0" title="0">{
                        return signaturebus.UpdateSignature{}, fmt.Errorf("parse: %w", err)
                }</span>
                <span class="cov0" title="0">devid = &amp;did</span>
        }

        <span class="cov0" title="0">var signat *time.Time
        if app.SignedAt != nil </span><span class="cov0" title="0">{
                snat, err := time.Parse(time.RFC3339, *app.SignedAt)
                if err != nil </span><span class="cov0" title="0">{
                        return signaturebus.UpdateSignature{}, fmt.Errorf("parse: %w", err)

                }</span>
                <span class="cov0" title="0">signat = &amp;snat</span>
        }

        <span class="cov0" title="0">var long *facilitytype.Long
        if app.Longitude != nil </span><span class="cov0" title="0">{
                lng, err := facilitytype.ParseLong(*app.Longitude)
                if err != nil </span><span class="cov0" title="0">{
                        return signaturebus.UpdateSignature{}, fmt.Errorf("parse: %w", err)
                }</span>
                <span class="cov0" title="0">long = &amp;lng</span>
        }

        <span class="cov0" title="0">var lat *facilitytype.Lat
        if app.Latitude != nil </span><span class="cov0" title="0">{
                lt, err := facilitytype.ParseLat(*app.Longitude)
                if err != nil </span><span class="cov0" title="0">{
                        return signaturebus.UpdateSignature{}, fmt.Errorf("parse: %w", err)
                }</span>
                <span class="cov0" title="0">lat = &amp;lt</span>
        }

        <span class="cov0" title="0">var timestamp *time.Time
        if app.TimeStamp != nil </span><span class="cov0" title="0">{
                ts, err := time.Parse(time.RFC3339, *app.TimeStamp)
                if err != nil </span><span class="cov0" title="0">{
                        return signaturebus.UpdateSignature{}, fmt.Errorf("parse: %w", err)

                }</span>
                <span class="cov0" title="0">timestamp = &amp;ts</span>
        }

        <span class="cov0" title="0">bus := signaturebus.UpdateSignature{
                ManifestID:     mnfid,
                SignedByID:     snby,
                EventType:      evntype,
                SignatureType:  signtype,
                SignatureHash:  signhsh,
                DeviceID:       devid,
                SignedAt:       signat,
                Longitude:      long,
                Latitude:       lat,
                InsideGeofence: app.InsideGeofence,
                IsVerified:     app.IsVerified,
                IsSynced:       app.IsSynced,
                TimeStamp:      timestamp,
        }

        return bus, nil</span>
}

type SignatureDelete struct {
        Message string `json:"message"`
}

func (e SignatureDelete) Encode() ([]byte, string, error) <span class="cov0" title="0">{
        data, err := json.Marshal(e)
        return data, "application/json", err
}</span>
</pre>
		
		<pre class="file" id="file57" style="display: none">package signatureapp

import (
        "net/http"

        "github.com/FITHSCS/backend/app/sdk/authclient"
        "github.com/FITHSCS/backend/app/sdk/mid"
        "github.com/FITHSCS/backend/business/domain/signaturebus"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/FITHSCS/backend/foundation/web"
)

type Config struct {
        Log          *logger.Logger
        SignatureBus *signaturebus.Business
        AuthClient   *authclient.Client
}

func Routes(app *web.App, cfg Config) <span class="cov0" title="0">{

        const version = "v1"

        authen := mid.Authenticate(cfg.AuthClient)

        api := newApp(cfg.SignatureBus)

        app.HandlerFunc(http.MethodPost, version, "/signature", api.create, authen)
        app.HandlerFunc(http.MethodGet, version, "/signature", api.query)
        app.HandlerFunc(http.MethodGet, version, "/signature/{signature_id}", api.queryByID, authen)
        app.HandlerFunc(http.MethodPut, version, "/signature/{signature_id}", api.update, authen)
        app.HandlerFunc(http.MethodPut, version, "/signature/sdelete/{signature_id}", api.softDelete, authen)
        app.HandlerFunc(http.MethodDelete, version, "/signature/hdelete/{signature_id}", api.hardDelete, authen)

}</span>
</pre>
		
		<pre class="file" id="file58" style="display: none">// Package signatureapp maintains the app layer api for the signature domain.
package signatureapp

import (
        "context"
        "net/http"

        "github.com/FITHSCS/backend/app/sdk/errs"
        "github.com/FITHSCS/backend/app/sdk/query"
        "github.com/FITHSCS/backend/business/domain/signaturebus"
        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/foundation/web"
        "github.com/google/uuid"
)

type app struct {
        signaturebus *signaturebus.Business
}

func newApp(signatureBus *signaturebus.Business) *app <span class="cov0" title="0">{
        return &amp;app{
                signaturebus: signatureBus,
        }
}</span>

func (a *app) create(ctx context.Context, r *http.Request) web.Encoder <span class="cov0" title="0">{

        var pb NewSignature
        if err := web.Decode(r, &amp;pb); err != nil </span><span class="cov0" title="0">{

                return errs.New(errs.InvalidArgument, err)
        }</span>

        <span class="cov0" title="0">nc, err := toBusNewSignature(pb)
        if err != nil </span><span class="cov0" title="0">{
                return errs.New(errs.InvalidArgument, err)
        }</span>

        <span class="cov0" title="0">pckpBtchCretd, err := a.signaturebus.Create(ctx, nc)
        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "create pickupbatch[%+v]: %s", pckpBtchCretd, err)
        }</span>
        <span class="cov0" title="0">return toAppSingature(pckpBtchCretd)</span>
}

func (a *app) update(ctx context.Context, r *http.Request) web.Encoder <span class="cov0" title="0">{
        pickupbatchIDStr := web.Param(r, "signature_id")
        pickupbatchID, err := uuid.Parse(pickupbatchIDStr)

        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "id not correctly formatted: %s", err)
        }</span>

        <span class="cov0" title="0">var update UpdateSignature
        if err := web.Decode(r, &amp;update); err != nil </span><span class="cov0" title="0">{
                return errs.New(errs.InvalidArgument, err)
        }</span>

        <span class="cov0" title="0">updatePickupBatchBus, err := toBusUpdateSignature(update)
        if err != nil </span><span class="cov0" title="0">{
                return errs.New(errs.InvalidArgument, err)
        }</span>

        <span class="cov0" title="0">updatedPickupBatch, err := a.signaturebus.Update(ctx, pickupbatchID, updatePickupBatchBus)
        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "update: applyr, ID: [%s] Request: %v", pickupbatchID, update)
        }</span>

        <span class="cov0" title="0">return toAppSingature(updatedPickupBatch)</span>
}

func (a *app) query(ctx context.Context, r *http.Request) web.Encoder <span class="cov0" title="0">{
        queryParameters, err := ParseQueryParams(r)
        if err != nil </span><span class="cov0" title="0">{
                return errs.New(errs.InvalidArgument, err)
        }</span>

        <span class="cov0" title="0">page, err := page.Parse(queryParameters.Page, queryParameters.Rows)
        if err != nil </span><span class="cov0" title="0">{
                return errs.NewFieldErrors("page", err)
        }</span>

        <span class="cov0" title="0">filter, err := ParseFilter(queryParameters)
        if err != nil </span><span class="cov0" title="0">{
                return err.(*errs.Error)
        }</span>

        <span class="cov0" title="0">orderBy, err := order.Parse(orderByFields, queryParameters.OrderBy, signaturebus.DefaultOrderBy)
        if err != nil </span><span class="cov0" title="0">{
                return errs.NewFieldErrors("order", err)
        }</span>

        <span class="cov0" title="0">signatures, err := a.signaturebus.Query(ctx, filter, orderBy, page)
        if err != nil </span><span class="cov0" title="0">{
                return errs.NewFieldErrors("query", err)
        }</span>

        <span class="cov0" title="0">total, err := a.signaturebus.Count(ctx, filter)
        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "count: %s", err)
        }</span>

        <span class="cov0" title="0">return query.NewResult(toAppSignatures(signatures), total, page)</span>
}

func (a *app) queryByID(ctx context.Context, r *http.Request) web.Encoder <span class="cov0" title="0">{

        pickupbatchIDStr := web.Param(r, "signature_id")
        pickupbatchID, err := uuid.Parse(pickupbatchIDStr)

        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "id not correctly formatted: %s", err)
        }</span>

        <span class="cov0" title="0">pickupbatchRetrieved, err := a.signaturebus.QueryByID(ctx, pickupbatchID)
        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "queryid: pickupbatchapp[%s]: %s", pickupbatchID, err)
        }</span>

        <span class="cov0" title="0">return toAppSingature(pickupbatchRetrieved)</span>
}

func (a *app) softDelete(ctx context.Context, r *http.Request) web.Encoder <span class="cov0" title="0">{

        signatureIDStr := web.Param(r, "signature_id")

        signatureID, err := uuid.Parse(signatureIDStr)

        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "signatureID missing in context %s", err)
        }</span>
        <span class="cov0" title="0">if err := a.signaturebus.SoftDelete(ctx, signatureID); err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "delete: signatureID[%s]: %s", signatureID, err)
        }</span>
        <span class="cov0" title="0">return SignatureDelete{
                Message: "signature delete successfull",
        }</span>
}

func (a *app) hardDelete(ctx context.Context, r *http.Request) web.Encoder <span class="cov0" title="0">{

        signatureIDStr := web.Param(r, "signature_id")

        signatureID, err := uuid.Parse(signatureIDStr)

        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "signatureID missing in context %s", err)
        }</span>
        <span class="cov0" title="0">if err := a.signaturebus.HardDelete(ctx, signatureID); err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "delete: signatureID[%s]: %s", signatureID, err)
        }</span>
        <span class="cov0" title="0">return SignatureDelete{
                Message: "signature delete successfull",
        }</span>
}
</pre>
		
		<pre class="file" id="file59" style="display: none">package statusapp

import "encoding/json"

type status struct {
        Status string `json:"status"`
}

// Encode implements the encoder interface.
func (app status) Encode() ([]byte, string, error) <span class="cov0" title="0">{
        data, err := json.Marshal(app)
        return data, "application/json", err
}</span>
</pre>
		
		<pre class="file" id="file60" style="display: none">package statusapp

import (
        "net/http"

        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/FITHSCS/backend/foundation/web"
        "github.com/jmoiron/sqlx"
)

type Config struct {
        Log *logger.Logger
        DB  *sqlx.DB
}

// Routes adds specific routes for this group.
func Routes(app *web.App, cfg Config) <span class="cov0" title="0">{
        const version = "v1"

        api := newApp(cfg.Log, cfg.DB)

        app.HandlerFuncNoMid(http.MethodGet, version, "/status", api.status)
        app.HandlerFuncNoMid(http.MethodGet, version, "/readiness", api.readiness)
}</span>
</pre>
		
		<pre class="file" id="file61" style="display: none">// Package statusapp maintains the app layer api for the status domain.
package statusapp

import (
        "context"
        "net/http"
        "time"

        "github.com/FITHSCS/backend/app/sdk/errs"
        "github.com/FITHSCS/backend/business/sdk/sqldb"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/FITHSCS/backend/foundation/web"
        "github.com/jmoiron/sqlx"
)

type app struct {
        log *logger.Logger
        db  *sqlx.DB
}

func newApp(log *logger.Logger, db *sqlx.DB) *app <span class="cov0" title="0">{
        return &amp;app{
                log: log,
                db:  db,
        }
}</span>

func (a *app) status(_ context.Context, _ *http.Request) web.Encoder <span class="cov0" title="0">{
        return status{
                Status: "Server: OK",
        }
}</span>

// readiness checks if the database is ready and if not will return a 500 status.
// Do not respond by just returning an error because further up in the call
// stack it will interpret that as a non-trusted error.
func (a *app) readiness(ctx context.Context, r *http.Request) web.Encoder <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(ctx, time.Second)
        defer cancel()

        if err := sqldb.StatusCheck(ctx, a.db); err != nil </span><span class="cov0" title="0">{
                a.log.Info(ctx, "readiness failure", "ERROR", err)
                return errs.New(errs.Internal, err)
        }</span>

        <span class="cov0" title="0">return status{
                Status: "Database: OK",
        }</span>
}
</pre>
		
		<pre class="file" id="file62" style="display: none">package syncapp

import (
        "encoding/json"
        "fmt"
        "time"

        "github.com/FITHSCS/backend/business/domain/syncbatchbus"
        "github.com/FITHSCS/backend/business/types/name"
)

type NewBatch struct {
        BatchID   string       `json:"batch_id"`
        DeviceID  string       `json:"device_id"`
        EventID   string       `json:"event_id"`
        TimeStamp time.Time    `json:"time"`
        Records   []SyncRecord `json:"records"`
}

type SyncRecord struct {
        TableName string                 `json:"table_name"`
        Data      map[string]interface{} `json:"data"`
}

type SyncBatch struct {
        ID        string `json:"id"`
        BatchID   string `json:"batch_id"`
        DeviceID  string `json:"device_id"`
        EventID   string `json:"event_id"`
        TimeStamp string `json:"time_stamp"`
        Status    string `json:"status"`
}

type NewSyncBatch struct {
        BatchID   string
        DeviceID  string
        EventID   string
        TimeStamp time.Time
        Status    string
}

func (app *NewBatch) Decode(data []byte) error <span class="cov0" title="0">{
        return json.Unmarshal(data, app)
}</span>

func (app SyncBatch) Encode() ([]byte, string, error) <span class="cov0" title="0">{
        data, err := json.Marshal(app)
        return data, "application/json", err
}</span>

func toAppSyncBatch(syncbatch syncbatchbus.SyncBatch) SyncBatch <span class="cov0" title="0">{

        return SyncBatch{
                ID:        syncbatch.ID.String(),
                BatchID:   syncbatch.BatchID.String(),
                DeviceID:  syncbatch.DeviceID.String(),
                EventID:   syncbatch.EventID.String(),
                TimeStamp: syncbatch.TimeStamp.String(),
                Status:    syncbatch.Status,
        }
}</span>

func toBusNewSyncBatch(app NewSyncBatch) (syncbatchbus.NewSyncBatch, error) <span class="cov0" title="0">{

        batchID, err := name.Parse(app.BatchID)
        if err != nil </span><span class="cov0" title="0">{
                return syncbatchbus.NewSyncBatch{}, fmt.Errorf("parse: %w", err)
        }</span>
        <span class="cov0" title="0">deviceID, err := name.Parse(app.DeviceID)
        if err != nil </span><span class="cov0" title="0">{
                return syncbatchbus.NewSyncBatch{}, fmt.Errorf("parse: %w", err)
        }</span>
        <span class="cov0" title="0">eventID, err := name.Parse(app.EventID)
        if err != nil </span><span class="cov0" title="0">{
                return syncbatchbus.NewSyncBatch{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">timeStamp := app.TimeStamp

        bus := syncbatchbus.NewSyncBatch{
                BatchID:   batchID,
                DeviceID:  deviceID,
                EventID:   eventID,
                TimeStamp: timeStamp,
                Status:    "Recieved",
        }
        return bus, nil</span>

}
</pre>
		
		<pre class="file" id="file63" style="display: none">package syncapp

import (
        "net/http"

        "time"

        "github.com/FITHSCS/backend/app/sdk/authclient"
        "github.com/FITHSCS/backend/app/sdk/mid"
        "github.com/FITHSCS/backend/app/sdk/mux"
        "github.com/FITHSCS/backend/business/domain/syncbatchbus"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/FITHSCS/backend/foundation/web"
        "github.com/segmentio/kafka-go"
)

type Config struct {
        Log               *logger.Logger
        SyncBatchBus      *syncbatchbus.Business
        AuthClient        *authclient.Client
        KafkaConfig       mux.KafkaConfig
        KafkaRequiredAcks kafka.RequiredAcks
        KafkaMaxAttempts  int
        KafkaTimeout      time.Duration
}

func Routes(app *web.App, cfg Config) <span class="cov0" title="0">{
        const version = "v1"

        authen := mid.Authenticate(cfg.AuthClient)

        api := newApp(cfg)

        app.HandlerFunc(http.MethodPost, version, "/sync", api.Sync, authen)
}</span>
</pre>
		
		<pre class="file" id="file64" style="display: none">// Package syncapp maintains the app layer api for the sync domain.
package syncapp

import (
        "context"
        "encoding/json"

        "net/http"
        "time"

        "github.com/FITHSCS/backend/app/sdk/authclient"
        "github.com/FITHSCS/backend/app/sdk/errs"

        "github.com/FITHSCS/backend/app/sdk/mux"

        "sync"

        "github.com/FITHSCS/backend/business/domain/syncbatchbus"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/FITHSCS/backend/foundation/web"
        "github.com/google/uuid"
        "github.com/segmentio/kafka-go"
)

/*


/*

  Please write the logic that validates those that have been processed
  and are part of the response of the server so that we can use that
  on the mobile side to process and make sure those data are sent back


*/

type app struct {
        Log          *logger.Logger
        syncbatchBus *syncbatchbus.Business
        AuthClient   *authclient.Client
        KafkaConfig  mux.KafkaConfig
        KafkaWriter  *kafka.Writer
        SyncQueue    chan NewBatch
        wg           sync.WaitGroup
}

func newApp(cfg Config) *app <span class="cov0" title="0">{
        kafkaWriter := &amp;kafka.Writer{
                Addr:         kafka.TCP(cfg.KafkaConfig.Brokers...),
                Topic:        cfg.KafkaConfig.Topic,
                Balancer:     &amp;kafka.LeastBytes{},
                RequiredAcks: cfg.KafkaRequiredAcks,
                Async:        false,
                MaxAttempts:  cfg.KafkaMaxAttempts,
                ReadTimeout:  cfg.KafkaTimeout,
                WriteTimeout: cfg.KafkaTimeout,
                BatchSize:    100,
                BatchTimeout: 1 * time.Millisecond,
        }

        syncQueue := make(chan NewBatch, 100) //created a buffer of 100 Batch data type

        a := &amp;app{
                Log:          cfg.Log,
                syncbatchBus: cfg.SyncBatchBus,
                AuthClient:   cfg.AuthClient,
                KafkaConfig:  cfg.KafkaConfig,
                KafkaWriter:  kafkaWriter,
                SyncQueue:    syncQueue,
        }
        a.wg.Add(1)
        go a.processSyncQueue() //goroutine started to do the process
        return a
}</span>

// closing resources
func (a *app) Shutdown(ctx context.Context) error <span class="cov0" title="0">{

        a.Log.Info(ctx, "syncapp: Shutdown started")
        defer a.Log.Info(ctx, "syncapp: Shutdown completed")

        close(a.SyncQueue)
        a.wg.Wait()
        if err := a.KafkaWriter.Close(); err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "closing kafka writer: %s", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (a *app) processSyncQueue() <span class="cov0" title="0">{

        defer a.wg.Done()

        for batch := range a.SyncQueue </span><span class="cov0" title="0">{

                ctx := context.Background()

                batchData, err := json.Marshal(batch)
                if err != nil </span><span class="cov0" title="0">{
                        a.Log.Error(ctx, "failed to marshal batch", "batch_id", batch.BatchID, "err", err)
                        continue</span>
                }

                <span class="cov0" title="0">msg := kafka.Message{
                        Value: batchData,
                        Key:   []byte(batch.EventID), //we are using event_id for distribution
                        Headers: []kafka.Header{
                                {Key: "correlation-id", Value: []byte(batch.EventID)},
                                {Key: "timestamp", Value: []byte(time.Now().Format(time.RFC3339))},
                        },
                }

                start := time.Now()
                if err := a.KafkaWriter.WriteMessages(ctx, msg); err != nil </span><span class="cov0" title="0">{
                        a.Log.Error(ctx, "Failed to produce to kafka",
                                "batch_id", batch.BatchID,
                                "err", err,
                                "retry", "false")
                        continue</span>
                }
                <span class="cov0" title="0">latency := time.Since(start)
                a.Log.Info(ctx, "batch produced to kafka", "batch_id", batch.BatchID, "latency_ms", latency.Milliseconds())</span>
        }
}
func (a *app) Sync(ctx context.Context, r *http.Request) web.Encoder <span class="cov0" title="0">{

        var batch NewBatch

        if err := web.Decode(r, &amp;batch); err != nil </span><span class="cov0" title="0">{
                return errs.New(errs.InvalidArgument, err)
        }</span>
        /*
           if err := a.ValidateBatch(batch); err != nil {

                 return err.(*errs.Error)
           }
        */

        <span class="cov0" title="0">batchID, err := uuid.Parse(batch.BatchID)
        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "Id not correcttly formatted: %s", err)
        }</span>
        <span class="cov0" title="0">batchRetrieved, err := a.syncbatchBus.QueryByID(ctx, batchID)
        if err != nil </span><span class="cov0" title="0">{
                if err == syncbatchbus.ErrNotFound </span><span class="cov0" title="0">{
                        a.Log.Info(ctx, "There is no such Batch", "batch_id", batchID)
                }</span> else<span class="cov0" title="0"> {
                        return errs.Newf(errs.Internal, "There was a problem when Querying By ID: %s", err)
                }</span>
        }
        // This means the batchID already exists
        // Also checking if the batchID persisited is a very good win maybe
        <span class="cov0" title="0">if (batchRetrieved != syncbatchbus.SyncBatch{}) </span><span class="cov0" title="0">{
                return toAppSyncBatch(batchRetrieved)
        }</span>

        //But if not now we need to pursist
        <span class="cov0" title="0">syncBatch := NewSyncBatch{
                BatchID:   batch.BatchID,
                DeviceID:  batch.DeviceID,
                EventID:   batch.EventID,
                TimeStamp: batch.TimeStamp,
        }
        newsyncBatch, err := toBusNewSyncBatch(syncBatch)
        if err != nil </span><span class="cov0" title="0">{
                return errs.New(errs.InvalidArgument, err)
        }</span>

        <span class="cov0" title="0">syncbatchCreated, err := a.syncbatchBus.Create(ctx, newsyncBatch)
        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "Error creating syncbatch in Bus: %s", err)
        }</span>
        <span class="cov0" title="0">a.Log.Info(ctx, "Successfully Created SyncBatch", "syncbatchID", syncbatchCreated.ID)
        a.Log.Info(ctx, "received batch", "batch_id", batch.BatchID, "device_id", batch.DeviceID)

        select </span>{
        case a.SyncQueue &lt;- batch:<span class="cov0" title="0"></span>
                //successfully added incoming batch to syncqueue
        default:<span class="cov0" title="0">
                return errs.Newf(errs.Unavailable, "sync queue is full, please try again later")</span>
        }
        <span class="cov0" title="0">return toAppSyncBatch(syncbatchCreated)</span>
}
</pre>
		
		<pre class="file" id="file65" style="display: none">package userapp

import (
        "net/http"
        "net/mail"
        "time"

        "github.com/FITHSCS/backend/app/sdk/errs"
        "github.com/FITHSCS/backend/business/domain/userbus"
        "github.com/FITHSCS/backend/business/types/name"
        "github.com/google/uuid"
)

type queryParams struct {
        Page             string
        Rows             string
        OrderBy          string
        ID               string
        Name             string
        Email            string
        StartCreatedDate string
        EndCreatedDate   string
}

func parseQueryParams(r *http.Request) (queryParams, error) <span class="cov0" title="0">{
        values := r.URL.Query()

        filter := queryParams{
                Page:             values.Get("page"),
                Rows:             values.Get("rows"),
                OrderBy:          values.Get("orderBy"),
                ID:               values.Get("user_id"),
                Name:             values.Get("name"),
                Email:            values.Get("email"),
                StartCreatedDate: values.Get("start_created_date"),
                EndCreatedDate:   values.Get("end_created_date"),
        }

        return filter, nil
}</span>

func parseFilter(qp queryParams) (userbus.QueryFilter, error) <span class="cov0" title="0">{
        var fieldErrors errs.FieldErrors
        var filter userbus.QueryFilter

        if qp.ID != "" </span><span class="cov0" title="0">{
                id, err := uuid.Parse(qp.ID)
                switch err </span>{
                case nil:<span class="cov0" title="0">
                        // This was *id figure out why that was wrong
                        // filter.ID = &amp;id
                        filter.ID = id</span>
                default:<span class="cov0" title="0">
                        fieldErrors.Add("user_id", err)</span>
                }
        }

        <span class="cov0" title="0">if qp.Name != "" </span><span class="cov0" title="0">{
                name, err := name.Parse(qp.Name)
                switch err </span>{
                case nil:<span class="cov0" title="0">
                        filter.Name = &amp;name</span>
                default:<span class="cov0" title="0">
                        fieldErrors.Add("name", err)</span>
                }
        }

        <span class="cov0" title="0">if qp.Email != "" </span><span class="cov0" title="0">{
                addr, err := mail.ParseAddress(qp.Email)
                switch err </span>{
                case nil:<span class="cov0" title="0">
                        filter.Email = addr</span>
                default:<span class="cov0" title="0">
                        fieldErrors.Add("email", err)</span>
                }
        }

        <span class="cov0" title="0">if qp.StartCreatedDate != "" </span><span class="cov0" title="0">{
                t, err := time.Parse(time.RFC3339, qp.StartCreatedDate)
                switch err </span>{
                case nil:<span class="cov0" title="0">
                        filter.StartCreatedDate = &amp;t</span>
                default:<span class="cov0" title="0">
                        fieldErrors.Add("start_created_date", err)</span>
                }
        }

        <span class="cov0" title="0">if qp.EndCreatedDate != "" </span><span class="cov0" title="0">{
                t, err := time.Parse(time.RFC3339, qp.EndCreatedDate)
                switch err </span>{
                case nil:<span class="cov0" title="0">
                        filter.EndCreatedDate = &amp;t</span>
                default:<span class="cov0" title="0">
                        fieldErrors.Add("end_created_date", err)</span>
                }
        }

        <span class="cov0" title="0">if fieldErrors != nil </span><span class="cov0" title="0">{
                return userbus.QueryFilter{}, fieldErrors.ToError()
        }</span>

        <span class="cov0" title="0">return filter, nil</span>
}
</pre>
		
		<pre class="file" id="file66" style="display: none">package userapp

import (
        "encoding/json"
        "fmt"
        "net/mail"
        "time"

        "github.com/FITHSCS/backend/app/sdk/errs"
        "github.com/FITHSCS/backend/business/domain/userbus"
        "github.com/FITHSCS/backend/business/types/facilitytype"
        "github.com/FITHSCS/backend/business/types/name"
        "github.com/FITHSCS/backend/business/types/role"
)

// User represents information about an individual user.
type User struct {
        ID           string   `json:"id"`
        Name         string   `json:"name"`
        Email        string   `json:"email"`
        Phone        string   `json:"phone"`
        Roles        []string `json:"roles"`
        PasswordHash []byte   `json:"-"`
        Department   string   `json:"department"`
        Enabled      bool     `json:"enabled"`
        DateCreated  string   `json:"dateCreated"`
        DateUpdated  string   `json:"dateUpdated"`
}

// Encode implements the encoder interface.
func (app User) Encode() ([]byte, string, error) <span class="cov0" title="0">{
        data, err := json.Marshal(app)
        return data, "application/json", err
}</span>

// converts business to app api response
func toAppUser(bus userbus.User) User <span class="cov0" title="0">{
        return User{
                ID:           bus.ID.String(),
                Name:         bus.Name.String(),
                Email:        bus.Email.Address,
                Phone:        bus.Phone.String(),
                Roles:        role.ParseToString(bus.Roles),
                PasswordHash: bus.PasswordHash,
                Department:   bus.Department.String(),
                Enabled:      bus.Enabled,
                DateCreated:  bus.DateCreated.Format(time.RFC3339),
                DateUpdated:  bus.DateUpdated.Format(time.RFC3339),
        }
}</span>

func toAppUsers(users []userbus.User) []User <span class="cov0" title="0">{
        app := make([]User, len(users))
        for i, usr := range users </span><span class="cov0" title="0">{
                app[i] = toAppUser(usr)
        }</span>
        <span class="cov0" title="0">return app</span>
}

// =============================================================================

// NewUser defines the data needed to add a new user.
type NewUser struct {
        Name            string   `json:"name" validate:"required"`
        Email           string   `json:"email" validate:"required,email"`
        Phone           string   `json:"phone" validate:"required"`
        Roles           []string `json:"roles" validate:"required"`
        Department      string   `json:"department"`
        Password        string   `json:"password" validate:"required"`
        PasswordConfirm string   `json:"passwordConfirm" validate:"eqfield=Password"`
}

// Decode implements the decoder interface.
func (app *NewUser) Decode(data []byte) error <span class="cov0" title="0">{
        return json.Unmarshal(data, app)
}</span>

// Validate checks the data in the model is considered clean.
func (app NewUser) Validate() error <span class="cov0" title="0">{
        if err := errs.Check(app); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("validate: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// converts app inserted data to buiness layer data
func toBusNewUser(app NewUser) (userbus.NewUser, error) <span class="cov0" title="0">{
        roles, err := role.ParseMany(app.Roles)
        if err != nil </span><span class="cov0" title="0">{
                return userbus.NewUser{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">addr, err := mail.ParseAddress(app.Email)
        if err != nil </span><span class="cov0" title="0">{
                return userbus.NewUser{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">nme, err := name.Parse(app.Name)
        if err != nil </span><span class="cov0" title="0">{
                return userbus.NewUser{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">department, err := name.ParseNull(app.Department)
        if err != nil </span><span class="cov0" title="0">{
                return userbus.NewUser{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">pne, err := facilitytype.ParsePhoneNumber(app.Phone)
        if err != nil </span><span class="cov0" title="0">{
                return userbus.NewUser{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">bus := userbus.NewUser{
                Name:       nme,
                Email:      *addr,
                Phone:      pne,
                Roles:      roles,
                Department: department,
                Password:   app.Password,
        }

        return bus, nil</span>
}

// =============================================================================

// UpdateUserRole defines the data needed to update a user role.
type UpdateUserRole struct {
        Roles []string `json:"roles" validate:"required"`
}

// Decode implements the decoder interface.
func (app *UpdateUserRole) Decode(data []byte) error <span class="cov0" title="0">{
        return json.Unmarshal(data, app)
}</span>

// Validate checks the data in the model is considered clean.
func (app UpdateUserRole) Validate() error <span class="cov0" title="0">{
        if err := errs.Check(app); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("validate: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// converts data to be updated and be sent to business layer data
func toBusUpdateUserRole(app UpdateUserRole) (userbus.UpdateUser, error) <span class="cov0" title="0">{
        var roles []role.Role
        if app.Roles != nil </span><span class="cov0" title="0">{
                var err error
                roles, err = role.ParseMany(app.Roles)
                if err != nil </span><span class="cov0" title="0">{
                        return userbus.UpdateUser{}, fmt.Errorf("parse: %w", err)
                }</span>
        }

        <span class="cov0" title="0">bus := userbus.UpdateUser{
                Roles: roles,
        }

        return bus, nil</span>
}

// =============================================================================

// UpdateUser defines the data needed to update a user.
type UpdateUser struct {
        Name            *string `json:"name"`
        Email           *string `json:"email" validate:"omitempty,email"`
        Phone           *string `json:"phone"`
        Department      *string `json:"department"`
        Password        *string `json:"password"`
        PasswordConfirm *string `json:"passwordConfirm" validate:"omitempty,eqfield=Password"`
        Enabled         *bool   `json:"enabled"`
}

// Decode implements the decoder interface.
func (app *UpdateUser) Decode(data []byte) error <span class="cov0" title="0">{
        return json.Unmarshal(data, app)
}</span>

// Validate checks the data in the model is considered clean.
func (app UpdateUser) Validate() error <span class="cov0" title="0">{
        if err := errs.Check(app); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("validate: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

//converts data to be updated and be sent to business layer data

func toBusUpdateUser(app UpdateUser) (userbus.UpdateUser, error) <span class="cov0" title="0">{
        var addr *mail.Address
        if app.Email != nil </span><span class="cov0" title="0">{
                var err error
                addr, err = mail.ParseAddress(*app.Email)
                if err != nil </span><span class="cov0" title="0">{
                        return userbus.UpdateUser{}, fmt.Errorf("parse: %w", err)
                }</span>
        }

        <span class="cov0" title="0">var nme *name.Name
        if app.Name != nil </span><span class="cov0" title="0">{
                nm, err := name.Parse(*app.Name)
                if err != nil </span><span class="cov0" title="0">{
                        return userbus.UpdateUser{}, fmt.Errorf("parse: %w", err)
                }</span>
                <span class="cov0" title="0">nme = &amp;nm</span>
        }

        <span class="cov0" title="0">var department *name.Null
        if app.Department != nil </span><span class="cov0" title="0">{
                dep, err := name.ParseNull(*app.Department)
                if err != nil </span><span class="cov0" title="0">{
                        return userbus.UpdateUser{}, fmt.Errorf("parse: %w", err)
                }</span>
                <span class="cov0" title="0">department = &amp;dep</span>
        }

        <span class="cov0" title="0">var phone *facilitytype.PhoneNumber
        if app.Phone != nil </span><span class="cov0" title="0">{
                pne, err := facilitytype.ParsePhoneNumber(*app.Phone)
                if err != nil </span><span class="cov0" title="0">{
                        return userbus.UpdateUser{}, fmt.Errorf("parse: %w", err)
                }</span>
                <span class="cov0" title="0">phone = &amp;pne</span>
        }

        <span class="cov0" title="0">bus := userbus.UpdateUser{
                Name:       nme,
                Email:      addr,
                Phone:      phone,
                Department: department,
                Password:   app.Password,
                Enabled:    app.Enabled,
        }

        return bus, nil</span>
}
</pre>
		
		<pre class="file" id="file67" style="display: none">package userapp

import (
        "net/http"

        "github.com/FITHSCS/backend/app/sdk/auth"
        "github.com/FITHSCS/backend/app/sdk/authclient"
        "github.com/FITHSCS/backend/app/sdk/mid"
        "github.com/FITHSCS/backend/business/domain/userbus"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/FITHSCS/backend/foundation/web"
)

type Config struct {
        Log        *logger.Logger
        UserBus    userbus.ExtBusiness
        AuthClient *authclient.Client
}

func Routes(app *web.App, cfg Config) <span class="cov0" title="0">{
        const version = "v1"

        authen := mid.Authenticate(cfg.AuthClient)
        ruleAdmin := mid.Authorize(cfg.AuthClient, auth.RuleAdminOnly)
        ruleAuthorizeUser := mid.AuthorizeUser(cfg.AuthClient, cfg.UserBus, auth.RuleAdminOrSubject)
        ruleAuthorizeAdmin := mid.AuthorizeUser(cfg.AuthClient, cfg.UserBus, auth.RuleAdminOnly)

        api := newApp(cfg.UserBus)

        app.HandlerFunc(http.MethodGet, version, "/users", api.query, authen, ruleAdmin)
        app.HandlerFunc(http.MethodGet, version, "/users/{user_id}", api.queryByID, authen, ruleAuthorizeUser)
        app.HandlerFunc(http.MethodPost, version, "/users", api.create, authen, ruleAdmin)

        app.HandlerFunc(http.MethodPut, version, "/users/role/{user_id}", api.updateRole, authen, ruleAuthorizeAdmin)
        app.HandlerFunc(http.MethodPut, version, "/users/{user_id}", api.update, authen, ruleAuthorizeUser)
        app.HandlerFunc(http.MethodDelete, version, "/users/{user_id}", api.delete, authen, ruleAuthorizeUser)

}</span>
</pre>
		
		<pre class="file" id="file68" style="display: none">// Package userapp maintains the app layer api for the user domain.
package userapp

import (
        "context"
        "errors"
        "net/http"

        "github.com/FITHSCS/backend/app/sdk/errs"
        "github.com/FITHSCS/backend/app/sdk/mid"
        "github.com/FITHSCS/backend/app/sdk/query"
        "github.com/FITHSCS/backend/business/domain/userbus"
        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/foundation/web"
)

type app struct {
        userBus userbus.ExtBusiness
}

func newApp(userBus userbus.ExtBusiness) *app <span class="cov0" title="0">{
        return &amp;app{
                userBus: userBus,
        }
}</span>

func (a *app) create(ctx context.Context, r *http.Request) web.Encoder <span class="cov0" title="0">{
        var app NewUser
        if err := web.Decode(r, &amp;app); err != nil </span><span class="cov0" title="0">{
                return errs.New(errs.InvalidArgument, err)
        }</span>

        <span class="cov0" title="0">nc, err := toBusNewUser(app)
        if err != nil </span><span class="cov0" title="0">{
                return errs.New(errs.InvalidArgument, err)
        }</span>

        <span class="cov0" title="0">usr, err := a.userBus.Create(ctx, mid.GetSubjectID(ctx), nc)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, userbus.ErrUniqueEmail) </span><span class="cov0" title="0">{
                        return errs.New(errs.Aborted, userbus.ErrUniqueEmail)
                }</span>
                <span class="cov0" title="0">return errs.Newf(errs.Internal, "create usr[%+v]: %s", usr, err)</span>
        }

        <span class="cov0" title="0">return toAppUser(usr)</span>
}

func (a *app) update(ctx context.Context, r *http.Request) web.Encoder <span class="cov0" title="0">{
        var app UpdateUser
        if err := web.Decode(r, &amp;app); err != nil </span><span class="cov0" title="0">{
                return errs.New(errs.InvalidArgument, err)
        }</span>

        <span class="cov0" title="0">uu, err := toBusUpdateUser(app)
        if err != nil </span><span class="cov0" title="0">{
                return errs.New(errs.InvalidArgument, err)
        }</span>

        <span class="cov0" title="0">usr, err := mid.GetUser(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "user missing in context: %s", err)
        }</span>

        <span class="cov0" title="0">updUsr, err := a.userBus.Update(ctx, mid.GetSubjectID(ctx), usr, uu)
        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "update: userID[%s] uu[%+v]: %s", usr.ID, uu, err)
        }</span>

        <span class="cov0" title="0">return toAppUser(updUsr)</span>
}

func (a *app) updateRole(ctx context.Context, r *http.Request) web.Encoder <span class="cov0" title="0">{
        var app UpdateUserRole
        if err := web.Decode(r, &amp;app); err != nil </span><span class="cov0" title="0">{
                return errs.New(errs.InvalidArgument, err)
        }</span>

        <span class="cov0" title="0">uu, err := toBusUpdateUserRole(app)
        if err != nil </span><span class="cov0" title="0">{
                return errs.New(errs.InvalidArgument, err)
        }</span>

        <span class="cov0" title="0">usr, err := mid.GetUser(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "user missing in context: %s", err)
        }</span>

        <span class="cov0" title="0">updUsr, err := a.userBus.Update(ctx, mid.GetSubjectID(ctx), usr, uu)
        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "updaterole: userID[%s] uu[%+v]: %s", usr.ID, uu, err)
        }</span>

        <span class="cov0" title="0">return toAppUser(updUsr)</span>
}

func (a *app) delete(ctx context.Context, _ *http.Request) web.Encoder <span class="cov0" title="0">{
        usr, err := mid.GetUser(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "userID missing in context: %s", err)
        }</span>

        <span class="cov0" title="0">if err := a.userBus.Delete(ctx, mid.GetSubjectID(ctx), usr); err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "delete: userID[%s]: %s", usr.ID, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (a *app) query(ctx context.Context, r *http.Request) web.Encoder <span class="cov0" title="0">{
        qp, err := parseQueryParams(r)
        if err != nil </span><span class="cov0" title="0">{
                return errs.New(errs.InvalidArgument, err)
        }</span>

        <span class="cov0" title="0">page, err := page.Parse(qp.Page, qp.Rows)
        if err != nil </span><span class="cov0" title="0">{
                return errs.NewFieldErrors("page", err)
        }</span>

        <span class="cov0" title="0">filter, err := parseFilter(qp)
        if err != nil </span><span class="cov0" title="0">{
                return err.(*errs.Error)
        }</span>

        <span class="cov0" title="0">orderBy, err := order.Parse(orderByFields, qp.OrderBy, userbus.DefaultOrderBy)
        if err != nil </span><span class="cov0" title="0">{
                return errs.NewFieldErrors("order", err)
        }</span>

        <span class="cov0" title="0">usrs, err := a.userBus.Query(ctx, filter, orderBy, page)
        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "query: %s", err)
        }</span>

        <span class="cov0" title="0">total, err := a.userBus.Count(ctx, filter)
        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "count: %s", err)
        }</span>

        <span class="cov0" title="0">return query.NewResult(toAppUsers(usrs), total, page)</span>
}

func (a *app) queryByID(ctx context.Context, _ *http.Request) web.Encoder <span class="cov0" title="0">{
        usr, err := mid.GetUser(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "querybyid: %s", err)
        }</span>

        <span class="cov0" title="0">return toAppUser(usr)</span>
}
</pre>
		
		<pre class="file" id="file69" style="display: none">package vehicleapp

import (
        "net/http"
        //"net/mail"
        "time"

        "github.com/FITHSCS/backend/app/sdk/errs"
        "github.com/FITHSCS/backend/business/domain/vehiclebus"
        "github.com/FITHSCS/backend/business/types/name"

        //"github.com/FITHSCS/backend/business/types/facilitytype"
        "github.com/google/uuid"
        //"strconv"
)

type queryParams struct {
        Page           string
        Rows           string
        OrderBy        string
        ID             string
        PlateNumber    string
        VehicleType    string
        WeightCapacity string
        VolumeCapacity string
        CurrentStatus  string
        CreatedAt      string
        UpdatedAt      string
}

func ParseQueryParams(r *http.Request) (queryParams, error) <span class="cov0" title="0">{

        values := r.URL.Query()

        filter := queryParams{

                Page:           values.Get("page"),
                Rows:           values.Get("rows"),
                OrderBy:        values.Get("orderBy"),
                ID:             values.Get("vehicle_id"),
                PlateNumber:    values.Get("plate_number"),
                VehicleType:    values.Get("vehicle_type"),
                WeightCapacity: values.Get("weight_capacity"),
                VolumeCapacity: values.Get("volume_capacity"),
                CurrentStatus:  values.Get("current_status"),
                CreatedAt:      values.Get("start_created_date"),
                UpdatedAt:      values.Get("end_created_date"),
        }

        return filter, nil
}</span>

func ParseFilter(qp queryParams) (vehiclebus.QueryFilter, error) <span class="cov0" title="0">{

        var fieldErrors errs.FieldErrors
        var filter vehiclebus.QueryFilter

        if qp.ID != "" </span><span class="cov0" title="0">{
                id, err := uuid.Parse(qp.ID)
                if err != nil </span><span class="cov0" title="0">{
                        fieldErrors.Add("vehicle_id", err)
                }</span> else<span class="cov0" title="0"> {
                        filter.ID = id
                }</span>
        }

        <span class="cov0" title="0">if qp.PlateNumber != "" </span><span class="cov0" title="0">{
                number, err := name.Parse(qp.PlateNumber)
                switch err </span>{
                case nil:<span class="cov0" title="0">
                        filter.PlateNumber = &amp;number</span>
                default:<span class="cov0" title="0">
                        fieldErrors.Add("Facility name", err)</span>
                }
        }

        <span class="cov0" title="0">if qp.VehicleType != "" </span><span class="cov0" title="0">{

                vehType, err := name.Parse(qp.VehicleType)
                switch err </span>{
                case nil:<span class="cov0" title="0">
                        filter.VehicleType = &amp;vehType</span>
                default:<span class="cov0" title="0">
                        fieldErrors.Add("Vehicle type", err)</span>
                }
        }

        <span class="cov0" title="0">if qp.WeightCapacity != "" </span><span class="cov0" title="0">{
                wCapacity, err := name.Parse(qp.WeightCapacity)
                switch err </span>{
                case nil:<span class="cov0" title="0">
                        filter.WeightCapacity = &amp;wCapacity</span>
                default:<span class="cov0" title="0">
                        fieldErrors.Add("weight capacity", err)</span>
                }
        }
        <span class="cov0" title="0">if qp.VolumeCapacity != "" </span><span class="cov0" title="0">{

                vCapacity, err := name.Parse(qp.VolumeCapacity)
                switch err </span>{
                case nil:<span class="cov0" title="0">
                        filter.VolumeCapacity = &amp;vCapacity</span>
                default:<span class="cov0" title="0">
                        fieldErrors.Add("volume capacity", err)</span>
                }
        }

        <span class="cov0" title="0">if qp.CurrentStatus != "" </span><span class="cov0" title="0">{

                cStatus, err := name.Parse(qp.CurrentStatus)
                switch err </span>{
                case nil:<span class="cov0" title="0">
                        filter.CurrentStatus = &amp;cStatus</span>
                default:<span class="cov0" title="0">
                        fieldErrors.Add("volume capacity", err)</span>
                }
        }

        <span class="cov0" title="0">if qp.CreatedAt != "" </span><span class="cov0" title="0">{
                t, err := time.Parse(time.RFC3339, qp.CreatedAt)
                switch err </span>{
                case nil:<span class="cov0" title="0">
                        filter.CreatedAt = &amp;t</span>
                default:<span class="cov0" title="0">
                        fieldErrors.Add("Start_created_date", err)</span>
                }
        }
        <span class="cov0" title="0">if qp.UpdatedAt != "" </span><span class="cov0" title="0">{
                t, err := time.Parse(time.RFC3339, qp.UpdatedAt)
                switch err </span>{
                case nil:<span class="cov0" title="0">
                        filter.UpdatedAt = &amp;t</span>
                default:<span class="cov0" title="0">
                        fieldErrors.Add("End created date", err)</span>
                }
        }
        <span class="cov0" title="0">if fieldErrors != nil </span><span class="cov0" title="0">{
                return vehiclebus.QueryFilter{}, fieldErrors.ToError()
        }</span>
        <span class="cov0" title="0">return filter, nil</span>
}
</pre>
		
		<pre class="file" id="file70" style="display: none">package vehicleapp

import (
        "encoding/json"
        "fmt"

        "github.com/FITHSCS/backend/app/sdk/errs"
        "github.com/FITHSCS/backend/business/domain/vehiclebus"
        "github.com/FITHSCS/backend/business/types/genstringtype"
)

type Vehicle struct {
        ID             string `json:"vehicle_id"`
        PlateNumber    string `json:"plate_number"`
        VehicleType    string `json:"vehicle_type"`
        WeightCapacity int    `json:"weight_capacity"`
        VolumeCapacity int    `json:"volume_capacity"`
        CurrentStatus  string `json:"current_status"`
        CreatedAt      string `json:"created_at"`
        UpdatedAt      string `json:"updated_at"`
}

type Vehicles []Vehicle

func (v Vehicles) Encode() ([]byte, string, error) <span class="cov0" title="0">{

        data, err := json.Marshal(v)
        return data, "application/json", err
}</span>

func (app Vehicle) Encode() ([]byte, string, error) <span class="cov0" title="0">{

        data, err := json.Marshal(app)
        return data, "application/json", err
}</span>

//&lt;================STRUCT CONVERTING TO API RESPONSE ===========================&gt;
//converting it to APP struct for the api Response to user

func toAppVehicle(vehicle vehiclebus.Vehicle) Vehicle <span class="cov0" title="0">{

        return Vehicle{

                ID:             vehicle.ID.String(),
                PlateNumber:    vehicle.PlateNumber.String(),
                VehicleType:    vehicle.VehicleType.String(),
                WeightCapacity: vehicle.WeightCapacity,
                VolumeCapacity: vehicle.VolumeCapacity,
                CurrentStatus:  vehicle.CurrentStatus.String(),
                CreatedAt:      vehicle.CreatedAt.String(),
                UpdatedAt:      vehicle.UpdatedAt.String(),
        }
}</span>

//when sending all the existing facility to the api we do the following
//&lt;============================================ ===========================&gt;

func toAppVehicles(vehicles []vehiclebus.Vehicle) []Vehicle <span class="cov0" title="0">{

        app := make([]Vehicle, len(vehicles))

        for i, vehicle := range vehicles </span><span class="cov0" title="0">{

                app[i] = toAppVehicle(vehicle)
        }</span>
        <span class="cov0" title="0">return app</span>
}

//&lt;================CONVERTING TO API RESPONSE ===========================&gt;

//=&gt; struct that holds values from http Request or from user

type NewVehicle struct {
        PlateNumber    string `json:"plate_number"`
        VehicleType    string `json:"vehicle_type"`
        WeightCapacity int    `json:"weight_capacity"`
        VolumeCapacity int    `json:"volume_capacity"`
        CurrentStatus  string `json:"current_status"`
}

//&lt;============================DECODE=============================&gt;

func (app *NewVehicle) Decode(data []byte) error <span class="cov0" title="0">{

        return json.Unmarshal(data, app)

}</span>

func (app NewVehicle) Validate() error <span class="cov0" title="0">{

        if err := errs.Check(app); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("validate: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

//&lt;=====================Sending Data Business Layer ====================&gt;

func toBusNewVehicle(app NewVehicle) (vehiclebus.NewVehicle, error) <span class="cov0" title="0">{

        pltNumber, err := genstringtype.Parse(app.PlateNumber)

        if err != nil </span><span class="cov0" title="0">{
                return vehiclebus.NewVehicle{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">vehType, err := genstringtype.Parse(app.VehicleType)
        if err != nil </span><span class="cov0" title="0">{
                return vehiclebus.NewVehicle{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">currentStatus, err := genstringtype.Parse(app.CurrentStatus)
        if err != nil </span><span class="cov0" title="0">{
                return vehiclebus.NewVehicle{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">bus := vehiclebus.NewVehicle{
                PlateNumber:    pltNumber,
                VehicleType:    vehType,
                WeightCapacity: app.WeightCapacity,
                VolumeCapacity: app.VolumeCapacity,
                CurrentStatus:  currentStatus,
        }

        return bus, nil</span>
}

//&lt;=====================Sending Data Business Layer ====================&gt;

//&lt;==============UPDATE STRUCT THAT WILL HOLD INFO FROM REQUEST =========================&gt;

type UpdateVehicle struct {
        PlateNumber    *string `json:"plate_number"`
        VehicleType    *string `json:"vehicle_type"`
        WeightCapacity *int    `json:"weight_capacity"`
        VolumeCapacity *int    `json:"volume_capacity"`
        CurrentStatus  *string `json:"current_status"`
}

//&lt;========================================================&gt;

func (app *UpdateVehicle) Decode(data []byte) error <span class="cov0" title="0">{
        return json.Unmarshal(data, app)
}</span>

func (app UpdateVehicle) Validate() error <span class="cov0" title="0">{
        if err := errs.Check(app); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("validate: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>

}

func toBusUpdateVehicle(app UpdateVehicle) (vehiclebus.UpdateVehicle, error) <span class="cov0" title="0">{

        var plateNumber *genstringtype.GenString
        if app.PlateNumber != nil </span><span class="cov0" title="0">{
                typePlate, err := genstringtype.Parse(*app.PlateNumber)
                if err != nil </span><span class="cov0" title="0">{
                        return vehiclebus.UpdateVehicle{}, fmt.Errorf("parse: %w", err)
                }</span>
                <span class="cov0" title="0">plateNumber = &amp;typePlate</span>
        }

        <span class="cov0" title="0">var vehType *genstringtype.GenString
        if app.VehicleType != nil </span><span class="cov0" title="0">{
                typeVehicle, err := genstringtype.Parse(*app.VehicleType)
                if err != nil </span><span class="cov0" title="0">{
                        return vehiclebus.UpdateVehicle{}, fmt.Errorf("parse: %w", err)
                }</span>

                <span class="cov0" title="0">vehType = &amp;typeVehicle</span>
        }

        <span class="cov0" title="0">var weigCapacity *int
        if app.WeightCapacity != nil </span><span class="cov0" title="0">{
                weigCapacity = app.WeightCapacity
        }</span>

        <span class="cov0" title="0">var volCapacity *int
        if app.VolumeCapacity != nil </span><span class="cov0" title="0">{
                volCapacity = app.VolumeCapacity
        }</span>

        <span class="cov0" title="0">var curStatus *genstringtype.GenString
        if app.CurrentStatus != nil </span><span class="cov0" title="0">{
                status, err := genstringtype.Parse(*app.CurrentStatus)
                if err != nil </span><span class="cov0" title="0">{
                        return vehiclebus.UpdateVehicle{}, fmt.Errorf("parse: %w", err)
                }</span>
                <span class="cov0" title="0">curStatus = &amp;status</span>
        }

        <span class="cov0" title="0">bus := vehiclebus.UpdateVehicle{
                PlateNumber:    plateNumber,
                VehicleType:    vehType,
                WeightCapacity: weigCapacity,
                VolumeCapacity: volCapacity,
                CurrentStatus:  curStatus,
        }
        return bus, nil</span>
}
</pre>
		
		<pre class="file" id="file71" style="display: none">package vehicleapp

import (
        "net/http"
        //"github.com/FITHSCS/backend/app/sdk/auth"
        "github.com/FITHSCS/backend/app/sdk/authclient"
        "github.com/FITHSCS/backend/app/sdk/mid"

        "github.com/FITHSCS/backend/business/domain/vehiclebus"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/FITHSCS/backend/foundation/web"
        //"github.com/jmoiron/sqlx"
)

type Config struct {
        Log        *logger.Logger
        VehicleBus *vehiclebus.Business
        AuthClient *authclient.Client
}

func Routes(app *web.App, cfg Config) <span class="cov0" title="0">{

        const version = "v1"

        authen := mid.Authenticate(cfg.AuthClient)

        api := newApp(cfg.VehicleBus)

        app.HandlerFunc(http.MethodPost, version, "/vehicle", api.create, authen)
        app.HandlerFunc(http.MethodGet, version, "/vehicle", api.query)
        app.HandlerFunc(http.MethodGet, version, "/vehicle/{vehicle_id}", api.queryByID, authen)
        app.HandlerFunc(http.MethodPut, version, "/vehicle/{vehicle_id}", api.update, authen)
        app.HandlerFunc(http.MethodDelete, version, "/vehicle/{vehicle_id}", api.delete, authen)
}</span>
</pre>
		
		<pre class="file" id="file72" style="display: none">// Package vehicleapp maintains the app layer api for the vehicle domain.
package vehicleapp

import (
        "context"

        "net/http"

        "github.com/FITHSCS/backend/app/sdk/errs"

        "github.com/FITHSCS/backend/app/sdk/query"
        "github.com/FITHSCS/backend/business/domain/vehiclebus"
        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/foundation/web"
        "github.com/google/uuid"
)

type app struct {
        vehicleBus *vehiclebus.Business
}

func newApp(vehiclebus *vehiclebus.Business) *app <span class="cov0" title="0">{

        return &amp;app{
                vehicleBus: vehiclebus,
        }
}</span>

func (a *app) create(ctx context.Context, r *http.Request) web.Encoder <span class="cov0" title="0">{

        var nv NewVehicle
        if err := web.Decode(r, &amp;nv); err != nil </span><span class="cov0" title="0">{

                return errs.New(errs.InvalidArgument, err)
        }</span>

        <span class="cov0" title="0">nc, err := toBusNewVehicle(nv)

        if err != nil </span><span class="cov0" title="0">{
                return errs.New(errs.InvalidArgument, err)
        }</span>

        <span class="cov0" title="0">vehicleCreated, err := a.vehicleBus.Create(ctx, nc)

        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "create vehicle[%+v]: %s", vehicleCreated, err)
        }</span>

        <span class="cov0" title="0">return toAppVehicle(vehicleCreated)</span>
}

func (a *app) query(ctx context.Context, r *http.Request) web.Encoder <span class="cov0" title="0">{
        queryParameters, err := ParseQueryParams(r)

        if err != nil </span><span class="cov0" title="0">{
                return errs.New(errs.InvalidArgument, err)
        }</span>
        <span class="cov0" title="0">page, err := page.Parse(queryParameters.Page, queryParameters.Rows)
        if err != nil </span><span class="cov0" title="0">{
                return errs.NewFieldErrors("page", err)
        }</span>
        <span class="cov0" title="0">filter, err := ParseFilter(queryParameters)
        if err != nil </span><span class="cov0" title="0">{
                return err.(*errs.Error)
        }</span>
        <span class="cov0" title="0">orderBy, err := order.Parse(orderByFields, queryParameters.OrderBy, vehiclebus.DefaultOrderBy)

        if err != nil </span><span class="cov0" title="0">{
                return errs.NewFieldErrors("order", err)
        }</span>

        <span class="cov0" title="0">vehicles, err := a.vehicleBus.Query(ctx, filter, orderBy, page)
        if err != nil </span><span class="cov0" title="0">{
                return errs.NewFieldErrors("query: ", err)
        }</span>

        <span class="cov0" title="0">total, err := a.vehicleBus.Count(ctx, filter)
        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "count: %s", err)
        }</span>

        <span class="cov0" title="0">return query.NewResult(toAppVehicles(vehicles), total, page)</span>

}

func (a *app) update(ctx context.Context, r *http.Request) web.Encoder <span class="cov0" title="0">{

        vehicleIDStr := web.Param(r, "vehicle_id")
        if vehicleIDStr == "" </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "ID not set")
        }</span>

        <span class="cov0" title="0">vehicleID, err := uuid.Parse(vehicleIDStr)

        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "id not correctly formatted: %s", err)
        }</span>

        <span class="cov0" title="0">var update UpdateVehicle

        if err := web.Decode(r, &amp;update); err != nil </span><span class="cov0" title="0">{
                return errs.New(errs.InvalidArgument, err)
        }</span>

        <span class="cov0" title="0">updateVehicleBus, err := toBusUpdateVehicle(update)

        if err != nil </span><span class="cov0" title="0">{
                return errs.New(errs.InvalidArgument, err)
        }</span>
        <span class="cov0" title="0">updatedVehicle, err := a.vehicleBus.Update(ctx, vehicleID, updateVehicleBus)
        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "update Failed, ID: %s Request: %v", vehicleID, update)
        }</span>

        <span class="cov0" title="0">return toAppVehicle(updatedVehicle)</span>
}

func (a *app) queryByID(ctx context.Context, r *http.Request) web.Encoder <span class="cov0" title="0">{

        vehicleIDStr := web.Param(r, "vehicle_id")

        vehicleID, err := uuid.Parse(vehicleIDStr)

        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "id not correctly formatted: %s", err)
        }</span>

        <span class="cov0" title="0">vehicleRetrieved, err := a.vehicleBus.QueryByID(ctx, vehicleID)
        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "querybyid: %s", err)
        }</span>

        <span class="cov0" title="0">return toAppVehicle(vehicleRetrieved)</span>
}

func (a *app) delete(ctx context.Context, r *http.Request) web.Encoder <span class="cov0" title="0">{

        vehicleIDStr := web.Param(r, "vehicle_id")

        vehicleID, err := uuid.Parse(vehicleIDStr)

        if err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "vehicle id missing in context %s", err)
        }</span>

        <span class="cov0" title="0">if err := a.vehicleBus.Delete(ctx, vehicleID); err != nil </span><span class="cov0" title="0">{
                return errs.Newf(errs.Internal, "delete: vehicleID[%s]: %s", vehicleID, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file73" style="display: none">// Package apitest provides support for excuting api test logic.
package apitest

import (
        "bytes"
        "context"
        "encoding/json"
        "net/http"
        "net/http/httptest"
        "net/mail"
        "testing"
        "time"

        "github.com/FITHSCS/backend/app/sdk/auth"
        "github.com/FITHSCS/backend/business/domain/userbus"
        "github.com/FITHSCS/backend/business/sdk/dbtest"
        "github.com/FITHSCS/backend/business/types/role"
        "github.com/golang-jwt/jwt/v4"
)

// Test contains functions for executing an api test.
type Test struct {
        DB   *dbtest.Database
        Auth *auth.Auth
        mux  http.Handler
}

// Run performs the actual test logic based on the table data.
func (at *Test) Run(t *testing.T, table []Table, testName string) <span class="cov0" title="0">{
        for _, tt := range table </span><span class="cov0" title="0">{
                f := func(t *testing.T) </span><span class="cov0" title="0">{
                        r := httptest.NewRequest(tt.Method, tt.URL, nil)
                        w := httptest.NewRecorder()

                        if tt.Input != nil </span><span class="cov0" title="0">{
                                d, err := json.Marshal(tt.Input)
                                if err != nil </span><span class="cov0" title="0">{
                                        t.Fatalf("Should be able to marshal the model : %s", err)
                                }</span>

                                <span class="cov0" title="0">r = httptest.NewRequest(tt.Method, tt.URL, bytes.NewBuffer(d))</span>
                        }

                        <span class="cov0" title="0">r.Header.Set("Authorization", "Bearer "+tt.Token)
                        at.mux.ServeHTTP(w, r)

                        if w.Code != tt.StatusCode </span><span class="cov0" title="0">{
                                t.Fatalf("%s: Should receive a status code of %d for the response : %d", tt.Name, tt.StatusCode, w.Code)
                        }</span>

                        <span class="cov0" title="0">if tt.StatusCode == http.StatusNoContent </span><span class="cov0" title="0">{
                                return
                        }</span>

                        <span class="cov0" title="0">if err := json.Unmarshal(w.Body.Bytes(), tt.GotResp); err != nil </span><span class="cov0" title="0">{
                                t.Fatalf("Should be able to unmarshal the response : %s", err)
                        }</span>

                        <span class="cov0" title="0">diff := tt.CmpFunc(tt.GotResp, tt.ExpResp)
                        if diff != "" </span><span class="cov0" title="0">{
                                t.Log("DIFF")
                                t.Logf("%s", diff)
                                t.Log("GOT")
                                t.Logf("%#v", tt.GotResp)
                                t.Log("EXP")
                                t.Logf("%#v", tt.ExpResp)
                                t.Fatalf("Should get the expected response")
                        }</span>
                }

                <span class="cov0" title="0">t.Run(testName+"-"+tt.Name, f)</span>
        }
}

// =============================================================================

// Token generates an authenticated token for a user.
func Token(userBus userbus.ExtBusiness, ath *auth.Auth, email string) string <span class="cov0" title="0">{
        addr, _ := mail.ParseAddress(email)

        dbUsr, err := userBus.QueryByEmail(context.Background(), *addr)
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">claims := auth.Claims{
                RegisteredClaims: jwt.RegisteredClaims{
                        Subject:   dbUsr.ID.String(),
                        Issuer:    ath.Issuer(),
                        ExpiresAt: jwt.NewNumericDate(time.Now().UTC().Add(time.Hour)),
                        IssuedAt:  jwt.NewNumericDate(time.Now().UTC()),
                },
                Roles: role.ParseToString(dbUsr.Roles),
        }

        token, err := ath.GenerateToken(kid, claims)
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">return token</span>
}
</pre>
		
		<pre class="file" id="file74" style="display: none">package apitest

// KeyStore represents a mock keystore with a hardcoded key.
type KeyStore struct{}

// PrivateKey implements the auth interface.
func (ks *KeyStore) PrivateKey(kid string) (string, error) <span class="cov0" title="0">{
        return privateKeyPEM, nil
}</span>

// PublicKey implements the auth interface.
func (ks *KeyStore) PublicKey(kid string) (string, error) <span class="cov0" title="0">{
        return publicKeyPEM, nil
}</span>

const (
        kid = "s4sKIjD9kIRjxs2tulPqGLdxSfgPErRN1Mu3Hd9k9NQ"

        privateKeyPEM = `-----BEGIN PRIVATE KEY-----
MIIEpQIBAAKCAQEAvMAHb0IoLvoYuW2kA+LTmnk+hfnBq1eYIh4CT/rMPCxgtzjq
U0guQOMnLg69ydyA5uu37v6rbS1+stuBTEiMQl/bxAhgLkGrUhgpZ10Bt6GzSEgw
QNloZoGaxe4p20wMPpT4kcMKNHkQds3uONNcLxPUmfjbbH64g+seg28pbgQPwKFK
tF7bIsOBgz0g5Ptn5mrkdzqMPUSy9k9VCu+R42LH9c75JsRzz4FeN+VzwMAL6yQn
ZvOi7/zOgNyxeVia8XVKykrnhgcpiOn5oaLRBzQGN00Z7TuBRIfDJWU21qQN4Cq7
keZmMP4gqCVWjYneK4bzrG/+H2w9BJ2TsmMGvwIDAQABAoIBAFQmQKpHkmavNYql
6POaksBRwaA1YzSijr7XJizGIXvKRSwqgb2zdnuTSgpspAx09Dr/aDdy7rZ0DAJt
fk2mInINDottOIQm3txwzTS58GQQAT/+fxTKWJMqwPfxYFPWqbbU76T8kXYna0Gs
OcK36GdMrgIfQqQyMs0Na8MpMg1LmkAxuqnFCXS/NMyKl9jInaaTS+Kz+BSzUMGQ
zebfLFsf2N7sLZuimt9zlRG30JJTfBlB04xsYMo734usA2ITe8U0XqG6Og0qc6ev
6lsoM8hpvEUsQLcjQQ5up7xx3S2stZJ8o0X8GEX5qUMaomil8mZ7X5xOlEqf7p+v
lXQ46cECgYEA2lbZQON6l3ZV9PCn9j1rEGaXio3SrAdTyWK3D1HF+/lEjClhMkfC
XrECOZYj+fiI9n+YpSog+tTDF7FTLf7VP21d2gnhQN6KAXUnLIypzXxodcC6h+8M
ZGJh/EydLvC7nPNoaXx96bohxzS8hrOlOlkCbr+8gPYKf8qkbe7HyxECgYEA3U6e
x9g4FfTvI5MGrhp2BIzoRSn7HlNQzjJ71iMHmM2kBm7TsER8Co1PmPDrP8K/UyGU
Q25usTsPSrHtKQEV6EsWKaP/6p2Q82sDkT9bZlV+OjRvOfpdO5rP6Q95vUmMGWJ/
S6oimbXXL8p3gDafw3vC1PCAhoaxMnGyKuZwlM8CgYEAixT1sXr2dZMg8DV4mMfI
8pqXf+AVyhWkzsz+FVkeyAKiIrKdQp0peI5C/5HfevVRscvX3aY3efCcEfSYKt2A
07WEKkdO4LahrIoHGT7FT6snE5NgfwTMnQl6p2/aVLNun20CHuf5gTBbIf069odr
Af7/KLMkjfWs/HiGQ6zuQjECgYEAv+DIvlDz3+Wr6dYyNoXuyWc6g60wc0ydhQo0
YKeikJPLoWA53lyih6uZ1escrP23UOaOXCDFjJi+W28FR0YProZbwuLUoqDW6pZg
U3DxWDrL5L9NqKEwcNt7ZIDsdnfsJp5F7F6o/UiyOFd9YQb7YkxN0r5rUTg7Lpdx
eMyv0/UCgYEAhX9MPzmTO4+N8naGFof1o8YP97pZj0HkEvM0hTaeAQFKJiwX5ijQ
xumKGh//G0AYsjqP02ItzOm2mWnbI3FrNlKmGFvR6VxIZMOyXvpLofHucjJ5SWli
eYjPklKcXaMftt1FVO4n+EKj1k1+Tv14nytq/J5WN+r4FBlNEYj/6vg=
-----END PRIVATE KEY-----
`
        publicKeyPEM = `-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAvMAHb0IoLvoYuW2kA+LT
mnk+hfnBq1eYIh4CT/rMPCxgtzjqU0guQOMnLg69ydyA5uu37v6rbS1+stuBTEiM
Ql/bxAhgLkGrUhgpZ10Bt6GzSEgwQNloZoGaxe4p20wMPpT4kcMKNHkQds3uONNc
LxPUmfjbbH64g+seg28pbgQPwKFKtF7bIsOBgz0g5Ptn5mrkdzqMPUSy9k9VCu+R
42LH9c75JsRzz4FeN+VzwMAL6yQnZvOi7/zOgNyxeVia8XVKykrnhgcpiOn5oaLR
BzQGN00Z7TuBRIfDJWU21qQN4Cq7keZmMP4gqCVWjYneK4bzrG/+H2w9BJ2TsmMG
vwIDAQAB
-----END PUBLIC KEY-----`
)
</pre>
		
		<pre class="file" id="file75" style="display: none">package apitest

import (
        "net/http/httptest"
        "testing"

        authall "github.com/FITHSCS/backend/api/services/auth/build"
        coreall "github.com/FITHSCS/backend/api/services/core/build/all"
        "github.com/FITHSCS/backend/app/sdk/auth"
        "github.com/FITHSCS/backend/app/sdk/authclient"
        "github.com/FITHSCS/backend/app/sdk/mux"
        "github.com/FITHSCS/backend/business/sdk/dbtest"
)

// New initialized the system to run a test.
func New(t *testing.T, testName string) *Test <span class="cov0" title="0">{
        db := dbtest.New(t, testName)

        // -------------------------------------------------------------------------

        auth, err := auth.New(auth.Config{
                Log:       db.Log,
                UserBus:   db.BusDomain.User,
                KeyLookup: &amp;KeyStore{},
        })
        if err != nil </span><span class="cov0" title="0">{
                t.Fatal(err)
        }</span>

        // -------------------------------------------------------------------------

        <span class="cov0" title="0">server := httptest.NewServer(mux.WebAPI(mux.Config{
                Log: db.Log,
                DB:  db.DB,
                BusConfig: mux.BusConfig{
                        UserBus:     db.BusDomain.User,
                        AuditBus:    db.BusDomain.Audit,
                        FacilityBus: db.BusDomain.Facility,
                },
                AuthConfig: mux.AuthConfig{
                        Auth: auth,
                },
        }, authall.Routes()))

        authClient := authclient.New(db.Log, server.URL)

        // -------------------------------------------------------------------------

        mux := mux.WebAPI(mux.Config{
                Log: db.Log,
                DB:  db.DB,
                BusConfig: mux.BusConfig{
                        AuditBus: db.BusDomain.Audit,
                        UserBus:  db.BusDomain.User,
                },
                AuthClientConfig: mux.AuthClientConfig{
                        AuthClient: authClient,
                },
        }, coreall.Routes())

        return &amp;Test{
                DB:   db,
                Auth: auth,
                mux:  mux,
        }</span>
}
</pre>
		
		<pre class="file" id="file76" style="display: none">// Package auth provides authentication and authorization support.
// Authentication: You are who you say you are.
// Authorization:  You have permission to do what you are requesting to do.
package auth

import (
        "context"
        "errors"
        "fmt"
        "strings"

        "github.com/FITHSCS/backend/business/domain/userbus"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/golang-jwt/jwt/v4"
        "github.com/google/uuid"
        "github.com/open-policy-agent/opa/v1/rego"
)

// ErrForbidden is returned when a auth issue is identified.
var ErrForbidden = errors.New("attempted action is not allowed")

// Claims represents the authorization claims transmitted via a JWT.
type Claims struct {
        jwt.RegisteredClaims
        Roles []string `json:"roles"`
}

// KeyLookup declares a method set of behavior for looking up
// private and public keys for JWT use. The return could be a
// PEM encoded string or a JWS based key.
type KeyLookup interface {
        PrivateKey(kid string) (key string, err error)
        PublicKey(kid string) (key string, err error)
}

// Config represents information required to initialize auth.
type Config struct {
        Log       *logger.Logger
        UserBus   userbus.ExtBusiness
        KeyLookup KeyLookup
        Issuer    string
}

// Auth is used to authenticate clients. It can generate a token for a
// set of user claims and recreate the claims by parsing the token.
type Auth struct {
        log       *logger.Logger
        keyLookup KeyLookup
        userBus   userbus.ExtBusiness
        method    jwt.SigningMethod
        parser    *jwt.Parser
        issuer    string
}

// New creates an Auth to support authentication/authorization.
func New(cfg Config) (*Auth, error) <span class="cov0" title="0">{

        a := Auth{
                log:       cfg.Log,
                keyLookup: cfg.KeyLookup,
                userBus:   cfg.UserBus,
                method:    jwt.GetSigningMethod(jwt.SigningMethodRS256.Name),
                parser:    jwt.NewParser(jwt.WithValidMethods([]string{jwt.SigningMethodRS256.Name})),
                issuer:    cfg.Issuer,
        }

        return &amp;a, nil
}</span>

// Issuer provides the configured issuer used to authenticate tokens.
func (a *Auth) Issuer() string <span class="cov0" title="0">{
        return a.issuer
}</span>

// GenerateToken generates a signed JWT token string representing the user Claims.
func (a *Auth) GenerateToken(kid string, claims Claims) (string, error) <span class="cov0" title="0">{
        token := jwt.NewWithClaims(a.method, claims)
        token.Header["kid"] = kid

        privateKeyPEM, err := a.keyLookup.PrivateKey(kid)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("private key: %w", err)
        }</span>

        <span class="cov0" title="0">privateKey, err := jwt.ParseRSAPrivateKeyFromPEM([]byte(privateKeyPEM))
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("parsing private pem: %w", err)
        }</span>

        <span class="cov0" title="0">str, err := token.SignedString(privateKey)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("signing token: %w", err)
        }</span>

        <span class="cov0" title="0">return str, nil</span>
}

// Authenticate processes the token to validate the sender's token is valid.
func (a *Auth) Authenticate(ctx context.Context, bearerToken string) (Claims, error) <span class="cov0" title="0">{
        if !strings.HasPrefix(bearerToken, "Bearer ") </span><span class="cov0" title="0">{
                return Claims{}, errors.New("expected authorization header format: Bearer &lt;token&gt;")
        }</span>

        <span class="cov0" title="0">jwt := bearerToken[7:]

        var claims Claims
        token, _, err := a.parser.ParseUnverified(jwt, &amp;claims)
        if err != nil </span><span class="cov0" title="0">{
                return Claims{}, fmt.Errorf("error parsing token: %w", err)
        }</span>

        <span class="cov0" title="0">kidRaw, exists := token.Header["kid"]
        if !exists </span><span class="cov0" title="0">{
                return Claims{}, errors.New("kid missing from header")
        }</span>

        <span class="cov0" title="0">kid, ok := kidRaw.(string)
        if !ok </span><span class="cov0" title="0">{
                return Claims{}, errors.New("kid malformed")
        }</span>

        <span class="cov0" title="0">pem, err := a.keyLookup.PublicKey(kid)
        if err != nil </span><span class="cov0" title="0">{
                return Claims{}, fmt.Errorf("failed to fetch public key: %w", err)
        }</span>

        <span class="cov0" title="0">input := map[string]any{
                "Key":   pem,
                "Token": jwt,
                "ISS":   a.issuer,
        }

        if err := a.opaPolicyEvaluation(ctx, regoAuthentication, RuleAuthenticate, input); err != nil </span><span class="cov0" title="0">{
                a.log.Info(ctx, "**Authenticate-FAILED**", "token", jwt)
                return Claims{}, fmt.Errorf("authentication failed : %w", err)
        }</span>

        // Check the database for this user to verify they are still enabled.

        <span class="cov0" title="0">if err := a.isUserEnabled(ctx, claims); err != nil </span><span class="cov0" title="0">{
                return Claims{}, fmt.Errorf("user not enabled : %w", err)
        }</span>

        <span class="cov0" title="0">return claims, nil</span>
}

// Authorize attempts to authorize the user with the provided input roles, if
// none of the input roles are within the user's claims, we return an error
// otherwise the user is authorized.
func (a *Auth) Authorize(ctx context.Context, claims Claims, userID uuid.UUID, rule string) error <span class="cov0" title="0">{
        input := map[string]any{
                "Roles":   claims.Roles,
                "Subject": claims.Subject,
                "UserID":  userID,
        }

        if err := a.opaPolicyEvaluation(ctx, regoAuthorization, rule, input); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("rego evaluation failed : %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// opaPolicyEvaluation asks opa to evaluate the token against the specified token
// policy and public key.
func (a *Auth) opaPolicyEvaluation(ctx context.Context, regoScript string, rule string, input any) error <span class="cov0" title="0">{
        query := fmt.Sprintf("x = data.%s.%s", opaPackage, rule)

        q, err := rego.New(
                rego.Query(query),
                rego.Module("policy.rego", regoScript),
        ).PrepareForEval(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">results, err := q.Eval(ctx, rego.EvalInput(input))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("query: %w", err)
        }</span>

        <span class="cov0" title="0">if len(results) == 0 </span><span class="cov0" title="0">{
                return errors.New("no results")
        }</span>

        <span class="cov0" title="0">result, ok := results[0].Bindings["x"].(bool)
        if !ok || !result </span><span class="cov0" title="0">{
                return fmt.Errorf("bindings results[%v] ok[%v]", results, ok)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// isUserEnabled hits the database and checks the user is not disabled. If the
// no database connection was provided, this check is skipped.
func (a *Auth) isUserEnabled(ctx context.Context, claims Claims) error <span class="cov0" title="0">{
        if a.userBus == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">userID, err := uuid.Parse(claims.Subject)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("parse user: %w", err)
        }</span>

        <span class="cov0" title="0">usr, err := a.userBus.QueryByID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("query user: %w", err)
        }</span>

        <span class="cov0" title="0">if !usr.Enabled </span><span class="cov0" title="0">{
                return fmt.Errorf("user disabled")
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file77" style="display: none">// Package authclient provides support to access the auth service.
package authclient

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "net"
        "net/http"
        "net/url"
        "path"
        "time"

        "github.com/FITHSCS/backend/app/sdk/errs"
        "github.com/FITHSCS/backend/foundation/logger"
)

// This provides a default client configuration, but it's recommended
// this is replaced by the user with application specific settings using
// the WithClient function at the time a AuthAPI is constructed.
// DualStack Deprecated: Fast Fallback is enabled by default. To disable, set FallbackDelay to a negative value.
var defaultClient = http.Client{
        Transport: &amp;http.Transport{
                Proxy: http.ProxyFromEnvironment,
                DialContext: (&amp;net.Dialer{
                        Timeout:   10 * time.Second,
                        KeepAlive: 15 * time.Second,
                }).DialContext,
                ForceAttemptHTTP2:     true,
                MaxIdleConns:          100,
                IdleConnTimeout:       90 * time.Second,
                TLSHandshakeTimeout:   10 * time.Second,
                ExpectContinueTimeout: 1 * time.Second,
        },
}

// Client represents a client that can talk to the auth service.
type Client struct {
        log  *logger.Logger
        url  string
        http *http.Client
}

// New constructs an Auth that can be used to talk with the auth service.
func New(log *logger.Logger, url string, options ...func(cln *Client)) *Client <span class="cov0" title="0">{
        cln := Client{
                log:  log,
                url:  url,
                http: &amp;defaultClient,
        }

        for _, option := range options </span><span class="cov0" title="0">{
                option(&amp;cln)
        }</span>

        <span class="cov0" title="0">return &amp;cln</span>
}

// WithClient adds a custom client for processing requests. It's recommend
// to not use the default client and provide your own.
func WithClient(http *http.Client) func(cln *Client) <span class="cov0" title="0">{
        return func(cln *Client) </span><span class="cov0" title="0">{
                cln.http = http
        }</span>
}

// Authenticate calls the auth service to authenticate the user.
func (cln *Client) Authenticate(ctx context.Context, authorization string) (AuthenticateResp, error) <span class="cov0" title="0">{
        endpoint := fmt.Sprintf("%s/v1/auth/authenticate", cln.url)

        headers := map[string]string{
                "authorization": authorization,
        }

        var resp AuthenticateResp
        if err := cln.do(ctx, http.MethodGet, endpoint, headers, nil, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return AuthenticateResp{}, err
        }</span>

        <span class="cov0" title="0">return resp, nil</span>
}

// Authorize calls the auth service to authorize the user.
func (cln *Client) Authorize(ctx context.Context, auth Authorize) error <span class="cov0" title="0">{
        endpoint := fmt.Sprintf("%s/v1/auth/authorize", cln.url)

        if err := cln.do(ctx, http.MethodPost, endpoint, nil, auth, nil); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (cln *Client) do(ctx context.Context, method string, endpoint string, headers map[string]string, body any, v any) error <span class="cov0" title="0">{
        var statusCode int

        u, err := url.Parse(endpoint)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("parsing endpoint: %w", err)
        }</span>
        <span class="cov0" title="0">base := path.Base(u.Path)

        cln.log.Info(ctx, "authclient: rawRequest: started", "method", method, "call", base, "endpoint", endpoint)
        defer func() </span><span class="cov0" title="0">{
                cln.log.Info(ctx, "authclient: rawRequest: completed", "status", statusCode)
        }</span>()

        <span class="cov0" title="0">var b bytes.Buffer
        if body != nil </span><span class="cov0" title="0">{
                if err := json.NewEncoder(&amp;b).Encode(body); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("encoding error: %w", err)
                }</span>
        }

        <span class="cov0" title="0">req, err := http.NewRequestWithContext(ctx, method, endpoint, &amp;b)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("create request error: %w", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Cache-Control", "no-cache")
        req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Accept", "application/json")
        for key, value := range headers </span><span class="cov0" title="0">{
                cln.log.Info(ctx, "authclient: rawRequest", "key", key, "value", value)
                req.Header.Set(key, value)
        }</span>

        <span class="cov0" title="0">resp, err := cln.http.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("do: error: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        // Assign so it can be logged in the defer above.
        statusCode = resp.StatusCode

        if statusCode == http.StatusNoContent </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">data, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("copy error: %w", err)
        }</span>

        <span class="cov0" title="0">switch statusCode </span>{
        case http.StatusOK:<span class="cov0" title="0">
                if err := json.Unmarshal(data, v); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed: response: %s, decoding error: %w ", string(data), err)
                }</span>
                <span class="cov0" title="0">return nil</span>

        case http.StatusUnauthorized:<span class="cov0" title="0">
                var err *errs.Error
                if err := json.Unmarshal(data, &amp;err); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed: response: %s, decoding error: %w ", string(data), err)
                }</span>
                <span class="cov0" title="0">return err</span>

        default:<span class="cov0" title="0">
                return fmt.Errorf("failed: response: %s", string(data))</span>
        }
}
</pre>
		
		<pre class="file" id="file78" style="display: none">package authclient

import (
        "encoding/json"

        "github.com/FITHSCS/backend/app/sdk/auth"
        "github.com/google/uuid"
)

// Authorize defines the information required to perform an authorization.
type Authorize struct {
        UserID uuid.UUID
        Claims auth.Claims
        Rule   string
}

// Decode implements the decoder interface.
func (a *Authorize) Decode(data []byte) error <span class="cov0" title="0">{
        return json.Unmarshal(data, a)
}</span>

// AuthenticateResp defines the information that will be received on authenticate.
type AuthenticateResp struct {
        UserID uuid.UUID
        Claims auth.Claims
}

// Encode implements the encoder interface.
func (ar AuthenticateResp) Encode() ([]byte, string, error) <span class="cov0" title="0">{
        data, err := json.Marshal(ar)
        return data, "application/json", err
}</span>
</pre>
		
		<pre class="file" id="file79" style="display: none">// Package debug provides handler support for the debugging endpoints.
package debug

import (
        "expvar"
        "net/http"
        "net/http/pprof"

        "github.com/arl/statsviz"
)

// Mux registers all the debug routes from the standard library into a new mux
// bypassing the use of the DefaultServerMux. Using the DefaultServerMux would
// be a security risk since a dependency could inject a handler into our service
// without us knowing it.
func Mux() *http.ServeMux <span class="cov0" title="0">{
        mux := http.NewServeMux()

        mux.HandleFunc("/debug/pprof/", pprof.Index)
        mux.HandleFunc("/debug/pprof/cmdline", pprof.Cmdline)
        mux.HandleFunc("/debug/pprof/profile", pprof.Profile)
        mux.HandleFunc("/debug/pprof/symbol", pprof.Symbol)
        mux.HandleFunc("/debug/pprof/trace", pprof.Trace)
        mux.Handle("/debug/vars/", expvar.Handler())

        statsviz.Register(mux)

        return mux
}</span>
</pre>
		
		<pre class="file" id="file80" style="display: none">// Package errs provides types and support related to web error functionality.
package errs

import (
        "encoding/json"
        "errors"
        "fmt"
        "runtime"
)

// ErrCode represents an error code in the system.
type ErrCode struct {
        value int
}

// Value returns the integer value of the error code.
func (ec ErrCode) Value() int <span class="cov0" title="0">{
        return ec.value
}</span>

// String returns the string representation of the error code.
func (ec ErrCode) String() string <span class="cov0" title="0">{
        return codeNames[ec]
}</span>

// UnmarshalText implement the unmarshal interface for JSON conversions.
func (ec *ErrCode) UnmarshalText(data []byte) error <span class="cov0" title="0">{
        errName := string(data)

        v, exists := codeNumbers[errName]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("err code %q does not exist", errName)
        }</span>

        <span class="cov0" title="0">*ec = v

        return nil</span>
}

// MarshalText implement the marshal interface for JSON conversions.
func (ec ErrCode) MarshalText() ([]byte, error) <span class="cov0" title="0">{
        return []byte(ec.String()), nil
}</span>

// Equal provides support for the go-cmp package and testing.
func (ec ErrCode) Equal(ec2 ErrCode) bool <span class="cov0" title="0">{
        return ec.value == ec2.value
}</span>

// =============================================================================

// Error represents an error in the system.
type Error struct {
        Code     ErrCode `json:"code"`
        Message  string  `json:"message"`
        FuncName string  `json:"-"`
        FileName string  `json:"-"`
}

// New constructs an error based on an app error.
func New(code ErrCode, err error) *Error <span class="cov0" title="0">{
        pc, filename, line, _ := runtime.Caller(1)

        return &amp;Error{
                Code:     code,
                Message:  err.Error(),
                FuncName: runtime.FuncForPC(pc).Name(),
                FileName: fmt.Sprintf("%s:%d", filename, line),
        }
}</span>

// Newf constructs an error based on a error message.
func Newf(code ErrCode, format string, v ...any) *Error <span class="cov0" title="0">{
        pc, filename, line, _ := runtime.Caller(1)

        return &amp;Error{
                Code:     code,
                Message:  fmt.Sprintf(format, v...),
                FuncName: runtime.FuncForPC(pc).Name(),
                FileName: fmt.Sprintf("%s:%d", filename, line),
        }
}</span>

// NewError checks for an Error in the error interface value. If it doesn't
// exist, will create one from the error.
func NewError(err error) *Error <span class="cov0" title="0">{
        var errsErr *Error
        if errors.As(err, &amp;errsErr) </span><span class="cov0" title="0">{
                return errsErr
        }</span>

        <span class="cov0" title="0">return New(Internal, err)</span>
}

// Error implements the error interface.
func (e *Error) Error() string <span class="cov0" title="0">{
        return e.Message
}</span>

// Encode implements the encoder interface.
func (e *Error) Encode() ([]byte, string, error) <span class="cov0" title="0">{
        data, err := json.Marshal(e)
        return data, "application/json", err
}</span>

// HTTPStatus implements the web package httpStatus interface so the
// web framework can use the correct http status.
func (e *Error) HTTPStatus() int <span class="cov0" title="0">{
        return httpStatus[e.Code]
}</span>

// Equal provides support for the go-cmp package and testing.
func (e *Error) Equal(e2 *Error) bool <span class="cov0" title="0">{
        return e.Code == e2.Code &amp;&amp; e.Message == e2.Message
}</span>

// =============================================================================

// FieldError is used to indicate an error with a specific request field.
type FieldError struct {
        Field string `json:"field"`
        Err   string `json:"error"`
}

// FieldErrors represents a collection of field errors.
type FieldErrors []FieldError

// NewFieldErrors creates a field errors.
func NewFieldErrors(field string, err error) *Error <span class="cov0" title="0">{
        fe := FieldErrors{
                {
                        Field: field,
                        Err:   err.Error(),
                },
        }

        return fe.ToError()
}</span>

// Add adds a field error to the collection.
func (fe *FieldErrors) Add(field string, err error) <span class="cov0" title="0">{
        *fe = append(*fe, FieldError{
                Field: field,
                Err:   err.Error(),
        })
}</span>

// ToError converts the field errors to an Error.
func (fe FieldErrors) ToError() *Error <span class="cov0" title="0">{
        return New(InvalidArgument, fe)
}</span>

// Error implements the error interface.
func (fe FieldErrors) Error() string <span class="cov0" title="0">{
        d, err := json.Marshal(fe)
        if err != nil </span><span class="cov0" title="0">{
                return err.Error()
        }</span>
        <span class="cov0" title="0">return string(d)</span>
}
</pre>
		
		<pre class="file" id="file81" style="display: none">package errs

import (
        "errors"
        "reflect"
        "strings"

        "github.com/go-playground/locales/en"
        ut "github.com/go-playground/universal-translator"
        "github.com/go-playground/validator/v10"
        en_translations "github.com/go-playground/validator/v10/translations/en"
)

// validate holds the settings and caches for validating request struct values.
var validate *validator.Validate

// translator is a cache of locale and translation information.
var translator ut.Translator

func init() <span class="cov0" title="0">{

        // Instantiate a validator.
        validate = validator.New(validator.WithRequiredStructEnabled())

        // Create a translator for english so the error messages are
        // more human-readable than technical.
        translator, _ = ut.New(en.New(), en.New()).GetTranslator("en")

        // Register the english error messages for use.
        en_translations.RegisterDefaultTranslations(validate, translator)

        // Use JSON tag names for errors instead of Go struct names.
        validate.RegisterTagNameFunc(func(fld reflect.StructField) string </span><span class="cov0" title="0">{
                name := strings.SplitN(fld.Tag.Get("json"), ",", 2)[0]
                if name == "-" </span><span class="cov0" title="0">{
                        return ""
                }</span>
                <span class="cov0" title="0">return name</span>
        })
}

// Check validates the provided model against it's declared tags.
func Check(val any) error <span class="cov0" title="0">{
        if err := validate.Struct(val); err != nil </span><span class="cov0" title="0">{
                verrors, ok := err.(validator.ValidationErrors)
                if !ok </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">var fields FieldErrors
                for _, verror := range verrors </span><span class="cov0" title="0">{
                        fields.Add(
                                verror.Field(),
                                errors.New(verror.Translate(translator)),
                        )
                }</span>

                <span class="cov0" title="0">return fields</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file82" style="display: none">// Package metrics constructs the metrics the application will track.
package metrics

import (
        "context"
        "expvar"
        "runtime"
)

// This holds the single instance of the metrics value needed for
// collecting metrics. The expvar package is already based on a singleton
// for the different metrics that are registered with the package so there
// isn't much choice here.
var m metrics

// metrics represents the set of metrics we gather. These fields are
// safe to be accessed concurrently thanks to expvar. No extra abstraction is required.
type metrics struct {
        goroutines *expvar.Int
        requests   *expvar.Int
        errors     *expvar.Int
        panics     *expvar.Int
}

// init constructs the metrics value that will be used to capture metrics.
// The metrics value is stored in a package level variable since everything
// inside of expvar is registered as a singleton. The use of once will make
// sure this initialization only happens once.
func init() <span class="cov0" title="0">{
        m = metrics{
                goroutines: expvar.NewInt("goroutines"),
                requests:   expvar.NewInt("requests"),
                errors:     expvar.NewInt("errors"),
                panics:     expvar.NewInt("panics"),
        }
}</span>

type ctxKey int

const key ctxKey = 1

// Set sets the metrics data into the context.
func Set(ctx context.Context) context.Context <span class="cov0" title="0">{
        return context.WithValue(ctx, key, &amp;m)
}</span>

// AddGoroutines refreshes the goroutine metric.
func AddGoroutines(ctx context.Context) int64 <span class="cov0" title="0">{
        if v, ok := ctx.Value(key).(*metrics); ok </span><span class="cov0" title="0">{
                g := int64(runtime.NumGoroutine())
                v.goroutines.Set(g)
                return g
        }</span>

        <span class="cov0" title="0">return 0</span>
}

// AddRequests increments the request metric by 1.
func AddRequests(ctx context.Context) int64 <span class="cov0" title="0">{
        v, ok := ctx.Value(key).(*metrics)
        if ok </span><span class="cov0" title="0">{
                v.requests.Add(1)
                return v.requests.Value()
        }</span>

        <span class="cov0" title="0">return 0</span>
}

// AddErrors increments the errors metric by 1.
func AddErrors(ctx context.Context) int64 <span class="cov0" title="0">{
        if v, ok := ctx.Value(key).(*metrics); ok </span><span class="cov0" title="0">{
                v.errors.Add(1)
                return v.errors.Value()
        }</span>

        <span class="cov0" title="0">return 0</span>
}

// AddPanics increments the panics metric by 1.
func AddPanics(ctx context.Context) int64 <span class="cov0" title="0">{
        if v, ok := ctx.Value(key).(*metrics); ok </span><span class="cov0" title="0">{
                v.panics.Add(1)
                return v.panics.Value()
        }</span>

        <span class="cov0" title="0">return 0</span>
}
</pre>
		
		<pre class="file" id="file83" style="display: none">package mid

import (
        "context"
        "encoding/base64"
        "net/http"
        "strings"
        "time"

        "github.com/FITHSCS/backend/app/sdk/auth"
        "github.com/FITHSCS/backend/app/sdk/authclient"
        "github.com/FITHSCS/backend/app/sdk/errs"
        "github.com/FITHSCS/backend/business/domain/userbus"
        "github.com/FITHSCS/backend/business/types/facilitytype"
        "github.com/FITHSCS/backend/business/types/role"
        "github.com/FITHSCS/backend/foundation/web"
        "github.com/golang-jwt/jwt/v4"
        "github.com/google/uuid"
)

// Authenticate is a middleware function that integrates with an authentication client
// to validate user credentials and attach user data to the request context.
func Authenticate(client *authclient.Client) web.MidFunc <span class="cov0" title="0">{
        m := func(next web.HandlerFunc) web.HandlerFunc </span><span class="cov0" title="0">{
                h := func(ctx context.Context, r *http.Request) web.Encoder </span><span class="cov0" title="0">{
                        ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
                        defer cancel()

                        resp, err := client.Authenticate(ctx, r.Header.Get("authorization"))
                        if err != nil </span><span class="cov0" title="0">{
                                return errs.New(errs.Unauthenticated, err)
                        }</span>

                        <span class="cov0" title="0">ctx = setUserID(ctx, resp.UserID)
                        ctx = setClaims(ctx, resp.Claims)

                        return next(ctx, r)</span>
                }

                <span class="cov0" title="0">return h</span>
        }

        <span class="cov0" title="0">return m</span>
}

// Bearer processes JWT authentication logic.
func Bearer(ath *auth.Auth) web.MidFunc <span class="cov0" title="0">{
        m := func(next web.HandlerFunc) web.HandlerFunc </span><span class="cov0" title="0">{
                h := func(ctx context.Context, r *http.Request) web.Encoder </span><span class="cov0" title="0">{
                        claims, err := ath.Authenticate(ctx, r.Header.Get("authorization"))
                        if err != nil </span><span class="cov0" title="0">{
                                return errs.New(errs.Unauthenticated, err)
                        }</span>

                        <span class="cov0" title="0">if claims.Subject == "" </span><span class="cov0" title="0">{
                                return errs.Newf(errs.Unauthenticated, "authorize: you are not authorized for that action, no claims")
                        }</span>

                        <span class="cov0" title="0">subjectID, err := uuid.Parse(claims.Subject)
                        if err != nil </span><span class="cov0" title="0">{
                                return errs.Newf(errs.Unauthenticated, "parsing subject: %s", err)
                        }</span>

                        <span class="cov0" title="0">ctx = setUserID(ctx, subjectID)
                        ctx = setClaims(ctx, claims)

                        return next(ctx, r)</span>
                }

                <span class="cov0" title="0">return h</span>
        }

        <span class="cov0" title="0">return m</span>
}

// Basic processes basic authentication logic.
func Basic(ath *auth.Auth, userBus userbus.ExtBusiness) web.MidFunc <span class="cov0" title="0">{
        m := func(next web.HandlerFunc) web.HandlerFunc </span><span class="cov0" title="0">{
                h := func(ctx context.Context, r *http.Request) web.Encoder </span><span class="cov0" title="0">{
                        phnum, pass, ok := parseBasicAuth(r.Header.Get("authorization"))
                        if !ok </span><span class="cov0" title="0">{
                                return errs.Newf(errs.Unauthenticated, "invalid Basic auth")
                        }</span>

                        <span class="cov0" title="0">phone, err := facilitytype.ParsePhoneNumber(phnum)
                        if err != nil </span><span class="cov0" title="0">{
                                return errs.New(errs.Unauthenticated, err)
                        }</span>

                        <span class="cov0" title="0">usr, err := userBus.Authenticate(ctx, phone, pass)
                        if err != nil </span><span class="cov0" title="0">{
                                return errs.New(errs.Unauthenticated, err)
                        }</span>

                        <span class="cov0" title="0">claims := auth.Claims{
                                RegisteredClaims: jwt.RegisteredClaims{
                                        Subject:   usr.ID.String(),
                                        Issuer:    ath.Issuer(),
                                        ExpiresAt: jwt.NewNumericDate(time.Now().UTC().Add(8760 * time.Hour)),
                                        IssuedAt:  jwt.NewNumericDate(time.Now().UTC()),
                                },
                                Roles: role.ParseToString(usr.Roles),
                        }

                        subjectID, err := uuid.Parse(claims.Subject)
                        if err != nil </span><span class="cov0" title="0">{
                                return errs.Newf(errs.Unauthenticated, "parsing subject: %s", err)
                        }</span>

                        <span class="cov0" title="0">ctx = setUserID(ctx, subjectID)
                        ctx = setClaims(ctx, claims)

                        return next(ctx, r)</span>
                }

                <span class="cov0" title="0">return h</span>
        }

        <span class="cov0" title="0">return m</span>
}

func parseBasicAuth(auth string) (string, string, bool) <span class="cov0" title="0">{
        parts := strings.Split(auth, " ")
        if len(parts) != 2 || parts[0] != "Basic" </span><span class="cov0" title="0">{
                return "", "", false
        }</span>

        <span class="cov0" title="0">c, err := base64.StdEncoding.DecodeString(parts[1])
        if err != nil </span><span class="cov0" title="0">{
                return "", "", false
        }</span>

        <span class="cov0" title="0">username, password, ok := strings.Cut(string(c), ":")
        if !ok </span><span class="cov0" title="0">{
                return "", "", false
        }</span>

        <span class="cov0" title="0">return username, password, true</span>
}
</pre>
		
		<pre class="file" id="file84" style="display: none">package mid

import (
        "context"
        "errors"
        "net/http"
        "time"

        "github.com/FITHSCS/backend/app/sdk/authclient"
        "github.com/FITHSCS/backend/app/sdk/errs"
        "github.com/FITHSCS/backend/business/domain/userbus"
        "github.com/FITHSCS/backend/foundation/web"
        "github.com/google/uuid"
)

// ErrInvalidID represents a condition where the id is not a uuid.
var ErrInvalidID = errors.New("ID is not in its proper form")

// Authorize validates authorization via the auth service.
func Authorize(client *authclient.Client, rule string) web.MidFunc <span class="cov0" title="0">{
        m := func(next web.HandlerFunc) web.HandlerFunc </span><span class="cov0" title="0">{
                h := func(ctx context.Context, r *http.Request) web.Encoder </span><span class="cov0" title="0">{
                        userID, err := GetUserID(ctx)
                        if err != nil </span><span class="cov0" title="0">{
                                return errs.New(errs.Unauthenticated, err)
                        }</span>

                        <span class="cov0" title="0">auth := authclient.Authorize{
                                Claims: GetClaims(ctx),
                                UserID: userID,
                                Rule:   rule,
                        }

                        ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
                        defer cancel()

                        if err := client.Authorize(ctx, auth); err != nil </span><span class="cov0" title="0">{
                                return errs.New(errs.Unauthenticated, err)
                        }</span>

                        <span class="cov0" title="0">return next(ctx, r)</span>
                }

                <span class="cov0" title="0">return h</span>
        }

        <span class="cov0" title="0">return m</span>
}

// AuthorizeUser executes the specified role and extracts the specified
// user from the DB if a user id is specified in the call. Depending on the rule
// specified, the userid from the claims may be compared with the specified
// user id.
func AuthorizeUser(client *authclient.Client, userBus userbus.ExtBusiness, rule string) web.MidFunc <span class="cov0" title="0">{
        m := func(next web.HandlerFunc) web.HandlerFunc </span><span class="cov0" title="0">{
                h := func(ctx context.Context, r *http.Request) web.Encoder </span><span class="cov0" title="0">{
                        id := web.Param(r, "user_id")

                        var userID uuid.UUID

                        if id != "" </span><span class="cov0" title="0">{
                                var err error
                                userID, err = uuid.Parse(id)
                                if err != nil </span><span class="cov0" title="0">{
                                        return errs.New(errs.Unauthenticated, ErrInvalidID)
                                }</span>

                                <span class="cov0" title="0">usr, err := userBus.QueryByID(ctx, userID)
                                if err != nil </span><span class="cov0" title="0">{
                                        switch </span>{
                                        case errors.Is(err, userbus.ErrNotFound):<span class="cov0" title="0">
                                                return errs.New(errs.Unauthenticated, err)</span>
                                        default:<span class="cov0" title="0">
                                                return errs.Newf(errs.Unauthenticated, "querybyid: userID[%s]: %s", userID, err)</span>
                                        }
                                }

                                <span class="cov0" title="0">ctx = setUser(ctx, usr)</span>
                        }

                        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
                        defer cancel()

                        auth := authclient.Authorize{
                                Claims: GetClaims(ctx),
                                UserID: userID,
                                Rule:   rule,
                        }

                        if err := client.Authorize(ctx, auth); err != nil </span><span class="cov0" title="0">{
                                return errs.New(errs.Unauthenticated, err)
                        }</span>

                        <span class="cov0" title="0">return next(ctx, r)</span>
                }

                <span class="cov0" title="0">return h</span>
        }

        <span class="cov0" title="0">return m</span>
}
</pre>
		
		<pre class="file" id="file85" style="display: none">package mid

import (
        "context"
        "errors"
        "net/http"
        "path"

        "github.com/FITHSCS/backend/app/sdk/errs"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/FITHSCS/backend/foundation/web"
)

// Errors handles errors coming out of the call chain.
func Errors(log *logger.Logger) web.MidFunc <span class="cov0" title="0">{
        m := func(next web.HandlerFunc) web.HandlerFunc </span><span class="cov0" title="0">{
                h := func(ctx context.Context, r *http.Request) web.Encoder </span><span class="cov0" title="0">{
                        resp := next(ctx, r)
                        err := isError(resp)
                        if err == nil </span><span class="cov0" title="0">{
                                return resp
                        }</span>

                        <span class="cov0" title="0">var appErr *errs.Error
                        if !errors.As(err, &amp;appErr) </span><span class="cov0" title="0">{
                                appErr = errs.Newf(errs.Internal, "Internal Server Error")
                        }</span>

                        <span class="cov0" title="0">log.Error(ctx, "handled error during request",
                                "err", err,
                                "source_err_file", path.Base(appErr.FileName),
                                "source_err_func", path.Base(appErr.FuncName))

                        if appErr.Code == errs.InternalOnlyLog </span><span class="cov0" title="0">{
                                appErr = errs.Newf(errs.Internal, "Internal Server Error")
                        }</span>

                        // Send the error to the transport package so the error can be
                        // used as the response.

                        <span class="cov0" title="0">return appErr</span>
                }

                <span class="cov0" title="0">return h</span>
        }

        <span class="cov0" title="0">return m</span>
}
</pre>
		
		<pre class="file" id="file86" style="display: none">package mid

import (
        "context"
        "errors"
        "fmt"
        "net/http"
        "time"

        "github.com/FITHSCS/backend/app/sdk/errs"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/FITHSCS/backend/foundation/web"
)

// Logger writes information about the request to the logs.
func Logger(log *logger.Logger) web.MidFunc <span class="cov0" title="0">{
        m := func(next web.HandlerFunc) web.HandlerFunc </span><span class="cov0" title="0">{
                h := func(ctx context.Context, r *http.Request) web.Encoder </span><span class="cov0" title="0">{
                        now := time.Now()

                        path := r.URL.Path
                        if r.URL.RawQuery != "" </span><span class="cov0" title="0">{
                                path = fmt.Sprintf("%s?%s", path, r.URL.RawQuery)
                        }</span>

                        <span class="cov0" title="0">log.Info(ctx, "request started", "method", r.Method, "path", path, "remoteaddr", r.RemoteAddr)

                        resp := next(ctx, r)
                        err := isError(resp)

                        var statusCode = errs.OK
                        if err != nil </span><span class="cov0" title="0">{
                                statusCode = errs.Internal

                                var v *errs.Error
                                if errors.As(err, &amp;v) </span><span class="cov0" title="0">{
                                        statusCode = v.Code
                                }</span>
                        }

                        <span class="cov0" title="0">log.Info(ctx, "request completed", "method", r.Method, "path", path, "remoteaddr", r.RemoteAddr,
                                "statuscode", statusCode, "since", time.Since(now).String())

                        return resp</span>
                }

                <span class="cov0" title="0">return h</span>
        }

        <span class="cov0" title="0">return m</span>
}
</pre>
		
		<pre class="file" id="file87" style="display: none">package mid

import (
        "context"
        "net/http"

        "github.com/FITHSCS/backend/app/sdk/metrics"
        "github.com/FITHSCS/backend/foundation/web"
)

// Metrics updates program counters.
func Metrics() web.MidFunc <span class="cov0" title="0">{
        m := func(next web.HandlerFunc) web.HandlerFunc </span><span class="cov0" title="0">{
                h := func(ctx context.Context, r *http.Request) web.Encoder </span><span class="cov0" title="0">{
                        ctx = metrics.Set(ctx)

                        resp := next(ctx, r)

                        n := metrics.AddRequests(ctx)

                        if n%1000 == 0 </span><span class="cov0" title="0">{
                                metrics.AddGoroutines(ctx)
                        }</span>

                        <span class="cov0" title="0">if isError(resp) != nil </span><span class="cov0" title="0">{
                                metrics.AddErrors(ctx)
                        }</span>

                        <span class="cov0" title="0">return resp</span>
                }

                <span class="cov0" title="0">return h</span>
        }

        <span class="cov0" title="0">return m</span>
}
</pre>
		
		<pre class="file" id="file88" style="display: none">// Package mid provides app level middleware support.
package mid

import (
        "context"
        "errors"

        "github.com/FITHSCS/backend/app/sdk/auth"
        "github.com/FITHSCS/backend/business/domain/userbus"
        "github.com/FITHSCS/backend/foundation/web"
        "github.com/google/uuid"
)

// isError tests if the Encoder has an error inside of it.
func isError(e web.Encoder) error <span class="cov0" title="0">{
        err, isError := e.(error)
        if isError </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// =============================================================================

type ctxKey int

const (
        claimKey ctxKey = iota + 1
        userIDKey
        userKey
)

func setClaims(ctx context.Context, claims auth.Claims) context.Context <span class="cov0" title="0">{
        return context.WithValue(ctx, claimKey, claims)
}</span>

// GetClaims returns the claims from the context.
func GetClaims(ctx context.Context) auth.Claims <span class="cov0" title="0">{
        v, ok := ctx.Value(claimKey).(auth.Claims)
        if !ok </span><span class="cov0" title="0">{
                return auth.Claims{}
        }</span>
        <span class="cov0" title="0">return v</span>
}

// GetSubjectID returns the subject id from the claims.
func GetSubjectID(ctx context.Context) uuid.UUID <span class="cov0" title="0">{
        v := GetClaims(ctx)

        subjectID, err := uuid.Parse(v.Subject)
        if err != nil </span><span class="cov0" title="0">{
                return uuid.UUID{}
        }</span>

        <span class="cov0" title="0">return subjectID</span>
}

func setUserID(ctx context.Context, userID uuid.UUID) context.Context <span class="cov0" title="0">{
        return context.WithValue(ctx, userIDKey, userID)
}</span>

// GetUserID returns the user id from the context.
func GetUserID(ctx context.Context) (uuid.UUID, error) <span class="cov0" title="0">{
        v, ok := ctx.Value(userIDKey).(uuid.UUID)
        if !ok </span><span class="cov0" title="0">{
                return uuid.UUID{}, errors.New("user id not found in context")
        }</span>

        <span class="cov0" title="0">return v, nil</span>
}

func setUser(ctx context.Context, usr userbus.User) context.Context <span class="cov0" title="0">{
        return context.WithValue(ctx, userKey, usr)
}</span>

// GetUser returns the user from the context.
func GetUser(ctx context.Context) (userbus.User, error) <span class="cov0" title="0">{
        v, ok := ctx.Value(userKey).(userbus.User)
        if !ok </span><span class="cov0" title="0">{
                return userbus.User{}, errors.New("user not found in context")
        }</span>

        <span class="cov0" title="0">return v, nil</span>
}
</pre>
		
		<pre class="file" id="file89" style="display: none">package mid

import (
        "context"
        "net/http"

        "github.com/FITHSCS/backend/foundation/otel"
        "github.com/FITHSCS/backend/foundation/web"
        "go.opentelemetry.io/otel/trace"
)

// Otel starts the otel tracing and stores the trace id in the context.
func Otel(tracer trace.Tracer) web.MidFunc <span class="cov0" title="0">{
        m := func(next web.HandlerFunc) web.HandlerFunc </span><span class="cov0" title="0">{
                h := func(ctx context.Context, r *http.Request) web.Encoder </span><span class="cov0" title="0">{
                        ctx = otel.InjectTracing(ctx, tracer)

                        return next(ctx, r)
                }</span>

                <span class="cov0" title="0">return h</span>
        }

        <span class="cov0" title="0">return m</span>
}
</pre>
		
		<pre class="file" id="file90" style="display: none">package mid

import (
        "context"
        "net/http"
        "runtime/debug"

        "github.com/FITHSCS/backend/app/sdk/errs"
        "github.com/FITHSCS/backend/foundation/web"
)

// Panics recovers from panics and converts the panic to an error so it is
// reported in Metrics and handled in Errors.
func Panics() web.MidFunc <span class="cov0" title="0">{
        m := func(next web.HandlerFunc) web.HandlerFunc </span><span class="cov0" title="0">{
                h := func(ctx context.Context, r *http.Request) (resp web.Encoder) </span><span class="cov0" title="0">{

                        // Defer a function to recover from a panic and set the err return
                        // variable after the fact.
                        defer func() </span><span class="cov0" title="0">{
                                if rec := recover(); rec != nil </span><span class="cov0" title="0">{
                                        trace := debug.Stack()
                                        resp = errs.Newf(errs.InternalOnlyLog, "PANIC [%v] TRACE[%s]", rec, string(trace))

                                }</span>
                        }()

                        <span class="cov0" title="0">return next(ctx, r)</span>
                }

                <span class="cov0" title="0">return h</span>
        }

        <span class="cov0" title="0">return m</span>
}
</pre>
		
		<pre class="file" id="file91" style="display: none">// Package mux provides support to bind domain level routes
// to the application mux.
package mux

import (
        "net/http"

        "github.com/FITHSCS/backend/app/sdk/auth"
        "github.com/FITHSCS/backend/app/sdk/authclient"
        "github.com/FITHSCS/backend/app/sdk/mid"
        "github.com/FITHSCS/backend/business/domain/auditbus"
        "github.com/FITHSCS/backend/business/domain/delexceptionbus"
        "github.com/FITHSCS/backend/business/domain/facilitybus"
        "github.com/FITHSCS/backend/business/domain/gpstrackingbus"
        "github.com/FITHSCS/backend/business/domain/imagebus"
        "github.com/FITHSCS/backend/business/domain/manifestbus"
        "github.com/FITHSCS/backend/business/domain/pickupbatchbus"
        "github.com/FITHSCS/backend/business/domain/routebus"
        "github.com/FITHSCS/backend/business/domain/signaturebus"
        "github.com/FITHSCS/backend/business/domain/syncbatchbus"
        "github.com/FITHSCS/backend/business/domain/userbus"
        "github.com/FITHSCS/backend/business/domain/vehiclebus"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/FITHSCS/backend/foundation/web"
        "github.com/jmoiron/sqlx"
        "go.opentelemetry.io/otel/trace"
)

// Options represent optional parameters.
type Options struct {
        corsOrigin []string
}

// WithCORS provides configuration options for CORS.
func WithCORS(origins []string) func(opts *Options) <span class="cov0" title="0">{
        return func(opts *Options) </span><span class="cov0" title="0">{
                opts.corsOrigin = origins
        }</span>
}

// AuthClientConfig contains auth client service specific config.
type AuthClientConfig struct {
        AuthClient *authclient.Client
}

type KafkaConfig struct {
        Brokers []string
        Topic   string
}

// AuthConfig contains auth service specific config.
type AuthConfig struct {
        Auth *auth.Auth
}

type BusConfig struct {
        AuditBus             *auditbus.Business
        UserBus              userbus.ExtBusiness
        FacilityBus          *facilitybus.Business
        VehicleBus           *vehiclebus.Business
        GPSTrackingBus       *gpstrackingbus.Business
        PickupBatchBus       *pickupbatchbus.Business
        ManifestBus          *manifestbus.Business
        SignatureBus         *signaturebus.Business
        DeliveryExceptionBus *delexceptionbus.Business
        ImageBus             *imagebus.Business
        RouteBus             *routebus.Business
        SyncBatchBus         *syncbatchbus.Business
}

// Config contains all the mandatory systems required by handlers.
type Config struct {
        Build            string
        Log              *logger.Logger
        DB               *sqlx.DB
        Tracer           trace.Tracer
        BusConfig        BusConfig
        AuthClientConfig AuthClientConfig
        AuthConfig       AuthConfig
        KafkaConfig      KafkaConfig
}

// RouteAdder defines behavior that sets the routes to bind for an instance
// of the service.
type RouteAdder interface {
        Add(app *web.App, cfg Config)
}

// WebAPI constructs a http.Handler with all application routes bound.
func WebAPI(cfg Config, routeAdder RouteAdder, options ...func(opts *Options)) http.Handler <span class="cov0" title="0">{

        app := web.NewApp(
                cfg.Log.Info,
                cfg.Tracer,
                mid.Otel(cfg.Tracer),
                mid.Logger(cfg.Log),
                mid.Errors(cfg.Log),
                mid.Metrics(),
                mid.Panics(),
        )

        var opts Options
        for _, option := range options </span><span class="cov0" title="0">{
                option(&amp;opts)
        }</span>

        <span class="cov0" title="0">if len(opts.corsOrigin) &gt; 0 </span><span class="cov0" title="0">{
                app.EnableCORS(opts.corsOrigin)
        }</span>

        <span class="cov0" title="0">routeAdder.Add(app, cfg)

        return app</span>
}
</pre>
		
		<pre class="file" id="file92" style="display: none">// Package query provides support for query paging.
package query

import (
        "encoding/json"

        "github.com/FITHSCS/backend/business/sdk/page"
)

// Result is the data model used when returning a query result.
type Result[T any] struct {
        Items       []T `json:"items"`
        Total       int `json:"total"`
        Page        int `json:"page"`
        RowsPerPage int `json:"rowsPerPage"`
}

// NewResult constructs a result value to return query results.
func NewResult[T any](items []T, total int, page page.Page) Result[T] <span class="cov0" title="0">{
        return Result[T]{
                Items:       items,
                Total:       total,
                Page:        page.Number(),
                RowsPerPage: page.RowsPerPage(),
        }
}</span>

// Encode implements the encoder interface.
func (r Result[T]) Encode() ([]byte, string, error) <span class="cov0" title="0">{
        data, err := json.Marshal(r)
        return data, "application/json", err
}</span>
</pre>
		
		<pre class="file" id="file93" style="display: none">// Package auditbus provides a business logic layer for handling audit events.
package auditbus

import (
        "context"
        "encoding/json"
        "fmt"
        "time"

        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/google/uuid"
)

// Storer interface declares the behavior this package needs to persist and
// retrieve data.
type Storer interface {
        Create(ctx context.Context, audit Audit) error
        Query(ctx context.Context, filter QueryFilter, orderBy order.By, page page.Page) ([]Audit, error)
        Count(ctx context.Context, filter QueryFilter) (int, error)
}

// Business manages the set of APIs for audit access.
type Business struct {
        log    *logger.Logger
        storer Storer
}

// NewBusiness constructs a audit business API for use.
func NewBusiness(log *logger.Logger, storer Storer) *Business <span class="cov1" title="1">{
        return &amp;Business{
                log:    log,
                storer: storer,
        }
}</span>

// Create adds a new audit record to the system.
func (b *Business) Create(ctx context.Context, na NewAudit) (Audit, error) <span class="cov10" title="2">{

        jsonData, err := json.Marshal(na.Data)
        if err != nil </span><span class="cov0" title="0">{
                return Audit{}, fmt.Errorf("marshal object: %w", err)
        }</span>

        <span class="cov10" title="2">audit := Audit{
                ID:        uuid.New(),
                ObjID:     na.ObjID,
                ObjDomain: na.ObjDomain,
                ObjName:   na.ObjName,
                ActorID:   na.ActorID,
                Action:    na.Action,
                Data:      jsonData,
                Message:   na.Message,
                Timestamp: time.Now(),
        }

        if err := b.storer.Create(ctx, audit); err != nil </span><span class="cov0" title="0">{
                return Audit{}, fmt.Errorf("create audit: %w", err)
        }</span>

        <span class="cov10" title="2">return audit, nil</span>
}

// Query retrieves a list of existing audit records.
func (b *Business) Query(ctx context.Context, filter QueryFilter, orderBy order.By, page page.Page) ([]Audit, error) <span class="cov1" title="1">{

        audits, err := b.storer.Query(ctx, filter, orderBy, page)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("query audits: %w", err)
        }</span>

        <span class="cov1" title="1">return audits, nil</span>
}

// Count returns the total number of users.
func (b *Business) Count(ctx context.Context, filter QueryFilter) (int, error) <span class="cov0" title="0">{
        return b.storer.Count(ctx, filter)
}</span>
</pre>
		
		<pre class="file" id="file94" style="display: none">// Package auditdb contains audit related CRUD functionality.
package auditdb

import (
        "bytes"
        "context"
        "fmt"

        "github.com/FITHSCS/backend/business/domain/auditbus"
        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/business/sdk/sqldb"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/jmoiron/sqlx"
)

// Store manages the set of APIs for audit database access.
type Store struct {
        log *logger.Logger
        db  sqlx.ExtContext
}

// NewStore constructs the API for data access.
func NewStore(log *logger.Logger, db *sqlx.DB) *Store <span class="cov0" title="0">{
        return &amp;Store{
                log: log,
                db:  db,
        }
}</span>

// Create inserts a new audit record into the database.
func (s *Store) Create(ctx context.Context, a auditbus.Audit) error <span class="cov0" title="0">{
        const q = `
        INSERT INTO audit
                (id, obj_id, obj_domain, obj_name, actor_id, action, data, message, timestamp)
        VALUES
                (:id, :obj_id, :obj_domain, :obj_name, :actor_id, :action, :data, :message, :timestamp)`

        dbAudit, err := toDBAudit(a)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := sqldb.NamedExecContext(ctx, s.log, s.db, q, dbAudit); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("namedexeccontext: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *Store) Query(ctx context.Context, filter auditbus.QueryFilter, orderBy order.By, page page.Page) ([]auditbus.Audit, error) <span class="cov0" title="0">{
        data := map[string]any{
                "offset":        (page.Number() - 1) * page.RowsPerPage(),
                "rows_per_page": page.RowsPerPage(),
        }

        const q = `
        SELECT
                id, obj_id, obj_domain, obj_name, actor_id, action, data, message, timestamp
        FROM
                audit
        `

        buf := bytes.NewBufferString(q)
        applyFilter(filter, data, buf)

        orderByClause, err := orderByClause(orderBy)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">buf.WriteString(orderByClause)
        buf.WriteString(" OFFSET :offset ROWS FETCH NEXT :rows_per_page ROWS ONLY")

        var dbAudits []audit
        if err := sqldb.NamedQuerySlice(ctx, s.log, s.db, buf.String(), data, &amp;dbAudits); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("namedqueryslice: %w", err)
        }</span>

        <span class="cov0" title="0">return toBusAudits(dbAudits)</span>
}

// Count returns the total number of users in the DB.
func (s *Store) Count(ctx context.Context, filter auditbus.QueryFilter) (int, error) <span class="cov0" title="0">{
        data := map[string]any{}

        const q = `
        SELECT
                count(1)
        FROM
                audit`

        buf := bytes.NewBufferString(q)
        applyFilter(filter, data, buf)

        var count struct {
                Count int `db:"count"`
        }
        if err := sqldb.NamedQueryStruct(ctx, s.log, s.db, buf.String(), data, &amp;count); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("db: %w", err)
        }</span>

        <span class="cov0" title="0">return count.Count, nil</span>
}
</pre>
		
		<pre class="file" id="file95" style="display: none">package auditdb

import (
        "bytes"
        "fmt"
        "strings"

        "github.com/FITHSCS/backend/business/domain/auditbus"
)

func applyFilter(filter auditbus.QueryFilter, data map[string]any, buf *bytes.Buffer) <span class="cov0" title="0">{
        var wc []string

        if filter.ObjID != nil </span><span class="cov0" title="0">{
                data["obj_id"] = filter.ObjID
                wc = append(wc, "obj_id = :obj_id")
        }</span>

        <span class="cov0" title="0">if filter.ObjDomain != nil </span><span class="cov0" title="0">{
                data["obj_domain"] = filter.ObjDomain.String()
                wc = append(wc, "obj_domain = :obj_domain")
        }</span>

        <span class="cov0" title="0">if filter.ObjName != nil </span><span class="cov0" title="0">{
                data["obj_name"] = fmt.Sprintf("%%%s%%", filter.ObjName.String())
                wc = append(wc, "obj_name LIKE :obj_name")
        }</span>

        <span class="cov0" title="0">if filter.ActorID != nil </span><span class="cov0" title="0">{
                data["actor_id"] = filter.ActorID
                wc = append(wc, "actor_id = :actor_id")
        }</span>

        <span class="cov0" title="0">if filter.Action != nil </span><span class="cov0" title="0">{
                data["action"] = filter.Action
                wc = append(wc, "action = :action")
        }</span>

        <span class="cov0" title="0">if filter.Since != nil </span><span class="cov0" title="0">{
                data["since"] = filter.Since
                wc = append(wc, "timestamp &gt;= :since")
        }</span>

        <span class="cov0" title="0">if filter.Until != nil </span><span class="cov0" title="0">{
                data["until"] = filter.Until
                wc = append(wc, "timestamp &lt;= :until")
        }</span>

        <span class="cov0" title="0">if len(wc) &gt; 0 </span><span class="cov0" title="0">{
                buf.WriteString(" WHERE ")
                buf.WriteString(strings.Join(wc, " AND "))
        }</span>
}
</pre>
		
		<pre class="file" id="file96" style="display: none">package auditdb

import (
        "encoding/json"
        "fmt"
        "time"

        "github.com/FITHSCS/backend/business/domain/auditbus"
        "github.com/FITHSCS/backend/business/types/domain"
        "github.com/FITHSCS/backend/business/types/name"
        "github.com/google/uuid"
        "github.com/jmoiron/sqlx/types"
)

type audit struct {
        ID        uuid.UUID          `db:"id"`
        ObjID     uuid.UUID          `db:"obj_id"`
        ObjDomain string             `db:"obj_domain"`
        ObjName   string             `db:"obj_name"`
        ActorID   uuid.UUID          `db:"actor_id"`
        Action    string             `db:"action"`
        Data      types.NullJSONText `db:"data"`
        Message   string             `db:"message"`
        Timestamp time.Time          `db:"timestamp"`
}

func toDBAudit(bus auditbus.Audit) (audit, error) <span class="cov0" title="0">{
        db := audit{
                ID:        bus.ID,
                ObjID:     bus.ObjID,
                ObjDomain: bus.ObjDomain.String(),
                ObjName:   bus.ObjName.String(),
                ActorID:   bus.ActorID,
                Action:    bus.Action,
                Data:      types.NullJSONText{JSONText: []byte(bus.Data), Valid: true},
                Message:   bus.Message,
                Timestamp: bus.Timestamp.UTC(),
        }

        return db, nil
}</span>

func toBusAudit(db audit) (auditbus.Audit, error) <span class="cov0" title="0">{
        domain, err := domain.Parse(db.ObjDomain)
        if err != nil </span><span class="cov0" title="0">{
                return auditbus.Audit{}, fmt.Errorf("parse domain: %w", err)
        }</span>

        <span class="cov0" title="0">name, err := name.Parse(db.ObjName)
        if err != nil </span><span class="cov0" title="0">{
                return auditbus.Audit{}, fmt.Errorf("parse name: %w", err)
        }</span>

        <span class="cov0" title="0">bus := auditbus.Audit{
                ID:        db.ID,
                ObjID:     db.ObjID,
                ObjDomain: domain,
                ObjName:   name,
                ActorID:   db.ActorID,
                Action:    db.Action,
                Data:      json.RawMessage(db.Data.JSONText),
                Message:   db.Message,
                Timestamp: db.Timestamp.Local(),
        }

        return bus, nil</span>
}

func toBusAudits(dbs []audit) ([]auditbus.Audit, error) <span class="cov0" title="0">{
        audits := make([]auditbus.Audit, len(dbs))

        for i, db := range dbs </span><span class="cov0" title="0">{
                a, err := toBusAudit(db)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">audits[i] = a</span>
        }

        <span class="cov0" title="0">return audits, nil</span>
}
</pre>
		
		<pre class="file" id="file97" style="display: none">package auditdb

import (
        "fmt"

        "github.com/FITHSCS/backend/business/domain/auditbus"
        "github.com/FITHSCS/backend/business/sdk/order"
)

var orderByFields = map[string]string{
        auditbus.OrderByObjID:     "obj_id",
        auditbus.OrderByObjDomain: "obj_domain",
        auditbus.OrderByObjName:   "obj_name",
        auditbus.OrderByActorID:   "actor_id",
        auditbus.OrderByAction:    "action",
}

func orderByClause(orderBy order.By) (string, error) <span class="cov0" title="0">{

        by, exists := orderByFields[orderBy.Field]
        if !exists </span><span class="cov0" title="0">{
                return "", fmt.Errorf("field %q does not exist", orderBy.Field)
        }</span>

        <span class="cov0" title="0">return " ORDER BY " + by + " " + orderBy.Direction, nil</span>
}
</pre>
		
		<pre class="file" id="file98" style="display: none">package auditbus

import (
        "context"
        "fmt"
        "math/rand"

        "github.com/FITHSCS/backend/business/types/domain"
        "github.com/FITHSCS/backend/business/types/name"
        "github.com/google/uuid"
)

// TestNewAudits is a helper method for testing.
func TestNewAudits(n int, actorID uuid.UUID, objDomain domain.Domain, action string) []NewAudit <span class="cov1" title="1">{
        newAudits := make([]NewAudit, n)

        idx := rand.Intn(10000)
        for i := range n </span><span class="cov10" title="2">{
                idx++

                na := NewAudit{
                        ObjID:     uuid.New(),
                        ObjDomain: objDomain,
                        ObjName:   name.MustParse(fmt.Sprintf("ObjName%d", idx)),
                        ActorID:   actorID,
                        Action:    action,
                        Data:      struct{ Name string }{Name: fmt.Sprintf("Name%d", idx)},
                        Message:   fmt.Sprintf("Message%d", idx),
                }

                newAudits[i] = na
        }</span>

        <span class="cov1" title="1">return newAudits</span>
}

// TestSeedAudits is a helper method for testing.
func TestSeedAudits(ctx context.Context, n int, actorID uuid.UUID, objDomain domain.Domain, action string, api *Business) ([]Audit, error) <span class="cov1" title="1">{
        newAudits := TestNewAudits(n, actorID, objDomain, action)

        audits := make([]Audit, len(newAudits))
        for i, na := range newAudits </span><span class="cov10" title="2">{
                adt, err := api.Create(ctx, na)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("seeding audit: idx: %d : %w", i, err)
                }</span>

                <span class="cov10" title="2">audits[i] = adt</span>
        }

        <span class="cov1" title="1">return audits, nil</span>
}
</pre>
		
		<pre class="file" id="file99" style="display: none">// Package delexceptionbus provides business access to facilities domain.
package delexceptionbus

import (
        "context"
        "errors"
        "fmt"
        "time"

        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/google/uuid"
)

var (
        ErrNotFound              = errors.New("exception not found")
        ErrAuthenticationFailure = errors.New("authentication failed")
)

type Storer interface {
        Create(ctx context.Context, delexception DeliveryException) error
        Update(ctx context.Context, delexception DeliveryException) error
        SoftDelete(ctx context.Context, delexceptionID uuid.UUID) error
        HardDelete(ctx context.Context, delexceptionID uuid.UUID) error
        Query(ctx context.Context, filter QueryFilter, orderby order.By, page page.Page) ([]DeliveryException, error)
        Count(ctx context.Context, filter QueryFilter) (int, error)
        QueryByID(ctx context.Context, facilityID uuid.UUID) (DeliveryException, error)
}

type Business struct {
        log    *logger.Logger
        storer Storer
}

func NewBusiness(log *logger.Logger, storer Storer) *Business <span class="cov1" title="1">{
        return &amp;Business{
                log:    log,
                storer: storer,
        }
}</span>

func (b *Business) Create(ctx context.Context, nde NewDeliveryException) (DeliveryException, error) <span class="cov10" title="6">{
        now := time.Now().Truncate(time.Microsecond)

        facility := DeliveryException{
                ExceptionID:      uuid.New(),
                ManifestID:       nde.ManifestID,
                DeliveryPersonID: nde.DeliveryPersonID,
                Severity:         nde.Severity,
                ExceptionType:    nde.ExceptionType,
                Description:      nde.Description,
                CapturedAt:       nde.CapturedAt,
                ResolutionStatus: nde.ResolutionStatus,
                ResolvedBy:       nde.ResolvedBy,
                IsDeleted:        false,
                IsSynced:         nde.IsSynced,
                TimeStamp:        nde.TimeStamp,
                CreatedAt:        now,
                UpdatedAt:        now,
        }
        if err := b.storer.Create(ctx, facility); err != nil </span><span class="cov0" title="0">{
                return DeliveryException{}, fmt.Errorf("create: %w", err)
        }</span>
        <span class="cov10" title="6">return facility, nil</span>
}

func (b *Business) Update(ctx context.Context, excID uuid.UUID, uptdelexc UpdateDeliveryException) (DeliveryException, error) <span class="cov4" title="2">{

        delexcDBRtrvd, err := b.storer.QueryByID(ctx, excID)
        if err != nil </span><span class="cov0" title="0">{
                return DeliveryException{}, fmt.Errorf("Update: %w", err)
        }</span>

        <span class="cov4" title="2">if uptdelexc.ManifestID != nil </span><span class="cov4" title="2">{
                delexcDBRtrvd.ManifestID = *uptdelexc.ManifestID
        }</span>

        <span class="cov4" title="2">if uptdelexc.DeliveryPersonID != nil </span><span class="cov4" title="2">{
                delexcDBRtrvd.DeliveryPersonID = *uptdelexc.DeliveryPersonID
        }</span>

        <span class="cov4" title="2">if uptdelexc.Severity != nil </span><span class="cov4" title="2">{
                delexcDBRtrvd.Severity = *uptdelexc.Severity
        }</span>

        <span class="cov4" title="2">if uptdelexc.ExceptionType != nil </span><span class="cov4" title="2">{
                delexcDBRtrvd.ExceptionType = *uptdelexc.ExceptionType
        }</span>

        <span class="cov4" title="2">if uptdelexc.Description != nil </span><span class="cov4" title="2">{
                delexcDBRtrvd.Description = *uptdelexc.Description
        }</span>

        <span class="cov4" title="2">if uptdelexc.ResolutionStatus != nil </span><span class="cov4" title="2">{
                delexcDBRtrvd.ResolutionStatus = *uptdelexc.ResolutionStatus
        }</span>

        <span class="cov4" title="2">if uptdelexc.ResolvedBy != nil </span><span class="cov4" title="2">{
                delexcDBRtrvd.ResolvedBy = *uptdelexc.ResolvedBy
        }</span>

        <span class="cov4" title="2">delexcDBRtrvd.UpdatedAt = time.Now().Truncate(time.Microsecond)

        if err := b.storer.Update(ctx, delexcDBRtrvd); err != nil </span><span class="cov0" title="0">{
                return DeliveryException{}, fmt.Errorf("update: %w", err)
        }</span>
        <span class="cov4" title="2">return delexcDBRtrvd, nil</span>
}

func (b *Business) QueryByID(ctx context.Context, excID uuid.UUID) (DeliveryException, error) <span class="cov1" title="1">{

        facility, err := b.storer.QueryByID(ctx, excID)
        if err != nil </span><span class="cov0" title="0">{
                return DeliveryException{}, fmt.Errorf("query: deliveryExceptionID[%s]: %w", excID, err)
        }</span>
        <span class="cov1" title="1">return facility, nil</span>
}
func (b *Business) Query(ctx context.Context, filter QueryFilter, orderBy order.By, page page.Page) ([]DeliveryException, error) <span class="cov1" title="1">{

        delExceptions, err := b.storer.Query(ctx, filter, orderBy, page)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Query: %w", err)
        }</span>
        <span class="cov1" title="1">return delExceptions, nil</span>
}

func (b *Business) Count(ctx context.Context, filter QueryFilter) (int, error) <span class="cov0" title="0">{
        return b.storer.Count(ctx, filter)
}</span>

func (b *Business) SoftDelete(ctx context.Context, delExceptionID uuid.UUID) error <span class="cov4" title="2">{

        facility, err := b.storer.QueryByID(ctx, delExceptionID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("softdeletequery: delExceptionID[%s]: %w", delExceptionID, err)
        }</span>

        <span class="cov4" title="2">if facility.IsDeleted </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: already deleted", delExceptionID)
        }</span>

        <span class="cov4" title="2">if err := b.storer.SoftDelete(ctx, delExceptionID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("delete: %w", err)
        }</span>
        <span class="cov4" title="2">return nil</span>

}

func (b *Business) HardDelete(ctx context.Context, delExceptionID uuid.UUID) error <span class="cov4" title="2">{

        if err := b.storer.HardDelete(ctx, delExceptionID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("delete: %w", err)
        }</span>
        <span class="cov4" title="2">return nil</span>

}
</pre>
		
		<pre class="file" id="file100" style="display: none">// Package delexceptiondb contains product related CRUD functionality.
package delexceptiondb

import (
        "bytes"
        "context"
        "errors"
        "fmt"

        "github.com/FITHSCS/backend/business/domain/delexceptionbus"
        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/business/sdk/sqldb"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/google/uuid"
        "github.com/jmoiron/sqlx"
)

type Store struct {
        log *logger.Logger
        db  sqlx.ExtContext
}

func NewStore(log *logger.Logger, db *sqlx.DB) *Store <span class="cov0" title="0">{
        return &amp;Store{
                log: log,
                db:  db,
        }
}</span>

func (s *Store) Create(ctx context.Context, f delexceptionbus.DeliveryException) error <span class="cov0" title="0">{
        const stmt = `
    INSERT INTO delivery_exception (
      exception_id,
          manifest_id,
          delivery_personnel_id,
          severity,
          exception_type,
          description,
      captured_at,
          resolution_status,
          resolved_by,
          is_deleted,
          is_synced,
          time_stamp,
      created_at,
          updated_at
    ) VALUES (
      :exception_id, 
          :manifest_id, 
          :delivery_personnel_id, 
          :severity,
          :exception_type, 
          :description,
      :captured_at, 
          :resolution_status, 
          :resolved_by,
      :is_deleted,
          :is_synced,
          :time_stamp,
      :created_at, 
          :updated_at
    )`

        return sqldb.NamedExecContext(ctx, s.log, s.db, stmt, toDBDeliveryException(f))
}</span>

func (s *Store) Update(ctx context.Context, f delexceptionbus.DeliveryException) error <span class="cov0" title="0">{
        const stmt = `
    UPDATE 
                delivery_exception
        SET 
                manifest_id                           = :manifest_id,
            delivery_personnel_id   = :delivery_personnel_id,
                severity                                = :severity,
            exception_type                 = :exception_type,
                description                         = :description, 
            resolution_status       = :resolution_status,
            resolved_by                         = :resolved_by,
               updated_at                      = :updated_at
    WHERE 
                exception_id = :exception_id`
        return sqldb.NamedExecContext(ctx, s.log, s.db, stmt, toDBDeliveryException(f))
}</span>

func (s *Store) Query(ctx context.Context, filter delexceptionbus.QueryFilter, orderBy order.By, page page.Page) ([]delexceptionbus.DeliveryException, error) <span class="cov0" title="0">{

        data := map[string]any{
                "offset":        (page.Number() - 1) * page.RowsPerPage(),
                "rows_per_page": page.RowsPerPage(),
        }

        const q = `
    SELECT
      exception_id,
          manifest_id,
          delivery_personnel_id,
          severity,
          exception_type,
          description,
      captured_at,
          resolution_status,
          resolved_by,
          is_deleted,
          is_synced,
          time_stamp,
      created_at,
          updated_at
    FROM 
                delivery_exception`

        buf := bytes.NewBufferString(q)
        s.applyFilter(filter, data, buf)

        orderByClause, err := orderByClause(orderBy)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">buf.WriteString(orderByClause)
        buf.WriteString(" OFFSET :offset ROWS FETCH NEXT :rows_per_page ROWS ONLY")

        var dbRecs []deliveryexceptiondb
        if err := sqldb.NamedQuerySlice(ctx, s.log, s.db, buf.String(), data, &amp;dbRecs); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("namedqueryslice: %w", err)
        }</span>
        <span class="cov0" title="0">fmt.Println(dbRecs)
        return toBusDeliveryExceptions(dbRecs)</span>
}

// Count returns the total number of users in the DB.
func (s *Store) Count(ctx context.Context, filter delexceptionbus.QueryFilter) (int, error) <span class="cov0" title="0">{
        data := map[string]any{}

        const q = `
        SELECT
                count(1)
        FROM
                delivery_exception`

        buf := bytes.NewBufferString(q)
        s.applyFilter(filter, data, buf)

        var count struct {
                Count int `db:"count"`
        }
        if err := sqldb.NamedQueryStruct(ctx, s.log, s.db, buf.String(), data, &amp;count); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("db: %w", err)
        }</span>

        <span class="cov0" title="0">return count.Count, nil</span>
}

func (s *Store) QueryByID(ctx context.Context, id uuid.UUID) (delexceptionbus.DeliveryException, error) <span class="cov0" title="0">{
        param := map[string]any{
                "exception_id": id.String(),
        }
        const stmt = `
    SELECT
                exception_id,
                manifest_id,
                delivery_personnel_id,
                severity,
                exception_type,
                description,
                captured_at,
                resolution_status,
                resolved_by,
                is_deleted,
                is_synced,
                time_stamp,
                created_at,
                updated_at
          FROM 
                delivery_exception
          WHERE 
                exception_id = :exception_id`

        var rec deliveryexceptiondb
        if err := sqldb.NamedQueryStruct(ctx, s.log, s.db, stmt, param, &amp;rec); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sqldb.ErrDBNotFound) </span><span class="cov0" title="0">{
                        return delexceptionbus.DeliveryException{}, delexceptionbus.ErrNotFound
                }</span>
                <span class="cov0" title="0">return delexceptionbus.DeliveryException{}, err</span>
        }
        <span class="cov0" title="0">return toBusDeliveryException(rec)</span>
}

func (s *Store) SoftDelete(ctx context.Context, DeliveryExceptionID uuid.UUID) error <span class="cov0" title="0">{

        const q = `
    UPDATE
        delivery_exception
        SET
                is_deleted = :is_deleted
    WHERE
        exception_id = :exception_id`

        dbDeliveryException := deliveryexceptiondb{ExceptionID: DeliveryExceptionID, IsDeleted: true}

        if err := sqldb.NamedExecContext(ctx, s.log, s.db, q, dbDeliveryException); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("namedexeccontext: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *Store) HardDelete(ctx context.Context, DeliveryExceptionID uuid.UUID) error <span class="cov0" title="0">{

        const q = `
    DELETE FROM
        delivery_exception
    WHERE
        exception_id = :exception_id`

        dbDeliveryException := deliveryexceptiondb{ExceptionID: DeliveryExceptionID}

        if err := sqldb.NamedExecContext(ctx, s.log, s.db, q, dbDeliveryException); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("namedexeccontext: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file101" style="display: none">package delexceptiondb

import (
        "bytes"
        "strings"

        "github.com/FITHSCS/backend/business/domain/delexceptionbus"
)

func (s *Store) applyFilter(filter delexceptionbus.QueryFilter, data map[string]any, buf *bytes.Buffer) <span class="cov0" title="0">{

        var wc []string

        if filter.CreatedAt != nil </span><span class="cov0" title="0">{
                data["created_at"] = filter.CreatedAt.UTC()
                wc = append(wc, "created_at &gt;= :created_at")
        }</span>

        <span class="cov0" title="0">if filter.UpdatedAt != nil </span><span class="cov0" title="0">{
                data["updated_at"] = filter.UpdatedAt.UTC()
                wc = append(wc, "updated_at &lt;= :updated_at")
        }</span>

        <span class="cov0" title="0">if len(wc) &gt; 0 </span><span class="cov0" title="0">{
                buf.WriteString(" WHERE ")
                buf.WriteString(strings.Join(wc, " AND "))
        }</span>
}
</pre>
		
		<pre class="file" id="file102" style="display: none">package delexceptiondb

import (
        "fmt"
        "time"

        "github.com/FITHSCS/backend/business/domain/delexceptionbus"
        "github.com/FITHSCS/backend/business/types/genstringtype"
        "github.com/google/uuid"
)

type deliveryexceptiondb struct {
        ExceptionID      uuid.UUID     `db:"exception_id"`
        ManifestID       uuid.UUID     `db:"manifest_id"`
        DeliveryPersonID uuid.UUID     `db:"delivery_personnel_id"`
        Severity         string        `db:"severity"`
        ExceptionType    string        `db:"exception_type"`
        Description      string        `db:"description"`
        CapturedAt       time.Time     `db:"captured_at"`
        ResolutionStatus string        `db:"resolution_status"`
        ResolvedBy       uuid.NullUUID `db:"resolved_by"`
        IsDeleted        bool          `db:"is_deleted"`
        IsSynced         bool          `db:"is_synced"`
        TimeStamp        time.Time     `db:"time_stamp"`
        CreatedAt        time.Time     `db:"created_at"`
        UpdatedAt        time.Time     `db:"updated_at"`
}

func toDBDeliveryException(bus delexceptionbus.DeliveryException) deliveryexceptiondb <span class="cov0" title="0">{

        return deliveryexceptiondb{
                ExceptionID:      bus.ExceptionID,
                ManifestID:       bus.ManifestID,
                DeliveryPersonID: bus.DeliveryPersonID,
                Severity:         bus.Severity.String(),
                ExceptionType:    bus.ExceptionType.String(),
                Description:      bus.Description.String(),
                CapturedAt:       bus.CapturedAt.UTC(),
                ResolutionStatus: bus.ResolutionStatus.String(),
                ResolvedBy:       bus.ResolvedBy,
                IsDeleted:        bus.IsDeleted,
                IsSynced:         bus.IsSynced,
                TimeStamp:        bus.TimeStamp.UTC(),
                CreatedAt:        bus.CreatedAt.UTC(),
                UpdatedAt:        bus.UpdatedAt.UTC(),
        }
}</span>

func toBusDeliveryException(db deliveryexceptiondb) (delexceptionbus.DeliveryException, error) <span class="cov0" title="0">{

        exctype, err := genstringtype.Parse(db.ExceptionType)
        if err != nil </span><span class="cov0" title="0">{
                return delexceptionbus.DeliveryException{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">desc, err := genstringtype.Parse(db.Description)
        if err != nil </span><span class="cov0" title="0">{
                return delexceptionbus.DeliveryException{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">resusts, err := genstringtype.Parse(db.ResolutionStatus)
        if err != nil </span><span class="cov0" title="0">{
                return delexceptionbus.DeliveryException{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">sev, err := genstringtype.Parse(db.Severity)
        if err != nil </span><span class="cov0" title="0">{
                return delexceptionbus.DeliveryException{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">bus := delexceptionbus.DeliveryException{
                ExceptionID:      db.ExceptionID,
                ManifestID:       db.ManifestID,
                DeliveryPersonID: db.DeliveryPersonID,
                Severity:         sev,
                ExceptionType:    exctype,
                Description:      desc,
                CapturedAt:       db.CapturedAt.In(time.Local),
                ResolutionStatus: resusts,
                ResolvedBy:       db.ResolvedBy,
                IsDeleted:        db.IsDeleted,
                IsSynced:         db.IsSynced,
                TimeStamp:        db.TimeStamp.In(time.Local),
                CreatedAt:        db.CreatedAt.In(time.Local),
                UpdatedAt:        db.UpdatedAt.In(time.Local),
        }
        return bus, nil</span>

}

func toBusDeliveryExceptions(dbs []deliveryexceptiondb) ([]delexceptionbus.DeliveryException, error) <span class="cov0" title="0">{
        bus := make([]delexceptionbus.DeliveryException, len(dbs))
        for i, db := range dbs </span><span class="cov0" title="0">{
                var err error
                bus[i], err = toBusDeliveryException(db)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">return bus, nil</span>
}
</pre>
		
		<pre class="file" id="file103" style="display: none">package delexceptiondb

import (
        "fmt"

        "github.com/FITHSCS/backend/business/domain/delexceptionbus"
        "github.com/FITHSCS/backend/business/sdk/order"
)

var orderByFields = map[string]string{
        delexceptionbus.OrderByExceptionID:      "exception_id",
        delexceptionbus.OrderByManifestID:       "manifest_id",
        delexceptionbus.OrderByExceptionType:    "exception_type",
        delexceptionbus.OrderByResolutionStatus: "resolution_status",
        delexceptionbus.OrderByCreatedAt:        "created_at",
        delexceptionbus.OrderByUpdatedAt:        "updated_at",
}

// orderByClause converts an order.By value into the final
// " ORDER BY  ASC|DESC" fragment the store adds to its SELECT.
func orderByClause(ob order.By) (string, error) <span class="cov0" title="0">{
        col, ok := orderByFields[ob.Field]
        if !ok </span><span class="cov0" title="0">{
                return "", fmt.Errorf("field %q does not exist", ob.Field)
        }</span>
        <span class="cov0" title="0">return " ORDER BY " + col + " " + ob.Direction, nil</span>
}
</pre>
		
		<pre class="file" id="file104" style="display: none">package delexceptionbus

import (
        "context"
        "fmt"
        "math/rand"
        "time"

        "github.com/FITHSCS/backend/business/types/genstringtype"
        "github.com/google/uuid"
)

func TestGenerateNewDeliveryException(n int, manID, delpersID, resBy uuid.UUID) []NewDeliveryException <span class="cov5" title="2">{
        newfs := make([]NewDeliveryException, n)
        svr := []string{"low", "medium", "high"}
        exetype := []string{"damaged", "descripancy", "refused", "no_recipient", "wrong_address", "other"}
        resolsts := []string{"pending", "resolved"}
        resby := []uuid.NullUUID{
                {UUID: resBy, Valid: true},
                {UUID: uuid.UUID{}, Valid: false},
        }

        CapturedAt, _ := time.Parse(time.RFC3339, "2025-06-10T15:59:33+03:00")
        timestamp := CapturedAt.Add(time.Minute + 1)

        idx := rand.Intn(10000)
        for i := range n </span><span class="cov10" title="4">{
                idx++

                nf := NewDeliveryException{
                        ManifestID:       manID,
                        DeliveryPersonID: delpersID,
                        Severity:         genstringtype.MustParse(svr[i%3]),
                        ExceptionType:    genstringtype.MustParse(exetype[i%6]),
                        Description:      genstringtype.MustParse("This is the description for this exception"),
                        CapturedAt:       CapturedAt,
                        ResolutionStatus: genstringtype.MustParse(resolsts[i%2]),
                        ResolvedBy:       resby[i%2],
                        IsSynced:         true,
                        TimeStamp:        timestamp,
                }

                newfs[i] = nf
        }</span>

        <span class="cov5" title="2">return newfs</span>
}

func TestGenerateSeedDeliveryException(ctx context.Context, n int, api *Business, manID, delpersID, resBy uuid.UUID) ([]DeliveryException, error) <span class="cov5" title="2">{
        newfs := TestGenerateNewDeliveryException(n, manID, delpersID, resBy)

        facs := make([]DeliveryException, len(newfs))
        for i, np := range newfs </span><span class="cov10" title="4">{
                prd, err := api.Create(ctx, np)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("seeding deliveryexception: idx: %d : %w", i, err)
                }</span>

                <span class="cov10" title="4">facs[i] = prd</span>
        }

        <span class="cov5" title="2">return facs, nil</span>
}
</pre>
		
		<pre class="file" id="file105" style="display: none">// Package facilitybus provides business access to facilities domain.
package facilitybus

import (
        "context"
        "errors"
        "fmt"

        "time"

        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/google/uuid"
)

var (
        ErrNotFound              = errors.New("facility not found")
        ErrAuthenticationFailure = errors.New("authentication failed")
)

type Storer interface {
        Create(ctx context.Context, facility Facility) error
        Update(ctx context.Context, facility Facility) error
        SoftDelete(ctx context.Context, facilityID uuid.UUID) error
        HardDelete(ctx context.Context, facilityID uuid.UUID) error
        Query(ctx context.Context, filter QueryFilter, orderby order.By, page page.Page) ([]Facility, error)
        Count(ctx context.Context, filter QueryFilter) (int, error)
        QueryByID(ctx context.Context, facilityID uuid.UUID) (Facility, error)
}

func (b *Business) GetStorer() Storer <span class="cov0" title="0">{
        return b.storer
}</span>

type Business struct {
        log    *logger.Logger
        storer Storer
}

func NewBusiness(log *logger.Logger, storer Storer) *Business <span class="cov1" title="1">{
        return &amp;Business{
                log:    log,
                storer: storer,
        }
}</span>

func (b *Business) Create(ctx context.Context, nf NewFacility) (Facility, error) <span class="cov10" title="5">{
        now := time.Now().Truncate(time.Microsecond)

        facility := Facility{
                ID:              uuid.New(),
                FacilityName:    nf.FacilityName,
                FacilityType:    nf.FacilityType,
                Address:         nf.Address,
                Region:          nf.Region,
                Latitude:        nf.Latitude,
                Longitude:       nf.Longitude,
                GeofenceRadius:  nf.GeofenceRadius,
                ContactPersonID: nf.ContactPersonID,
                ContactPhone:    nf.ContactPhone,
                IsDeleted:       false,
                CreatedAt:       now,
                UpdatedAt:       now,
        }
        if err := b.storer.Create(ctx, facility); err != nil </span><span class="cov0" title="0">{
                return Facility{}, fmt.Errorf("create: %w", err)
        }</span>
        <span class="cov10" title="5">return facility, nil</span>
}

func (b *Business) Update(ctx context.Context, facilityID uuid.UUID, updtFacility UpdateFacility) (Facility, error) <span class="cov1" title="1">{

        facDBRetrieved, err := b.storer.QueryByID(ctx, facilityID)
        if err != nil </span><span class="cov0" title="0">{
                return Facility{}, fmt.Errorf("Update: %w", err)
        }</span>

        <span class="cov1" title="1">if updtFacility.FacilityName != nil </span><span class="cov1" title="1">{
                facDBRetrieved.FacilityName = *updtFacility.FacilityName
        }</span>

        <span class="cov1" title="1">if updtFacility.FacilityType != nil </span><span class="cov1" title="1">{
                facDBRetrieved.FacilityType = *updtFacility.FacilityType
        }</span>

        <span class="cov1" title="1">if updtFacility.Address != nil </span><span class="cov1" title="1">{
                facDBRetrieved.Address = *updtFacility.Address
        }</span>

        <span class="cov1" title="1">if updtFacility.Region != nil </span><span class="cov1" title="1">{
                facDBRetrieved.Region = *updtFacility.Region
        }</span>

        <span class="cov1" title="1">if updtFacility.Latitude != nil </span><span class="cov1" title="1">{
                facDBRetrieved.Latitude = *updtFacility.Latitude
        }</span>
        <span class="cov1" title="1">if updtFacility.Longitude != nil </span><span class="cov1" title="1">{
                facDBRetrieved.Longitude = *updtFacility.Longitude
        }</span>
        <span class="cov1" title="1">if updtFacility.GeofenceRadius != nil </span><span class="cov1" title="1">{
                facDBRetrieved.GeofenceRadius = *updtFacility.GeofenceRadius
        }</span>

        <span class="cov1" title="1">if updtFacility.ContactPersonID != nil </span><span class="cov1" title="1">{
                facDBRetrieved.ContactPersonID = *updtFacility.ContactPersonID
        }</span>

        <span class="cov1" title="1">if updtFacility.ContactPhone != nil </span><span class="cov1" title="1">{
                facDBRetrieved.ContactPhone = *updtFacility.ContactPhone
        }</span>

        <span class="cov1" title="1">if updtFacility.IsDeleted != nil </span><span class="cov0" title="0">{
                facDBRetrieved.IsDeleted = *updtFacility.IsDeleted
        }</span>

        <span class="cov1" title="1">facDBRetrieved.UpdatedAt = time.Now().Truncate(time.Microsecond)

        if err := b.storer.Update(ctx, facDBRetrieved); err != nil </span><span class="cov0" title="0">{
                return Facility{}, fmt.Errorf("update: %w", err)
        }</span>
        <span class="cov1" title="1">return facDBRetrieved, nil</span>
}

func (b *Business) QueryByID(ctx context.Context, facilityID uuid.UUID) (Facility, error) <span class="cov1" title="1">{

        facility, err := b.storer.QueryByID(ctx, facilityID)
        if err != nil </span><span class="cov0" title="0">{
                return Facility{}, fmt.Errorf("query: facilityID[%s]: %w", facilityID, err)
        }</span>
        <span class="cov1" title="1">return facility, nil</span>
}
func (b *Business) Query(ctx context.Context, filter QueryFilter, orderBy order.By, page page.Page) ([]Facility, error) <span class="cov1" title="1">{

        facilities, err := b.storer.Query(ctx, filter, orderBy, page)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Query: %w", err)
        }</span>
        <span class="cov1" title="1">return facilities, nil</span>
}

func (b *Business) Count(ctx context.Context, filter QueryFilter) (int, error) <span class="cov0" title="0">{
        return b.storer.Count(ctx, filter)
}</span>

func (b *Business) SoftDelete(ctx context.Context, facilityID uuid.UUID) error <span class="cov0" title="0">{

        facility, err := b.storer.QueryByID(ctx, facilityID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("softdeletequery: facilityID[%s]: %w", facilityID, err)
        }</span>

        <span class="cov0" title="0">if facility.IsDeleted </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: already deleted", facilityID)
        }</span>

        <span class="cov0" title="0">if err := b.storer.SoftDelete(ctx, facilityID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("delete: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>

}

func (b *Business) HardDelete(ctx context.Context, facilityID uuid.UUID) error <span class="cov4" title="2">{

        if err := b.storer.HardDelete(ctx, facilityID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("delete: %w", err)
        }</span>
        <span class="cov4" title="2">return nil</span>

}
</pre>
		
		<pre class="file" id="file106" style="display: none">// Package facilitydb contains product related CRUD functionality.
package facilitydb

import (
        "bytes"
        "context"
        "errors"
        "fmt"

        "github.com/FITHSCS/backend/business/domain/facilitybus"
        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/business/sdk/sqldb"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/google/uuid"
        "github.com/jmoiron/sqlx"
)

// -----------------------------------------------------------------------------
// Store
// -----------------------------------------------------------------------------

type Store struct {
        log *logger.Logger
        db  sqlx.ExtContext
}
func NewStore(log *logger.Logger, db *sqlx.DB) *Store <span class="cov0" title="0">{
        return &amp;Store{
                log: log,
                db:  db,
        }
}</span>

func (s *Store) Create(ctx context.Context, f facilitybus.Facility) error <span class="cov0" title="0">{
        const stmt = `
    INSERT INTO facility (
      facility_id,
          facility_name,
          facility_type,
          address,
          region,
      latitude,
          longitude,
          geofence_radius,
      contact_person_id,
          contact_person_phone,
          is_deleted,
      created_at,
          updated_at
    ) VALUES (
      :facility_id, 
          :facility_name, 
          :facility_type, 
          :address, 
          :region,
      :latitude, 
          :longitude, 
          :geofence_radius,
      :contact_person_id, 
          :contact_person_phone,
      :is_deleted,
      :created_at, 
          :updated_at
    )`

        return sqldb.NamedExecContext(ctx, s.log, s.db, stmt, toDBFacility(f))
}</span>

func (s *Store) Update(ctx context.Context, f facilitybus.Facility) error <span class="cov0" title="0">{
        const stmt = `
    UPDATE 
                facility
        SET 
                facility_name           = :facility_name,
            facility_type           = :facility_type,
            address                 = :address,
                region                                 = :region, 
            latitude                = :latitude,
            longitude               = :longitude,
            geofence_radius         = :geofence_radius,
            contact_person_id          = :contact_person_id,
            contact_person_phone   = :contact_person_phone,
               updated_at              = :updated_at
    WHERE 
                facility_id = :facility_id`
        return sqldb.NamedExecContext(ctx, s.log, s.db, stmt, toDBFacility(f))
}</span>

func (s *Store) Query(ctx context.Context, filter facilitybus.QueryFilter, orderBy order.By, page page.Page) ([]facilitybus.Facility, error) <span class="cov0" title="0">{

        data := map[string]any{
                "offset":        (page.Number() - 1) * page.RowsPerPage(),
                "rows_per_page": page.RowsPerPage(),
        }

        const q = `
    SELECT
              facility_id,
                facility_name, 
                facility_type, 
                address,
                region, 
              latitude, 
                longitude, 
                geofence_radius,      
                contact_person_id, 
                contact_person_phone,  
                is_deleted,    
                created_at, 
                updated_at
    FROM 
                facility`

        buf := bytes.NewBufferString(q)
        s.applyFilter(filter, data, buf)

        orderByClause, err := orderByClause(orderBy)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">buf.WriteString(orderByClause)
        buf.WriteString(" OFFSET :offset ROWS FETCH NEXT :rows_per_page ROWS ONLY")

        var dbRecs []facilitydb
        if err := sqldb.NamedQuerySlice(ctx, s.log, s.db, buf.String(), data, &amp;dbRecs); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("namedqueryslice: %w", err)
        }</span>
        <span class="cov0" title="0">fmt.Println(dbRecs)
        return toBusFacilities(dbRecs)</span>
}

// Count returns the total number of users in the DB.
func (s *Store) Count(ctx context.Context, filter facilitybus.QueryFilter) (int, error) <span class="cov0" title="0">{
        data := map[string]any{}

        const q = `
        SELECT
                count(1)
        FROM
                facility`

        buf := bytes.NewBufferString(q)
        s.applyFilter(filter, data, buf)

        var count struct {
                Count int `db:"count"`
        }
        if err := sqldb.NamedQueryStruct(ctx, s.log, s.db, buf.String(), data, &amp;count); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("db: %w", err)
        }</span>

        <span class="cov0" title="0">return count.Count, nil</span>
}

func (s *Store) QueryByID(ctx context.Context, id uuid.UUID) (facilitybus.Facility, error) <span class="cov0" title="0">{
        param := map[string]any{
                "facility_id": id.String(),
        }
        const stmt = `
    SELECT
                facility_id,
                facility_name,
                facility_type,
                address,
                region,
                latitude, longitude,
                geofence_radius,
                contact_person_id,
                contact_person_phone,
                is_deleted,
                created_at, updated_at
          FROM 
                facility
          WHERE 
                facility_id = :facility_id`

        var rec facilitydb
        if err := sqldb.NamedQueryStruct(ctx, s.log, s.db, stmt, param, &amp;rec); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sqldb.ErrDBNotFound) </span><span class="cov0" title="0">{
                        return facilitybus.Facility{}, facilitybus.ErrNotFound
                }</span>
                <span class="cov0" title="0">return facilitybus.Facility{}, err</span>
        }
        <span class="cov0" title="0">return toBusFacility(rec)</span>
}

func (s *Store) SoftDelete(ctx context.Context, facilityID uuid.UUID) error <span class="cov0" title="0">{

        const q = `
    UPDATE
        facility
        SET
                is_deleted = :is_deleted
    WHERE
        facility_id = :facility_id`

        dbFacility := facilitydb{ID: facilityID, IsDeleted: true}

        if err := sqldb.NamedExecContext(ctx, s.log, s.db, q, dbFacility); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("namedexeccontext: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *Store) HardDelete(ctx context.Context, facilityID uuid.UUID) error <span class="cov0" title="0">{

        const q = `
    DELETE FROM
        facility
    WHERE
        facility_id = :facility_id`

        dbFacility := facilitydb{ID: facilityID}

        if err := sqldb.NamedExecContext(ctx, s.log, s.db, q, dbFacility); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("namedexeccontext: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file107" style="display: none">package facilitydb

import (
        "bytes"
        "strings"

        "github.com/FITHSCS/backend/business/domain/facilitybus"
        "github.com/google/uuid"
)

func (s *Store) applyFilter(filter facilitybus.QueryFilter, data map[string]any, buf *bytes.Buffer) <span class="cov0" title="0">{

        var wc []string

        if filter.ID != uuid.Nil </span><span class="cov0" title="0">{
                data["facility_id"] = &amp;filter.ID
                wc = append(wc, "facility_id = :facility_id")
        }</span>

        <span class="cov0" title="0">if filter.FacilityName != nil </span><span class="cov0" title="0">{
                data["facility_name"] = *filter.FacilityName
                wc = append(wc, "facility_name LIKE :facility_name")
        }</span>
        <span class="cov0" title="0">if filter.FacilityType != nil </span><span class="cov0" title="0">{
                data["facility_type"] = *filter.FacilityType
                wc = append(wc, "facility_type = :facility_type")
        }</span>
        <span class="cov0" title="0">if filter.Address != nil </span><span class="cov0" title="0">{
                data["address"] = *filter.Address
                wc = append(wc, "address LIKE :address")
        }</span>

        <span class="cov0" title="0">if filter.Region != nil </span><span class="cov0" title="0">{
                data["region"] = *filter.Region
                wc = append(wc, "region LIKE :region")
        }</span>
        <span class="cov0" title="0">if filter.Latitude != nil </span><span class="cov0" title="0">{
                data["latitude"] = *filter.Latitude
                wc = append(wc, "latitude = :latitude")
        }</span>
        <span class="cov0" title="0">if filter.Longitude != nil </span><span class="cov0" title="0">{
                data["longitude"] = *filter.Longitude
                wc = append(wc, "longitude = :longitude")
        }</span>
        <span class="cov0" title="0">if filter.GeofenceRadius != nil </span><span class="cov0" title="0">{
                data["geofence_radius"] = *filter.GeofenceRadius
                wc = append(wc, "geofence_radius = :geofence_radius")
        }</span>

        <span class="cov0" title="0">if filter.ContactPerson != nil </span><span class="cov0" title="0">{
                data["contact_person"] = *filter.ContactPerson
                wc = append(wc, "contact_person = :contact_person")
        }</span>

        <span class="cov0" title="0">if filter.ContactPhone != nil </span><span class="cov0" title="0">{
                data["contact_phone"] = *filter.ContactPhone
                wc = append(wc, "contact_phone = :contact_phone")
        }</span>
        <span class="cov0" title="0">if filter.CreatedAt != nil </span><span class="cov0" title="0">{
                data["created_at"] = filter.CreatedAt.UTC()
                wc = append(wc, "created_at &gt;= :created_at")
        }</span>
        <span class="cov0" title="0">if filter.UpdatedAt != nil </span><span class="cov0" title="0">{
                data["updated_at"] = filter.UpdatedAt.UTC()
                wc = append(wc, "updated_at &lt;= :updated_at")
        }</span>
  
        <span class="cov0" title="0">if len(wc) &gt; 0 </span><span class="cov0" title="0">{
                buf.WriteString(" WHERE ")
                buf.WriteString(strings.Join(wc, " AND "))
        }</span>
}
</pre>
		
		<pre class="file" id="file108" style="display: none">package facilitydb

import (
        //"database/sql"
        "fmt"
        //"net/mail"
        "time"

        "github.com/FITHSCS/backend/business/domain/facilitybus"

        "github.com/FITHSCS/backend/business/types/facilitytype"
        "github.com/FITHSCS/backend/business/types/genstringtype"
        "github.com/google/uuid"
)

// &lt;============struct that is going to be passed to database schema =&gt; Final =======&gt;

type facilitydb struct {
        ID              uuid.UUID `db:"facility_id"`
        FacilityName    string    `db:"facility_name"`
        FacilityType    string    `db:"facility_type"`
        Address         string    `db:"address"`
        Region          string    `db:"region"`
        Latitude        float64   `db:"latitude"`
        Longitude       float64   `db:"longitude"`
        GeofenceRadius  float64   `db:"geofence_radius"`
        ContactPersonID uuid.UUID `db:"contact_person_id"`
        ContactPhone    string    `db:"contact_person_phone"`
        IsDeleted       bool      `db:"is_deleted"`
        CreatedAt       time.Time `db:"created_at"`
        UpdatedAt       time.Time `db:"updated_at"`
}

//&lt;==========================================================&gt;

// &lt;====================converting it to DB SCHEMA WHICH WILL BE USED =======================&gt;

func toDBFacility(bus facilitybus.Facility) facilitydb <span class="cov0" title="0">{

        return facilitydb{
                ID:              bus.ID,
                FacilityName:    bus.FacilityName.String(),
                FacilityType:    bus.FacilityType.String(),
                Address:         bus.Address.String(),
                Region:          bus.Region.String(),
                Latitude:        bus.Latitude.Float64(),
                Longitude:       bus.Longitude.Float64(),
                GeofenceRadius:  bus.GeofenceRadius.Float64(),
                ContactPersonID: bus.ContactPersonID,
                ContactPhone:    bus.ContactPhone.String(),
                IsDeleted:       bus.IsDeleted,
                CreatedAt:       bus.CreatedAt.UTC(),
                UpdatedAt:       bus.UpdatedAt.UTC(),
        }
}</span>

// =======================================================================
func toBusFacility(db facilitydb) (facilitybus.Facility, error) <span class="cov0" title="0">{

        facName, err := genstringtype.Parse(db.FacilityName)
        if err != nil </span><span class="cov0" title="0">{
                return facilitybus.Facility{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">facType, err := genstringtype.Parse(db.FacilityType)
        if err != nil </span><span class="cov0" title="0">{
                return facilitybus.Facility{}, fmt.Errorf("parse: %w", err)
        }</span>
        <span class="cov0" title="0">facAddress, err := facilitytype.ParseAddress(db.Address)
        if err != nil </span><span class="cov0" title="0">{
                return facilitybus.Facility{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">facRegion, err := genstringtype.Parse(db.Region)
        if err != nil </span><span class="cov0" title="0">{
                return facilitybus.Facility{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">facLongitude, err := facilitytype.ParseLong(db.Longitude)
        if err != nil </span><span class="cov0" title="0">{
                return facilitybus.Facility{}, fmt.Errorf("parse: %w", err)
        }</span>
        <span class="cov0" title="0">facLatitude, err := facilitytype.ParseLat(db.Latitude)
        if err != nil </span><span class="cov0" title="0">{
                return facilitybus.Facility{}, fmt.Errorf("parse: %w", err)
        }</span>
        <span class="cov0" title="0">facGeofence, err := facilitytype.ParseGeofence(db.GeofenceRadius)
        if err != nil </span><span class="cov0" title="0">{
                return facilitybus.Facility{}, fmt.Errorf("parse: %w", err)
        }</span>
        <span class="cov0" title="0">facContPhone, err := facilitytype.ParseCleanPhoneNumber(db.ContactPhone)
        if err != nil </span><span class="cov0" title="0">{
                return facilitybus.Facility{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">bus := facilitybus.Facility{
                ID:              db.ID,
                FacilityName:    facName,
                FacilityType:    facType,
                Address:         facAddress,
                Region:          facRegion,
                Latitude:        facLatitude,
                Longitude:       facLongitude,
                GeofenceRadius:  facGeofence,
                ContactPersonID: db.ContactPersonID,
                ContactPhone:    facContPhone,
                IsDeleted:       db.IsDeleted,
                CreatedAt:       db.CreatedAt.In(time.Local),
                UpdatedAt:       db.UpdatedAt.In(time.Local),
        }
        return bus, nil</span>

}

func toBusFacilities(dbs []facilitydb) ([]facilitybus.Facility, error) <span class="cov0" title="0">{
        bus := make([]facilitybus.Facility, len(dbs))
        for i, db := range dbs </span><span class="cov0" title="0">{
                var err error
                bus[i], err = toBusFacility(db)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">return bus, nil</span>
}
</pre>
		
		<pre class="file" id="file109" style="display: none">package facilitydb

import (
        "fmt"

        "github.com/FITHSCS/backend/business/domain/facilitybus"
        "github.com/FITHSCS/backend/business/sdk/order"
)

var orderByFields = map[string]string{
        facilitybus.OrderByID:        "facility_id",
        facilitybus.OrderByName:      "name",
        facilitybus.OrderByType:      "type",
        facilitybus.OrderByCreatedAt: "created_at",
        facilitybus.OrderByUpdatedAt: "updated_at",
}

// orderByClause converts an order.By value into the final
// " ORDER BY  ASC|DESC" fragment the store adds to its SELECT.
func orderByClause(ob order.By) (string, error) <span class="cov0" title="0">{
        col, ok := orderByFields[ob.Field]
        if !ok </span><span class="cov0" title="0">{
                return "", fmt.Errorf("field %q does not exist", ob.Field)
        }</span>
        <span class="cov0" title="0">return " ORDER BY " + col + " " + ob.Direction, nil</span>
}
</pre>
		
		<pre class="file" id="file110" style="display: none">package facilitybus

import (
        "context"
        "fmt"
        "math/rand"

        "github.com/FITHSCS/backend/business/types/facilitytype"
        "github.com/FITHSCS/backend/business/types/genstringtype"
        "github.com/google/uuid"
)

func TestGenerateNewFacilities(n int, userID uuid.UUID) []NewFacility <span class="cov5" title="2">{
        newfs := make([]NewFacility, n)
        facTypes := []string{"warehouse", "health_facility"}

        idx := rand.Intn(10000)
        for i := range n </span><span class="cov10" title="4">{
                idx++

                nf := NewFacility{
                        FacilityName:    genstringtype.MustParse(fmt.Sprintf("Name%d", idx)),
                        FacilityType:    genstringtype.MustParse(facTypes[i%2]),
                        Address:         facilitytype.MustParseAddress(fmt.Sprintf("FacName%d", idx)),
                        Region:          genstringtype.MustParse(fmt.Sprintf("Region:%d", idx)),
                        Latitude:        facilitytype.MustParseLat(9.019499778747559),
                        Longitude:       facilitytype.MustParseLong(38.739200592041016),
                        GeofenceRadius:  facilitytype.MustParseGeofence(10.0),
                        ContactPersonID: userID,
                        ContactPhone:    facilitytype.MustParsePhoneNumber(fmt.Sprintf("092233%04d", idx)),
                }

                newfs[i] = nf
        }</span>

        <span class="cov5" title="2">return newfs</span>
}

func TestGenerateSeedFacilities(ctx context.Context, n int, api *Business, usrID uuid.UUID) ([]Facility, error) <span class="cov5" title="2">{
        newfs := TestGenerateNewFacilities(n, usrID)

        facs := make([]Facility, len(newfs))
        for i, np := range newfs </span><span class="cov10" title="4">{
                prd, err := api.Create(ctx, np)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("seeding facilities: idx: %d : %w", i, err)
                }</span>

                <span class="cov10" title="4">facs[i] = prd</span>
        }

        <span class="cov5" title="2">return facs, nil</span>
}
</pre>
		
		<pre class="file" id="file111" style="display: none">// Package gpstrackingbus provides business access to gps tracking bus domain.
package gpstrackingbus

import (
        "context"
        "errors"
        "fmt"
        "time"

        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/google/uuid"
)

// Set of error variables for CRUD operations.
var (
        ErrNotFound     = errors.New("track and trace not found")
        ErrUserDisabled = errors.New("user disabled")
)

// Storer interface declares the behavior this package needs to persist and
// retrieve data.
type Storer interface {
        Create(ctx context.Context, trackTrace TrackTrace) error
        Update(ctx context.Context, trackTrace TrackTrace) error
        QueryByID(ctx context.Context, trackTraceID uuid.UUID) (TrackTrace, error)
        SoftDelete(ctx context.Context, trackTraceID uuid.UUID) error
        HardDelete(ctx context.Context, trackTraceID uuid.UUID) error
        Query(ctx context.Context, filter QueryFilter, orderBy order.By, page page.Page) ([]TrackTrace, error)
        Count(ctx context.Context, filter QueryFilter) (int, error)
}

func (b *Business) GetStorer() Storer <span class="cov0" title="0">{
        return b.storer
}</span>

// Business manages the set of APIs for epickup access.
type Business struct {
        log    *logger.Logger
        storer Storer
}

// NewBusiness constructs a epickup business API for use.
func NewBusiness(log *logger.Logger, storer Storer) *Business <span class="cov1" title="1">{
        return &amp;Business{
                log:    log,
                storer: storer,
        }

}</span>

// Create adds a new tracktrace to the system.
func (b *Business) Create(ctx context.Context, ntt NewTrackTrace) (TrackTrace, error) <span class="cov10" title="5">{

        now := time.Now().Truncate(time.Millisecond)

        tracktrace := TrackTrace{
                TrackTraceID:        uuid.New(),
                RouteID:             ntt.RouteID,
                DeliveryPersonnelID: ntt.DeliveryPersonnelID,
                VehicleID:           ntt.VehicleID,
                Latitude:            ntt.Latitude,
                Longitude:           ntt.Longitude,
                Accuracy:            ntt.Accuracy,
                Speed:               ntt.Speed,
                BatteryLevel:        ntt.BatteryLevel,
                IsSynced:            ntt.IsSynced,
                TimeStamp:           ntt.TimeStamp,
                IsDeleted:           false,
                CreatedAt:           now,
                UpdatedAt:           now,
        }

        if err := b.storer.Create(ctx, tracktrace); err != nil </span><span class="cov0" title="0">{
                return TrackTrace{}, fmt.Errorf("create: %w", err)
        }</span>

        <span class="cov10" title="5">return tracktrace, nil</span>
}

func (b *Business) Update(ctx context.Context, utracktrace UpdateTrackTrace, trackTraceID uuid.UUID) (TrackTrace, error) <span class="cov1" title="1">{

        // Fetch the original pickup data
        origTrackTrace, err := b.storer.QueryByID(ctx, trackTraceID)
        if err != nil </span><span class="cov0" title="0">{
                return TrackTrace{}, fmt.Errorf("user.querybyid: %s: %w", trackTraceID, err)
        }</span>

        <span class="cov1" title="1">if utracktrace.RouteID != nil </span><span class="cov1" title="1">{
                origTrackTrace.RouteID = *utracktrace.RouteID
        }</span>

        <span class="cov1" title="1">if utracktrace.DeliveryPersonnelID != nil </span><span class="cov1" title="1">{
                origTrackTrace.DeliveryPersonnelID = *utracktrace.DeliveryPersonnelID
        }</span>

        <span class="cov1" title="1">if utracktrace.VehicleID != nil </span><span class="cov1" title="1">{
                origTrackTrace.VehicleID = *utracktrace.VehicleID
        }</span>

        <span class="cov1" title="1">if utracktrace.Latitude != nil </span><span class="cov1" title="1">{
                origTrackTrace.Latitude = *utracktrace.Latitude
        }</span>

        <span class="cov1" title="1">if utracktrace.Longitude != nil </span><span class="cov1" title="1">{
                origTrackTrace.Longitude = *utracktrace.Longitude
        }</span>

        // TODO: Decide what to do when the data has already been synced
        <span class="cov1" title="1">if utracktrace.IsSynced != nil </span><span class="cov1" title="1">{
                origTrackTrace.IsSynced = *utracktrace.IsSynced
        }</span>

        <span class="cov1" title="1">if utracktrace.TimeStamp != nil </span><span class="cov1" title="1">{
                origTrackTrace.TimeStamp = *utracktrace.TimeStamp
        }</span>

        <span class="cov1" title="1">origTrackTrace.UpdatedAt = time.Now().Truncate(time.Millisecond)

        if err := b.storer.Update(ctx, origTrackTrace); err != nil </span><span class="cov0" title="0">{
                return TrackTrace{}, fmt.Errorf("update: %w", err)
        }</span>

        <span class="cov1" title="1">return origTrackTrace, nil</span>
}

// QueryByID finds the epickup by the specified ID.
func (b *Business) QueryByID(ctx context.Context, trackTraceID uuid.UUID) (TrackTrace, error) <span class="cov1" title="1">{

        trackTrace, err := b.storer.QueryByID(ctx, trackTraceID)
        if err != nil </span><span class="cov0" title="0">{
                return TrackTrace{}, fmt.Errorf("query: trackTraceID[%s]: %w", trackTraceID, err)
        }</span>

        <span class="cov1" title="1">return trackTrace, nil</span>
}

// Query retrieves a list of existing products.
func (b *Business) Query(ctx context.Context, filter QueryFilter, orderBy order.By, page page.Page) ([]TrackTrace, error) <span class="cov1" title="1">{
        prds, err := b.storer.Query(ctx, filter, orderBy, page)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("query: %w", err)
        }</span>

        <span class="cov1" title="1">return prds, nil</span>
}

// Count returns the total number of pickups.
func (b *Business) Count(ctx context.Context, filter QueryFilter) (int, error) <span class="cov0" title="0">{
        return b.storer.Count(ctx, filter)
}</span>

func (b *Business) HardDelete(ctx context.Context, trackTraceID uuid.UUID) error <span class="cov4" title="2">{

        if err := b.storer.HardDelete(ctx, trackTraceID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("delete: %w", err)
        }</span>

        <span class="cov4" title="2">return nil</span>
}

func (b *Business) SoftDelete(ctx context.Context, trackTraceID uuid.UUID) error <span class="cov4" title="2">{

        if err := b.storer.SoftDelete(ctx, trackTraceID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("delete: %w", err)
        }</span>

        <span class="cov4" title="2">return nil</span>
}
</pre>
		
		<pre class="file" id="file112" style="display: none">package gpstrackingdb

import (
        "bytes"
        "strings"

        "github.com/FITHSCS/backend/business/domain/gpstrackingbus"
)

func (s *Store) applyFilter(filter gpstrackingbus.QueryFilter, data map[string]any, buf *bytes.Buffer) <span class="cov0" title="0">{
        var wc []string

        if filter.TrackTraceID != nil </span><span class="cov0" title="0">{
                data["tracking_id"] = *filter.TrackTraceID
                wc = append(wc, "tracking_id = :tracking_id")
        }</span>

        <span class="cov0" title="0">if filter.RouteID != nil </span><span class="cov0" title="0">{
                data["route_id"] = *filter.RouteID
                wc = append(wc, "route_id = :route_id")
        }</span>

        <span class="cov0" title="0">if filter.PackageDetailID != nil </span><span class="cov0" title="0">{
                data["package_detail_id"] = *filter.PackageDetailID
                wc = append(wc, "package_detail_id = :package_detail_id")
        }</span>

        <span class="cov0" title="0">if filter.VehicleID != nil </span><span class="cov0" title="0">{
                data["vehicle_id"] = *filter.VehicleID
                wc = append(wc, "vehicle_id = :vehicle_id")
        }</span>

        <span class="cov0" title="0">if len(wc) &gt; 0 </span><span class="cov0" title="0">{
                buf.WriteString(" WHERE ")
                buf.WriteString(strings.Join(wc, " AND "))
        }</span>
}
</pre>
		
		<pre class="file" id="file113" style="display: none">// Package gpstrackingdb contains product related CRUD functionality.
package gpstrackingdb

import (
        "bytes"
        "context"
        "errors"
        "fmt"

        "github.com/FITHSCS/backend/business/domain/gpstrackingbus"
        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/business/sdk/sqldb"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/google/uuid"
        "github.com/jmoiron/sqlx"
)

// Store manages the set of APIs for product database access.
type Store struct {
        log *logger.Logger
        db  sqlx.ExtContext
}

// NewStore constructs the api for data access.
func NewStore(log *logger.Logger, db *sqlx.DB) *Store <span class="cov0" title="0">{
        return &amp;Store{
                log: log,
                db:  db,
        }
}</span>

// Create adds a Product to the sqldb. It returns the created Product with
// fields like ID and DateCreated populated.
func (s *Store) Create(ctx context.Context, trc gpstrackingbus.TrackTrace) error <span class="cov0" title="0">{

        const q = `
        INSERT INTO gps_tracking
                (
                        tracking_id,
                        route_id, 
                        delivery_personnel_id, 
                        vehicle_id, 
                        latitude, 
                        longitude, 
                        accuracy, 
                        speed, 
                        battery_level, 
                        time_stamp, 
                        is_deleted,
                        is_synced,
                        created_at,
                        updated_at
                )
        VALUES
                (
                        :tracking_id, 
                        :route_id, 
                        :delivery_personnel_id, 
                        :vehicle_id, 
                        :latitude, 
                        :longitude, 
                        :accuracy, 
                        :speed, 
                        :battery_level, 
                        :time_stamp,
                        :is_deleted,
                        :is_synced,
                        :created_at,
                        :updated_at
                )
        `

        if err := sqldb.NamedExecContext(ctx, s.log, s.db, q, toDBTrackTrace(trc)); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("namedexeccontext: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// QueryByID finds the epickup identified by a given ID.
func (s *Store) QueryByID(ctx context.Context, trackingID uuid.UUID) (gpstrackingbus.TrackTrace, error) <span class="cov0" title="0">{
        data := struct {
                ID string `db:"tracking_id"`
        }{
                ID: trackingID.String(),
        }

        const q = `
        SELECT
            tracking_id,
                route_id, 
                delivery_personnel_id, 
                vehicle_id, 
                latitude, 
                longitude, 
                accuracy, 
                speed, 
                battery_level, 
                time_stamp,
                is_deleted, 
                is_synced,
                created_at,
                updated_at
        FROM
                gps_tracking
        WHERE
                tracking_id = :tracking_id`

        var trackTraceDB TrackTraceDB
        if err := sqldb.NamedQueryStruct(ctx, s.log, s.db, q, data, &amp;trackTraceDB); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sqldb.ErrDBNotFound) </span><span class="cov0" title="0">{
                        return gpstrackingbus.TrackTrace{}, fmt.Errorf("db: %w", gpstrackingbus.ErrNotFound)
                }</span>
                <span class="cov0" title="0">return gpstrackingbus.TrackTrace{}, fmt.Errorf("db: %w", err)</span>
        }

        <span class="cov0" title="0">return toBusTrackTrace(trackTraceDB)</span>
}

func (s *Store) Update(ctx context.Context, tracktrace gpstrackingbus.TrackTrace) error <span class="cov0" title="0">{
        const q = `
        UPDATE gps_tracking
        SET
                tracking_id = :tracking_id,
                route_id = :route_id,
                delivery_personnel_id = :delivery_personnel_id,
                vehicle_id = :vehicle_id,
                latitude = :latitude,
                longitude = :longitude,
                accuracy = :accuracy,
                speed = :speed,
                battery_level = :battery_level,
                is_synced = :is_synced,
                is_deleted = :is_deleted,
                time_stamp = :time_stamp,
                created_at = :created_at,
                updated_at = :updated_at
        WHERE
                tracking_id = :tracking_id`

        if err := sqldb.NamedExecContext(ctx, s.log, s.db, q, toDBTrackTrace(tracktrace)); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("namedexeccontext: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *Store) HardDelete(ctx context.Context, tracktraceID uuid.UUID) error <span class="cov0" title="0">{

        const q = `
        DELETE FROM
                gps_tracking
        WHERE
                tracking_id = :tracking_id`

        data := TrackTraceDB{TrackTraceID: tracktraceID}

        if err := sqldb.NamedExecContext(ctx, s.log, s.db, q, data); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("namedexeccontext: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *Store) SoftDelete(ctx context.Context, tracktraceID uuid.UUID) error <span class="cov0" title="0">{

        const q = `
        UPDATE gps_tracking
        SET
                is_deleted = :is_deleted
        WHERE
                tracking_id = :tracking_id`

        data := TrackTraceDB{TrackTraceID: tracktraceID, IsDeleted: true}

        if err := sqldb.NamedExecContext(ctx, s.log, s.db, q, data); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("namedexeccontext: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Query gets all epickups from the database.
func (s *Store) Query(ctx context.Context, filter gpstrackingbus.QueryFilter, orderBy order.By, page page.Page) ([]gpstrackingbus.TrackTrace, error) <span class="cov0" title="0">{
        data := map[string]any{
                "offset":        (page.Number() - 1) * page.RowsPerPage(),
                "rows_per_page": page.RowsPerPage(),
        }

        const q = `
        SELECT
            tracking_id,
                route_id, 
                delivery_personnel_id, 
                vehicle_id, 
                latitude, 
                longitude, 
                accuracy, 
                speed, 
                battery_level,
                time_stamp, 
                is_deleted,
                is_synced,
                created_at,
                updated_at
        FROM
                gps_tracking`

        buf := bytes.NewBufferString(q)
        s.applyFilter(filter, data, buf)

        orderByClause, err := orderByClause(orderBy)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">buf.WriteString(orderByClause)
        buf.WriteString(" OFFSET :offset ROWS FETCH NEXT :rows_per_page ROWS ONLY")

        var dbPrds []TrackTraceDB
        if err := sqldb.NamedQuerySlice(ctx, s.log, s.db, buf.String(), data, &amp;dbPrds); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("namedqueryslice: %w", err)
        }</span>

        <span class="cov0" title="0">return toBusTrackTraces(dbPrds)</span>
}

// Count returns the total number of records in the DB.
func (s *Store) Count(ctx context.Context, filter gpstrackingbus.QueryFilter) (int, error) <span class="cov0" title="0">{
        data := map[string]any{}

        const q = `
        SELECT
                count(1)
        FROM
                gps_tracking`

        buf := bytes.NewBufferString(q)
        s.applyFilter(filter, data, buf)

        var count struct {
                Count int `db:"count"`
        }
        if err := sqldb.NamedQueryStruct(ctx, s.log, s.db, buf.String(), data, &amp;count); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("db: %w", err)
        }</span>

        <span class="cov0" title="0">return count.Count, nil</span>
}
</pre>
		
		<pre class="file" id="file114" style="display: none">package gpstrackingdb

import (
        "fmt"
        "time"

        "github.com/FITHSCS/backend/business/domain/gpstrackingbus"
        "github.com/FITHSCS/backend/business/types/facilitytype"
        "github.com/google/uuid"
)

type TrackTraceDB struct {
        TrackTraceID        uuid.UUID `db:"tracking_id"`
        RouteID             uuid.UUID `db:"route_id"`
        DeliveryPersonnelID uuid.UUID `db:"delivery_personnel_id"`
        VehicleID           uuid.UUID `db:"vehicle_id"`
        Latitude            float64   `db:"latitude"`
        Longitude           float64   `db:"longitude"`
        Accuracy            float64   `db:"accuracy"`
        Speed               float64   `db:"speed"`
        BatteryLevel        float64   `db:"battery_level"`
        IsSynced            bool      `db:"is_synced"`
        IsDeleted           bool      `db:"is_deleted"`
        TimeStamp           time.Time `db:"time_stamp"`
        CreatedAt           time.Time `db:"created_at"`
        UpdatedAt           time.Time `db:"updated_at"`
}

func toDBTrackTrace(bus gpstrackingbus.TrackTrace) TrackTraceDB <span class="cov0" title="0">{

        db := TrackTraceDB{
                TrackTraceID:        bus.TrackTraceID,
                RouteID:             bus.RouteID,
                DeliveryPersonnelID: bus.DeliveryPersonnelID,
                VehicleID:           bus.VehicleID,
                Latitude:            bus.Latitude.Float64(),
                Longitude:           bus.Longitude.Float64(),
                Accuracy:            bus.Accuracy,
                Speed:               bus.Speed,
                BatteryLevel:        bus.BatteryLevel,
                IsDeleted:           bus.IsDeleted,
                IsSynced:            bus.IsSynced,
                TimeStamp:           bus.TimeStamp.UTC(),
                CreatedAt:           bus.CreatedAt.UTC(),
                UpdatedAt:           bus.UpdatedAt.UTC(),
        }
        return db
}</span>

// toBusTrackTrace converts an TrackTraceDB (database object) back to an TrackTraceBus (business object).
func toBusTrackTrace(db TrackTraceDB) (gpstrackingbus.TrackTrace, error) <span class="cov0" title="0">{
        // Perform any necessary parsing or validation if complex types were used.
        // In this case, types map directly or only involve time zone conversion.

        lat, err := facilitytype.ParseLat(db.Latitude)
        if err != nil </span><span class="cov0" title="0">{
                return gpstrackingbus.TrackTrace{}, fmt.Errorf("parse: %v", err)
        }</span>

        <span class="cov0" title="0">long, err := facilitytype.ParseLong(db.Longitude)
        if err != nil </span><span class="cov0" title="0">{
                return gpstrackingbus.TrackTrace{}, fmt.Errorf("parse: %v", err)
        }</span>

        <span class="cov0" title="0">bus := gpstrackingbus.TrackTrace{
                TrackTraceID:        db.TrackTraceID,
                RouteID:             db.RouteID,
                DeliveryPersonnelID: db.DeliveryPersonnelID,
                VehicleID:           db.VehicleID,
                Latitude:            lat,
                Longitude:           long,
                Accuracy:            db.Accuracy,
                Speed:               db.Speed,
                BatteryLevel:        db.BatteryLevel,
                IsDeleted:           db.IsDeleted,
                IsSynced:            db.IsSynced,
                TimeStamp:           db.TimeStamp.In(time.Local),
                CreatedAt:           db.CreatedAt.In(time.Local),
                UpdatedAt:           db.UpdatedAt.In(time.Local),
        }

        return bus, nil</span>
}

// toBusEPickups converts a slice of ePickupDB objects to a slice of EPickup objects.
func toBusTrackTraces(dbs []TrackTraceDB) ([]gpstrackingbus.TrackTrace, error) <span class="cov0" title="0">{
        bus := make([]gpstrackingbus.TrackTrace, len(dbs))

        for i, db := range dbs </span><span class="cov0" title="0">{
                var err error
                bus[i], err = toBusTrackTrace(db)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">return bus, nil</span>
}
</pre>
		
		<pre class="file" id="file115" style="display: none">package gpstrackingdb

import (
        "fmt"

        "github.com/FITHSCS/backend/business/domain/gpstrackingbus"
        "github.com/FITHSCS/backend/business/sdk/order"
)

var orderByFields = map[string]string{
        gpstrackingbus.OrderByTrackAndTraceID:     "tracking_id",
        gpstrackingbus.OrderByDeliveryPersonnelID: "delivery_personnel_id",
        gpstrackingbus.OrderByRouteID:             "route_id",
        gpstrackingbus.OrderByCreatedAt:           "created_at",
        gpstrackingbus.OrderByBatteryLevel:        "battery_level",
}

func orderByClause(orderBy order.By) (string, error) <span class="cov0" title="0">{
        by, exists := orderByFields[orderBy.Field]
        if !exists </span><span class="cov0" title="0">{
                return "", fmt.Errorf("field %q does not exist", orderBy.Field)
        }</span>

        <span class="cov0" title="0">return " ORDER BY " + by + " " + orderBy.Direction, nil</span>
}
</pre>
		
		<pre class="file" id="file116" style="display: none">package gpstrackingbus

import (
        "context"
        "fmt"
        "math/rand"
        "time"

        "github.com/FITHSCS/backend/business/types/facilitytype"
        "github.com/google/uuid"
)

func TestGenerateNewGPSTracking(n int, rte, delperID, vehID uuid.UUID) []NewTrackTrace <span class="cov5" title="2">{
        newroute := make([]NewTrackTrace, n)

        tmesmp, _ := time.Parse(time.RFC3339, "2025-06-10T15:59:33+03:00")

        idx := rand.Intn(10000)
        for i := range n </span><span class="cov10" title="4">{
                idx++

                nf := NewTrackTrace{
                        RouteID:             rte,
                        DeliveryPersonnelID: delperID,
                        VehicleID:           vehID,
                        Latitude:            facilitytype.MustParseLat(9.01949999999),
                        Longitude:           facilitytype.MustParseLong(38.7399999999),
                        Accuracy:            10.21,
                        Speed:               32.2,
                        BatteryLevel:        67,
                        IsSynced:            true,
                        TimeStamp:           tmesmp,
                }

                newroute[i] = nf
        }</span>

        <span class="cov5" title="2">return newroute</span>
}

func TestGenerateSeedGPSTracking(ctx context.Context, n int, api *Business, rte, delperID, vehID uuid.UUID) ([]TrackTrace, error) <span class="cov5" title="2">{
        newfs := TestGenerateNewGPSTracking(n, rte, delperID, vehID)

        facs := make([]TrackTrace, len(newfs))
        for i, np := range newfs </span><span class="cov10" title="4">{
                prd, err := api.Create(ctx, np)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("seeding routes: idx: %d : %w", i, err)
                }</span>

                <span class="cov10" title="4">facs[i] = prd</span>
        }

        <span class="cov5" title="2">return facs, nil</span>
}
</pre>
		
		<pre class="file" id="file117" style="display: none">// Package imagebus provides business access to image domain.
package imagebus

import (
        "context"
        "errors"
        "fmt"
        "time"

        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/google/uuid"
)

var (
        ErrNotFound       = errors.New("iamge not found")
        ErrAuthentication = errors.New("authentication failed")
)

type Storer interface {
        Create(ctx context.Context, image Image) error
        Update(ctx context.Context, image Image) error
        SoftDelete(ctx context.Context, imageID uuid.UUID) error
        HardDelete(ctx context.Context, imageID uuid.UUID) error
        Query(ctx context.Context, filter QueryFilter, orderby order.By, page page.Page) ([]Image, error)
        QueryByID(ctx context.Context, imageID uuid.UUID) (Image, error)
        Count(ctx context.Context, filter QueryFilter) (int, error)
}

type Business struct {
        log    *logger.Logger
        storer Storer
}

func NewBusiness(log *logger.Logger, storer Storer) *Business <span class="cov1" title="1">{

        return &amp;Business{
                log:    log,
                storer: storer,
        }
}</span>

func (b *Business) Create(ctx context.Context, ni NewImage) (Image, error) <span class="cov10" title="6">{

        now := time.Now().Truncate(time.Millisecond)

        image := Image{
                ImageID:     uuid.New(),
                ManifestID:  ni.ManifestID,
                CapturedBy:  ni.CapturedBy,
                ExceptionID: ni.ExceptionID,
                EventType:   ni.EventType,
                ImageType:   ni.ImageType,
                ImageURL:    ni.ImageURL,
                ImageHash:   ni.ImageHash,
                IsSynced:    ni.IsSynced,
                IsDeleted:   false,
                TimeStamp:   now,
                CreatedAt:   now,
                UpdatedAt:   now,
        }

        if err := b.storer.Create(ctx, image); err != nil </span><span class="cov0" title="0">{
                return Image{}, fmt.Errorf("Create: %w", err)
        }</span>
        <span class="cov10" title="6">return image, nil</span>
}

func (b *Business) Update(ctx context.Context, imgID uuid.UUID, updateimg UpdateImage) (Image, error) <span class="cov4" title="2">{

        imgOrgnl, err := b.storer.QueryByID(ctx, imgID)
        if err != nil </span><span class="cov0" title="0">{
                return Image{}, fmt.Errorf("querybyid: %w", err)
        }</span>

        <span class="cov4" title="2">if updateimg.ManifestID != nil </span><span class="cov4" title="2">{
                imgOrgnl.ManifestID = *updateimg.ManifestID
        }</span>

        <span class="cov4" title="2">if updateimg.CapturedBy != nil </span><span class="cov4" title="2">{
                imgOrgnl.CapturedBy = *updateimg.CapturedBy
        }</span>

        <span class="cov4" title="2">if updateimg.ExceptionID != nil </span><span class="cov4" title="2">{
                imgOrgnl.ExceptionID = *updateimg.ExceptionID
        }</span>

        <span class="cov4" title="2">if updateimg.EventType != nil </span><span class="cov4" title="2">{
                imgOrgnl.EventType = *updateimg.EventType
        }</span>

        <span class="cov4" title="2">if updateimg.ImageType != nil </span><span class="cov4" title="2">{
                imgOrgnl.ImageType = *updateimg.ImageType
        }</span>

        <span class="cov4" title="2">if updateimg.ImageURL != nil </span><span class="cov4" title="2">{
                imgOrgnl.ImageURL = updateimg.ImageURL
        }</span>

        <span class="cov4" title="2">if updateimg.ImageHash != nil </span><span class="cov4" title="2">{
                imgOrgnl.ImageHash = *updateimg.ImageHash
        }</span>

        <span class="cov4" title="2">if updateimg.IsSynced != nil </span><span class="cov4" title="2">{
                imgOrgnl.IsSynced = *updateimg.IsSynced
        }</span>

        <span class="cov4" title="2">imgOrgnl.UpdatedAt = time.Now().Truncate(time.Microsecond)

        if err := b.storer.Update(ctx, imgOrgnl); err != nil </span><span class="cov0" title="0">{
                return Image{}, fmt.Errorf("update: %w", err)
        }</span>

        <span class="cov4" title="2">return imgOrgnl, nil</span>
}

func (b *Business) Query(ctx context.Context, filter QueryFilter, orderBy order.By, page page.Page) ([]Image, error) <span class="cov1" title="1">{
        images, err := b.storer.Query(ctx, filter, orderBy, page)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Query: %w", err)
        }</span>
        <span class="cov1" title="1">return images, nil</span>
}
func (b *Business) Count(ctx context.Context, filter QueryFilter) (int, error) <span class="cov0" title="0">{
        return b.storer.Count(ctx, filter)
}</span>

func (b *Business) QueryByID(ctx context.Context, ImageID uuid.UUID) (Image, error) <span class="cov1" title="1">{

        pickupbatch, err := b.storer.QueryByID(ctx, ImageID)
        if err != nil </span><span class="cov0" title="0">{
                return Image{}, fmt.Errorf("query: ImageID[%s]: %w", ImageID, err)
        }</span>
        <span class="cov1" title="1">return pickupbatch, nil</span>
}

func (b *Business) SoftDelete(ctx context.Context, ImageID uuid.UUID) error <span class="cov4" title="2">{
        facility, err := b.storer.QueryByID(ctx, ImageID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("softdeletequery: imageID[%s]: %w", ImageID, err)
        }</span>
        <span class="cov4" title="2">if facility.IsDeleted </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: already deleted", ImageID)
        }</span>

        <span class="cov4" title="2">if err := b.storer.SoftDelete(ctx, ImageID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("delete: %w", err)
        }</span>

        <span class="cov4" title="2">return nil</span>
}

func (b *Business) HardDelete(ctx context.Context, ImageID uuid.UUID) error <span class="cov4" title="2">{

        if err := b.storer.HardDelete(ctx, ImageID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("delete: %w", err)
        }</span>
        <span class="cov4" title="2">return nil</span>

}
</pre>
		
		<pre class="file" id="file118" style="display: none">package imagedb

import (
        "bytes"
        "strings"

        "github.com/FITHSCS/backend/business/domain/imagebus"
)

func applyFilter(filter imagebus.QueryFilter, data map[string]any, buf *bytes.Buffer) <span class="cov0" title="0">{

        var wc []string

        if filter.ID != nil </span><span class="cov0" title="0">{
                data["image_id"] = &amp;filter.ID
                wc = append(wc, "image_id = :image_id")
        }</span>

        <span class="cov0" title="0">if filter.EventType != nil </span><span class="cov0" title="0">{
                data["event_type"] = &amp;filter.ID
                wc = append(wc, "event_type = :event_type")
        }</span>

        <span class="cov0" title="0">if len(wc) &gt; 0 </span><span class="cov0" title="0">{
                buf.WriteString(" WHERE ")
                buf.WriteString(strings.Join(wc, " AND "))
        }</span>
}
</pre>
		
		<pre class="file" id="file119" style="display: none">// Package imagedb contains product related CRUD functionality.
package imagedb

import (
        "bytes"
        "context"
        "errors"
        "fmt"

        "github.com/FITHSCS/backend/business/domain/imagebus"
        "github.com/FITHSCS/backend/business/domain/pickupbatchbus"
        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/business/sdk/sqldb"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/google/uuid"
        "github.com/jmoiron/sqlx"
)

type Store struct {
        log *logger.Logger
        db  sqlx.ExtContext
}

func NewStore(log *logger.Logger, db *sqlx.DB) *Store <span class="cov0" title="0">{
        return &amp;Store{log: log, db: db}
}</span>

func (s *Store) Create(ctx context.Context, p imagebus.Image) error <span class="cov0" title="0">{
        const stmt = `
    INSERT INTO image (
            image_id, 
                manifest_id,
                captured_by,
                exception_id, 
            event_type,
                image_type,
                image_url,
                image_hash,
            is_synced, 
                is_deleted,
                time_stamp, 
            created_at,
                updated_at 
    ) 
        VALUES (
            :image_id, 
                :manifest_id, 
                :captured_by,
                :exception_id, 
            :event_type, 
                :image_type,
                :image_url,
                :image_hash,
            :is_synced, 
                :is_deleted,
                :time_stamp, 
            :created_at, 
                :updated_at
    )`
        returnedValue, err := toDBImage(p)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return sqldb.NamedExecContext(ctx, s.log, s.db, stmt, returnedValue)</span>
}

func (s *Store) Update(ctx context.Context, p imagebus.Image) error <span class="cov0" title="0">{
        const stmt = `
    UPDATE 
                image
    SET 
                manifest_id       = :manifest_id,
        captured_by       = :captured_by,
        exception_id      = :exception_id,
        event_type        = :event_type,
        image_type        = :image_type,
        image_url         = :image_url,
                image_hash                   = :image_hash,
        is_synced         = :is_synced,
        is_deleted        = :is_deleted,
        time_stamp        = :time_stamp,
        updated_at        = :updated_at
    WHERE 
                image_id          = :image_id`

        returnedValue, err := toDBImage(p)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return sqldb.NamedExecContext(ctx, s.log, s.db, stmt, returnedValue)</span>
}

func (s *Store) Query(ctx context.Context, filter imagebus.QueryFilter, orderBy order.By, page page.Page) ([]imagebus.Image, error) <span class="cov0" title="0">{

        data := map[string]any{
                "offset":        (page.Number() - 1) * page.RowsPerPage(),
                "rows_per_page": page.RowsPerPage(),
        }

        const q = `
    SELECT
            image_id, 
                manifest_id,
                captured_by,
                exception_id, 
            event_type,
                image_type,
                image_url,
                image_hash,
            is_synced, 
                is_deleted,
                time_stamp, 
            created_at,
                updated_at 
    FROM 
                image        `

        var buf bytes.Buffer
        buf.WriteString(q)
        applyFilter(filter, data, &amp;buf)

        clause, err := orderByClause(orderBy)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">buf.WriteString(clause)
        buf.WriteString(" OFFSET :offset ROWS FETCH NEXT :rows_per_page ROWS ONLY")

        var dbRecs []imagedb

        if err := sqldb.NamedQuerySlice(ctx, s.log, s.db, buf.String(), data, &amp;dbRecs); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("namedqueryslice: %w", err)
        }</span>

        <span class="cov0" title="0">return toBusImages(dbRecs)</span>
}

func (s *Store) Count(ctx context.Context, filter imagebus.QueryFilter) (int, error) <span class="cov0" title="0">{
        data := map[string]any{}
        const base = `SELECT count(1) FROM image`

        var buf bytes.Buffer
        buf.WriteString(base)
        applyFilter(filter, data, &amp;buf)

        var out struct {
                Count int `db:"count"`
        }
        if err := sqldb.NamedQueryStruct(ctx, s.log, s.db, buf.String(), data, &amp;out); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("db: %w", err)
        }</span>
        <span class="cov0" title="0">return out.Count, nil</span>
}

func (s *Store) QueryByID(ctx context.Context, imageID uuid.UUID) (imagebus.Image, error) <span class="cov0" title="0">{
        param := map[string]any{
                "image_id": imageID.String(),
        }
        const stmt = `
    SELECT
            image_id, 
                manifest_id,
                captured_by,
                exception_id, 
            event_type,
                image_type,
                image_url,
                image_hash,
            is_synced, 
                is_deleted,
                time_stamp, 
            created_at,
                updated_at 
        FROM 
                  image
        WHERE 
                  image_id = :image_id`

        var rec imagedb
        if err := sqldb.NamedQueryStruct(ctx, s.log, s.db, stmt, param, &amp;rec); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sqldb.ErrDBNotFound) </span><span class="cov0" title="0">{
                        return imagebus.Image{}, fmt.Errorf("db: %w", pickupbatchbus.ErrNotFound)
                }</span>
                <span class="cov0" title="0">return imagebus.Image{}, fmt.Errorf("db: %w", err)</span>
        }
        <span class="cov0" title="0">return toBusImage(rec)</span>
}

func (s *Store) SoftDelete(ctx context.Context, imageID uuid.UUID) error <span class="cov0" title="0">{

        const q = `
    UPDATE
        image
        SET
                is_deleted = :is_deleted
    WHERE
        image_id = :image_id`

        img := imagedb{ImageID: imageID, IsDeleted: true}

        if err := sqldb.NamedExecContext(ctx, s.log, s.db, q, img); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("namedexeccontext: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *Store) HardDelete(ctx context.Context, manifestID uuid.UUID) error <span class="cov0" title="0">{
        const q = `
    DELETE FROM
        image
    WHERE
        image_id = :image_id`

        img := imagedb{ImageID: manifestID}

        if err := sqldb.NamedExecContext(ctx, s.log, s.db, q, img); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("namedexeccontext: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file120" style="display: none">package imagedb

import (
        "fmt"
        "net/url"
        "time"

        "github.com/FITHSCS/backend/business/domain/imagebus"
        "github.com/FITHSCS/backend/business/types/genstringtype"
        "github.com/google/uuid"
)

type imagedb struct {
        ImageID     uuid.UUID     `db:"image_id"`
        ManifestID  uuid.UUID     `db:"manifest_id"`
        CapturedBy  uuid.UUID     `db:"captured_by"`
        ExceptionID uuid.NullUUID `db:"exception_id"`
        EventType   string        `db:"event_type"`
        ImageType   string        `db:"image_type"`
        ImageURL    string        `db:"image_url"`
        ImageHash   string        `db:"image_hash"`
        IsSynced    bool          `db:"is_synced"`
        IsDeleted   bool          `db:"is_deleted"`
        TimeStamp   time.Time     `db:"time_stamp"`
        CreatedAt   time.Time     `db:"created_at"`
        UpdatedAt   time.Time     `db:"updated_at"`
}

func toDBImage(bus imagebus.Image) (imagedb, error) <span class="cov0" title="0">{

        img := imagedb{
                ImageID:     bus.ImageID,
                ManifestID:  bus.ManifestID,
                CapturedBy:  bus.CapturedBy,
                ExceptionID: bus.ExceptionID,
                EventType:   bus.EventType.String(),
                ImageType:   bus.ImageType.String(),
                ImageURL:    bus.ImageURL.String(),
                ImageHash:   bus.ImageHash.String(),
                IsSynced:    bus.IsSynced,
                IsDeleted:   bus.IsDeleted,
                TimeStamp:   bus.TimeStamp.UTC(),
                CreatedAt:   bus.CreatedAt.UTC(),
                UpdatedAt:   bus.UpdatedAt.UTC(),
        }

        return img, nil
}</span>

func toBusImage(db imagedb) (imagebus.Image, error) <span class="cov0" title="0">{

        entyp, err := genstringtype.Parse(db.EventType)
        if err != nil </span><span class="cov0" title="0">{
                return imagebus.Image{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">imgtyp, err := genstringtype.Parse(db.ImageType)
        if err != nil </span><span class="cov0" title="0">{
                return imagebus.Image{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">imgurl, err := url.Parse(db.ImageURL)
        if err != nil </span><span class="cov0" title="0">{
                return imagebus.Image{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">imghsh, err := genstringtype.Parse(db.ImageHash)
        if err != nil </span><span class="cov0" title="0">{
                return imagebus.Image{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">bus := imagebus.Image{
                ImageID:     db.ImageID,
                ManifestID:  db.ManifestID,
                CapturedBy:  db.CapturedBy,
                ExceptionID: db.ExceptionID,
                EventType:   entyp,
                ImageType:   imgtyp,
                ImageURL:    imgurl,
                ImageHash:   imghsh,
                IsSynced:    db.IsSynced,
                IsDeleted:   db.IsDeleted,
                TimeStamp:   db.TimeStamp.In(time.Local),
                CreatedAt:   db.CreatedAt.In(time.Local),
                UpdatedAt:   db.UpdatedAt.In(time.Local),
        }
        return bus, nil</span>

}

func toBusImages(dbs []imagedb) ([]imagebus.Image, error) <span class="cov0" title="0">{
        bus := make([]imagebus.Image, len(dbs))

        for i, db := range dbs </span><span class="cov0" title="0">{
                var err error
                bus[i], err = toBusImage(db)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">return bus, nil</span>
}
</pre>
		
		<pre class="file" id="file121" style="display: none">package imagedb

import (
        "fmt"

        "github.com/FITHSCS/backend/business/domain/imagebus"
        "github.com/FITHSCS/backend/business/sdk/order"
)

var orderByFields = map[string]string{
        imagebus.OrderByID:        "image_id",
        imagebus.OrderByEventType: "event_type",
        imagebus.OrderByImageType: "image_type",
        imagebus.OrderByIsSynced:  "is_synced",
        imagebus.OrderByTimeStamp: "time_stamp",
        imagebus.OrderByCreatedAt: "created_at",
        imagebus.OrderByUpdatedAt: "updated_at",
}

// orderByClause converts an order.By value into the final
// " ORDER BY  ASC|DESC" fragment the store adds to its SELECT.
func orderByClause(ob order.By) (string, error) <span class="cov0" title="0">{
        col, ok := orderByFields[ob.Field]
        if !ok </span><span class="cov0" title="0">{
                return "", fmt.Errorf("field %q does not exist", ob.Field)
        }</span>
        <span class="cov0" title="0">return " ORDER BY " + col + " " + ob.Direction, nil</span>
}
</pre>
		
		<pre class="file" id="file122" style="display: none">package imagebus

import (
        "context"
        "fmt"
        "math/rand"
        "net/url"
        "time"

        "github.com/FITHSCS/backend/business/types/genstringtype"
        "github.com/google/uuid"
)

func TestGenerateNewImage(n int, manID, capbyID uuid.UUID, delexID []uuid.NullUUID) []NewImage <span class="cov5" title="2">{
        newfs := make([]NewImage, n)
        eventype := []string{"pickup", "delivery_exception", "delivery"}
        imgType := []string{"model19", "model19_descripancy", "exception"}

        CapturedAt, _ := time.Parse(time.RFC3339, "2025-06-10T15:59:33+03:00")
        timestamp := CapturedAt.Add(time.Minute + 1)

        u, _ := url.Parse("example.com/imge/url")

        idx := rand.Intn(10000)
        for i := range n </span><span class="cov10" title="4">{
                idx++

                nf := NewImage{
                        ManifestID:  manID,
                        CapturedBy:  capbyID,
                        ExceptionID: delexID[i%2],
                        EventType:   genstringtype.MustParse(eventype[i%6]),
                        ImageType:   genstringtype.MustParse(imgType[i%6]),
                        ImageURL:    u,
                        ImageHash:   genstringtype.MustParse("imagehash3242342gegfqrefviopqruqv8903prv9w"),
                        IsSynced:    true,
                        TimeStamp:   timestamp,
                }

                newfs[i] = nf
        }</span>

        <span class="cov5" title="2">return newfs</span>
}

func TestGenerateSeedImage(ctx context.Context, n int, api *Business, manID, capbyID uuid.UUID, delexID []uuid.NullUUID) ([]Image, error) <span class="cov5" title="2">{
        newfs := TestGenerateNewImage(n, manID, capbyID, delexID)

        facs := make([]Image, len(newfs))
        for i, np := range newfs </span><span class="cov10" title="4">{
                prd, err := api.Create(ctx, np)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("seeding image: idx: %d : %w", i, err)
                }</span>

                <span class="cov10" title="4">facs[i] = prd</span>
        }

        <span class="cov5" title="2">return facs, nil</span>
}
</pre>
		
		<pre class="file" id="file123" style="display: none">// Package manifestbus provides business access to packagedetail domain.
package manifestbus

import (
        "context"
        "errors"
        "fmt"
        "time"

        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/google/uuid"
)

var (
        ErrNotFound       = errors.New("pickupbatch not found")
        ErrAuthentication = errors.New("authentication failed")
)

type Storer interface {
        Create(ctx context.Context, manifest Manifest) error
        Update(ctx context.Context, manifest Manifest) error
        SoftDelete(ctx context.Context, manifestID uuid.UUID) error
        HardDelete(ctx context.Context, manifestID uuid.UUID) error
        Query(ctx context.Context, filter QueryFilter, orderby order.By, page page.Page) ([]Manifest, error)
        QueryByID(ctx context.Context, manifestID uuid.UUID) (Manifest, error)
        Count(ctx context.Context, filter QueryFilter) (int, error)
}

func (b *Business) GetStorer() Storer <span class="cov0" title="0">{
        return b.storer
}</span>

type Business struct {
        log    *logger.Logger
        storer Storer
}

func NewBusiness(log *logger.Logger, storer Storer) *Business <span class="cov1" title="1">{

        return &amp;Business{
                log:    log,
                storer: storer,
        }
}</span>

func (b *Business) Create(ctx context.Context, nm NewManifest) (Manifest, error) <span class="cov10" title="5">{

        now := time.Now().Truncate(time.Millisecond)

        manifest := Manifest{
                ID:                    uuid.New(),
                PickupBatchID:         nm.PickupBatchID,
                OriginFacilityID:      nm.OriginFacilityID,
                DestinationFacilityID: nm.DestinationFacilityID,
                OrderID:               nm.OrderID,
                DeliveryID:            nm.DeliveryID,
                Status:                nm.Status,
                ItemsSummary:          nm.ItemsSummary,
                PickupTime:            nm.PickupTime,
                DeliveryTime:          nm.DeliveryTime,
                IsDeleted:             false,
                IsSynced:              nm.IsSynced,
                TimeStamp:             now,
                CreatedAt:             now,
                UpdatedAt:             now,
        }

        if err := b.storer.Create(ctx, manifest); err != nil </span><span class="cov0" title="0">{
                return Manifest{}, fmt.Errorf("Create: %w", err)
        }</span>
        <span class="cov10" title="5">return manifest, nil</span>
}

func (b *Business) Update(ctx context.Context, pickupBatchID uuid.UUID, updatemanifest UpdateManifest) (Manifest, error) <span class="cov1" title="1">{

        mnfstOrgnl, err := b.storer.QueryByID(ctx, pickupBatchID)
        if err != nil </span><span class="cov0" title="0">{
                return Manifest{}, fmt.Errorf("querybyid: %w", err)
        }</span>

        <span class="cov1" title="1">if updatemanifest.PickupBatchID != nil </span><span class="cov1" title="1">{
                mnfstOrgnl.PickupBatchID = *updatemanifest.PickupBatchID
        }</span>

        <span class="cov1" title="1">if updatemanifest.OriginFacilityID != nil </span><span class="cov1" title="1">{
                mnfstOrgnl.OriginFacilityID = *updatemanifest.OriginFacilityID
        }</span>

        <span class="cov1" title="1">if updatemanifest.OrderID != nil </span><span class="cov1" title="1">{
                mnfstOrgnl.OrderID = *updatemanifest.OrderID
        }</span>

        <span class="cov1" title="1">if updatemanifest.DeliveryID != nil </span><span class="cov1" title="1">{
                mnfstOrgnl.DeliveryID = *updatemanifest.DeliveryID
        }</span>

        <span class="cov1" title="1">if updatemanifest.Status != nil </span><span class="cov1" title="1">{
                mnfstOrgnl.Status = *updatemanifest.Status
        }</span>

        <span class="cov1" title="1">if updatemanifest.ItemsSummary != nil </span><span class="cov1" title="1">{
                mnfstOrgnl.ItemsSummary = *updatemanifest.ItemsSummary
        }</span>

        <span class="cov1" title="1">if updatemanifest.PickupTime != nil </span><span class="cov1" title="1">{
                mnfstOrgnl.PickupTime = *updatemanifest.PickupTime
        }</span>

        <span class="cov1" title="1">if updatemanifest.DeliveryTime != nil </span><span class="cov1" title="1">{
                mnfstOrgnl.DeliveryTime = *updatemanifest.DeliveryTime
        }</span>

        <span class="cov1" title="1">if updatemanifest.TimeStamp != nil </span><span class="cov1" title="1">{
                mnfstOrgnl.TimeStamp = *updatemanifest.TimeStamp
        }</span>

        <span class="cov1" title="1">if updatemanifest.IsSynced != nil </span><span class="cov1" title="1">{
                mnfstOrgnl.IsSynced = *updatemanifest.IsSynced
        }</span>

        <span class="cov1" title="1">mnfstOrgnl.UpdatedAt = time.Now().Truncate(time.Microsecond)

        if err := b.storer.Update(ctx, mnfstOrgnl); err != nil </span><span class="cov0" title="0">{
                return Manifest{}, fmt.Errorf("update: %w", err)
        }</span>

        <span class="cov1" title="1">return mnfstOrgnl, nil</span>
}

func (b *Business) Query(ctx context.Context, filter QueryFilter, orderBy order.By, page page.Page) ([]Manifest, error) <span class="cov1" title="1">{
        manifests, err := b.storer.Query(ctx, filter, orderBy, page)

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Query: %w", err)
        }</span>
        <span class="cov1" title="1">return manifests, nil</span>
}
func (b *Business) Count(ctx context.Context, filter QueryFilter) (int, error) <span class="cov0" title="0">{
        return b.storer.Count(ctx, filter)
}</span>

func (b *Business) QueryByID(ctx context.Context, pickupBatchID uuid.UUID) (Manifest, error) <span class="cov1" title="1">{

        pickupbatch, err := b.storer.QueryByID(ctx, pickupBatchID)
        if err != nil </span><span class="cov0" title="0">{
                return Manifest{}, fmt.Errorf("query: pickupbatchID[%s]: %w", pickupBatchID, err)
        }</span>
        <span class="cov1" title="1">return pickupbatch, nil</span>
}

func (b *Business) SoftDelete(ctx context.Context, pickupBatchID uuid.UUID) error <span class="cov4" title="2">{
        facility, err := b.storer.QueryByID(ctx, pickupBatchID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("softdeletequery: manifestID[%s]: %w", pickupBatchID, err)
        }</span>
        <span class="cov4" title="2">if facility.IsDeleted </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: already deleted", pickupBatchID)
        }</span>

        <span class="cov4" title="2">if err := b.storer.SoftDelete(ctx, pickupBatchID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("delete: %w", err)
        }</span>

        <span class="cov4" title="2">return nil</span>
}

func (b *Business) HardDelete(ctx context.Context, pickupBatchID uuid.UUID) error <span class="cov4" title="2">{

        if err := b.storer.HardDelete(ctx, pickupBatchID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("delete: %w", err)
        }</span>
        <span class="cov4" title="2">return nil</span>

}
</pre>
		
		<pre class="file" id="file124" style="display: none">package manifestdb

import (
        "bytes"
        "strings"

        "github.com/FITHSCS/backend/business/domain/manifestbus"
)

func applyFilter(filter manifestbus.QueryFilter, data map[string]any, buf *bytes.Buffer) <span class="cov0" title="0">{

        var wc []string

        if filter.ManifestID != nil </span><span class="cov0" title="0">{
                data["manifest_id"] = &amp;filter.ManifestID
                wc = append(wc, "manifest_id = :manifest_id")
        }</span>

        <span class="cov0" title="0">if len(wc) &gt; 0 </span><span class="cov0" title="0">{
                buf.WriteString(" WHERE ")
                buf.WriteString(strings.Join(wc, " AND "))
        }</span>
}
</pre>
		
		<pre class="file" id="file125" style="display: none">// Package manifestdb contains product related CRUD functionality.
package manifestdb

import (
        "bytes"
        "context"
        "errors"
        "fmt"

        "github.com/FITHSCS/backend/business/domain/manifestbus"
        "github.com/FITHSCS/backend/business/domain/pickupbatchbus"
        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/business/sdk/sqldb"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/google/uuid"
        "github.com/jmoiron/sqlx"
)

type Store struct {
        log *logger.Logger
        db  sqlx.ExtContext
}

func NewStore(log *logger.Logger, db *sqlx.DB) *Store <span class="cov0" title="0">{
        return &amp;Store{log: log, db: db}
}</span>

func (s *Store) Create(ctx context.Context, p manifestbus.Manifest) error <span class="cov0" title="0">{
        const stmt = `
    INSERT INTO manifest (
            manifest_id, 
                pickup_batch_id,
                origin_facility_id,
                destination_facility_id, 
            order_id,
                delivery_id,
                status,
                items_summary,
                pickup_time,
                delivery_time,
            is_synced, 
                is_deleted,
                time_stamp, 
            created_at,
                updated_at 
    ) 
        VALUES (
            :manifest_id, 
                :pickup_batch_id, 
                :origin_facility_id,
                :destination_facility_id, 
            :order_id, 
                :delivery_id,
                :status,
                :items_summary,
                :pickup_time,
                :delivery_time,
            :is_synced, 
                :is_deleted,
                :time_stamp, 
            :created_at, 
                :updated_at
    )`
        returnedValue, err := toDBManifest(p)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return sqldb.NamedExecContext(ctx, s.log, s.db, stmt, returnedValue)</span>
}

func (s *Store) Update(ctx context.Context, p manifestbus.Manifest) error <span class="cov0" title="0">{
        const stmt = `
    UPDATE 
                manifest
    SET 
                pickup_batch_id              = :pickup_batch_id,
        origin_facility_id           = :origin_facility_id,
        destination_facility_id      = :destination_facility_id,
        order_id                                 = :order_id,
        delivery_id                           = :delivery_id,
        status                                    = :status,
                items_summary                                   = :items_summary,
                pickup_time                                   = :pickup_time,
                delivery_time                                   = :delivery_time,
        is_synced                    = :is_synced,
        is_deleted                   = :is_deleted,
        time_stamp                   = :time_stamp,
        updated_at                   = :updated_at
    WHERE 
                manifest_id                             = :manifest_id`

        returnedValue, err := toDBManifest(p)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return sqldb.NamedExecContext(ctx, s.log, s.db, stmt, returnedValue)</span>
}

func (s *Store) Query(ctx context.Context,
        filter manifestbus.QueryFilter, orderBy order.By, page page.Page) ([]manifestbus.Manifest, error) <span class="cov0" title="0">{

        data := map[string]any{
                "offset":        (page.Number() - 1) * page.RowsPerPage(),
                "rows_per_page": page.RowsPerPage(),
        }

        const q = `
    SELECT
                manifest_id,
            pickup_batch_id,
                origin_facility_id,
                destination_facility_id, 
            order_id,
                delivery_id,
                status,
                items_summary,
                pickup_time,
                delivery_time,
            is_synced, 
                is_deleted,
                time_stamp, 
            created_at,
                updated_at 
    FROM 
                manifest        `

        var buf bytes.Buffer
        buf.WriteString(q)
        applyFilter(filter, data, &amp;buf)

        clause, err := orderByClause(orderBy)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">buf.WriteString(clause)
        buf.WriteString(" OFFSET :offset ROWS FETCH NEXT :rows_per_page ROWS ONLY")

        var dbRecs []manifestdb
        if err := sqldb.NamedQuerySlice(ctx, s.log, s.db, buf.String(), data, &amp;dbRecs); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("namedqueryslice: %w", err)
        }</span>
        <span class="cov0" title="0">fmt.Println(dbRecs)
        return toBusManifests(dbRecs)</span>
}

func (s *Store) Count(ctx context.Context, filter manifestbus.QueryFilter) (int, error) <span class="cov0" title="0">{
        data := map[string]any{}
        const base = `SELECT count(1) FROM manifest`

        var buf bytes.Buffer
        buf.WriteString(base)
        applyFilter(filter, data, &amp;buf)

        var out struct {
                Count int `db:"count"`
        }
        if err := sqldb.NamedQueryStruct(ctx, s.log, s.db, buf.String(), data, &amp;out); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("db: %w", err)
        }</span>
        <span class="cov0" title="0">return out.Count, nil</span>
}

func (s *Store) QueryByID(ctx context.Context, manifestID uuid.UUID) (manifestbus.Manifest, error) <span class="cov0" title="0">{
        param := map[string]any{
                "manifest_id": manifestID.String(),
        }
        const stmt = `
    SELECT
            manifest_id,
            pickup_batch_id,
                origin_facility_id,
                destination_facility_id, 
            order_id,
                delivery_id,
                status,
                items_summary,
                pickup_time,
                delivery_time,
            is_synced, 
                is_deleted,
                time_stamp, 
            created_at,
                updated_at 
        FROM 
                  manifest
        WHERE 
                  manifest_id = :manifest_id`

        var rec manifestdb
        if err := sqldb.NamedQueryStruct(ctx, s.log, s.db, stmt, param, &amp;rec); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sqldb.ErrDBNotFound) </span><span class="cov0" title="0">{
                        return manifestbus.Manifest{}, fmt.Errorf("db: %w", pickupbatchbus.ErrNotFound)
                }</span>
                <span class="cov0" title="0">return manifestbus.Manifest{}, fmt.Errorf("db: %w", err)</span>
        }
        <span class="cov0" title="0">return toBusManifest(rec)</span>
}

func (s *Store) SoftDelete(ctx context.Context, manifestID uuid.UUID) error <span class="cov0" title="0">{

        const q = `
    UPDATE
        manifest
        SET
                is_deleted = :is_deleted
    WHERE
        manifest_id = :manifest_id`

        manifest := manifestdb{ID: manifestID, IsDeleted: true}

        if err := sqldb.NamedExecContext(ctx, s.log, s.db, q, manifest); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("namedexeccontext: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *Store) HardDelete(ctx context.Context, manifestID uuid.UUID) error <span class="cov0" title="0">{
        const q = `
    DELETE FROM
        manifest
    WHERE
        manifest_id = :manifest_id`

        manifest := manifestdb{ID: manifestID}

        if err := sqldb.NamedExecContext(ctx, s.log, s.db, q, manifest); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("namedexeccontext: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file126" style="display: none">package manifestdb

import (
        "encoding/json"
        "fmt"
        "time"

        "github.com/FITHSCS/backend/business/domain/manifestbus"
        "github.com/FITHSCS/backend/business/types/genstringtype"
        "github.com/google/uuid"
        "github.com/jmoiron/sqlx/types"
)

type manifestdb struct {
        ID                    uuid.UUID          `db:"manifest_id"`
        PickupBatchID         uuid.UUID          `db:"pickup_batch_id"`
        OriginFacilityID      uuid.UUID          `db:"origin_facility_id"`
        DestinationFacilityID uuid.UUID          `db:"destination_facility_id"`
        OrderID               string             `db:"order_id"`
        DeliveryID            string             `db:"delivery_id"`
        Status                string             `db:"status"`
        ItemsSummary          types.NullJSONText `db:"items_summary"`
        PickupTime            time.Time          `db:"pickup_time"`
        DeliveryTime          time.Time          `db:"delivery_time"`
        IsSynced              bool               `db:"is_synced"`
        IsDeleted             bool               `db:"is_deleted"`
        TimeStamp             time.Time          `db:"time_stamp"`
        CreatedAt             time.Time          `db:"created_at"`
        UpdatedAt             time.Time          `db:"updated_at"`
}

func toDBManifest(bus manifestbus.Manifest) (manifestdb, error) <span class="cov0" title="0">{

        pkpBatch := manifestdb{
                ID:                    bus.ID,
                PickupBatchID:         bus.PickupBatchID,
                OriginFacilityID:      bus.OriginFacilityID,
                DestinationFacilityID: bus.DestinationFacilityID,
                OrderID:               bus.OrderID.String(),
                DeliveryID:            bus.DeliveryID.String(),
                Status:                bus.Status.String(),
                ItemsSummary:          types.NullJSONText{JSONText: []byte(bus.ItemsSummary), Valid: true},
                PickupTime:            bus.PickupTime.UTC(),
                DeliveryTime:          bus.DeliveryTime.UTC(),
                IsSynced:              bus.IsSynced,
                IsDeleted:             bus.IsDeleted,
                TimeStamp:             bus.TimeStamp.UTC(),
                CreatedAt:             bus.CreatedAt.UTC(),
                UpdatedAt:             bus.UpdatedAt.UTC(),
        }

        return pkpBatch, nil
}</span>

func toBusManifest(db manifestdb) (manifestbus.Manifest, error) <span class="cov0" title="0">{

        OrdrID, err := genstringtype.Parse(db.OrderID)
        if err != nil </span><span class="cov0" title="0">{
                return manifestbus.Manifest{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">dlvryID, err := genstringtype.Parse(db.DeliveryID)
        if err != nil </span><span class="cov0" title="0">{
                return manifestbus.Manifest{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">sts, err := genstringtype.Parse(db.Status)
        if err != nil </span><span class="cov0" title="0">{
                return manifestbus.Manifest{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">bus := manifestbus.Manifest{
                ID:                    db.ID,
                PickupBatchID:         db.PickupBatchID,
                OriginFacilityID:      db.OriginFacilityID,
                DestinationFacilityID: db.DestinationFacilityID,
                OrderID:               OrdrID,
                DeliveryID:            dlvryID,
                Status:                sts,
                ItemsSummary:          json.RawMessage(db.ItemsSummary.JSONText),
                PickupTime:            db.PickupTime.In(time.Local),
                DeliveryTime:          db.DeliveryTime.In(time.Local),
                IsDeleted:             db.IsDeleted,
                IsSynced:              db.IsSynced,
                TimeStamp:             db.TimeStamp.In(time.Local),
                CreatedAt:             db.CreatedAt.In(time.Local),
                UpdatedAt:             db.UpdatedAt.In(time.Local),
        }
        return bus, nil</span>

}

func toBusManifests(dbs []manifestdb) ([]manifestbus.Manifest, error) <span class="cov0" title="0">{
        bus := make([]manifestbus.Manifest, len(dbs))

        for i, db := range dbs </span><span class="cov0" title="0">{
                var err error
                bus[i], err = toBusManifest(db)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">return bus, nil</span>
}
</pre>
		
		<pre class="file" id="file127" style="display: none">package manifestdb

import (
        "fmt"

        "github.com/FITHSCS/backend/business/domain/manifestbus"
        "github.com/FITHSCS/backend/business/sdk/order"
)

var orderByFields = map[string]string{
        manifestbus.OrderByID:             "manifest_id",
        manifestbus.OrderByRouteID:        "route_id",
        manifestbus.OrderByOriginFacility: "origin_facility_id",
        manifestbus.OrderByIsSynced:       "is_synced",
        manifestbus.OrderByTimeStamp:      "time_stamp",
        manifestbus.OrderByCreatedAt:      "created_at",
        manifestbus.OrderByUpdatedAt:      "updated_at",
}

// orderByClause converts an order.By value into the final
// " ORDER BY  ASC|DESC" fragment the store adds to its SELECT.
func orderByClause(ob order.By) (string, error) <span class="cov0" title="0">{
        col, ok := orderByFields[ob.Field]
        if !ok </span><span class="cov0" title="0">{
                return "", fmt.Errorf("field %q does not exist", ob.Field)
        }</span>
        <span class="cov0" title="0">return " ORDER BY " + col + " " + ob.Direction, nil</span>
}
</pre>
		
		<pre class="file" id="file128" style="display: none">package manifestbus

import (
        "context"
        "encoding/json"
        "fmt"
        "math/rand"
        "time"

        "github.com/FITHSCS/backend/business/types/genstringtype"
        "github.com/google/uuid"
)

func TestGenerateNewManifest(n int, pickupBatchID, origFacID, destFacID uuid.UUID) []NewManifest <span class="cov5" title="2">{
        newfs := make([]NewManifest, n)
        sts := []string{"pending", "picked_up", "in_transit", "delivered", "exception"}

        pickupTime, _ := time.Parse(time.RFC3339, "2025-06-10T15:59:33+03:00")
        delTime := pickupTime.Add(time.Hour * 10)
        timestamp := pickupTime.Add(time.Minute + 1)

        idx := rand.Intn(10000)
        for i := range n </span><span class="cov10" title="4">{
                idx++

                jsonString := fmt.Sprintf(`{
                            "total_items": %d,
                            "total_weight_kg": %.2f,
                            "items": 
                                        {
                                        "Code": %d,
                                        "Type": %d
                                        },
                            "contains_fragile": %t
                }`, (i+1)*5, rand.Float64()*20, (i+1)*2, (i+1)*3, i%2 == 0)

                itemsSummaryJSON := json.RawMessage(jsonString)

                nf := NewManifest{
                        PickupBatchID:         pickupBatchID,
                        OriginFacilityID:      origFacID,
                        DestinationFacilityID: destFacID,
                        OrderID:               genstringtype.MustParse(fmt.Sprintf("OrderID:%d", idx)),
                        DeliveryID:            genstringtype.MustParse(fmt.Sprintf("DeliveryID:%d", idx)),
                        Status:                genstringtype.MustParse(sts[i%5]),
                        ItemsSummary:          itemsSummaryJSON,
                        PickupTime:            pickupTime,
                        DeliveryTime:          delTime,
                        IsSynced:              false,
                        TimeStamp:             timestamp,
                }

                newfs[i] = nf
        }</span>

        <span class="cov5" title="2">return newfs</span>
}

func TestGenerateSeedManifest(ctx context.Context, n int, api *Business, pickupBatchID, origFacID, destFacID uuid.UUID) ([]Manifest, error) <span class="cov5" title="2">{
        newfs := TestGenerateNewManifest(n, pickupBatchID, origFacID, destFacID)

        facs := make([]Manifest, len(newfs))
        for i, np := range newfs </span><span class="cov10" title="4">{
                prd, err := api.Create(ctx, np)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("seeding pickupbatch: idx: %d : %w", i, err)
                }</span>

                <span class="cov10" title="4">facs[i] = prd</span>
        }

        <span class="cov5" title="2">return facs, nil</span>
}
</pre>
		
		<pre class="file" id="file129" style="display: none">// Package pickupbatchbus provides business access to packagedetail domain.
package pickupbatchbus

import (
        "context"
        "errors"
        "fmt"

        "time"

        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/google/uuid"
)

var (
        ErrNotFound       = errors.New("pickupbatch not found")
        ErrAuthentication = errors.New("authentication failed")
)

type Storer interface {
        Create(ctx context.Context, pickupbatch PickupBatch) error
        Update(ctx context.Context, pickupbatch PickupBatch) error
        SoftDelete(ctx context.Context, pickupBatchID uuid.UUID) error
        HardDelete(ctx context.Context, pickupBatchID uuid.UUID) error
        Query(ctx context.Context, filter QueryFilter, orderby order.By, page page.Page) ([]PickupBatch, error)
        QueryByID(ctx context.Context, pickupBatchID uuid.UUID) (PickupBatch, error)
        Count(ctx context.Context, filter QueryFilter) (int, error)
}

func (b *Business) GetStorer() Storer <span class="cov0" title="0">{
        return b.storer
}</span>

type Business struct {
        log    *logger.Logger
        storer Storer
}

func NewBusiness(log *logger.Logger, storer Storer) *Business <span class="cov1" title="1">{

        return &amp;Business{
                log:    log,
                storer: storer,
        }
}</span>

func (b *Business) Create(ctx context.Context, pb NewPickupBatch) (PickupBatch, error) <span class="cov10" title="5">{

        now := time.Now()

        pickupbatch := PickupBatch{
                ID:                  uuid.New(),
                RouteID:             pb.RouteID,
                OriginFacilityID:    pb.OriginFacilityID,
                VehicleID:           pb.VehicleID,
                DeliveryPersonnelID: pb.DeliveryPersonnelID,
                BatchName:           pb.BatchName,
                BatchStatus:         pb.BatchStatus,
                PickedStartedAt:     pb.PickedStartedAt,
                PickupCompletedAt:   pb.PickupCompletedAt,
                TimeStamp:           now,
                IsDeleted:           false,
                IsSynced:            pb.IsSynced,
                CreatedAt:           now,
                UpdatedAt:           now,
        }

        if err := b.storer.Create(ctx, pickupbatch); err != nil </span><span class="cov0" title="0">{
                return PickupBatch{}, fmt.Errorf("Create: %w", err)
        }</span>

        <span class="cov10" title="5">return pickupbatch, nil</span>
}

func (b *Business) Update(ctx context.Context, pickupBatchID uuid.UUID, updatePickupbatch UpdatePickupBatch) (PickupBatch, error) <span class="cov1" title="1">{

        pkupBtchOrgnl, err := b.storer.QueryByID(ctx, pickupBatchID)
        if err != nil </span><span class="cov0" title="0">{
                return PickupBatch{}, fmt.Errorf("querybyid: %w", err)
        }</span>

        <span class="cov1" title="1">if updatePickupbatch.RouteID != nil </span><span class="cov1" title="1">{
                pkupBtchOrgnl.RouteID = *updatePickupbatch.RouteID
        }</span>

        <span class="cov1" title="1">if updatePickupbatch.OriginFacilityID != nil </span><span class="cov1" title="1">{
                pkupBtchOrgnl.OriginFacilityID = *updatePickupbatch.OriginFacilityID
        }</span>

        <span class="cov1" title="1">if updatePickupbatch.VehicleID != nil </span><span class="cov1" title="1">{
                pkupBtchOrgnl.VehicleID = *updatePickupbatch.VehicleID
        }</span>

        <span class="cov1" title="1">if updatePickupbatch.DeliveryPersonnelID != nil </span><span class="cov1" title="1">{
                pkupBtchOrgnl.DeliveryPersonnelID = *updatePickupbatch.DeliveryPersonnelID
        }</span>

        <span class="cov1" title="1">if updatePickupbatch.BatchStatus != nil </span><span class="cov1" title="1">{
                pkupBtchOrgnl.BatchStatus = *updatePickupbatch.BatchStatus
        }</span>

        <span class="cov1" title="1">if updatePickupbatch.BatchName != nil </span><span class="cov1" title="1">{
                pkupBtchOrgnl.BatchName = *updatePickupbatch.BatchName
        }</span>

        <span class="cov1" title="1">if updatePickupbatch.PickedStartedAt != nil </span><span class="cov1" title="1">{
                pkupBtchOrgnl.PickedStartedAt = *updatePickupbatch.PickedStartedAt
        }</span>

        <span class="cov1" title="1">if updatePickupbatch.PickupCompletedAt != nil </span><span class="cov1" title="1">{
                pkupBtchOrgnl.PickupCompletedAt = *updatePickupbatch.PickupCompletedAt
        }</span>

        <span class="cov1" title="1">if updatePickupbatch.TimeStamp != nil </span><span class="cov1" title="1">{
                pkupBtchOrgnl.TimeStamp = *updatePickupbatch.TimeStamp
        }</span>

        <span class="cov1" title="1">pkupBtchOrgnl.UpdatedAt = time.Now().Truncate(time.Microsecond)

        if err := b.storer.Update(ctx, pkupBtchOrgnl); err != nil </span><span class="cov0" title="0">{
                return PickupBatch{}, fmt.Errorf("update: %w", err)
        }</span>
        <span class="cov1" title="1">return pkupBtchOrgnl, nil</span>
}

func (b *Business) QueryByID(ctx context.Context, pickupBatchID uuid.UUID) (PickupBatch, error) <span class="cov1" title="1">{

        pickupbatch, err := b.storer.QueryByID(ctx, pickupBatchID)
        if err != nil </span><span class="cov0" title="0">{
                return PickupBatch{}, fmt.Errorf("query: pickupbatchID[%s]: %w", pickupBatchID, err)
        }</span>
        <span class="cov1" title="1">return pickupbatch, nil</span>
}

func (b *Business) Query(ctx context.Context, filter QueryFilter, orderBy order.By, page page.Page) ([]PickupBatch, error) <span class="cov1" title="1">{

        pickupbatches, err := b.storer.Query(ctx, filter, orderBy, page)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Query: %w", err)
        }</span>
        <span class="cov1" title="1">return pickupbatches, nil</span>
}

func (b *Business) Count(ctx context.Context, filter QueryFilter) (int, error) <span class="cov0" title="0">{

        return b.storer.Count(ctx, filter)
}</span>

func (b *Business) SoftDelete(ctx context.Context, pickupBatchID uuid.UUID) error <span class="cov4" title="2">{

        facility, err := b.storer.QueryByID(ctx, pickupBatchID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("softdeletequery: pickupBatch[%s]: %w", pickupBatchID, err)
        }</span>

        <span class="cov4" title="2">if facility.IsDeleted </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: already deleted", pickupBatchID)
        }</span>

        <span class="cov4" title="2">if err := b.storer.SoftDelete(ctx, pickupBatchID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("delete: %w", err)
        }</span>
        <span class="cov4" title="2">return nil</span>

}

func (b *Business) HardDelete(ctx context.Context, pickupBatchID uuid.UUID) error <span class="cov4" title="2">{

        if err := b.storer.HardDelete(ctx, pickupBatchID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("delete: %w", err)
        }</span>
        <span class="cov4" title="2">return nil</span>

}
</pre>
		
		<pre class="file" id="file130" style="display: none">package pickupbatchdb

import (
        "bytes"
        //"fmt"
        "strings"

        "github.com/FITHSCS/backend/business/domain/pickupbatchbus"
        "github.com/google/uuid"
)

func applyFilter(filter pickupbatchbus.QueryFilter, data map[string]any, buf *bytes.Buffer) <span class="cov0" title="0">{

        var wc []string

        if filter.ID != uuid.Nil </span><span class="cov0" title="0">{
                data["pickup_batch_id"] = &amp;filter.ID
                wc = append(wc, "pickupb_batch_id = :pickupb_batch_id")
        }</span>
        <span class="cov0" title="0">if filter.RouteID != nil </span><span class="cov0" title="0">{
                data["route_id"] = *filter.RouteID
                wc = append(wc, "route_id = :route_id")
        }</span>

        <span class="cov0" title="0">if filter.VehicleID != nil </span><span class="cov0" title="0">{
                data["vehicle_id"] = *filter.VehicleID
                wc = append(wc, "vehicle_id = :vehicle_id")
        }</span>
        <span class="cov0" title="0">if filter.OriginFacility != nil </span><span class="cov0" title="0">{
                data["origin_facility_id"] = *filter.OriginFacility
                wc = append(wc, "origin_facility_id = :origin_facility_id")
        }</span>
        <span class="cov0" title="0">if filter.DeliveryPersonnelID != nil </span><span class="cov0" title="0">{
                data["delivery_personnel_id"] = *filter.DeliveryPersonnelID
                wc = append(wc, "deliver_personnel_id = :delivery_personnel_id")
        }</span>

        <span class="cov0" title="0">if filter.DeliveryPersonnelSignature != nil </span><span class="cov0" title="0">{
                data["delivery_personnel_signature"] = *filter.DeliveryPersonnelSignature
                wc = append(wc, "deliver_personnel_signature = :delivery_personnel_signature")
        }</span>
        <span class="cov0" title="0">if filter.IsSynced != nil </span><span class="cov0" title="0">{
                data["is_synced"] = *filter.IsSynced
                wc = append(wc, "is_synced = :is_synced")
        }</span>

        <span class="cov0" title="0">if filter.IsSynced != nil </span><span class="cov0" title="0">{
                data["is_synced"] = *filter.IsSynced
                wc = append(wc, "is_synced = :is_synced")
        }</span>
        <span class="cov0" title="0">if filter.TimeStamp != nil </span><span class="cov0" title="0">{
                data["time_stamp"] = *filter.TimeStamp
                wc = append(wc, "time_stamp = :time_stamp")
        }</span>

        <span class="cov0" title="0">if filter.CreatedAt != nil </span><span class="cov0" title="0">{
                data["created_at"] = filter.CreatedAt.UTC()
                wc = append(wc, "date_created &gt;= :created_at")
        }</span>
        <span class="cov0" title="0">if filter.UpdatedAt != nil </span><span class="cov0" title="0">{
                data["updated_at"] = filter.UpdatedAt.UTC()
                wc = append(wc, "updated_at &lt;= :updated_at")
        }</span>

        <span class="cov0" title="0">if len(wc) &gt; 0 </span><span class="cov0" title="0">{
                buf.WriteString(" WHERE ")
                buf.WriteString(strings.Join(wc, " AND "))
        }</span>
}
</pre>
		
		<pre class="file" id="file131" style="display: none">package pickupbatchdb

import (
        "fmt"
        "time"

        "github.com/FITHSCS/backend/business/domain/pickupbatchbus"
        "github.com/FITHSCS/backend/business/types/genstringtype"

        "github.com/google/uuid"
)

type pickupbatch struct {
        ID                  uuid.UUID `db:"pickup_batch_id"`
        RouteID             uuid.UUID `db:"route_id"`
        OriginFacilityID    uuid.UUID `db:"origin_facility_id"`
        VehicleID           uuid.UUID `db:"vehicle_id"`
        DeliveryPersonnelID uuid.UUID `db:"delivery_personnel_id"`
        BatchName           string    `db:"batch_name"`
        BatchStatus         string    `db:"batch_status"`
        PickupStartedAt     time.Time `db:"pickup_started_at"`
        PickupCompletedAt   time.Time `db:"pickup_completed_at"`
        IsSynced            bool      `db:"is_synced"`
        IsDeleted           bool      `db:"is_deleted"`
        TimeStamp           time.Time `db:"time_stamp"`
        CreatedAt           time.Time `db:"created_at"`
        UpdatedAt           time.Time `db:"updated_at"`
}

//=============================================================================&gt;

func toDBPickupBatch(bus pickupbatchbus.PickupBatch) (pickupbatch, error) <span class="cov0" title="0">{

        pkpBatch := pickupbatch{
                ID:                  bus.ID,
                RouteID:             bus.RouteID,
                VehicleID:           bus.VehicleID,
                OriginFacilityID:    bus.OriginFacilityID,
                DeliveryPersonnelID: bus.DeliveryPersonnelID,
                BatchName:           bus.BatchName.String(),
                BatchStatus:         bus.BatchStatus.String(),
                PickupStartedAt:     bus.PickedStartedAt.UTC(),
                PickupCompletedAt:   bus.PickupCompletedAt.UTC(),
                IsSynced:            bus.IsSynced,
                IsDeleted:           bus.IsDeleted,
                TimeStamp:           bus.TimeStamp.UTC(),
                CreatedAt:           bus.CreatedAt.UTC(),
                UpdatedAt:           bus.UpdatedAt.UTC(),
        }

        return pkpBatch, nil
}</span>

func toBusPickupBatch(db pickupbatch) (pickupbatchbus.PickupBatch, error) <span class="cov0" title="0">{
        batchSts, err := genstringtype.Parse(db.BatchStatus)
        if err != nil </span><span class="cov0" title="0">{
                return pickupbatchbus.PickupBatch{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">batchName, err := genstringtype.Parse(db.BatchName)
        if err != nil </span><span class="cov0" title="0">{
                return pickupbatchbus.PickupBatch{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">bus := pickupbatchbus.PickupBatch{
                ID:                  db.ID,
                RouteID:             db.RouteID,
                OriginFacilityID:    db.OriginFacilityID,
                VehicleID:           db.VehicleID,
                DeliveryPersonnelID: db.DeliveryPersonnelID,
                BatchName:           batchName,
                BatchStatus:         batchSts,
                PickedStartedAt:     db.PickupStartedAt.In(time.Local),
                PickupCompletedAt:   db.PickupCompletedAt.In(time.Local),
                IsDeleted:           db.IsDeleted,
                IsSynced:            db.IsSynced,
                TimeStamp:           db.TimeStamp.In(time.Local),
                CreatedAt:           db.CreatedAt.In(time.Local),
                UpdatedAt:           db.UpdatedAt.In(time.Local),
        }

        return bus, nil</span>

}

func toBusPickupBatches(dbs []pickupbatch) ([]pickupbatchbus.PickupBatch, error) <span class="cov0" title="0">{

        bus := make([]pickupbatchbus.PickupBatch, len(dbs))

        for i, db := range dbs </span><span class="cov0" title="0">{
                var err error
                bus[i], err = toBusPickupBatch(db)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">return bus, nil</span>
}
</pre>
		
		<pre class="file" id="file132" style="display: none">package pickupbatchdb

import (
        "fmt"

        "github.com/FITHSCS/backend/business/domain/pickupbatchbus"
        "github.com/FITHSCS/backend/business/sdk/order"
)

var orderByFields = map[string]string{
        pickupbatchbus.OrderByID:                  "pickup_batch_id",
        pickupbatchbus.OrderByRouteID:             "route_id",
        pickupbatchbus.OrderByVehicleID:           "vehicle_id",
        pickupbatchbus.OrderByOriginFacility:      "origin_facility_id",
        pickupbatchbus.OrderByDeliveryPersonnelID: "delivery_personnel_id",
        pickupbatchbus.OrderByIsSynced:            "is_synced",
        pickupbatchbus.OrderByTimeStamp:           "time_stamp",
        pickupbatchbus.OrderByCreatedAt:           "created_at",
        pickupbatchbus.OrderByUpdatedAt:           "updated_at",
}

// orderByClause converts an order.By value into the final
// " ORDER BY  ASC|DESC" fragment the store adds to its SELECT.
func orderByClause(ob order.By) (string, error) <span class="cov0" title="0">{
        col, ok := orderByFields[ob.Field]
        if !ok </span><span class="cov0" title="0">{
                return "", fmt.Errorf("field %q does not exist", ob.Field)
        }</span>
        <span class="cov0" title="0">return " ORDER BY " + col + " " + ob.Direction, nil</span>
}
</pre>
		
		<pre class="file" id="file133" style="display: none">// Package pickupbatchdb contains product related CRUD functionality.
package pickupbatchdb

import (
        "bytes"
        "context"
        "errors"
        "fmt"

        "github.com/FITHSCS/backend/business/domain/pickupbatchbus"
        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/business/sdk/sqldb"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/google/uuid"
        "github.com/jmoiron/sqlx"
)

type Store struct {
        log *logger.Logger
        db  sqlx.ExtContext
}

func NewStore(log *logger.Logger, db *sqlx.DB) *Store <span class="cov0" title="0">{
        return &amp;Store{log: log, db: db}
}</span>

func (s *Store) Create(ctx context.Context, p pickupbatchbus.PickupBatch) error <span class="cov0" title="0">{
        const stmt = `
    INSERT INTO pickup_batch (
            pickup_batch_id, 
                route_id,
                origin_facility_id,
                vehicle_id, 
            delivery_personnel_id,
                batch_name,
                batch_status,
                pickup_started_at,
                pickup_completed_at,
            is_synced, 
                is_deleted,
                time_stamp, 
            created_at,
                updated_at 
    ) 
        VALUES (
            :pickup_batch_id, 
                :route_id, 
                :origin_facility_id,
                :vehicle_id, 
            :delivery_personnel_id, 
                :batch_name,
                :batch_status,
                :pickup_started_at,
                :pickup_completed_at,
            :is_synced, 
                :is_deleted,
                :time_stamp, 
            :created_at, 
                :updated_at
    )`
        returnedValue, err := toDBPickupBatch(p)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return sqldb.NamedExecContext(ctx, s.log, s.db, stmt, returnedValue)</span>
}

func (s *Store) Update(ctx context.Context, p pickupbatchbus.PickupBatch) error <span class="cov0" title="0">{
        const stmt = `
    UPDATE 
                pickup_batch
    SET 
                route_id                     = :route_id,
        origin_facility_id           = :origin_facility_id,
        vehicle_id                   = :vehicle_id,
        delivery_personnel_id        = :delivery_personnel_id,
        batch_name                           = :batch_name,
        batch_status                           = :batch_status,
                pickup_started_at                          = :pickup_started_at,
                pickup_completed_at                  = :pickup_completed_at,
        is_synced                    = :is_synced,
        is_deleted                   = :is_deleted,
        time_stamp                   = :time_stamp,
        updated_at                   = :updated_at
    WHERE pickup_batch_id            = :pickup_batch_id`

        returnedValue, err := toDBPickupBatch(p)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return sqldb.NamedExecContext(ctx, s.log, s.db, stmt, returnedValue)</span>
}

func (s *Store) Query(ctx context.Context,
        filter pickupbatchbus.QueryFilter, orderBy order.By, page page.Page) ([]pickupbatchbus.PickupBatch, error) <span class="cov0" title="0">{

        data := map[string]any{
                "offset":        (page.Number() - 1) * page.RowsPerPage(),
                "rows_per_page": page.RowsPerPage(),
        }

        const q = `
    SELECT
      pickup_batch_id,
          route_id, 
          origin_facility_id, 
          vehicle_id,
          delivery_personnel_id,
      batch_name,
          batch_status,
          pickup_started_at,
          pickup_completed_at, 
          is_synced,
          is_deleted,
          time_stamp,
      created_at, 
          updated_at
    FROM pickup_batch`

        var buf bytes.Buffer
        buf.WriteString(q)
        applyFilter(filter, data, &amp;buf)

        clause, err := orderByClause(orderBy)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">buf.WriteString(clause)
        buf.WriteString(" OFFSET :offset ROWS FETCH NEXT :rows_per_page ROWS ONLY")

        var dbRecs []pickupbatch
        if err := sqldb.NamedQuerySlice(ctx, s.log, s.db, buf.String(), data, &amp;dbRecs); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("namedqueryslice: %w", err)
        }</span>
        <span class="cov0" title="0">fmt.Println(dbRecs)
        return toBusPickupBatches(dbRecs)</span>
}

func (s *Store) QueryByID(ctx context.Context, pkupBatchID uuid.UUID) (pickupbatchbus.PickupBatch, error) <span class="cov0" title="0">{
        param := map[string]any{
                "pickup_batch_id": pkupBatchID.String(),
        }
        const stmt = `
    SELECT
            pickup_batch_id,
                  route_id, 
                  origin_facility_id, 
                vehicle_id,
                  delivery_personnel_id,
              batch_name,
                  batch_status,
                  pickup_started_at,
                  pickup_completed_at,
                  is_synced,
                  is_deleted,
                  time_stamp,
              created_at, 
                  updated_at
        FROM 
                  pickup_batch
        WHERE 
                  pickup_batch_id = :pickup_batch_id`

        var rec pickupbatch
        if err := sqldb.NamedQueryStruct(ctx, s.log, s.db, stmt, param, &amp;rec); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sqldb.ErrDBNotFound) </span><span class="cov0" title="0">{
                        return pickupbatchbus.PickupBatch{}, fmt.Errorf("db: %w", pickupbatchbus.ErrNotFound)
                }</span>
                <span class="cov0" title="0">return pickupbatchbus.PickupBatch{}, fmt.Errorf("db: %w", err)</span>
        }
        <span class="cov0" title="0">return toBusPickupBatch(rec)</span>
}

func (s *Store) Count(ctx context.Context, filter pickupbatchbus.QueryFilter) (int, error) <span class="cov0" title="0">{
        data := map[string]any{}
        const base = `SELECT count(1) FROM pickup_batch`

        var buf bytes.Buffer
        buf.WriteString(base)
        applyFilter(filter, data, &amp;buf)

        var out struct {
                Count int `db:"count"`
        }
        if err := sqldb.NamedQueryStruct(ctx, s.log, s.db, buf.String(), data, &amp;out); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("db: %w", err)
        }</span>
        <span class="cov0" title="0">return out.Count, nil</span>
}

func (s *Store) SoftDelete(ctx context.Context, pickupBatchID uuid.UUID) error <span class="cov0" title="0">{

        const q = `
    UPDATE
        pickup_batch
        SET
                is_deleted = :is_deleted
    WHERE
        pickup_batch_id = :pickup_batch_id`

        dbPickupBatch := pickupbatch{ID: pickupBatchID, IsDeleted: true}

        if err := sqldb.NamedExecContext(ctx, s.log, s.db, q, dbPickupBatch); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("namedexeccontext: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *Store) HardDelete(ctx context.Context, pickupBatchID uuid.UUID) error <span class="cov0" title="0">{
        const q = `
    DELETE FROM
        pickup_batch
    WHERE
        pickup_batch_id = :pickup_batch_id`

        dbPickupBatch := pickupbatch{ID: pickupBatchID}

        if err := sqldb.NamedExecContext(ctx, s.log, s.db, q, dbPickupBatch); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("namedexeccontext: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file134" style="display: none">package pickupbatchbus

import (
        "context"
        "fmt"
        "math/rand"
        "time"

        "github.com/FITHSCS/backend/business/types/genstringtype"
        "github.com/google/uuid"
)

func TestGenerateNewPickupBatch(n int, routeID, deliveryPersonnelID, OrigfacID, VehID uuid.UUID) []NewPickupBatch <span class="cov5" title="2">{
        newfs := make([]NewPickupBatch, n)
        sts := []string{"pending", "picked_up", "in_transit", "delivered"}

        pickupTime, _ := time.Parse(time.RFC3339, "2025-06-10T15:59:33+03:00")
        CompTime := pickupTime.Add(time.Hour * 10)
        timestamp := pickupTime.Add(time.Minute + 1)

        idx := rand.Intn(10000)
        for i := range n </span><span class="cov10" title="4">{
                idx++

                nf := NewPickupBatch{
                        RouteID:             routeID,
                        DeliveryPersonnelID: deliveryPersonnelID,
                        OriginFacilityID:    OrigfacID,
                        VehicleID:           VehID,
                        BatchName:           genstringtype.MustParse(fmt.Sprintf("BatchName%d", idx)),
                        BatchStatus:         genstringtype.MustParse(sts[i%2]),
                        PickedStartedAt:     pickupTime,
                        PickupCompletedAt:   CompTime,
                        IsSynced:            true,
                        IsDeleted:           false,
                        TimeStamp:           timestamp,
                }

                newfs[i] = nf
        }</span>

        <span class="cov5" title="2">return newfs</span>
}

func TestGenerateSeedPickupBatch(ctx context.Context, n int, api *Business, routeID, deliveryPersonnelID, OrigfacID, VehID uuid.UUID) ([]PickupBatch, error) <span class="cov5" title="2">{
        newfs := TestGenerateNewPickupBatch(n, routeID, deliveryPersonnelID, OrigfacID, VehID)

        facs := make([]PickupBatch, len(newfs))
        for i, np := range newfs </span><span class="cov10" title="4">{
                prd, err := api.Create(ctx, np)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("seeding pickupbatch: idx: %d : %w", i, err)
                }</span>

                <span class="cov10" title="4">facs[i] = prd</span>
        }

        <span class="cov5" title="2">return facs, nil</span>
}
</pre>
		
		<pre class="file" id="file135" style="display: none">// Package routebus provides business access to route domain.
package routebus

import (
        "context"
        "fmt"
        "time"

        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/google/uuid"
)

type Storer interface {
        Create(ctx context.Context, route Route) error
        Update(ctx context.Context, route Route) error
        Delete(ctx context.Context, routeID uuid.UUID) error
        Query(ctx context.Context, filter QueryFilter, orderby order.By, page page.Page) ([]Route, error)
        QueryByID(ctx context.Context, routeID uuid.UUID) (Route, error)
        Count(ctx context.Context, filter QueryFilter) (int, error)
}

func (b *Business) GetStorer() Storer <span class="cov0" title="0">{
        return b.storer
}</span>

type Business struct {
        log    *logger.Logger
        storer Storer
}

func NewBusiness(log *logger.Logger, storer Storer) *Business <span class="cov1" title="1">{
        return &amp;Business{
                log:    log,
                storer: storer,
        }
}</span>

func (b *Business) Create(ctx context.Context, pb NewRoute) (Route, error) <span class="cov10" title="5">{

        now := time.Now().Truncate(time.Millisecond)

        route := Route{
                RouteID:         uuid.New(),
                StartFacilityID: pb.StartFacilityID,
                EndFacilityID:   pb.EndFacilityID,
                RouteName:       pb.RouteName,
                TotalKM:         pb.TotalKM,
                TotalStops:      pb.TotalStops,
                StartLatitude:   pb.StartLatitude,
                StartLongitude:  pb.StartLongitude,
                EndLatitude:     pb.EndLatitude,
                EndLongitude:    pb.EndLongitude,
                IsActive:        true,
                CreatedAt:       now,
                UpdatedAt:       now,
        }

        if err := b.storer.Create(ctx, route); err != nil </span><span class="cov0" title="0">{
                return Route{}, fmt.Errorf("Create: %w", err)
        }</span>

        <span class="cov10" title="5">return route, nil</span>
}

func (b *Business) Update(ctx context.Context, routeID uuid.UUID, updrte UpdateRoute) (Route, error) <span class="cov1" title="1">{

        rteOrig, err := b.storer.QueryByID(ctx, routeID)
        if err != nil </span><span class="cov0" title="0">{
                return Route{}, fmt.Errorf("querybyid: %w", err)
        }</span>

        <span class="cov1" title="1">if updrte.StartFacilityID != nil </span><span class="cov1" title="1">{
                rteOrig.StartFacilityID = *updrte.StartFacilityID
        }</span>

        <span class="cov1" title="1">if updrte.EndFacilityID != nil </span><span class="cov1" title="1">{
                rteOrig.EndFacilityID = *updrte.EndFacilityID
        }</span>

        <span class="cov1" title="1">if updrte.RouteName != nil </span><span class="cov1" title="1">{
                rteOrig.RouteName = *updrte.RouteName
        }</span>

        <span class="cov1" title="1">if updrte.TotalKM != nil </span><span class="cov1" title="1">{
                rteOrig.TotalKM = *updrte.TotalKM
        }</span>

        <span class="cov1" title="1">if updrte.TotalStops != nil </span><span class="cov1" title="1">{
                rteOrig.TotalStops = *updrte.TotalStops
        }</span>

        <span class="cov1" title="1">if updrte.StartLatitude != nil </span><span class="cov1" title="1">{
                rteOrig.StartLatitude = *updrte.StartLatitude
        }</span>

        <span class="cov1" title="1">if updrte.StartLongitude != nil </span><span class="cov1" title="1">{
                rteOrig.StartLongitude = *updrte.StartLongitude
        }</span>

        <span class="cov1" title="1">if updrte.EndLatitude != nil </span><span class="cov1" title="1">{
                rteOrig.EndLatitude = *updrte.EndLatitude
        }</span>

        <span class="cov1" title="1">if updrte.EndLongitude != nil </span><span class="cov1" title="1">{
                rteOrig.EndLongitude = *updrte.EndLongitude
        }</span>

        <span class="cov1" title="1">rteOrig.UpdatedAt = time.Now().Truncate(time.Microsecond)

        if err := b.storer.Update(ctx, rteOrig); err != nil </span><span class="cov0" title="0">{
                return Route{}, fmt.Errorf("update: %w", err)
        }</span>
        <span class="cov1" title="1">return rteOrig, nil</span>
}

func (b *Business) QueryByID(ctx context.Context, routeID uuid.UUID) (Route, error) <span class="cov1" title="1">{

        rte, err := b.storer.QueryByID(ctx, routeID)
        if err != nil </span><span class="cov0" title="0">{
                return Route{}, fmt.Errorf("query: routeid[%s]: %w", routeID, err)
        }</span>
        <span class="cov1" title="1">return rte, nil</span>
}

func (b *Business) Query(ctx context.Context, filter QueryFilter, orderBy order.By, page page.Page) ([]Route, error) <span class="cov1" title="1">{
        rtebtch, err := b.storer.Query(ctx, filter, orderBy, page)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Query: %w", err)
        }</span>
        <span class="cov1" title="1">return rtebtch, nil</span>
}

func (b *Business) Count(ctx context.Context, filter QueryFilter) (int, error) <span class="cov0" title="0">{
        return b.storer.Count(ctx, filter)
}</span>

func (b *Business) Delete(ctx context.Context, routeID uuid.UUID) error <span class="cov4" title="2">{

        facility, err := b.storer.QueryByID(ctx, routeID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("delete: pickupBatch[%s]: %w", routeID, err)
        }</span>

        <span class="cov4" title="2">if !facility.IsActive </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: already deleted", routeID)
        }</span>

        <span class="cov4" title="2">if err := b.storer.Delete(ctx, routeID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("delete: %w", err)
        }</span>
        <span class="cov4" title="2">return nil</span>

}
</pre>
		
		<pre class="file" id="file136" style="display: none">package routedb

import (
        "bytes"
        "strings"

        "github.com/FITHSCS/backend/business/domain/routebus"
)

func applyFilter(filter routebus.QueryFilter, data map[string]any, buf *bytes.Buffer) <span class="cov0" title="0">{

        var wc []string

        if filter.ID != nil </span><span class="cov0" title="0">{
                data["route_id"] = &amp;filter.ID
                wc = append(wc, "route_id = :route_id")
        }</span>
        <span class="cov0" title="0">if filter.StartFacility != nil </span><span class="cov0" title="0">{
                data["start_facility_id"] = *filter.StartFacility
                wc = append(wc, "start_facility_id = :start_facility_id")
        }</span>

        <span class="cov0" title="0">if filter.EndFacility != nil </span><span class="cov0" title="0">{
                data["end_facility_id"] = *filter.EndFacility
                wc = append(wc, "end_facility_id = :end_facility_id")
        }</span>

        <span class="cov0" title="0">if filter.RouteName != nil </span><span class="cov0" title="0">{
                data["route_name"] = *filter.RouteName
                wc = append(wc, "route_name = :route_name")
        }</span>

        <span class="cov0" title="0">if filter.TotalKM != nil </span><span class="cov0" title="0">{
                data["total_km"] = *filter.TotalKM
                wc = append(wc, "total_km &gt;= :total_km")
        }</span>

        <span class="cov0" title="0">if filter.IsActive != nil </span><span class="cov0" title="0">{
                data["is_active"] = *filter.IsActive
                wc = append(wc, "is_active = :is_active")
        }</span>

        <span class="cov0" title="0">if filter.CreatedAt != nil </span><span class="cov0" title="0">{
                data["created_at"] = filter.CreatedAt.UTC()
                wc = append(wc, "date_created &gt;= :created_at")
        }</span>
        <span class="cov0" title="0">if filter.UpdatedAt != nil </span><span class="cov0" title="0">{
                data["updated_at"] = filter.UpdatedAt.UTC()
                wc = append(wc, "updated_at &lt;= :updated_at")
        }</span>

        <span class="cov0" title="0">if len(wc) &gt; 0 </span><span class="cov0" title="0">{
                buf.WriteString(" WHERE ")
                buf.WriteString(strings.Join(wc, " AND "))
        }</span>
}
</pre>
		
		<pre class="file" id="file137" style="display: none">package routedb

import (
        "fmt"
        "time"

        "github.com/FITHSCS/backend/business/domain/routebus"
        "github.com/FITHSCS/backend/business/types/facilitytype"
        "github.com/FITHSCS/backend/business/types/genstringtype"
        "github.com/google/uuid"
)

type routedb struct {
        ID              uuid.UUID `db:"route_id"`
        StartFacilityID uuid.UUID `db:"start_facility_id"`
        EndFacilityID   uuid.UUID `db:"end_facility_id"`
        RouteName       string    `db:"route_name"`
        TotalKM         float64   `db:"total_km"`
        TotalStops      int       `db:"total_stops"`
        StartLatitude   float64   `db:"start_latitude"`
        EndLatitude     float64   `db:"end_latitude"`
        StartLongitude  float64   `db:"start_longitude"`
        EndLongitude    float64   `db:"end_longitude"`
        IsActive        bool      `db:"is_active"`
        CreatedAt       time.Time `db:"created_at"`
        UpdatedAt       time.Time `db:"updated_at"`
}

func toDBRoutedb(bus routebus.Route) (routedb, error) <span class="cov0" title="0">{

        routedb := routedb{
                ID:              bus.RouteID,
                StartFacilityID: bus.StartFacilityID,
                EndFacilityID:   bus.EndFacilityID,
                RouteName:       bus.RouteName.String(),
                TotalKM:         bus.TotalKM,
                TotalStops:      bus.TotalStops,
                StartLatitude:   bus.StartLatitude.Float64(),
                EndLatitude:     bus.EndLatitude.Float64(),
                StartLongitude:  bus.StartLongitude.Float64(),
                EndLongitude:    bus.EndLongitude.Float64(),
                IsActive:        bus.IsActive,
                CreatedAt:       bus.CreatedAt.UTC(),
                UpdatedAt:       bus.UpdatedAt.UTC(),
        }

        return routedb, nil
}</span>

func toBusRoute(db routedb) (routebus.Route, error) <span class="cov0" title="0">{

        rteName, err := genstringtype.Parse(db.RouteName)
        if err != nil </span><span class="cov0" title="0">{
                return routebus.Route{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">stlat, err := facilitytype.ParseLat(db.StartLatitude)
        if err != nil </span><span class="cov0" title="0">{
                return routebus.Route{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">stlong, err := facilitytype.ParseLong(db.StartLongitude)
        if err != nil </span><span class="cov0" title="0">{
                return routebus.Route{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">endlat, err := facilitytype.ParseLat(db.EndLatitude)
        if err != nil </span><span class="cov0" title="0">{
                return routebus.Route{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">endlong, err := facilitytype.ParseLong(db.EndLongitude)
        if err != nil </span><span class="cov0" title="0">{
                return routebus.Route{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">rtebus := routebus.Route{
                RouteID:         db.ID,
                StartFacilityID: db.StartFacilityID,
                EndFacilityID:   db.EndFacilityID,
                RouteName:       rteName,
                TotalKM:         db.TotalKM,
                TotalStops:      db.TotalStops,
                StartLatitude:   stlat,
                StartLongitude:  stlong,
                EndLatitude:     endlat,
                EndLongitude:    endlong,
                IsActive:        db.IsActive,
                CreatedAt:       db.CreatedAt.In(time.Local),
                UpdatedAt:       db.UpdatedAt.In(time.Local),
        }

        return rtebus, nil</span>
}

func toBusRoutes(dbs []routedb) ([]routebus.Route, error) <span class="cov0" title="0">{

        bus := make([]routebus.Route, len(dbs))

        for i, db := range dbs </span><span class="cov0" title="0">{
                var err error
                bus[i], err = toBusRoute(db)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">return bus, nil</span>
}
</pre>
		
		<pre class="file" id="file138" style="display: none">package routedb

import (
        "fmt"

        "github.com/FITHSCS/backend/business/domain/routebus"
        "github.com/FITHSCS/backend/business/sdk/order"
)

var orderByFields = map[string]string{
        routebus.OrderByID:            "route_id",
        routebus.OrderByStartFacility: "start_facility_id",
        routebus.OrderByEndFacility:   "end_facility_id",
        routebus.OrderByRouteName:     "route_name",
        routebus.OrderByTotalKms:      "total_km",
        routebus.OrderByTotalStops:    "total_stops",
        routebus.OrderByIsActive:      "is_active",
        routebus.OrderByCreatedAt:     "created_at",
        routebus.OrderByUpdatedAt:     "updated_at",
}

// orderByClause converts an order.By value into the final
// " ORDER BY  ASC|DESC" fragment the store adds to its SELECT.
func orderByClause(ob order.By) (string, error) <span class="cov0" title="0">{
        col, ok := orderByFields[ob.Field]
        if !ok </span><span class="cov0" title="0">{
                return "", fmt.Errorf("field %q does not exist", ob.Field)
        }</span>
        <span class="cov0" title="0">return " ORDER BY " + col + " " + ob.Direction, nil</span>
}
</pre>
		
		<pre class="file" id="file139" style="display: none">// Package routedb contains product related CRUD functionality.
package routedb

import (
        "bytes"
        "context"
        "errors"
        "fmt"

        "github.com/FITHSCS/backend/business/domain/pickupbatchbus"
        "github.com/FITHSCS/backend/business/domain/routebus"
        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/business/sdk/sqldb"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/google/uuid"
        "github.com/jmoiron/sqlx"
)

type Store struct {
        log *logger.Logger
        db  sqlx.ExtContext
}

func NewStore(log *logger.Logger, db *sqlx.DB) *Store <span class="cov0" title="0">{
        return &amp;Store{log: log, db: db}
}</span>

func (s *Store) Create(ctx context.Context, r routebus.Route) error <span class="cov0" title="0">{
        const stmt = `
    INSERT INTO route (
            route_id, 
                start_facility_id,
                end_facility_id,
                route_name, 
            total_km,
                total_stops,
                start_latitude,
                start_longitude,
                end_latitude,
            end_longitude, 
                is_active,
            created_at,
                updated_at 
    ) 
        VALUES (
                :route_id, 
            :start_facility_id, 
                :end_facility_id,
                :route_name, 
            :total_km, 
                :total_stops,
                :start_latitude,
                :start_longitude,
                :end_latitude,
            :end_longitude, 
                :is_active,
            :created_at, 
                :updated_at
    )`
        returnedValue, err := toDBRoutedb(r)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return sqldb.NamedExecContext(ctx, s.log, s.db, stmt, returnedValue)</span>
}

func (s *Store) Update(ctx context.Context, r routebus.Route) error <span class="cov0" title="0">{
        const stmt = `
    UPDATE 
                route
    SET 
        start_facility_id   = :start_facility_id,
        end_facility_id     = :end_facility_id,
        route_name                = :route_name,
        total_km                  = :total_km,
        total_stops         = :total_stops,
                start_latitude                 = :start_latitude,
                start_longitude         = :start_longitude,
        end_latitude        = :end_latitude,
        end_longitude       = :end_longitude,
        is_active           = :is_active,
        updated_at          = :updated_at
    WHERE route_id          = :route_id`

        returnedValue, err := toDBRoutedb(r)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return sqldb.NamedExecContext(ctx, s.log, s.db, stmt, returnedValue)</span>
}

func (s *Store) Query(ctx context.Context,
        filter routebus.QueryFilter, orderBy order.By, page page.Page) ([]routebus.Route, error) <span class="cov0" title="0">{

        data := map[string]any{
                "offset":        (page.Number() - 1) * page.RowsPerPage(),
                "rows_per_page": page.RowsPerPage(),
        }

        const q = `
    SELECT
            route_id, 
                start_facility_id,
                end_facility_id,
                route_name, 
            total_km,
                total_stops,
                start_latitude,
                start_longitude,
                end_latitude,
            end_longitude, 
                is_active,
            created_at,
                updated_at 
    FROM 
                route`

        var buf bytes.Buffer
        buf.WriteString(q)
        applyFilter(filter, data, &amp;buf)

        clause, err := orderByClause(orderBy)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">buf.WriteString(clause)
        buf.WriteString(" OFFSET :offset ROWS FETCH NEXT :rows_per_page ROWS ONLY")

        var dbRecs []routedb
        if err := sqldb.NamedQuerySlice(ctx, s.log, s.db, buf.String(), data, &amp;dbRecs); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("namedqueryslice: %w", err)
        }</span>
        <span class="cov0" title="0">return toBusRoutes(dbRecs)</span>
}

func (s *Store) QueryByID(ctx context.Context, routeID uuid.UUID) (routebus.Route, error) <span class="cov0" title="0">{
        param := map[string]any{
                "route_id": routeID.String(),
        }
        const stmt = `
    SELECT
        route_id, 
                start_facility_id,
                end_facility_id,
                route_name, 
            total_km,
                total_stops,
                start_latitude,
                start_longitude,
                end_latitude,
            end_longitude, 
                is_active,
            created_at,
                updated_at 
        FROM 
                  route
        WHERE 
                  route_id = :route_id`

        var rec routedb
        if err := sqldb.NamedQueryStruct(ctx, s.log, s.db, stmt, param, &amp;rec); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sqldb.ErrDBNotFound) </span><span class="cov0" title="0">{
                        return routebus.Route{}, fmt.Errorf("db: %w", pickupbatchbus.ErrNotFound)
                }</span>
                <span class="cov0" title="0">return routebus.Route{}, fmt.Errorf("db: %w", err)</span>
        }
        <span class="cov0" title="0">return toBusRoute(rec)</span>
}

func (s *Store) Count(ctx context.Context, filter routebus.QueryFilter) (int, error) <span class="cov0" title="0">{
        data := map[string]any{}
        const base = `SELECT count(1) FROM route`

        var buf bytes.Buffer
        buf.WriteString(base)
        applyFilter(filter, data, &amp;buf)

        var out struct {
                Count int `db:"count"`
        }
        if err := sqldb.NamedQueryStruct(ctx, s.log, s.db, buf.String(), data, &amp;out); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("db: %w", err)
        }</span>
        <span class="cov0" title="0">return out.Count, nil</span>
}

func (s *Store) Delete(ctx context.Context, routeID uuid.UUID) error <span class="cov0" title="0">{

        const q = `
    UPDATE
        route
        SET
                is_active = :is_active
    WHERE
        route_id = :route_id`

        dbPickupBatch := routedb{ID: routeID, IsActive: false}

        if err := sqldb.NamedExecContext(ctx, s.log, s.db, q, dbPickupBatch); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("namedexeccontext: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file140" style="display: none">package routebus

import (
        "context"
        "fmt"
        "math/rand"

        "github.com/FITHSCS/backend/business/types/facilitytype"
        "github.com/FITHSCS/backend/business/types/genstringtype"
        "github.com/google/uuid"
)

func TestGenerateNewRoutes(n int, stFacID uuid.UUID, endFacID uuid.UUID) []NewRoute <span class="cov5" title="2">{
        newroute := make([]NewRoute, n)

        idx := rand.Intn(10000)
        for i := range n </span><span class="cov10" title="4">{
                idx++

                nf := NewRoute{
                        StartFacilityID: stFacID,
                        EndFacilityID:   endFacID,
                        RouteName:       genstringtype.MustParse(fmt.Sprintf("RouteName%d", idx)),
                        TotalKM:         float64(idx % 1000),
                        TotalStops:      int(idx % 100),
                        StartLatitude:   facilitytype.MustParseLat(9.01949999999),
                        EndLatitude:     facilitytype.MustParseLat(9.069499999999),
                        StartLongitude:  facilitytype.MustParseLong(38.7399999999),
                        EndLongitude:    facilitytype.MustParseLong(38.78929999999),
                        IsActive:        true,
                }

                newroute[i] = nf
        }</span>

        <span class="cov5" title="2">return newroute</span>
}

func TestGenerateSeedRoutes(ctx context.Context, n int, api *Business, stfacid uuid.UUID, endfacid uuid.UUID) ([]Route, error) <span class="cov5" title="2">{
        newfs := TestGenerateNewRoutes(n, stfacid, endfacid)

        facs := make([]Route, len(newfs))
        for i, np := range newfs </span><span class="cov10" title="4">{
                prd, err := api.Create(ctx, np)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("seeding routes: idx: %d : %w", i, err)
                }</span>

                <span class="cov10" title="4">facs[i] = prd</span>
        }

        <span class="cov5" title="2">return facs, nil</span>
}
</pre>
		
		<pre class="file" id="file141" style="display: none">// Package signaturebus provides business access to vehicles bus domain.
package signaturebus

import (
        "context"
        "fmt"
        "time"

        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/google/uuid"
)

type Storer interface {
        Create(ctx context.Context, signature Signature) error
        Update(ctx context.Context, signature Signature) error
        SoftDelete(ctx context.Context, signatureID uuid.UUID) error
        HardDelete(ctx context.Context, signatureID uuid.UUID) error
        Query(ctx context.Context, filter QueryFilter, orderby order.By, page page.Page) ([]Signature, error)
        QueryByID(ctx context.Context, signatureID uuid.UUID) (Signature, error)
        Count(ctx context.Context, filter QueryFilter) (int, error)
}


func (b *Business) GetStorer() Storer <span class="cov0" title="0">{
    return b.storer
}</span>



type Business struct {
        log    *logger.Logger
        storer Storer
}

func NewBusiness(log *logger.Logger, storer Storer) *Business <span class="cov1" title="1">{
        return &amp;Business{
                log:    log,
                storer: storer,
        }
}</span>

func (b *Business) Create(ctx context.Context, ns NewSignature) (Signature, error) <span class="cov10" title="5">{
        now := time.Now()

        signature := Signature{
                SignatureID:    uuid.New(),
                ManifestID:     ns.ManifestID,
                SignedByID:     ns.SignedByID,
                EventType:      ns.EventType,
                SignatureType:  ns.SignatureType,
                SignatureHash:  ns.SignatureHash,
                DeviceID:       ns.DeviceID,
                SignedAt:       ns.SignedAt,
                Longitude:      ns.Longitude,
                Latitude:       ns.Latitude,
                InsideGeofence: ns.InsideGeofence,
                IsVerified:     ns.IsVerified,
                IsDeleted:      false,
                IsSynced:       ns.IsSynced,
                TimeStamp:      now,
                CreatedAt:      now,
                UpdatedAt:      now,
        }

        if err := b.storer.Create(ctx, signature); err != nil </span><span class="cov0" title="0">{
                return Signature{}, fmt.Errorf("Create: %w", err)
        }</span>

        <span class="cov10" title="5">fmt.Printf("\n\n\nsignature: %v\n\n\n", signature)
        return signature, nil</span>
}

func (b *Business) Update(ctx context.Context, singatureID uuid.UUID, updateSignature UpdateSignature) (Signature, error) <span class="cov1" title="1">{

        signOrig, err := b.storer.QueryByID(ctx, singatureID)
        if err != nil </span><span class="cov0" title="0">{
                return Signature{}, fmt.Errorf("querybyid: %w", err)
        }</span>

        <span class="cov1" title="1">if updateSignature.ManifestID != nil </span><span class="cov1" title="1">{
                signOrig.ManifestID = *updateSignature.ManifestID
        }</span>

        <span class="cov1" title="1">if updateSignature.SignedByID != nil </span><span class="cov1" title="1">{
                signOrig.SignedByID = *updateSignature.SignedByID
        }</span>

        <span class="cov1" title="1">if updateSignature.EventType != nil </span><span class="cov1" title="1">{
                signOrig.EventType = *updateSignature.EventType
        }</span>

        <span class="cov1" title="1">if updateSignature.SignatureType != nil </span><span class="cov1" title="1">{
                signOrig.SignatureType = *updateSignature.SignatureType
        }</span>

        <span class="cov1" title="1">if updateSignature.SignatureHash != nil </span><span class="cov1" title="1">{
                signOrig.SignatureHash = *updateSignature.SignatureHash
        }</span>

        <span class="cov1" title="1">if updateSignature.DeviceID != nil </span><span class="cov1" title="1">{
                signOrig.DeviceID = *updateSignature.DeviceID
        }</span>

        <span class="cov1" title="1">if updateSignature.SignedAt != nil </span><span class="cov1" title="1">{
                signOrig.SignedAt = *updateSignature.SignedAt
        }</span>

        <span class="cov1" title="1">if updateSignature.Longitude != nil </span><span class="cov1" title="1">{
                signOrig.Longitude = *updateSignature.Longitude
        }</span>

        <span class="cov1" title="1">if updateSignature.Latitude != nil </span><span class="cov1" title="1">{
                signOrig.Latitude = *updateSignature.Latitude
        }</span>

        <span class="cov1" title="1">if updateSignature.InsideGeofence != nil </span><span class="cov1" title="1">{
                signOrig.InsideGeofence = *updateSignature.InsideGeofence
        }</span>

        <span class="cov1" title="1">if updateSignature.IsVerified != nil </span><span class="cov1" title="1">{
                signOrig.IsVerified = *updateSignature.IsVerified
        }</span>

        <span class="cov1" title="1">if updateSignature.IsSynced != nil </span><span class="cov1" title="1">{
                signOrig.IsSynced = *updateSignature.IsSynced
        }</span>

        <span class="cov1" title="1">if updateSignature.TimeStamp != nil </span><span class="cov1" title="1">{
                signOrig.TimeStamp = *updateSignature.TimeStamp
        }</span>

        <span class="cov1" title="1">signOrig.UpdatedAt = time.Now().Truncate(time.Microsecond)

        if err := b.storer.Update(ctx, signOrig); err != nil </span><span class="cov0" title="0">{
                return Signature{}, fmt.Errorf("update: %w", err)
        }</span>
        <span class="cov1" title="1">return signOrig, nil</span>
}

func (b *Business) QueryByID(ctx context.Context, signatureID uuid.UUID) (Signature, error) <span class="cov1" title="1">{

        signature, err := b.storer.QueryByID(ctx, signatureID)
        if err != nil </span><span class="cov0" title="0">{
                return Signature{}, fmt.Errorf("query: signatureID[%s]: %w", signatureID, err)
        }</span>
        <span class="cov1" title="1">return signature, nil</span>
}

func (b *Business) Query(ctx context.Context, filter QueryFilter, orderBy order.By, page page.Page) ([]Signature, error) <span class="cov1" title="1">{

        signatures, err := b.storer.Query(ctx, filter, orderBy, page)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Query: %w", err)
        }</span>
        <span class="cov1" title="1">return signatures, nil</span>
}

func (b *Business) Count(ctx context.Context, filter QueryFilter) (int, error) <span class="cov0" title="0">{
        return b.storer.Count(ctx, filter)
}</span>

func (b *Business) SoftDelete(ctx context.Context, signatureID uuid.UUID) error <span class="cov4" title="2">{

        facility, err := b.storer.QueryByID(ctx, signatureID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("softdeletequery: signature[%s]: %w", signatureID, err)
        }</span>

        <span class="cov4" title="2">if facility.IsDeleted </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: already deleted", signatureID)
        }</span>

        <span class="cov4" title="2">if err := b.storer.SoftDelete(ctx, signatureID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("delete: %w", err)
        }</span>
        <span class="cov4" title="2">return nil</span>

}

func (b *Business) HardDelete(ctx context.Context, signatureID uuid.UUID) error <span class="cov4" title="2">{
        if err := b.storer.HardDelete(ctx, signatureID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("delete: %w", err)
        }</span>
        <span class="cov4" title="2">return nil</span>

}
</pre>
		
		<pre class="file" id="file142" style="display: none">package signaturedb

import (
        "bytes"
        "strings"

        "github.com/FITHSCS/backend/business/domain/signaturebus"
)

func applyFilter(filter signaturebus.QueryFilter, data map[string]any, buf *bytes.Buffer) <span class="cov0" title="0">{

        var wc []string

        if filter.DeviceID != nil </span><span class="cov0" title="0">{
                data["is_synced"] = *filter.DeviceID
                wc = append(wc, "device_id = :device_id")
        }</span>

        <span class="cov0" title="0">if filter.InsideGeofence != nil </span><span class="cov0" title="0">{
                data["is_synced"] = *filter.InsideGeofence
                wc = append(wc, "inside_geofence = :inside_geofence")
        }</span>

        <span class="cov0" title="0">if filter.IsVerified != nil </span><span class="cov0" title="0">{
                data["is_synced"] = *filter.IsVerified
                wc = append(wc, "is_verified = :is_verified")
        }</span>

        <span class="cov0" title="0">if filter.IsSynced != nil </span><span class="cov0" title="0">{
                data["is_synced"] = *filter.IsSynced
                wc = append(wc, "is_synced = :is_synced")
        }</span>

        <span class="cov0" title="0">if filter.TimeStamp != nil </span><span class="cov0" title="0">{
                data["time_stamp"] = *filter.TimeStamp
                wc = append(wc, "time_stamp = :time_stamp")
        }</span>

        <span class="cov0" title="0">if filter.CreatedAt != nil </span><span class="cov0" title="0">{
                data["created_at"] = filter.CreatedAt.UTC()
                wc = append(wc, "date_created &gt;= :created_at")
        }</span>
        <span class="cov0" title="0">if filter.UpdatedAt != nil </span><span class="cov0" title="0">{
                data["updated_at"] = filter.UpdatedAt.UTC()
                wc = append(wc, "updated_at &lt;= :updated_at")
        }</span>

        <span class="cov0" title="0">if len(wc) &gt; 0 </span><span class="cov0" title="0">{
                buf.WriteString(" WHERE ")
                buf.WriteString(strings.Join(wc, " AND "))
        }</span>
}
</pre>
		
		<pre class="file" id="file143" style="display: none">package signaturedb

import (
        "fmt"
        "time"

        "github.com/FITHSCS/backend/business/domain/signaturebus"
        "github.com/FITHSCS/backend/business/types/facilitytype"
        "github.com/FITHSCS/backend/business/types/genstringtype"
        "github.com/google/uuid"
)

type signaturedb struct {
        SignatureID    uuid.UUID `db:"signature_id"`
        ManifestID     uuid.UUID `db:"manifest_id"`
        SignedByID     uuid.UUID `db:"signed_by_id"`
        EventType      string    `db:"event_type"`
        SignatureType  string    `db:"signature_type"`
        SignatureHash  string    `db:"signature_hash"`
        DeviceID       string    `db:"device_id"`
        SignedAt       time.Time `db:"signed_at"`
        Longitude      float64   `db:"longitude"`
        Latitude       float64   `db:"latitude"`
        InsideGeofence bool      `db:"inside_geofence"`
        IsVerified     bool      `db:"is_verified"`
        IsDeleted      bool      `db:"is_deleted"`
        IsSynced       bool      `db:"is_synced"`
        TimeStamp      time.Time `db:"time_stamp"`
        CreatedAt      time.Time `db:"created_at"`
        UpdatedAt      time.Time `db:"updated_at"`
}

//=============================================================================&gt;

func toDBSignature(bus signaturebus.Signature) (signaturedb, error) <span class="cov0" title="0">{

        siganture := signaturedb{
                SignatureID:    bus.SignatureID,
                ManifestID:     bus.ManifestID,
                SignedByID:     bus.SignedByID,
                EventType:      bus.EventType.String(),
                SignatureType:  bus.SignatureType.String(),
                SignatureHash:  bus.SignatureHash.String(),
                DeviceID:       bus.DeviceID.String(),
                SignedAt:       bus.SignedAt.UTC(),
                Longitude:      bus.Longitude.Float64(),
                Latitude:       bus.Latitude.Float64(),
                InsideGeofence: bus.InsideGeofence,
                IsVerified:     bus.IsVerified,
                IsSynced:       bus.IsSynced,
                IsDeleted:      bus.IsDeleted,
                TimeStamp:      bus.TimeStamp.UTC(),
                CreatedAt:      bus.CreatedAt.UTC(),
                UpdatedAt:      bus.UpdatedAt.UTC(),
        }

        return siganture, nil
}</span>

func toBusSignature(db signaturedb) (signaturebus.Signature, error) <span class="cov0" title="0">{
        snatureid, err := uuid.Parse(db.SignatureID.String())
        if err != nil </span><span class="cov0" title="0">{
                return signaturebus.Signature{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">manid, err := uuid.Parse(db.ManifestID.String())
        if err != nil </span><span class="cov0" title="0">{
                return signaturebus.Signature{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">signdbyid, err := uuid.Parse(db.SignedByID.String())
        if err != nil </span><span class="cov0" title="0">{
                return signaturebus.Signature{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">evntype, err := genstringtype.Parse(db.EventType)
        if err != nil </span><span class="cov0" title="0">{
                return signaturebus.Signature{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">signtype, err := genstringtype.Parse(db.SignatureType)
        if err != nil </span><span class="cov0" title="0">{
                return signaturebus.Signature{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">sgnhash, err := genstringtype.Parse(db.SignatureHash)
        if err != nil </span><span class="cov0" title="0">{
                return signaturebus.Signature{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">dvceid, err := genstringtype.Parse(db.DeviceID)
        if err != nil </span><span class="cov0" title="0">{
                return signaturebus.Signature{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">var sgnat time.Time
        if !db.SignedAt.IsZero() </span><span class="cov0" title="0">{
                sgnat = db.SignedAt.In(time.Local)
        }</span>

        <span class="cov0" title="0">lng, err := facilitytype.ParseLong(db.Longitude)
        if err != nil </span><span class="cov0" title="0">{
                return signaturebus.Signature{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">lat, err := facilitytype.ParseLat(db.Latitude)
        if err != nil </span><span class="cov0" title="0">{
                return signaturebus.Signature{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">bus := signaturebus.Signature{
                SignatureID:    snatureid,
                ManifestID:     manid,
                SignedByID:     signdbyid,
                EventType:      evntype,
                SignatureType:  signtype,
                SignatureHash:  sgnhash,
                DeviceID:       dvceid,
                SignedAt:       sgnat,
                Longitude:      lng,
                Latitude:       lat,
                InsideGeofence: db.InsideGeofence,
                IsVerified:     db.IsVerified,
                IsDeleted:      db.IsDeleted,
                IsSynced:       db.IsSynced,
                TimeStamp:      db.TimeStamp.In(time.Local),
                CreatedAt:      db.CreatedAt.In(time.Local),
                UpdatedAt:      db.UpdatedAt.In(time.Local),
        }

        return bus, nil</span>

}

func toBusSignatures(dbs []signaturedb) ([]signaturebus.Signature, error) <span class="cov0" title="0">{
        bus := make([]signaturebus.Signature, len(dbs))

        for i, db := range dbs </span><span class="cov0" title="0">{
                var err error
                bus[i], err = toBusSignature(db)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">return bus, nil</span>
}
</pre>
		
		<pre class="file" id="file144" style="display: none">package signaturedb

import (
        "fmt"

        "github.com/FITHSCS/backend/business/domain/signaturebus"
        "github.com/FITHSCS/backend/business/sdk/order"
)

var orderByFields = map[string]string{
        signaturebus.OrderBySignatureID: "signature_id",
        signaturebus.OrderByCreatedAt:   "created_at",
        signaturebus.OrderByDeviceID:    "device_id",
        signaturebus.OrderByEventType:   "event_type",
        signaturebus.OrderByTimeStamp:   "timestamp",
        signaturebus.OrderByUpdatedAt:   "updated_at",
}

// orderByClause converts an order.By value into the final
// " ORDER BY  ASC|DESC" fragment the store adds to its SELECT.
func orderByClause(ob order.By) (string, error) <span class="cov0" title="0">{
        col, ok := orderByFields[ob.Field]

        if !ok </span><span class="cov0" title="0">{
                return "", fmt.Errorf("field %q does not exist", ob.Field)
        }</span>
        <span class="cov0" title="0">return " ORDER BY " + col + " " + ob.Direction, nil</span>
}
</pre>
		
		<pre class="file" id="file145" style="display: none">// Package signaturedb contains product related CRUD functionality.
package signaturedb

import (
        "bytes"
        "context"
        "errors"
        "fmt"

        "github.com/FITHSCS/backend/business/domain/pickupbatchbus"
        "github.com/FITHSCS/backend/business/domain/signaturebus"
        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/business/sdk/sqldb"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/google/uuid"
        "github.com/jmoiron/sqlx"
)

type Store struct {
        log *logger.Logger
        db  sqlx.ExtContext
}

func NewStore(log *logger.Logger, db *sqlx.DB) *Store <span class="cov0" title="0">{
        return &amp;Store{log: log, db: db}
}</span>

func (s *Store) Create(ctx context.Context, p signaturebus.Signature) error <span class="cov0" title="0">{
        const stmt = `
    INSERT INTO signature (
            signature_id, 
                manifest_id,
                signed_by_id,
                event_type, 
            signature_type,
                signature_hash,
                device_id,
                signed_at,
                longitude,
                latitude,
                inside_geofence,
                is_verified,
                is_deleted,
            is_synced, 
                time_stamp, 
            created_at,
                updated_at 
    ) 
        VALUES (
            :signature_id, 
                :manifest_id, 
                :signed_by_id,
                :event_type, 
            :signature_type, 
                :signature_hash,
                :device_id,
                :signed_at,
                :longitude,
            :latitude, 
                :inside_geofence,
                :is_verified,
                :is_deleted,
                :is_synced,
                :time_stamp, 
            :created_at, 
                :updated_at
    )`
        returnedValue, err := toDBSignature(p)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return sqldb.NamedExecContext(ctx, s.log, s.db, stmt, returnedValue)</span>
}

func (s *Store) Update(ctx context.Context, p signaturebus.Signature) error <span class="cov0" title="0">{
        const stmt = `
    UPDATE 
                signature
    SET 
        manifest_id       = :manifest_id,
        signed_by_id      = :signed_by_id,
        event_type        = :event_type,
        signature_type    = :signature_type,
        signature_hash    = :signature_hash,
                device_id                   = :device_id,
                signed_at                   = :signed_at,
                longitude                   = :longitude,
                latitude                   = :latitude,
                inside_geofence   = :inside_geofence,
                is_verified           = :is_verified,
        is_synced         = :is_synced,
        time_stamp        = :time_stamp,
        updated_at        = :updated_at
    WHERE 
                signature_id = :signature_id`

        returnedValue, err := toDBSignature(p)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return sqldb.NamedExecContext(ctx, s.log, s.db, stmt, returnedValue)</span>
}

func (s *Store) Query(ctx context.Context,
        filter signaturebus.QueryFilter, orderBy order.By, page page.Page) ([]signaturebus.Signature, error) <span class="cov0" title="0">{
        data := map[string]any{
                "offset":        (page.Number() - 1) * page.RowsPerPage(),
                "rows_per_page": page.RowsPerPage(),
        }

        const q = `
    SELECT
            signature_id, 
                manifest_id,
                signed_by_id,
                event_type, 
            signature_type,
                signature_hash,
                device_id,
                signed_at,
                longitude,
                latitude,
                inside_geofence,
                is_verified,
                is_deleted,
            is_synced, 
                time_stamp, 
            created_at,
                updated_at 
    FROM 
                signature`

        var buf bytes.Buffer
        buf.WriteString(q)
        applyFilter(filter, data, &amp;buf)

        clause, err := orderByClause(orderBy)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">buf.WriteString(clause)
        buf.WriteString(" OFFSET :offset ROWS FETCH NEXT :rows_per_page ROWS ONLY")

        var dbRecs []signaturedb
        if err := sqldb.NamedQuerySlice(ctx, s.log, s.db, buf.String(), data, &amp;dbRecs); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("namedqueryslice: %w", err)
        }</span>
        <span class="cov0" title="0">return toBusSignatures(dbRecs)</span>
}

func (s *Store) QueryByID(ctx context.Context, signatureID uuid.UUID) (signaturebus.Signature, error) <span class="cov0" title="0">{
        param := map[string]any{
                "signature_id": signatureID.String(),
        }
        const stmt = `
    SELECT
            signature_id, 
                manifest_id,
                signed_by_id,
                event_type, 
            signature_type,
                signature_hash,
                device_id,
                signed_at,
                longitude,
                latitude,
                inside_geofence,
                is_verified,
                is_deleted,
            is_synced, 
                time_stamp, 
            created_at,
                updated_at
        FROM 
                  signature
        WHERE 
                  signature_id = :signature_id`

        var rec signaturedb
        if err := sqldb.NamedQueryStruct(ctx, s.log, s.db, stmt, param, &amp;rec); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sqldb.ErrDBNotFound) </span><span class="cov0" title="0">{
                        return signaturebus.Signature{}, fmt.Errorf("db: %w", pickupbatchbus.ErrNotFound)
                }</span>
                <span class="cov0" title="0">return signaturebus.Signature{}, fmt.Errorf("db: %w", err)</span>
        }
        <span class="cov0" title="0">return toBusSignature(rec)</span>
}

func (s *Store) Count(ctx context.Context, filter signaturebus.QueryFilter) (int, error) <span class="cov0" title="0">{
        data := map[string]any{}
        const base = `SELECT count(1) FROM signature`

        var buf bytes.Buffer
        buf.WriteString(base)
        applyFilter(filter, data, &amp;buf)

        var out struct {
                Count int `db:"count"`
        }
        if err := sqldb.NamedQueryStruct(ctx, s.log, s.db, buf.String(), data, &amp;out); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("db: %w", err)
        }</span>
        <span class="cov0" title="0">return out.Count, nil</span>
}

func (s *Store) SoftDelete(ctx context.Context, signatureID uuid.UUID) error <span class="cov0" title="0">{

        const q = `
    UPDATE
        signature
        SET
                is_deleted = :is_deleted
    WHERE
        signature_id = :signature_id`

        dbSignature := signaturedb{SignatureID: signatureID, IsDeleted: true}

        if err := sqldb.NamedExecContext(ctx, s.log, s.db, q, dbSignature); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("namedexeccontext: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *Store) HardDelete(ctx context.Context, signatureID uuid.UUID) error <span class="cov0" title="0">{
        const q = `
    DELETE FROM
        signature
    WHERE
        signature_id = :signature_id`

        dbSignature := signaturedb{SignatureID: signatureID}

        if err := sqldb.NamedExecContext(ctx, s.log, s.db, q, dbSignature); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("namedexeccontext: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file146" style="display: none">package signaturebus

import (
        "context"
        "fmt"
        "math/rand"
        "time"

        "github.com/FITHSCS/backend/business/types/facilitytype"
        "github.com/FITHSCS/backend/business/types/genstringtype"
        "github.com/google/uuid"
)

func TestGenerateNewSignature(n int, manID, sndbyID uuid.UUID) []NewSignature <span class="cov5" title="2">{
        newfs := make([]NewSignature, n)
        ecntype := []string{"pickup", "delivery"}
        signtype := []string{"PIN", "Freehand", "Fingerprint", "FaceID"}
        booleans := []bool{true, false}

        sndat, _ := time.Parse(time.RFC3339, "2025-06-10T15:59:33+03:00")
        timestamp := sndat.Add(time.Minute + 1)

        idx := rand.Intn(10000)
        for i := range n </span><span class="cov10" title="4">{
                idx++

                nf := NewSignature{
                        ManifestID:     manID,
                        SignedByID:     sndbyID,
                        EventType:      genstringtype.MustParse(ecntype[i%2]),
                        SignatureType:  genstringtype.MustParse(signtype[i%2]),
                        SignatureHash:  genstringtype.MustParse("q24cr98mq3vt9m9q4wrm9sdf3112"),
                        DeviceID:       genstringtype.MustParse(fmt.Sprintf("Device:%2d", idx)),
                        SignedAt:       sndat,
                        Longitude:      facilitytype.MustParseLong(38.739200592041016),
                        Latitude:       facilitytype.MustParseLat(9.019499778747559),
                        InsideGeofence: booleans[i%2],
                        IsVerified:     booleans[i%2],
                        IsSynced:       booleans[i%2],
                        TimeStamp:      timestamp,
                }

                newfs[i] = nf
        }</span>

        <span class="cov5" title="2">return newfs</span>
}

func TestGenerateSeedSignature(ctx context.Context, n int, api *Business, manID, sndbyID uuid.UUID) ([]Signature, error) <span class="cov5" title="2">{
        newfs := TestGenerateNewSignature(n, manID, sndbyID)

        facs := make([]Signature, len(newfs))
        for i, np := range newfs </span><span class="cov10" title="4">{
                prd, err := api.Create(ctx, np)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("seeding signature: idx: %d : %w", i, err)
                }</span>

                <span class="cov10" title="4">facs[i] = prd</span>
        }

        <span class="cov5" title="2">return facs, nil</span>
}
</pre>
		
		<pre class="file" id="file147" style="display: none">package syncbatchdb

import (
        //"database/sql"
        "fmt"
        //"net/mail"
        "time"

        "github.com/FITHSCS/backend/business/domain/syncbatchbus"

        //"github.com/FITHSCS/backend/business/sdk/sqldb/dbarray"
        "github.com/FITHSCS/backend/business/types/name"
        //"github.com/FITHSCS/backend/business/types/facilitytype"
        "github.com/google/uuid"
)

// &lt;=================== Struct that is going to be passed to database schema =&gt; //
type syncbatch struct {
        ID        uuid.UUID `db:"syncbatch_id"`
        BatchID   uuid.UUID `db:"batch_id"`
        DeviceID  uuid.UUID `db:"device_id"`
        EventID   uuid.UUID `db:"event_id"`
        TimeStamp time.Time `db:"time_stamp"`
        Status    string    `db:"status"`
        CreatedAt time.Time `db:"created_at"`
}

func toDBSyncBatch(bus syncbatchbus.SyncBatch) (syncbatch, error) <span class="cov0" title="0">{

        batchID, err := uuid.Parse(bus.BatchID.String())

        if err != nil </span><span class="cov0" title="0">{
                return syncbatch{}, err
        }</span>

        <span class="cov0" title="0">deviceID, err := uuid.Parse(bus.DeviceID.String())
        if err != nil </span><span class="cov0" title="0">{
                return syncbatch{}, err
        }</span>

        <span class="cov0" title="0">eventID, err := uuid.Parse(bus.EventID.String())
        if err != nil </span><span class="cov0" title="0">{
                return syncbatch{}, err
        }</span>

        <span class="cov0" title="0">return syncbatch{
                ID:        bus.ID,
                BatchID:   batchID,
                DeviceID:  deviceID,
                EventID:   eventID,
                TimeStamp: bus.TimeStamp.UTC(),
                Status:    bus.Status,
                CreatedAt: bus.CreatedAt.UTC(),
        }, nil</span>

}

func toBusSyncBatch(db syncbatch) (syncbatchbus.SyncBatch, error) <span class="cov0" title="0">{

        batchID, err := name.Parse(db.BatchID.String())
        if err != nil </span><span class="cov0" title="0">{
                return syncbatchbus.SyncBatch{}, fmt.Errorf("parse: %w", err)
        }</span>
        <span class="cov0" title="0">deviceID, err := name.Parse(db.DeviceID.String())
        if err != nil </span><span class="cov0" title="0">{
                return syncbatchbus.SyncBatch{}, fmt.Errorf("parse: %w", err)
        }</span>
        <span class="cov0" title="0">eventID, err := name.Parse(db.EventID.String())
        if err != nil </span><span class="cov0" title="0">{
                return syncbatchbus.SyncBatch{}, fmt.Errorf("parse: %w", err)
        }</span>
        <span class="cov0" title="0">status := db.Status

        bus := syncbatchbus.SyncBatch{

                ID:        db.ID,
                BatchID:   batchID,
                DeviceID:  deviceID,
                EventID:   eventID,
                TimeStamp: db.TimeStamp.In(time.Local),
                Status:    status,
                CreatedAt: db.CreatedAt.In(time.Local),
        }
        return bus, nil</span>
}
</pre>
		
		<pre class="file" id="file148" style="display: none">// Package syncbatchdb contains product related CRUD functionality.
package syncbatchdb

import (
        "context"
        "errors"
        "fmt"

        "github.com/FITHSCS/backend/business/domain/syncbatchbus"
        "github.com/FITHSCS/backend/business/sdk/sqldb"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/google/uuid"
        "github.com/jmoiron/sqlx"
)

type Store struct {
        log *logger.Logger
        db  sqlx.ExtContext
}

func NewStore(log *logger.Logger, db *sqlx.DB) *Store <span class="cov0" title="0">{
        return &amp;Store{log: log, db: db}
}</span>

func (s *Store) Create(ctx context.Context, sb syncbatchbus.SyncBatch) error <span class="cov0" title="0">{
        fmt.Println("YOOOOOOOOOO AM INSIDE HERE")
        fmt.Println(sb)
        fmt.Println("Database Instance: ", s.db)
        const stmt = `
        INSERT INTO syncbatch (
            syncbatch_id, batch_id, device_id, event_id,
            time_stamp, status, created_at
        ) VALUES (
            :syncbatch_id, :batch_id, :device_id,
            :event_id, :time_stamp, :status, :created_at
        )`

        returnedValue, err := toDBSyncBatch(sb)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">fmt.Printf("Final DB Payload: %+v\n", returnedValue)
        return sqldb.NamedExecContext(ctx, s.log, s.db, stmt, returnedValue)</span>
}

func (s *Store) QueryByID(ctx context.Context, id uuid.UUID) (syncbatchbus.SyncBatch, error) <span class="cov0" title="0">{

        param := map[string]any{
                "batch_id": id.String(),
        }
        fmt.Println("I am query ID: ", id)
        const stmt = `
          SELECT
        syncbatch_id,
        batch_id,
        device_id,
        event_id,
        time_stamp,
        status,
        created_at
        FROM syncbatch
        WHERE batch_id = :batch_id
      `
        var rec syncbatch
        if err := sqldb.NamedQueryStruct(ctx, s.log, s.db, stmt, param, &amp;rec); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sqldb.ErrDBNotFound) </span><span class="cov0" title="0">{
                        return syncbatchbus.SyncBatch{}, syncbatchbus.ErrNotFound
                }</span>
                <span class="cov0" title="0">return syncbatchbus.SyncBatch{}, err</span>
        }
        <span class="cov0" title="0">return toBusSyncBatch(rec)</span>
}
</pre>
		
		<pre class="file" id="file149" style="display: none">// Package syncbatchbus provides business access to syncbatch bus domain.
package syncbatchbus

import (
        "context"
        "errors"
        "fmt"
        "time"

        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/google/uuid"
)

var (
        ErrNotFound       = errors.New("packagedetail not found")
        ErrAuthentication = errors.New("authentication failed")
)

type Storer interface {
        Create(ctx context.Context, syncbatch SyncBatch) error
        QueryByID(ctx context.Context, syncbatchID uuid.UUID) (SyncBatch, error)
}

func (b *Business) GetStorer() Storer <span class="cov0" title="0">{
        return b.storer
}</span>

type Business struct {
        log    *logger.Logger
        storer Storer
}

func NewBusiness(log *logger.Logger, storer Storer) *Business <span class="cov0" title="0">{

        return &amp;Business{
                log:    log,
                storer: storer,
        }
}</span>

func (b *Business) Create(ctx context.Context, sb NewSyncBatch) (SyncBatch, error) <span class="cov0" title="0">{

        now := time.Now()

        syncbatch := SyncBatch{
                ID:        uuid.New(),
                BatchID:   sb.BatchID,
                DeviceID:  sb.DeviceID,
                EventID:   sb.EventID,
                TimeStamp: now,
                Status:    sb.Status,
                CreatedAt: now,
        }
        if err := b.storer.Create(ctx, syncbatch); err != nil </span><span class="cov0" title="0">{
                return SyncBatch{}, fmt.Errorf("Create: %w", err)
        }</span>
        <span class="cov0" title="0">return syncbatch, nil</span>
}

func (b *Business) QueryByID(ctx context.Context, syncbatchID uuid.UUID) (SyncBatch, error) <span class="cov0" title="0">{

        syncBatch, err := b.storer.QueryByID(ctx, syncbatchID)
        if err != nil </span><span class="cov0" title="0">{
                return SyncBatch{}, err
        }</span>
        <span class="cov0" title="0">return syncBatch, nil</span>
}
</pre>
		
		<pre class="file" id="file150" style="display: none">// Package useraudit provides an extension for userbus that adds
// auditing functionality.
package useraudit

import (
        "context"
        "net/mail"

        "github.com/FITHSCS/backend/business/domain/auditbus"
        "github.com/FITHSCS/backend/business/domain/userbus"
        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/business/types/domain"
        "github.com/FITHSCS/backend/business/types/facilitytype"
        "github.com/google/uuid"
)

// Extension provides a wrapper for audit functionality around the userbus.
type Extension struct {
        bus      userbus.ExtBusiness
        auditBus *auditbus.Business
}

// NewExtension constructs a new extension that wraps the userbus with audit.
func NewExtension(auditBus *auditbus.Business) userbus.Extension <span class="cov0" title="0">{
        return func(bus userbus.ExtBusiness) userbus.ExtBusiness </span><span class="cov0" title="0">{
                return &amp;Extension{
                        bus:      bus,
                        auditBus: auditBus,
                }
        }</span>
}

// Create applies auditing to the user creation process.
func (ext *Extension) Create(ctx context.Context, actorID uuid.UUID, nu userbus.NewUser) (userbus.User, error) <span class="cov0" title="0">{
        usr, err := ext.bus.Create(ctx, actorID, nu)
        if err != nil </span><span class="cov0" title="0">{
                return userbus.User{}, err
        }</span>

        <span class="cov0" title="0">na := auditbus.NewAudit{
                ObjID:     usr.ID,
                ObjDomain: domain.User,
                ObjName:   usr.Name,
                ActorID:   actorID,
                Action:    "created",
                Data:      nu,
                Message:   "user created",
        }

        if _, err := ext.auditBus.Create(ctx, na); err != nil </span><span class="cov0" title="0">{
                return userbus.User{}, err
        }</span>

        <span class="cov0" title="0">return usr, nil</span>
}

// Update applies auditing to the user update process.
func (ext *Extension) Update(ctx context.Context, actorID uuid.UUID, usr userbus.User, uu userbus.UpdateUser) (userbus.User, error) <span class="cov0" title="0">{
        usr, err := ext.bus.Update(ctx, actorID, usr, uu)
        if err != nil </span><span class="cov0" title="0">{
                return userbus.User{}, err
        }</span>

        <span class="cov0" title="0">na := auditbus.NewAudit{
                ObjID:     usr.ID,
                ObjDomain: domain.User,
                ObjName:   usr.Name,
                ActorID:   actorID,
                Action:    "updated",
                Data:      uu,
                Message:   "user updated",
        }

        if _, err := ext.auditBus.Create(ctx, na); err != nil </span><span class="cov0" title="0">{
                return userbus.User{}, err
        }</span>

        <span class="cov0" title="0">return usr, nil</span>
}

// Delete applies auditing to the user deletion process.
func (ext *Extension) Delete(ctx context.Context, actorID uuid.UUID, usr userbus.User) error <span class="cov0" title="0">{
        if err := ext.bus.Delete(ctx, actorID, usr); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">na := auditbus.NewAudit{
                ObjID:     usr.ID,
                ObjDomain: domain.User,
                ObjName:   usr.Name,
                ActorID:   actorID,
                Action:    "deleted",
                Data:      nil,
                Message:   "user deleted",
        }

        if _, err := ext.auditBus.Create(ctx, na); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Query does not apply auditing.
func (ext *Extension) Query(ctx context.Context, filter userbus.QueryFilter, orderBy order.By, page page.Page) ([]userbus.User, error) <span class="cov0" title="0">{
        return ext.bus.Query(ctx, filter, orderBy, page)
}</span>

// Count does not apply auditing.
func (ext *Extension) Count(ctx context.Context, filter userbus.QueryFilter) (int, error) <span class="cov0" title="0">{
        return ext.bus.Count(ctx, filter)
}</span>

// QueryByID does not apply auditing.
func (ext *Extension) QueryByID(ctx context.Context, userID uuid.UUID) (userbus.User, error) <span class="cov0" title="0">{
        return ext.bus.QueryByID(ctx, userID)
}</span>

// QueryByEmail does not apply auditing.
func (ext *Extension) QueryByEmail(ctx context.Context, email mail.Address) (userbus.User, error) <span class="cov0" title="0">{
        return ext.bus.QueryByEmail(ctx, email)
}</span>

// QueryByPhone does not apply auditing.
func (ext *Extension) QueryByPhone(ctx context.Context, phone facilitytype.PhoneNumber) (userbus.User, error) <span class="cov0" title="0">{
        return ext.bus.QueryByPhone(ctx, phone)
}</span>

// Authenticate does not apply auditing.
func (ext *Extension) Authenticate(ctx context.Context, phone facilitytype.PhoneNumber, password string) (userbus.User, error) <span class="cov0" title="0">{
        return ext.bus.Authenticate(ctx, phone, password)
}</span>
</pre>
		
		<pre class="file" id="file151" style="display: none">// Package usercache contains user related CRUD functionality with caching.
package usercache

import (
        "context"
        "net/mail"
        "time"

        "github.com/FITHSCS/backend/business/domain/userbus"
        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/business/types/facilitytype"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/google/uuid"
        "github.com/viccon/sturdyc"
)

// Store manages the set of APIs for user data and caching.
type Store struct {
        log    *logger.Logger
        storer userbus.Storer
        cache  *sturdyc.Client[userbus.User]
}

// NewStore constructs the api for data and caching access.
func NewStore(log *logger.Logger, storer userbus.Storer, ttl time.Duration) *Store <span class="cov0" title="0">{
        const capacity = 10000
        const numShards = 10
        const evictionPercentage = 10

        return &amp;Store{
                log:    log,
                storer: storer,
                cache:  sturdyc.New[userbus.User](capacity, numShards, ttl, evictionPercentage),
        }
}</span>

// Create inserts a new user into the database.
func (s *Store) Create(ctx context.Context, usr userbus.User) error <span class="cov0" title="0">{
        if err := s.storer.Create(ctx, usr); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">s.writeCache(usr)

        return nil</span>
}

// Update replaces a user document in the database.
func (s *Store) Update(ctx context.Context, usr userbus.User) error <span class="cov0" title="0">{
        if err := s.storer.Update(ctx, usr); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">s.writeCache(usr)

        return nil</span>
}

// Delete removes a user from the database.
func (s *Store) Delete(ctx context.Context, usr userbus.User) error <span class="cov0" title="0">{
        if err := s.storer.Delete(ctx, usr); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">s.deleteCache(usr)

        return nil</span>
}

// Query retrieves a list of existing users from the database.
func (s *Store) Query(ctx context.Context, filter userbus.QueryFilter, orderBy order.By, page page.Page) ([]userbus.User, error) <span class="cov0" title="0">{
        return s.storer.Query(ctx, filter, orderBy, page)
}</span>

// Count returns the total number of cards in the DB.
func (s *Store) Count(ctx context.Context, filter userbus.QueryFilter) (int, error) <span class="cov0" title="0">{
        return s.storer.Count(ctx, filter)
}</span>

// QueryByID gets the specified user from the database.
func (s *Store) QueryByID(ctx context.Context, userID uuid.UUID) (userbus.User, error) <span class="cov0" title="0">{
        cachedUsr, ok := s.readCache(userID.String())
        if ok </span><span class="cov0" title="0">{
                return cachedUsr, nil
        }</span>

        <span class="cov0" title="0">usr, err := s.storer.QueryByID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return userbus.User{}, err
        }</span>

        <span class="cov0" title="0">s.writeCache(usr)

        return usr, nil</span>
}

// QueryByEmail gets the specified user from the database by email.
func (s *Store) QueryByEmail(ctx context.Context, email mail.Address) (userbus.User, error) <span class="cov0" title="0">{
        cachedUsr, ok := s.readCache(email.Address)
        if ok </span><span class="cov0" title="0">{
                return cachedUsr, nil
        }</span>

        <span class="cov0" title="0">usr, err := s.storer.QueryByEmail(ctx, email)
        if err != nil </span><span class="cov0" title="0">{
                return userbus.User{}, err
        }</span>

        <span class="cov0" title="0">s.writeCache(usr)

        return usr, nil</span>
}

// QueryByPhone gets the specified user from the database by email.
func (s *Store) QueryByPhone(ctx context.Context, phone facilitytype.PhoneNumber) (userbus.User, error) <span class="cov0" title="0">{
        cachedUsr, ok := s.readCache(phone.String())
        if ok </span><span class="cov0" title="0">{
                return cachedUsr, nil
        }</span>

        <span class="cov0" title="0">usr, err := s.storer.QueryByPhone(ctx, phone)
        if err != nil </span><span class="cov0" title="0">{
                return userbus.User{}, err
        }</span>

        <span class="cov0" title="0">s.writeCache(usr)

        return usr, nil</span>
}

// readCache performs a safe search in the cache for the specified key.
func (s *Store) readCache(key string) (userbus.User, bool) <span class="cov0" title="0">{
        usr, exists := s.cache.Get(key)
        if !exists </span><span class="cov0" title="0">{
                return userbus.User{}, false
        }</span>

        <span class="cov0" title="0">return usr, true</span>
}

// writeCache performs a safe write to the cache for the specified userbus.
func (s *Store) writeCache(bus userbus.User) <span class="cov0" title="0">{
        s.cache.Set(bus.ID.String(), bus)
        s.cache.Set(bus.Email.Address, bus)
}</span>

// deleteCache performs a safe removal from the cache for the specified userbus.
func (s *Store) deleteCache(bus userbus.User) <span class="cov0" title="0">{
        s.cache.Delete(bus.ID.String())
        s.cache.Delete(bus.Email.Address)
}</span>
</pre>
		
		<pre class="file" id="file152" style="display: none">package userdb

import (
        "bytes"
        "fmt"
        "strings"

        "github.com/FITHSCS/backend/business/domain/userbus"
        "github.com/google/uuid"
)

func applyFilter(filter userbus.QueryFilter, data map[string]any, buf *bytes.Buffer) <span class="cov0" title="0">{
        var wc []string

        if filter.ID != uuid.Nil </span><span class="cov0" title="0">{
                data["user_id"] = &amp;filter.ID
                wc = append(wc, "user_id = :user_id")
        }</span>

        <span class="cov0" title="0">if filter.Name != nil </span><span class="cov0" title="0">{
                data["name"] = fmt.Sprintf("%%%s%%", *filter.Name)
                wc = append(wc, "name LIKE :name")
        }</span>

        <span class="cov0" title="0">if filter.Email != nil </span><span class="cov0" title="0">{
                data["email"] = (*filter.Email).String()
                wc = append(wc, "email = :email")
        }</span>

        <span class="cov0" title="0">if filter.Phone != nil </span><span class="cov0" title="0">{
                data["phone"] = (*filter.Email).String()
                wc = append(wc, "phone = :phone")
        }</span>

        <span class="cov0" title="0">if filter.StartCreatedDate != nil </span><span class="cov0" title="0">{
                data["start_date_created"] = filter.StartCreatedDate.UTC()
                wc = append(wc, "created_at &gt;= :start_date_created")
        }</span>

        <span class="cov0" title="0">if filter.EndCreatedDate != nil </span><span class="cov0" title="0">{
                data["end_date_created"] = filter.EndCreatedDate.UTC()
                wc = append(wc, "created_at &lt;= :end_date_created")
        }</span>

        <span class="cov0" title="0">if len(wc) &gt; 0 </span><span class="cov0" title="0">{
                buf.WriteString(" WHERE ")
                buf.WriteString(strings.Join(wc, " AND "))
        }</span>
}
</pre>
		
		<pre class="file" id="file153" style="display: none">package userdb

import (
        "database/sql"
        "fmt"
        "net/mail"
        "time"

        "github.com/FITHSCS/backend/business/domain/userbus"
        "github.com/FITHSCS/backend/business/sdk/sqldb/dbarray"
        "github.com/FITHSCS/backend/business/types/facilitytype"
        "github.com/FITHSCS/backend/business/types/name"
        "github.com/FITHSCS/backend/business/types/role"
        "github.com/google/uuid"
)

type user struct {
        ID           uuid.UUID      `db:"user_id"`
        Name         string         `db:"name"`
        Email        string         `db:"email"`
        Phone        string         `db:"phone"`
        Roles        dbarray.String `db:"roles"`
        PasswordHash []byte         `db:"password_hash"`
        Department   sql.NullString `db:"department"`
        Enabled      bool           `db:"enabled"`
        DateCreated  time.Time      `db:"created_at"`
        DateUpdated  time.Time      `db:"updated_at"`
}

func toDBUser(bus userbus.User) user <span class="cov0" title="0">{
        return user{
                ID:           bus.ID,
                Name:         bus.Name.String(),
                Email:        bus.Email.Address,
                Phone:        bus.Phone.String(),
                Roles:        role.ParseToString(bus.Roles),
                PasswordHash: bus.PasswordHash,
                Department: sql.NullString{
                        String: bus.Department.String(),
                        Valid:  bus.Department.Valid(),
                },
                Enabled:     bus.Enabled,
                DateCreated: bus.DateCreated.UTC(),
                DateUpdated: bus.DateUpdated.UTC(),
        }
}</span>

func toBusUser(db user) (userbus.User, error) <span class="cov0" title="0">{
        addr := mail.Address{
                Address: db.Email,
        }

        roles, err := role.ParseMany(db.Roles)
        if err != nil </span><span class="cov0" title="0">{
                return userbus.User{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">nme, err := name.Parse(db.Name)
        if err != nil </span><span class="cov0" title="0">{
                return userbus.User{}, fmt.Errorf("parse name: %w", err)
        }</span>

        <span class="cov0" title="0">department, err := name.ParseNull(db.Department.String)
        if err != nil </span><span class="cov0" title="0">{
                return userbus.User{}, fmt.Errorf("parse department: %w", err)
        }</span>

        <span class="cov0" title="0">pne, err := facilitytype.ParsePhoneNumber(db.Phone)
        if err != nil </span><span class="cov0" title="0">{
                return userbus.User{}, fmt.Errorf("parse phonenum: %w", err)
        }</span>

        <span class="cov0" title="0">bus := userbus.User{
                ID:           db.ID,
                Name:         nme,
                Email:        addr,
                Phone:        pne,
                Roles:        roles,
                PasswordHash: db.PasswordHash,
                Enabled:      db.Enabled,
                Department:   department,
                DateCreated:  db.DateCreated.In(time.Local),
                DateUpdated:  db.DateUpdated.In(time.Local),
        }

        return bus, nil</span>
}

func toBusUsers(dbs []user) ([]userbus.User, error) <span class="cov0" title="0">{
        bus := make([]userbus.User, len(dbs))

        for i, db := range dbs </span><span class="cov0" title="0">{
                var err error
                bus[i], err = toBusUser(db)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">return bus, nil</span>
}
</pre>
		
		<pre class="file" id="file154" style="display: none">package userdb

import (
        "fmt"

        "github.com/FITHSCS/backend/business/domain/userbus"
        "github.com/FITHSCS/backend/business/sdk/order"
)

var orderByFields = map[string]string{
        userbus.OrderByID:      "user_id",
        userbus.OrderByName:    "name",
        userbus.OrderByEmail:   "email",
        userbus.OrderByPhone:   "phone",
        userbus.OrderByRoles:   "roles",
        userbus.OrderByEnabled: "enabled",
}

func orderByClause(orderBy order.By) (string, error) <span class="cov0" title="0">{
        by, exists := orderByFields[orderBy.Field]
        if !exists </span><span class="cov0" title="0">{
                return "", fmt.Errorf("field %q does not exist", orderBy.Field)
        }</span>

        <span class="cov0" title="0">return " ORDER BY " + by + " " + orderBy.Direction, nil</span>
}
</pre>
		
		<pre class="file" id="file155" style="display: none">// Package userdb contains product related CRUD functionality.
package userdb

import (
        "bytes"
        "context"
        "errors"
        "fmt"
        "net/mail"

        "github.com/FITHSCS/backend/business/domain/userbus"
        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/business/sdk/sqldb"
        "github.com/FITHSCS/backend/business/types/facilitytype"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/google/uuid"
        "github.com/jmoiron/sqlx"
)

// Store manages the set of APIs for user database access.
type Store struct {
        log *logger.Logger
        db  sqlx.ExtContext
}

// NewStore constructs the api for data access.
func NewStore(log *logger.Logger, db *sqlx.DB) *Store <span class="cov0" title="0">{
        return &amp;Store{
                log: log,
                db:  db,
        }
}</span>

// Create inserts a new user into the database.
func (s *Store) Create(ctx context.Context, usr userbus.User) error <span class="cov0" title="0">{
        const query = `
        INSERT INTO users
                (user_id, name, email, phone, password_hash, roles, department, enabled, created_at, updated_at)
        VALUES
                (:user_id, :name, :email, :phone, :password_hash, :roles, :department, :enabled, :created_at, :updated_at)`

        if err := sqldb.NamedExecContext(ctx, s.log, s.db, query, toDBUser(usr)); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sqldb.ErrDBDuplicatedEntry) </span><span class="cov0" title="0">{
                        return fmt.Errorf("creation Error: %w", userbus.ErrUniqueEmail)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("namedexeccontext: %w", err)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Update replaces a user document in the database.
func (s *Store) Update(ctx context.Context, usr userbus.User) error <span class="cov0" title="0">{
        const q = `
        UPDATE
                users
        SET 
                "name" = :name,
                "email" = :email,
                "phone" = :phone,
                "roles" = :roles,
                "password_hash" = :password_hash,
                "department" = :department,
                "enabled" = :enabled,
                "updated_at" = :updated_at
        WHERE
                user_id = :user_id`

        if err := sqldb.NamedExecContext(ctx, s.log, s.db, q, toDBUser(usr)); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sqldb.ErrDBDuplicatedEntry) </span><span class="cov0" title="0">{
                        return userbus.ErrUniqueEmail
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("namedexeccontext: %w", err)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Delete removes a user from the database.
func (s *Store) Delete(ctx context.Context, usr userbus.User) error <span class="cov0" title="0">{
        const q = `
        DELETE FROM
                users
        WHERE
                user_id = :user_id`

        if err := sqldb.NamedExecContext(ctx, s.log, s.db, q, toDBUser(usr)); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("namedexeccontext: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Query retrieves a list of existing users from the database.
func (s *Store) Query(ctx context.Context, filter userbus.QueryFilter, orderBy order.By, page page.Page) ([]userbus.User, error) <span class="cov0" title="0">{
        data := map[string]any{
                "offset":        (page.Number() - 1) * page.RowsPerPage(),
                "rows_per_page": page.RowsPerPage(),
        }

        const q = `
        SELECT
                user_id, name, email, phone, password_hash, roles, department, enabled, created_at, updated_at
        FROM
                users`

        buf := bytes.NewBufferString(q)
        applyFilter(filter, data, buf)

        orderByClause, err := orderByClause(orderBy)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">buf.WriteString(orderByClause)
        buf.WriteString(" OFFSET :offset ROWS FETCH NEXT :rows_per_page ROWS ONLY")

        var dbUsrs []user
        if err := sqldb.NamedQuerySlice(ctx, s.log, s.db, buf.String(), data, &amp;dbUsrs); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("namedqueryslice: %w", err)
        }</span>

        <span class="cov0" title="0">return toBusUsers(dbUsrs)</span>
}

// Count returns the total number of users in the DB.
func (s *Store) Count(ctx context.Context, filter userbus.QueryFilter) (int, error) <span class="cov0" title="0">{
        data := map[string]any{}

        const q = `
        SELECT
                count(1)
        FROM
                users`

        buf := bytes.NewBufferString(q)
        applyFilter(filter, data, buf)

        var count struct {
                Count int `db:"count"`
        }
        if err := sqldb.NamedQueryStruct(ctx, s.log, s.db, buf.String(), data, &amp;count); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("db: %w", err)
        }</span>

        <span class="cov0" title="0">return count.Count, nil</span>
}

// QueryByID gets the specified user from the database.
func (s *Store) QueryByID(ctx context.Context, userID uuid.UUID) (userbus.User, error) <span class="cov0" title="0">{
        data := struct {
                ID string `db:"user_id"`
        }{
                ID: userID.String(),
        }

        const q = `
        SELECT
        user_id, name, email, phone ,password_hash, roles, department, enabled, created_at, updated_at
        FROM
                users
        WHERE 
                user_id = :user_id`

        var dbUsr user
        if err := sqldb.NamedQueryStruct(ctx, s.log, s.db, q, data, &amp;dbUsr); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sqldb.ErrDBNotFound) </span><span class="cov0" title="0">{
                        return userbus.User{}, fmt.Errorf("db: %w", userbus.ErrNotFound)
                }</span>
                <span class="cov0" title="0">return userbus.User{}, fmt.Errorf("db: %w", err)</span>
        }

        <span class="cov0" title="0">return toBusUser(dbUsr)</span>
}

// QueryByEmail gets the specified user from the database by email.
func (s *Store) QueryByEmail(ctx context.Context, email mail.Address) (userbus.User, error) <span class="cov0" title="0">{
        data := struct {
                Email string `db:"email"`
        }{
                Email: email.Address,
        }

        const q = `
        SELECT
        user_id, name, email, phone, password_hash, roles, department, enabled, created_at, updated_at
        FROM
                users
        WHERE
                email = :email`

        var dbUsr user
        if err := sqldb.NamedQueryStruct(ctx, s.log, s.db, q, data, &amp;dbUsr); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sqldb.ErrDBNotFound) </span><span class="cov0" title="0">{
                        return userbus.User{}, fmt.Errorf("db: %w", userbus.ErrNotFound)
                }</span>
                <span class="cov0" title="0">return userbus.User{}, fmt.Errorf("db: %w", err)</span>
        }

        <span class="cov0" title="0">return toBusUser(dbUsr)</span>
}

// QueryByPhone gets the specified user from the database by email.
func (s *Store) QueryByPhone(ctx context.Context, phone facilitytype.PhoneNumber) (userbus.User, error) <span class="cov0" title="0">{
        data := struct {
                Phone string `db:"phone"`
        }{
                Phone: phone.String(),
        }

        const q = `
        SELECT
        user_id, name, email, phone, password_hash, roles, department, enabled, created_at, updated_at
        FROM
                users
        WHERE
                phone = :phone`

        var dbUsr user
        if err := sqldb.NamedQueryStruct(ctx, s.log, s.db, q, data, &amp;dbUsr); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sqldb.ErrDBNotFound) </span><span class="cov0" title="0">{
                        return userbus.User{}, fmt.Errorf("db: %w", userbus.ErrNotFound)
                }</span>
                <span class="cov0" title="0">return userbus.User{}, fmt.Errorf("db: %w", err)</span>
        }

        <span class="cov0" title="0">return toBusUser(dbUsr)</span>
}
</pre>
		
		<pre class="file" id="file156" style="display: none">package userbus

import (
        "context"
        "fmt"
        "math/rand"
        "net/mail"

        "github.com/FITHSCS/backend/business/types/facilitytype"
        "github.com/FITHSCS/backend/business/types/name"
        "github.com/FITHSCS/backend/business/types/role"
        "github.com/google/uuid"
)

func TestNewUsers(n int, rle role.Role) []NewUser <span class="cov5" title="2">{
        newUsrs := make([]NewUser, n)

        idx := rand.Intn(10000)
        for i := range n </span><span class="cov10" title="4">{
                idx++

                nu := NewUser{
                        Name:       name.MustParse(fmt.Sprintf("Name%d", idx)),
                        Email:      mail.Address{Address: fmt.Sprintf("mail%d@gmail.com", idx)},
                        Phone:      facilitytype.MustParsePhoneNumber(fmt.Sprintf("092233%04d", idx)),
                        Roles:      []role.Role{rle},
                        Department: name.MustParseNull(fmt.Sprintf("Department%d", idx)),
                        Password:   fmt.Sprintf("Password%d", idx),
                }

                newUsrs[i] = nu
        }</span>

        <span class="cov5" title="2">return newUsrs</span>
}

// TestSeedUsers is a helper method for testing.
func TestSeedUsers(ctx context.Context, n int, role role.Role, api ExtBusiness) ([]User, error) <span class="cov5" title="2">{
        newUsrs := TestNewUsers(n, role)

        usrs := make([]User, len(newUsrs))
        for i, nu := range newUsrs </span><span class="cov10" title="4">{
                usr, err := api.Create(ctx, uuid.UUID{}, nu)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("seeding user: idx: %d : %w", i, err)
                }</span>
                <span class="cov10" title="4">usrs[i] = usr</span>
        }

        <span class="cov5" title="2">return usrs, nil</span>
}
</pre>
		
		<pre class="file" id="file157" style="display: none">// Package userbus provides business access to user domain.
package userbus

import (
        "context"
        "errors"
        "fmt"
        "net/mail"
        "time"

        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/business/types/facilitytype"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/google/uuid"
        "golang.org/x/crypto/bcrypt"
)

// Set of error variables for CRUD operations.
var (
        ErrNotFound              = errors.New("user not found")
        ErrUniqueEmail           = errors.New("email is not unique")
        ErrAuthenticationFailure = errors.New("authentication failed")
)

// Storer interface declares the behavior this package needs to persist and
// retrieve data.
type Storer interface {
        Create(ctx context.Context, usr User) error
        Update(ctx context.Context, usr User) error
        Delete(ctx context.Context, usr User) error
        Query(ctx context.Context, filter QueryFilter, orderBy order.By, page page.Page) ([]User, error)
        Count(ctx context.Context, filter QueryFilter) (int, error)
        QueryByID(ctx context.Context, userID uuid.UUID) (User, error)
        QueryByEmail(ctx context.Context, email mail.Address) (User, error)
        QueryByPhone(ctx context.Context, pgone facilitytype.PhoneNumber) (User, error)
}

// ExtBusiness interface provides support for extensions that wrap extra functionality
// around the core busines logic.
type ExtBusiness interface {
        Create(ctx context.Context, actorID uuid.UUID, nu NewUser) (User, error)
        Update(ctx context.Context, actorID uuid.UUID, usr User, uu UpdateUser) (User, error)
        Delete(ctx context.Context, actorID uuid.UUID, usr User) error
        Query(ctx context.Context, filter QueryFilter, orderBy order.By, page page.Page) ([]User, error)
        Count(ctx context.Context, filter QueryFilter) (int, error)
        QueryByID(ctx context.Context, userID uuid.UUID) (User, error)
        QueryByEmail(ctx context.Context, email mail.Address) (User, error)
        QueryByPhone(ctx context.Context, phone facilitytype.PhoneNumber) (User, error)
        Authenticate(ctx context.Context, phone facilitytype.PhoneNumber, password string) (User, error)
}

// Extension is a function that wraps a new layer of business logic
// around the existing business logic.
type Extension func(ExtBusiness) ExtBusiness

// Business manages the set of APIs for user access.
type Business struct {
        log    *logger.Logger
        storer Storer
}

// NewBusiness constructs a user business API for use.
func NewBusiness(log *logger.Logger, storer Storer, extensions ...Extension) ExtBusiness <span class="cov1" title="1">{

        b := ExtBusiness(&amp;Business{
                log:    log,
                storer: storer,
        })

        for i := len(extensions) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                ext := extensions[i]
                if ext != nil </span><span class="cov0" title="0">{
                        b = ext(b)
                }</span>
        }

        <span class="cov1" title="1">return b</span>
}

// Create adds a new user to the system.
func (b *Business) Create(ctx context.Context, actorID uuid.UUID, nu NewUser) (User, error) <span class="cov10" title="5">{
        hash, err := bcrypt.GenerateFromPassword([]byte(nu.Password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return User{}, fmt.Errorf("generatefrompassword: %w", err)
        }</span>
        <span class="cov10" title="5">now := time.Now().Truncate(time.Microsecond)

        usr := User{
                ID:           uuid.New(),
                Name:         nu.Name,
                Email:        nu.Email,
                Phone:        nu.Phone,
                Roles:        nu.Roles,
                PasswordHash: hash,
                Department:   nu.Department,
                Enabled:      true,
                DateCreated:  now,
                DateUpdated:  now,
        }

        if err := b.storer.Create(ctx, usr); err != nil </span><span class="cov0" title="0">{
                return User{}, fmt.Errorf("create: %w", err)
        }</span>

        <span class="cov10" title="5">return usr, nil</span>
}

// Update modifies information about a user.
func (b *Business) Update(ctx context.Context, actorID uuid.UUID, usr User, uu UpdateUser) (User, error) <span class="cov1" title="1">{
        if uu.Name != nil </span><span class="cov1" title="1">{
                usr.Name = *uu.Name
        }</span>

        <span class="cov1" title="1">if uu.Email != nil </span><span class="cov1" title="1">{
                usr.Email = *uu.Email
        }</span>

        <span class="cov1" title="1">if uu.Phone != nil </span><span class="cov0" title="0">{
                usr.Phone = *uu.Phone
        }</span>

        <span class="cov1" title="1">if uu.Roles != nil </span><span class="cov1" title="1">{
                usr.Roles = uu.Roles
        }</span>

        <span class="cov1" title="1">if uu.Password != nil </span><span class="cov1" title="1">{
                pw, err := bcrypt.GenerateFromPassword([]byte(*uu.Password), bcrypt.DefaultCost)
                if err != nil </span><span class="cov0" title="0">{
                        return User{}, fmt.Errorf("generatefrompassword: %w", err)
                }</span>
                <span class="cov1" title="1">usr.PasswordHash = pw</span>
        }

        <span class="cov1" title="1">if uu.Department != nil </span><span class="cov1" title="1">{
                usr.Department = *uu.Department
        }</span>

        <span class="cov1" title="1">if uu.Enabled != nil </span><span class="cov0" title="0">{
                usr.Enabled = *uu.Enabled
        }</span>

        <span class="cov1" title="1">usr.DateUpdated = time.Now().Truncate(time.Microsecond)

        if err := b.storer.Update(ctx, usr); err != nil </span><span class="cov0" title="0">{
                return User{}, fmt.Errorf("update: %w", err)
        }</span>

        <span class="cov1" title="1">return usr, nil</span>
}

// Delete removes the specified user.
func (b *Business) Delete(ctx context.Context, actorID uuid.UUID, usr User) error <span class="cov4" title="2">{
        if err := b.storer.Delete(ctx, usr); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("delete: %w", err)
        }</span>

        <span class="cov4" title="2">return nil</span>
}

// Query retrieves a list of existing users.
func (b *Business) Query(ctx context.Context, filter QueryFilter, orderBy order.By, page page.Page) ([]User, error) <span class="cov1" title="1">{
        users, err := b.storer.Query(ctx, filter, orderBy, page)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("query: %w", err)
        }</span>

        <span class="cov1" title="1">return users, nil</span>
}

// Count returns the total number of users.
func (b *Business) Count(ctx context.Context, filter QueryFilter) (int, error) <span class="cov0" title="0">{
        return b.storer.Count(ctx, filter)
}</span>

// QueryByID finds the user by the specified ID.
func (b *Business) QueryByID(ctx context.Context, userID uuid.UUID) (User, error) <span class="cov0" title="0">{
        user, err := b.storer.QueryByID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return User{}, fmt.Errorf("query: userID[%s]: %w", userID, err)
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}

// QueryByEmail finds the user by a specified user email.
func (b *Business) QueryByEmail(ctx context.Context, email mail.Address) (User, error) <span class="cov0" title="0">{
        user, err := b.storer.QueryByEmail(ctx, email)
        if err != nil </span><span class="cov0" title="0">{
                return User{}, fmt.Errorf("query: email[%s]: %w", email, err)
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}

// QueryByPhone finds the user by a specified user email.
func (b *Business) QueryByPhone(ctx context.Context, pne facilitytype.PhoneNumber) (User, error) <span class="cov0" title="0">{
        user, err := b.storer.QueryByPhone(ctx, pne)
        if err != nil </span><span class="cov0" title="0">{
                return User{}, fmt.Errorf("query: phone number[%s]: %w", pne, err)
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}

// Authenticate finds a user by their email and verifies their password. On
// success it returns a Claims User representing this user. The claims can be
// used to generate a token for future authentication.
func (b *Business) Authenticate(ctx context.Context, phone facilitytype.PhoneNumber, password string) (User, error) <span class="cov0" title="0">{
        usr, err := b.QueryByPhone(ctx, phone)
        if err != nil </span><span class="cov0" title="0">{
                return User{}, fmt.Errorf("query: phone[%s]: %w", phone, err)
        }</span>

        <span class="cov0" title="0">if err := bcrypt.CompareHashAndPassword(usr.PasswordHash, []byte(password)); err != nil </span><span class="cov0" title="0">{
                return User{}, fmt.Errorf("comparehashandpassword: %w", ErrAuthenticationFailure)
        }</span>

        <span class="cov0" title="0">return usr, nil</span>
}
</pre>
		
		<pre class="file" id="file158" style="display: none">package vehicledb


import (
        "bytes"
        "fmt"
        "strings"

        "github.com/FITHSCS/backend/business/domain/vehiclebus"
        "github.com/google/uuid"
)
func applyFilter(filter vehiclebus.QueryFilter, data map[string]any, buf *bytes.Buffer) <span class="cov0" title="0">{

    var wc []string

    if filter.ID != uuid.Nil </span><span class="cov0" title="0">{
        data["vehicle_id"] = &amp;filter.ID
        wc = append(wc, "vehicle_id = :vehicle_id")
    }</span>
    <span class="cov0" title="0">if filter.PlateNumber != nil </span><span class="cov0" title="0">{
                  data["plate_number"] = fmt.Sprintf("%%%s%%", *filter.PlateNumber)
                  wc = append(wc, "plate_number LIKE :plate_number")
          }</span>
          <span class="cov0" title="0">if filter.VehicleType != nil </span><span class="cov0" title="0">{
                  data["vehicle_type"] = *filter.VehicleType
                  wc = append(wc, "vehicle_type = :vehicle_type")
          }</span>
          <span class="cov0" title="0">if filter.WeightCapacity != nil </span><span class="cov0" title="0">{
                  data["weight_capacity"] = fmt.Sprintf("%%%s%%", *filter.WeightCapacity)
                  wc = append(wc, "weight_capacity LIKE :weight_capacity")
          }</span>

          <span class="cov0" title="0">if filter.VolumeCapacity != nil </span><span class="cov0" title="0">{
                  data["volume_capacity"] = fmt.Sprintf("%%%s%%", *filter.VolumeCapacity)
      wc = append(wc, "volume_capacity LIKE :volume_capacity")
          }</span>
 
    
    <span class="cov0" title="0">if filter.CurrentStatus != nil </span><span class="cov0" title="0">{
        data["current_status"] = *filter.CurrentStatus
        wc = append(wc, "current_status = :current_status")
    }</span>
    
    <span class="cov0" title="0">if filter.CreatedAt != nil </span><span class="cov0" title="0">{
      data["created_at"] = filter.CreatedAt.UTC()
      wc = append(wc, "date_created &gt;= :created_at")
    }</span>
    <span class="cov0" title="0">if filter.UpdatedAt != nil </span><span class="cov0" title="0">{
        data["updated_at"] = filter.UpdatedAt.UTC()
        wc = append(wc, "updated_at &lt;= :updated_at")
    }</span>

    <span class="cov0" title="0">if len(wc) &gt; 0 </span><span class="cov0" title="0">{
        buf.WriteString(" WHERE ")
        buf.WriteString(strings.Join(wc, " AND "))
    }</span>
} 

</pre>
		
		<pre class="file" id="file159" style="display: none">package vehicledb

import (
        //"database/sql"
        "fmt"
        //"net/mail"
        "time"

        "github.com/FITHSCS/backend/business/domain/vehiclebus"

        "github.com/FITHSCS/backend/business/types/genstringtype"
        "github.com/google/uuid"
)

//&lt;============struct that is going to be passed to database schema =&gt; Final =======&gt;

type vehicle struct {
        ID             uuid.UUID `db:"vehicle_id"`
        PlateNumber    string    `db:"plate_number"`
        VehicleType    string    `db:"vehicle_type"`
        WeightCapacity int       `db:"weight_capacity"`
        VolumeCapacity int       `db:"volume_capacity"`
        CurrentStatus  string    `db:"current_status"`
        CreatedAt      time.Time `db:"created_at"`
        UpdatedAt      time.Time `db:"updated_at"`
}

//=============================================================================&gt;

func toDBVehicle(bus vehiclebus.Vehicle) vehicle <span class="cov0" title="0">{

        return vehicle{

                ID:             bus.ID,
                PlateNumber:    bus.PlateNumber.String(),
                VehicleType:    bus.VehicleType.String(),
                WeightCapacity: bus.WeightCapacity,
                VolumeCapacity: bus.VolumeCapacity,
                CurrentStatus:  bus.CurrentStatus.String(),
                CreatedAt:      bus.CreatedAt.UTC(),
                UpdatedAt:      bus.UpdatedAt.UTC(),
        }
}</span>

func toBusVehicle(db vehicle) (vehiclebus.Vehicle, error) <span class="cov0" title="0">{

        plteNumber, err := genstringtype.Parse(db.PlateNumber)
        if err != nil </span><span class="cov0" title="0">{
                return vehiclebus.Vehicle{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">vhiclType, err := genstringtype.Parse(db.VehicleType)
        if err != nil </span><span class="cov0" title="0">{
                return vehiclebus.Vehicle{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">currentStatus, err := genstringtype.Parse(db.CurrentStatus)
        if err != nil </span><span class="cov0" title="0">{
                return vehiclebus.Vehicle{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">bus := vehiclebus.Vehicle{

                ID:             db.ID,
                PlateNumber:    plteNumber,
                VehicleType:    vhiclType,
                WeightCapacity: db.WeightCapacity,
                VolumeCapacity: db.VolumeCapacity,
                CurrentStatus:  currentStatus,
                CreatedAt:      db.CreatedAt.In(time.Local),
                UpdatedAt:      db.UpdatedAt.In(time.Local),
        }
        return bus, nil</span>

}

func toBusVehicles(dbs []vehicle) ([]vehiclebus.Vehicle, error) <span class="cov0" title="0">{

        bus := make([]vehiclebus.Vehicle, len(dbs))

        for i, db := range dbs </span><span class="cov0" title="0">{
                var err error
                bus[i], err = toBusVehicle(db)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">return bus, nil</span>
}
</pre>
		
		<pre class="file" id="file160" style="display: none">package vehicledb


import (
  "fmt"

  "github.com/FITHSCS/backend/business/domain/vehiclebus"
  "github.com/FITHSCS/backend/business/sdk/order"
) 

var orderByFields = map[string]string{
    vehiclebus.OrderByID:                   "vehicle_id",
    vehiclebus.OrderByPlateNumber:          "plate_number",
    vehiclebus.OrderByVehicleType:          "vehicle_type",
    vehiclebus.OrderByWeightCapacity:       "weight_capacity",
    vehiclebus.OrderByVolumeCapacity:       "volume_capacity",
    vehiclebus.OrderByCurrentStatus:        "current_status",
    vehiclebus.OrderByCreatedAt:            "created_at",
    vehiclebus.OrderByUpdatedAt:            "updated_at",
}

// orderByClause converts an order.By value into the final
// " ORDER BY  ASC|DESC" fragment the store adds to its SELECT.
func orderByClause(ob order.By) (string, error) <span class="cov0" title="0">{
  col, ok := orderByFields[ob.Field]
  if !ok </span><span class="cov0" title="0">{
    return "", fmt.Errorf("field %q does not exist", ob.Field)
  }</span>
  <span class="cov0" title="0">return " ORDER BY " + col + " " + ob.Direction, nil</span>
}
</pre>
		
		<pre class="file" id="file161" style="display: none">// Package vehicledb contains product related CRUD functionality.
package vehicledb

import (
        "bytes"
        "context"
        "errors"
        "fmt"

        "github.com/FITHSCS/backend/business/domain/vehiclebus"
        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/business/sdk/sqldb"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/google/uuid"
        "github.com/jmoiron/sqlx"
)

type Store struct {
        log *logger.Logger
        db  sqlx.ExtContext
}

func NewStore(log *logger.Logger, db *sqlx.DB) *Store <span class="cov0" title="0">{
        return &amp;Store{log: log, db: db}
}</span>

// -----------------------------------------------------------------------------
// CRUD
// -----------------------------------------------------------------------------

func (s *Store) Create(ctx context.Context, v vehiclebus.Vehicle) error <span class="cov0" title="0">{
        fmt.Println(v)
        const stmt = `
    INSERT INTO vehicle (
            vehicle_id,
                plate_number, 
                vehicle_type, 
                weight_capacity,
            volume_capacity, 
                current_status, 
            created_at, 
                updated_at
    ) VALUES (
            :vehicle_id, 
                :plate_number, 
                :vehicle_type, 
                :weight_capacity,
            :volume_capacity, 
                :current_status,
            :created_at, 
                :updated_at
    )`
        return sqldb.NamedExecContext(ctx, s.log, s.db, stmt, toDBVehicle(v))
}</span>

func (s *Store) Update(ctx context.Context, v vehiclebus.Vehicle) error <span class="cov0" title="0">{
        const stmt = `
    UPDATE 
                vehicle
        SET 
                plate_number      = :plate_number,
            vehicle_type      = :vehicle_type,
            weight_capacity   = :weight_capacity,
            volume_capacity   = :volume_capacity,
            current_status    = :current_status,
            updated_at        = :updated_at
    WHERE 
                vehicle_id        = :vehicle_id`
        return sqldb.NamedExecContext(ctx, s.log, s.db, stmt, toDBVehicle(v))
}</span>

func (s *Store) Query(ctx context.Context,
        filter vehiclebus.QueryFilter, orderBy order.By, page page.Page) ([]vehiclebus.Vehicle, error) <span class="cov0" title="0">{
        //func (s *Store) Query(ctx context.Context) ([]vehiclebus.Vehicle, error) {

        data := map[string]any{
                "offset":        (page.Number() - 1) * page.RowsPerPage(),
                "rows_per_page": page.RowsPerPage(),
        }

        const q = `
    SELECT
            vehicle_id, 
                plate_number, 
                vehicle_type, 
                weight_capacity,
            volume_capacity, 
                current_status,
            created_at, 
                updated_at
    FROM 
                vehicle`

        var buf bytes.Buffer
        buf.WriteString(q)
        applyFilter(filter, data, &amp;buf)

        clause, err := orderByClause(orderBy)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">buf.WriteString(clause)
        buf.WriteString(" OFFSET :offset ROWS FETCH NEXT :rows_per_page ROWS ONLY")

        var dbRecs []vehicle
        if err := sqldb.NamedQuerySlice(ctx, s.log, s.db, buf.String(), data, &amp;dbRecs); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("namedqueryslice: %w", err)
        }</span>
        <span class="cov0" title="0">fmt.Println(dbRecs)
        return toBusVehicles(dbRecs)</span>
}

func (s *Store) Count(ctx context.Context, filter vehiclebus.QueryFilter) (int, error) <span class="cov0" title="0">{
        data := map[string]any{}
        const base = `SELECT count(1) FROM vehicle`

        var buf bytes.Buffer
        buf.WriteString(base)
        applyFilter(filter, data, &amp;buf)

        var out struct {
                Count int `db:"count"`
        }
        if err := sqldb.NamedQueryStruct(ctx, s.log, s.db, buf.String(), data, &amp;out); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("db: %w", err)
        }</span>
        <span class="cov0" title="0">return out.Count, nil</span>
}
func (s *Store) QueryByID(ctx context.Context, id uuid.UUID) (vehiclebus.Vehicle, error) <span class="cov0" title="0">{
        param := map[string]any{
                "vehicle_id": id.String(),
        }
        const stmt = `
    SELECT
                vehicle_id,
                plate_number,
                vehicle_type,
                weight_capacity,
                volume_capacity,
                current_status,
                created_at,
                updated_at
        FROM 
                vehicle
        WHERE 
                vehicle_id = :vehicle_id`

        var rec vehicle
        if err := sqldb.NamedQueryStruct(ctx, s.log, s.db, stmt, param, &amp;rec); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sqldb.ErrDBNotFound) </span><span class="cov0" title="0">{
                        return vehiclebus.Vehicle{}, vehiclebus.ErrNotFound
                }</span>
                <span class="cov0" title="0">return vehiclebus.Vehicle{}, err</span>
        }
        <span class="cov0" title="0">return toBusVehicle(rec)</span>
}

func (s *Store) Delete(ctx context.Context, vehicleID uuid.UUID) error <span class="cov0" title="0">{

        const q = `
    DELETE FROM
        vehicle
    WHERE
        vehicle_id = :vehicle_id`

        dbFacility := vehicle{ID: vehicleID}

        if err := sqldb.NamedExecContext(ctx, s.log, s.db, q, dbFacility); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("namedexeccontext: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file162" style="display: none">package vehiclebus

import (
        "context"
        "fmt"
        "math/rand"

        "github.com/FITHSCS/backend/business/types/genstringtype"
)

func TestGenerateNewVehicles(n int) []NewVehicle <span class="cov5" title="2">{
        newroute := make([]NewVehicle, n)

        idx := rand.Intn(10000)
        for i := range n </span><span class="cov10" title="4">{
                idx++

                nf := NewVehicle{
                        PlateNumber:    genstringtype.MustParse(fmt.Sprintf("03-B-12%2d", idx)),
                        VehicleType:    genstringtype.MustParse("Truck"),
                        WeightCapacity: idx,
                        VolumeCapacity: idx % 100,
                        CurrentStatus:  genstringtype.MustParse("Active"),
                }

                newroute[i] = nf
        }</span>

        <span class="cov5" title="2">return newroute</span>
}

func TestGenerateSeedVehicles(ctx context.Context, n int, api *Business) ([]Vehicle, error) <span class="cov5" title="2">{
        newfs := TestGenerateNewVehicles(n)

        facs := make([]Vehicle, len(newfs))
        for i, np := range newfs </span><span class="cov10" title="4">{
                prd, err := api.Create(ctx, np)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("seeding routes: idx: %d : %w", i, err)
                }</span>

                <span class="cov10" title="4">facs[i] = prd</span>
        }

        <span class="cov5" title="2">return facs, nil</span>
}
</pre>
		
		<pre class="file" id="file163" style="display: none">// Package vehiclebus provides business access to vehicles bus domain.
package vehiclebus

import (
        "context"
        "errors"
        "fmt"

        "time"

        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/google/uuid"
)

var (
        ErrNotFound       = errors.New("vehicle not found")
        ErrAuthentication = errors.New("authentication failed")
)

type Storer interface {
        Create(ctx context.Context, vehicle Vehicle) error
        Update(ctx context.Context, vehicle Vehicle) error
        Query(ctx context.Context, filter QueryFilter, orderby order.By, page page.Page) ([]Vehicle, error)
        QueryByID(ctx context.Context, vehicleID uuid.UUID) (Vehicle, error)
        Count(ctx context.Context, filter QueryFilter) (int, error)
        Delete(ctx context.Context, vehicleID uuid.UUID) error
}

type Business struct {
        log    *logger.Logger
        storer Storer
}

func NewBusiness(log *logger.Logger, storer Storer) *Business <span class="cov1" title="1">{

        return &amp;Business{
                log:    log,
                storer: storer,
        }
}</span>

func (b *Business) Create(ctx context.Context, vf NewVehicle) (Vehicle, error) <span class="cov10" title="5">{

        now := time.Now().Truncate(time.Microsecond)

        vehicle := Vehicle{

                ID:             uuid.New(),
                PlateNumber:    vf.PlateNumber,
                VehicleType:    vf.VehicleType,
                WeightCapacity: vf.WeightCapacity,
                VolumeCapacity: vf.VolumeCapacity,
                CurrentStatus:  vf.CurrentStatus,
                CreatedAt:      now,
                UpdatedAt:      now,
        }

        if err := b.storer.Create(ctx, vehicle); err != nil </span><span class="cov0" title="0">{
                return Vehicle{}, fmt.Errorf("Create: %w", err)
        }</span>
        <span class="cov10" title="5">return vehicle, nil</span>
}

func (b *Business) Update(ctx context.Context, vehicleID uuid.UUID, updateVehicle UpdateVehicle) (Vehicle, error) <span class="cov1" title="1">{

        vehicleDBRetrieved, err := b.storer.QueryByID(ctx, vehicleID)
        if err != nil </span><span class="cov0" title="0">{
                return Vehicle{}, fmt.Errorf("update: %w", err)
        }</span>

        <span class="cov1" title="1">if updateVehicle.PlateNumber != nil </span><span class="cov1" title="1">{
                vehicleDBRetrieved.PlateNumber = *updateVehicle.PlateNumber
        }</span>

        <span class="cov1" title="1">if updateVehicle.VehicleType != nil </span><span class="cov1" title="1">{
                vehicleDBRetrieved.VehicleType = *updateVehicle.VehicleType
        }</span>

        <span class="cov1" title="1">if updateVehicle.WeightCapacity != nil </span><span class="cov1" title="1">{
                vehicleDBRetrieved.WeightCapacity = *updateVehicle.WeightCapacity
        }</span>

        <span class="cov1" title="1">if updateVehicle.VolumeCapacity != nil </span><span class="cov1" title="1">{
                vehicleDBRetrieved.VolumeCapacity = *updateVehicle.VolumeCapacity
        }</span>

        <span class="cov1" title="1">if updateVehicle.CurrentStatus != nil </span><span class="cov1" title="1">{
                vehicleDBRetrieved.CurrentStatus = *updateVehicle.CurrentStatus
        }</span>

        <span class="cov1" title="1">vehicleDBRetrieved.UpdatedAt = time.Now().Truncate(time.Microsecond)

        if err := b.storer.Update(ctx, vehicleDBRetrieved); err != nil </span><span class="cov0" title="0">{
                return Vehicle{}, fmt.Errorf("update: %w", err)
        }</span>
        <span class="cov1" title="1">return vehicleDBRetrieved, nil</span>
}

func (b *Business) QueryByID(ctx context.Context, vehicleID uuid.UUID) (Vehicle, error) <span class="cov1" title="1">{

        vehicle, err := b.storer.QueryByID(ctx, vehicleID)
        if err != nil </span><span class="cov0" title="0">{
                return Vehicle{}, fmt.Errorf("query: vehicleID[%s]: %w", vehicleID, err)
        }</span>
        <span class="cov1" title="1">return vehicle, nil</span>
}

func (b *Business) Query(ctx context.Context, filter QueryFilter, orderBy order.By, page page.Page) ([]Vehicle, error) <span class="cov1" title="1">{
        vehicles, err := b.storer.Query(ctx, filter, orderBy, page)

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Query: %w", err)
        }</span>
        <span class="cov1" title="1">return vehicles, nil</span>
}

func (b *Business) Count(ctx context.Context, filter QueryFilter) (int, error) <span class="cov0" title="0">{
        return b.storer.Count(ctx, filter)
}</span>

func (b *Business) Delete(ctx context.Context, vehicleID uuid.UUID) error <span class="cov4" title="2">{

        if err := b.storer.Delete(ctx, vehicleID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("delete: %w", err)
        }</span>
        <span class="cov4" title="2">return nil</span>
}
</pre>
		
		<pre class="file" id="file164" style="display: none">package dbtest

import (
        "time"

        "github.com/FITHSCS/backend/business/domain/auditbus"
        "github.com/FITHSCS/backend/business/domain/auditbus/stores/auditdb"
        "github.com/FITHSCS/backend/business/domain/delexceptionbus"
        "github.com/FITHSCS/backend/business/domain/delexceptionbus/store/delexceptiondb"
        "github.com/FITHSCS/backend/business/domain/facilitybus"
        "github.com/FITHSCS/backend/business/domain/facilitybus/stores/facilitydb"
        "github.com/FITHSCS/backend/business/domain/gpstrackingbus"
        "github.com/FITHSCS/backend/business/domain/gpstrackingbus/stores/gpstrackingdb"
        "github.com/FITHSCS/backend/business/domain/imagebus"
        "github.com/FITHSCS/backend/business/domain/imagebus/stores/imagedb"
        "github.com/FITHSCS/backend/business/domain/manifestbus"
        "github.com/FITHSCS/backend/business/domain/manifestbus/stores/manifestdb"
        "github.com/FITHSCS/backend/business/domain/pickupbatchbus"
        "github.com/FITHSCS/backend/business/domain/pickupbatchbus/stores/pickupbatchdb"
        "github.com/FITHSCS/backend/business/domain/routebus"
        "github.com/FITHSCS/backend/business/domain/routebus/stores/routedb"
        "github.com/FITHSCS/backend/business/domain/signaturebus"
        "github.com/FITHSCS/backend/business/domain/signaturebus/stores/signaturedb"
        "github.com/FITHSCS/backend/business/domain/userbus"
        "github.com/FITHSCS/backend/business/domain/userbus/stores/usercache"
        "github.com/FITHSCS/backend/business/domain/userbus/stores/userdb"
        "github.com/FITHSCS/backend/business/domain/vehiclebus"
        "github.com/FITHSCS/backend/business/domain/vehiclebus/stores/vehicledb"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/jmoiron/sqlx"
)

// BusDomain represents all the business domain apis needed for testing.
type BusDomain struct {
        User              userbus.ExtBusiness
        Facility          *facilitybus.Business
        Routes            *routebus.Business
        Audit             *auditbus.Business
        Vehicle           *vehiclebus.Business
        PickupBatch       *pickupbatchbus.Business
        Manifest          *manifestbus.Business
        Signature         *signaturebus.Business
        DeliveryException *delexceptionbus.Business
        Image             *imagebus.Business
        GPStrackingbus    *gpstrackingbus.Business
}

func newBusDomains(log *logger.Logger, db *sqlx.DB) BusDomain <span class="cov0" title="0">{
        userBus := userbus.NewBusiness(log, usercache.NewStore(log, userdb.NewStore(log, db), time.Minute))
        facilitybus := facilitybus.NewBusiness(log, facilitydb.NewStore(log, db))
        auditBus := auditbus.NewBusiness(log, auditdb.NewStore(log, db))
        routebus := routebus.NewBusiness(log, routedb.NewStore(log, db))
        vehiclebus := vehiclebus.NewBusiness(log, vehicledb.NewStore(log, db))
        pickupbtch := pickupbatchbus.NewBusiness(log, pickupbatchdb.NewStore(log, db))
        manifestbus := manifestbus.NewBusiness(log, manifestdb.NewStore(log, db))
        signaturebus := signaturebus.NewBusiness(log, signaturedb.NewStore(log, db))
        delexbus := delexceptionbus.NewBusiness(log, delexceptiondb.NewStore(log, db))
        imagebus := imagebus.NewBusiness(log, imagedb.NewStore(log, db))
        gpsbus := gpstrackingbus.NewBusiness(log, gpstrackingdb.NewStore(log, db))

        return BusDomain{
                User:              userBus,
                Audit:             auditBus,
                Facility:          facilitybus,
                Routes:            routebus,
                Vehicle:           vehiclebus,
                PickupBatch:       pickupbtch,
                Manifest:          manifestbus,
                Signature:         signaturebus,
                DeliveryException: delexbus,
                Image:             imagebus,
                GPStrackingbus:    gpsbus,
        }
}</span>
</pre>
		
		<pre class="file" id="file165" style="display: none">// Package dbtest contains supporting code for running tests that hit the DB.
package dbtest

import (
        "bytes"
        "context"
        "math/rand"
        "testing"
        "time"

        "github.com/FITHSCS/backend/business/sdk/migrate"
        "github.com/FITHSCS/backend/business/sdk/sqldb"
        "github.com/FITHSCS/backend/foundation/docker"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/FITHSCS/backend/foundation/otel"
        "github.com/jmoiron/sqlx"
)

// Database owns state for running and shutting down tests.
type Database struct {
        DB        *sqlx.DB
        Log       *logger.Logger
        BusDomain BusDomain
}

// New creates a new test database inside the database that was started
// to handle testing. The database is migrated to the current version and
// a connection pool is provided with business domain packages.
func New(t *testing.T, testName string) *Database <span class="cov0" title="0">{
        image := "postgres:17.4"
        name := "servicetest"
        port := "5432"
        dockerArgs := []string{"-e", "POSTGRES_PASSWORD=postgres"}
        appArgs := []string{"-c", "log_statement=all"}

        c, err := docker.StartContainer(image, name, port, dockerArgs, appArgs)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Starting database: %v", err)
        }</span>

        <span class="cov0" title="0">t.Logf("Name    : %s\n", c.Name)
        t.Logf("HostPort: %s\n", c.HostPort)

        dbM, err := sqldb.Open(sqldb.Config{
                User:       "postgres",
                Password:   "postgres",
                Host:       c.HostPort,
                Name:       "postgres",
                DisableTLS: true,
        })
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Opening database connection: %v", err)
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        if err := sqldb.StatusCheck(ctx, dbM); err != nil </span><span class="cov0" title="0">{
                t.Fatalf("status check database: %v", err)
        }</span>

        // -------------------------------------------------------------------------

        <span class="cov0" title="0">const letterBytes = "abcdefghijklmnopqrstuvwxyz"
        b := make([]byte, 4)
        for i := range b </span><span class="cov0" title="0">{
                b[i] = letterBytes[rand.Intn(len(letterBytes))]
        }</span>
        <span class="cov0" title="0">dbName := string(b)

        t.Logf("Create Database: %s\n", dbName)
        if _, err := dbM.ExecContext(context.Background(), "CREATE DATABASE "+dbName); err != nil </span><span class="cov0" title="0">{
                t.Fatalf("creating database %s: %v", dbName, err)
        }</span>

        // -------------------------------------------------------------------------

        <span class="cov0" title="0">db, err := sqldb.Open(sqldb.Config{
                User:       "postgres",
                Password:   "postgres",
                Host:       c.HostPort,
                Name:       dbName,
                DisableTLS: true,
        })
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Opening database connection: %v", err)
        }</span>

        <span class="cov0" title="0">t.Logf("Migrate Database: %s\n", dbName)
        if err := migrate.Migrate(ctx, db); err != nil </span><span class="cov0" title="0">{
                t.Logf("Logs for %s\n%s:", c.Name, docker.DumpContainerLogs(c.Name))
                t.Fatalf("Migrating error: %s", err)
        }</span>

        // -------------------------------------------------------------------------

        <span class="cov0" title="0">var buf bytes.Buffer
        log := logger.New(&amp;buf, logger.LevelInfo, "TEST", func(context.Context) string </span><span class="cov0" title="0">{ return otel.GetTraceID(ctx) }</span>)

        // -------------------------------------------------------------------------

        <span class="cov0" title="0">t.Cleanup(func() </span><span class="cov0" title="0">{
                t.Helper()

                t.Logf("Drop Database: %s\n", dbName)
                if _, err := dbM.ExecContext(context.Background(), "DROP DATABASE "+dbName); err != nil </span><span class="cov0" title="0">{
                        t.Fatalf("dropping database %s: %v", dbName, err)
                }</span>

                <span class="cov0" title="0">db.Close()
                dbM.Close()

                t.Logf("******************** LOGS (%s) ********************\n\n", testName)
                t.Log(buf.String())
                t.Logf("******************** LOGS (%s) ********************\n", testName)</span>
        })

        <span class="cov0" title="0">return &amp;Database{
                DB:        db,
                Log:       log,
                BusDomain: newBusDomains(log, db),
        }</span>
}
</pre>
		
		<pre class="file" id="file166" style="display: none">package dbtest

import (
        "encoding/json"
        "time"

        "github.com/FITHSCS/backend/business/types/facilitytype"
        "github.com/FITHSCS/backend/business/types/genstringtype"
        "github.com/FITHSCS/backend/business/types/name"
        "github.com/google/uuid"
)

// StringPointer is a helper to get a *string from a string. It is in the tests
// package because we normally don't want to deal with pointers to basic types
// but it's useful in some tests.
func StringPointer(s string) *string <span class="cov0" title="0">{
        return &amp;s
}</span>

// IntPointer is a helper to get a *int from a int. It is in the tests package
// because we normally don't want to deal with pointers to basic types but it's
// useful in some tests.
func IntPointer(i int) *int <span class="cov0" title="0">{
        return &amp;i
}</span>

// FloatPointer is a helper to get a *float64 from a float64. It is in the tests
// package because we normally don't want to deal with pointers to basic types
// but it's useful in some tests.
func FloatPointer(f float64) *float64 <span class="cov0" title="0">{
        return &amp;f
}</span>

// BoolPointer is a helper to get a *bool from a bool. It is in the tests package
// because we normally don't want to deal with pointers to basic types but it's
// useful in some tests.
func BoolPointer(b bool) *bool <span class="cov0" title="0">{
        return &amp;b
}</span>

// NamePointer is a helper to get a *Name from a string. It's in the tests
// package because we normally don't want to deal with pointers to basic types
// but it's useful in some tests.
func NamePointer(value string) *name.Name <span class="cov0" title="0">{
        name := name.MustParse(value)
        return &amp;name
}</span>

// NameNullPointer is a helper to get a *EmptyName from a string. It's in the tests
// package because we normally don't want to deal with pointers to basic types
// but it's useful in some tests.
func NameNullPointer(value string) *name.Null <span class="cov0" title="0">{
        name := name.MustParseNull(value)
        return &amp;name
}</span>

// ==========================================================
// Eyu's implementation for types

func AddressPointer(value string) *facilitytype.Address <span class="cov0" title="0">{
        add := facilitytype.MustParseAddress(value)
        return &amp;add
}</span>

func LatitudePointer(f float64) *facilitytype.Lat <span class="cov0" title="0">{
        lat := facilitytype.MustParseLat(f)
        return &amp;lat
}</span>

func LongitudePointer(f float64) *facilitytype.Long <span class="cov0" title="0">{
        long := facilitytype.MustParseLong(f)
        return &amp;long
}</span>

func GeofencePointer(f float64) *facilitytype.Geofence <span class="cov0" title="0">{
        geofence := facilitytype.MustParseGeofence(f)

        return &amp;geofence
}</span>

func PhoneNumberPointer(str string) *facilitytype.PhoneNumber <span class="cov0" title="0">{
        phonum := facilitytype.MustParsePhoneNumber(str)
        return &amp;phonum
}</span>

func GenStringPointer(str string) *genstringtype.GenString <span class="cov0" title="0">{
        genericString := genstringtype.MustParse(str)
        return &amp;genericString
}</span>

func UUIDStringPointer(str string) *uuid.UUID <span class="cov0" title="0">{
        id := uuid.MustParse(str)
        return &amp;id
}</span>

func NullUUIDStringPointer(id uuid.NullUUID) *uuid.NullUUID <span class="cov0" title="0">{
        return &amp;id
}</span>

func TimePointer(tme time.Time) *time.Time <span class="cov0" title="0">{
        return &amp;tme
}</span>

func RawJSONPointer(rj json.RawMessage) *json.RawMessage <span class="cov0" title="0">{
        return &amp;rj
}</span>
</pre>
		
		<pre class="file" id="file167" style="display: none">// Package delegate provides the ability to make function calls between
// different domain packages when an import is not possible.
package delegate

import (
        "context"

        "github.com/FITHSCS/backend/foundation/logger"
)

// These types are just for documentation so we know what keys go
// where in the map.
type (
        domain string
        action string
)

// Delegate manages the set of functions to be called by domain
// packages when an import is not possible.
type Delegate struct {
        log   *logger.Logger
        funcs map[domain]map[action][]Func
}

// New constructs a delegate for indirect api access.
func New(log *logger.Logger) *Delegate <span class="cov0" title="0">{
        return &amp;Delegate{
                log:   log,
                funcs: make(map[domain]map[action][]Func),
        }
}</span>

// Register adds a function to be called for a specified domain and action.
func (d *Delegate) Register(domainType string, actionType string, fn Func) <span class="cov0" title="0">{
        aMap, ok := d.funcs[domain(domainType)]
        if !ok </span><span class="cov0" title="0">{
                aMap = make(map[action][]Func)
                d.funcs[domain(domainType)] = aMap
        }</span>

        <span class="cov0" title="0">funcs := aMap[action(actionType)]
        funcs = append(funcs, fn)
        aMap[action(actionType)] = funcs</span>
}

// Call executes all functions registered for the specified domain and
// action. These functions are executed synchronously on the G making the call.
func (d *Delegate) Call(ctx context.Context, data Data) error <span class="cov0" title="0">{
        d.log.Info(ctx, "delegate call", "status", "started", "domain", data.Domain, "action", data.Action, "params", data.RawParams)
        defer d.log.Info(ctx, "delegate call", "status", "completed")

        if dMap, ok := d.funcs[domain(data.Domain)]; ok </span><span class="cov0" title="0">{
                if funcs, ok := dMap[action(data.Action)]; ok </span><span class="cov0" title="0">{
                        for _, fn := range funcs </span><span class="cov0" title="0">{
                                d.log.Info(ctx, "delegate call", "status", "sending")

                                if err := fn(ctx, data); err != nil </span><span class="cov0" title="0">{
                                        d.log.Error(ctx, "delegate call", "err", err)
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file168" style="display: none">package delegate

import (
        "context"
        "fmt"
)

// Func represents a function that is registered and called by the system.
type Func func(context.Context, Data) error

// Data represents an event between domains.
type Data struct {
        Domain    string
        Action    string
        RawParams []byte
}

// String implements the Stringer interface.
func (d Data) String() string <span class="cov0" title="0">{
        return fmt.Sprintf(
                "Event{Domain:%#v, Action:%#v, RawParams:%#v}",
                d.Domain, d.Action, string(d.RawParams),
        )
}</span>
</pre>
		
		<pre class="file" id="file169" style="display: none">// Package migrate contains the database schema, migrations and seeding data.
package migrate

import (
        "context"
        "database/sql"
        _ "embed"
        "errors"
        "fmt"

        "github.com/FITHSCS/backend/business/sdk/sqldb"
        "github.com/ardanlabs/darwin/v3"
        "github.com/ardanlabs/darwin/v3/dialects/postgres"
        "github.com/ardanlabs/darwin/v3/drivers/generic"
        "github.com/jmoiron/sqlx"
)

var (
        //go:embed sql/migrate.sql
        migrateDoc string

        //go:embed sql/seed.sql
        seedDoc string
)

// Migrate attempts to bring the database up to date with the migrations
// defined in this package.
func Migrate(ctx context.Context, db *sqlx.DB) error <span class="cov0" title="0">{
        if err := sqldb.StatusCheck(ctx, db); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("status check database: %w", err)
        }</span>

        <span class="cov0" title="0">driver, err := generic.New(db.DB, postgres.Dialect{})
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("construct darwin driver: %w", err)
        }</span>

        <span class="cov0" title="0">d := darwin.New(driver, darwin.ParseMigrations(migrateDoc))
        return d.Migrate()</span>
}

// Seed runs the seed document defined in this package against db. The queries
// are run in a transaction and rolled back if any fail.
func Seed(ctx context.Context, db *sqlx.DB) (err error) <span class="cov0" title="0">{
        if err := sqldb.StatusCheck(ctx, db); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("status check database: %w", err)
        }</span>

        <span class="cov0" title="0">tx, err := db.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if errTx := tx.Rollback(); errTx != nil </span><span class="cov0" title="0">{
                        if errors.Is(errTx, sql.ErrTxDone) </span><span class="cov0" title="0">{
                                return
                        }</span>

                        <span class="cov0" title="0">err = fmt.Errorf("rollback: %w", errTx)
                        return</span>
                }
        }()

        <span class="cov0" title="0">if _, err := tx.Exec(seedDoc); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("exec: %w", err)
        }</span>

        <span class="cov0" title="0">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("commit: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file170" style="display: none">// Package order provides support for describing the ordering of data.
package order

import (
        "fmt"
        "strings"
)

// Set of directions for data ordering.
const (
        ASC  = "ASC"
        DESC = "DESC"
)

var directions = map[string]string{
        ASC:  "ASC",
        DESC: "DESC",
}

// By represents a field used to order by and direction.
type By struct {
        Field     string
        Direction string
}

// NewBy constructs a new By value with no checks.
func NewBy(field string, direction string) By <span class="cov0" title="0">{
        if _, exists := directions[direction]; !exists </span><span class="cov0" title="0">{
                return By{
                        Field:     field,
                        Direction: ASC,
                }
        }</span>

        <span class="cov0" title="0">return By{
                Field:     field,
                Direction: direction,
        }</span>
}

// Parse constructs a By value by parsing a string in the form of
// "field,direction" ie "user_id,ASC".
func Parse(fieldMappings map[string]string, orderBy string, defaultOrder By) (By, error) <span class="cov0" title="0">{
        if orderBy == "" </span><span class="cov0" title="0">{
                return defaultOrder, nil
        }</span>

        <span class="cov0" title="0">orderParts := strings.Split(orderBy, ",")

        orgFieldName := strings.TrimSpace(orderParts[0])
        fieldName, exists := fieldMappings[orgFieldName]
        if !exists </span><span class="cov0" title="0">{
                return By{}, fmt.Errorf("unknown order: %s", orgFieldName)
        }</span>

        <span class="cov0" title="0">switch len(orderParts) </span>{
        case 1:<span class="cov0" title="0">
                return NewBy(fieldName, ASC), nil</span>

        case 2:<span class="cov0" title="0">
                direction := strings.TrimSpace(orderParts[1])
                if _, exists := directions[direction]; !exists </span><span class="cov0" title="0">{
                        return By{}, fmt.Errorf("unknown direction: %s", direction)
                }</span>

                <span class="cov0" title="0">return NewBy(fieldName, direction), nil</span>

        default:<span class="cov0" title="0">
                return By{}, fmt.Errorf("unknown order: %s", orderBy)</span>
        }
}
</pre>
		
		<pre class="file" id="file171" style="display: none">// Package page provides support for query paging.
package page

import (
        "fmt"
        "strconv"
)

// Page represents the requested page and rows per page.
type Page struct {
        number int
        rows   int
}

// Parse parses the strings and validates the values are in reason.
func Parse(page string, rowsPerPage string) (Page, error) <span class="cov0" title="0">{
        number := 1
        if page != "" </span><span class="cov0" title="0">{
                var err error
                number, err = strconv.Atoi(page)
                if err != nil </span><span class="cov0" title="0">{
                        return Page{}, fmt.Errorf("page conversion: %w", err)
                }</span>
        }

        <span class="cov0" title="0">rows := 10
        if rowsPerPage != "" </span><span class="cov0" title="0">{
                var err error
                rows, err = strconv.Atoi(rowsPerPage)
                if err != nil </span><span class="cov0" title="0">{
                        return Page{}, fmt.Errorf("rows conversion: %w", err)
                }</span>
        }

        <span class="cov0" title="0">if number &lt;= 0 </span><span class="cov0" title="0">{
                return Page{}, fmt.Errorf("page value too small, must be larger than 0")
        }</span>

        <span class="cov0" title="0">if rows &lt;= 0 </span><span class="cov0" title="0">{
                return Page{}, fmt.Errorf("rows value too small, must be larger than 0")
        }</span>

        <span class="cov0" title="0">if rows &gt; 100 </span><span class="cov0" title="0">{
                return Page{}, fmt.Errorf("rows value too large, must be less than 100")
        }</span>

        <span class="cov0" title="0">p := Page{
                number: number,
                rows:   rows,
        }

        return p, nil</span>
}

// MustParse creates a paging value for testing.
func MustParse(page string, rowsPerPage string) Page <span class="cov0" title="0">{
        pg, err := Parse(page, rowsPerPage)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">return pg</span>
}

// String implements the stringer interface.
func (p Page) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("page: %d rows: %d", p.number, p.rows)
}</span>

// Number returns the page number.
func (p Page) Number() int <span class="cov0" title="0">{
        return p.number
}</span>

// RowsPerPage returns the rows per page.
func (p Page) RowsPerPage() int <span class="cov0" title="0">{
        return p.rows
}</span>
</pre>
		
		<pre class="file" id="file172" style="display: none">/*
Code taken from https://github.com/lib/pq

Copyright (c) 2011-2013, 'pq' Contributors Portions Copyright (C) 2011 Blake Mizerany

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
Software, and to permit persons to whom the Software is furnished to do so, subject
to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

// Package dbarray provides support for database array types.
package dbarray

import (
        "bytes"
        "database/sql"
        "database/sql/driver"
        "encoding/hex"
        "fmt"
        "reflect"
        "strconv"
        "strings"
)

var typeByteSlice = reflect.TypeOf([]byte{})
var typeDriverValuer = reflect.TypeOf((*driver.Valuer)(nil)).Elem()
var typeSQLScanner = reflect.TypeOf((*sql.Scanner)(nil)).Elem()

// Array returns the optimal driver.Valuer and sql.Scanner for an array or
// slice of any dimension.
//
// For example:
//
//        db.Query(`SELECT * FROM t WHERE id = ANY($1)`, pq.Array([]int{235, 401}))
//
//        var x []sql.NullInt64
//        db.QueryRow(`SELECT ARRAY[235, 401]`).Scan(pq.Array(&amp;x))
//
// Scanning multi-dimensional arrays is not supported.  Arrays where the lower
// bound is not one (such as `[0:0]={1}') are not supported.
func Array(a any) interface {
        driver.Valuer
        sql.Scanner
} <span class="cov0" title="0">{
        switch a := a.(type) </span>{
        case []bool:<span class="cov0" title="0">
                return (*Bool)(&amp;a)</span>
        case []float64:<span class="cov0" title="0">
                return (*Float64)(&amp;a)</span>
        case []float32:<span class="cov0" title="0">
                return (*Float32)(&amp;a)</span>
        case []int64:<span class="cov0" title="0">
                return (*Int64)(&amp;a)</span>
        case []int32:<span class="cov0" title="0">
                return (*Int32)(&amp;a)</span>
        case []string:<span class="cov0" title="0">
                return (*String)(&amp;a)</span>
        case [][]byte:<span class="cov0" title="0">
                return (*Bytea)(&amp;a)</span>

        case *[]bool:<span class="cov0" title="0">
                return (*Bool)(a)</span>
        case *[]float64:<span class="cov0" title="0">
                return (*Float64)(a)</span>
        case *[]float32:<span class="cov0" title="0">
                return (*Float32)(a)</span>
        case *[]int64:<span class="cov0" title="0">
                return (*Int64)(a)</span>
        case *[]int32:<span class="cov0" title="0">
                return (*Int32)(a)</span>
        case *[]string:<span class="cov0" title="0">
                return (*String)(a)</span>
        case *[][]byte:<span class="cov0" title="0">
                return (*Bytea)(a)</span>
        }

        <span class="cov0" title="0">return Generic{a}</span>
}

// Delimiter may be optionally implemented by driver.Valuer or sql.Scanner
// to override the array delimiter used by Generic.
type Delimiter interface {
        // Delimiter returns the delimiter character(s) for this element's type.
        Delimiter() string
}

// Bool represents a one-dimensional array of the PostgreSQL boolean type.
type Bool []bool

// Scan implements the sql.Scanner interface.
func (a *Bool) Scan(src any) error <span class="cov0" title="0">{
        switch src := src.(type) </span>{
        case []byte:<span class="cov0" title="0">
                return a.scanBytes(src)</span>
        case string:<span class="cov0" title="0">
                return a.scanBytes([]byte(src))</span>
        case nil:<span class="cov0" title="0">
                *a = nil
                return nil</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("database: cannot convert %T to Bool", src)</span>
}

func (a *Bool) scanBytes(src []byte) error <span class="cov0" title="0">{
        elems, err := scanLinearArray(src, []byte{','}, "Bool")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if *a != nil &amp;&amp; len(elems) == 0 </span><span class="cov0" title="0">{
                *a = (*a)[:0]
        }</span> else<span class="cov0" title="0"> {
                b := make(Bool, len(elems))
                for i, v := range elems </span><span class="cov0" title="0">{
                        if len(v) != 1 </span><span class="cov0" title="0">{
                                return fmt.Errorf("database: could not parse boolean array index %d: invalid boolean %q", i, v)
                        }</span>
                        <span class="cov0" title="0">switch v[0] </span>{
                        case 't':<span class="cov0" title="0">
                                b[i] = true</span>
                        case 'f':<span class="cov0" title="0">
                                b[i] = false</span>
                        default:<span class="cov0" title="0">
                                return fmt.Errorf("database: could not parse boolean array index %d: invalid boolean %q", i, v)</span>
                        }
                }
                <span class="cov0" title="0">*a = b</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// Value implements the driver.Valuer interface.
func (a Bool) Value() (driver.Value, error) <span class="cov0" title="0">{
        if a == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">if n := len(a); n &gt; 0 </span><span class="cov0" title="0">{
                // There will be exactly two curly brackets, N bytes of values,
                // and N-1 bytes of delimiters.
                b := make([]byte, 1+2*n)

                for i := 0; i &lt; n; i++ </span><span class="cov0" title="0">{
                        b[2*i] = ','
                        if a[i] </span><span class="cov0" title="0">{
                                b[1+2*i] = 't'
                        }</span> else<span class="cov0" title="0"> {
                                b[1+2*i] = 'f'
                        }</span>
                }

                <span class="cov0" title="0">b[0] = '{'
                b[2*n] = '}'

                return string(b), nil</span>
        }

        <span class="cov0" title="0">return "{}", nil</span>
}

// Bytea represents a one-dimensional array of the PostgreSQL bytea type.
type Bytea [][]byte

// Scan implements the sql.Scanner interface.
func (a *Bytea) Scan(src any) error <span class="cov0" title="0">{
        switch src := src.(type) </span>{
        case []byte:<span class="cov0" title="0">
                return a.scanBytes(src)</span>
        case string:<span class="cov0" title="0">
                return a.scanBytes([]byte(src))</span>
        case nil:<span class="cov0" title="0">
                *a = nil
                return nil</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("database: cannot convert %T to Bytea", src)</span>
}

func (a *Bytea) scanBytes(src []byte) error <span class="cov0" title="0">{
        elems, err := scanLinearArray(src, []byte{','}, "Bytea")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if *a != nil &amp;&amp; len(elems) == 0 </span><span class="cov0" title="0">{
                *a = (*a)[:0]
        }</span> else<span class="cov0" title="0"> {
                b := make(Bytea, len(elems))
                for i, v := range elems </span><span class="cov0" title="0">{
                        b[i], err = parseBytea(v)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("could not parse bytea array index %d: %s", i, err.Error())
                        }</span>
                }
                <span class="cov0" title="0">*a = b</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// Value implements the driver.Valuer interface. It uses the "hex" format which
// is only supported on PostgreSQL 9.0 or newer.
func (a Bytea) Value() (driver.Value, error) <span class="cov0" title="0">{
        if a == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">if n := len(a); n &gt; 0 </span><span class="cov0" title="0">{
                // There will be at least two curly brackets, 2*N bytes of quotes,
                // 3*N bytes of hex formatting, and N-1 bytes of delimiters.
                size := 1 + 6*n
                for _, x := range a </span><span class="cov0" title="0">{
                        size += hex.EncodedLen(len(x))
                }</span>

                <span class="cov0" title="0">b := make([]byte, size)

                for i, s := 0, b; i &lt; n; i++ </span><span class="cov0" title="0">{
                        o := copy(s, `,"\\x`)
                        o += hex.Encode(s[o:], a[i])
                        s[o] = '"'
                        s = s[o+1:]
                }</span>

                <span class="cov0" title="0">b[0] = '{'
                b[size-1] = '}'

                return string(b), nil</span>
        }

        <span class="cov0" title="0">return "{}", nil</span>
}

// Float64 represents a one-dimensional array of the PostgreSQL double
// precision type.
type Float64 []float64

// Scan implements the sql.Scanner interface.
func (a *Float64) Scan(src any) error <span class="cov0" title="0">{
        switch src := src.(type) </span>{
        case []byte:<span class="cov0" title="0">
                return a.scanBytes(src)</span>
        case string:<span class="cov0" title="0">
                return a.scanBytes([]byte(src))</span>
        case nil:<span class="cov0" title="0">
                *a = nil
                return nil</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("database: cannot convert %T to Float64", src)</span>
}

func (a *Float64) scanBytes(src []byte) error <span class="cov0" title="0">{
        elems, err := scanLinearArray(src, []byte{','}, "Float64")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if *a != nil &amp;&amp; len(elems) == 0 </span><span class="cov0" title="0">{
                *a = (*a)[:0]
        }</span> else<span class="cov0" title="0"> {
                b := make(Float64, len(elems))
                for i, v := range elems </span><span class="cov0" title="0">{
                        if b[i], err = strconv.ParseFloat(string(v), 64); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("database: parsing array element index %d: %v", i, err)
                        }</span>
                }
                <span class="cov0" title="0">*a = b</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// Value implements the driver.Valuer interface.
func (a Float64) Value() (driver.Value, error) <span class="cov0" title="0">{
        if a == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">if n := len(a); n &gt; 0 </span><span class="cov0" title="0">{
                // There will be at least two curly brackets, N bytes of values,
                // and N-1 bytes of delimiters.
                b := make([]byte, 1, 1+2*n)
                b[0] = '{'

                b = strconv.AppendFloat(b, a[0], 'f', -1, 64)
                for i := 1; i &lt; n; i++ </span><span class="cov0" title="0">{
                        b = append(b, ',')
                        b = strconv.AppendFloat(b, a[i], 'f', -1, 64)
                }</span>

                <span class="cov0" title="0">return string(append(b, '}')), nil</span>
        }

        <span class="cov0" title="0">return "{}", nil</span>
}

// Float32 represents a one-dimensional array of the PostgreSQL double
// precision type.
type Float32 []float32

// Scan implements the sql.Scanner interface.
func (a *Float32) Scan(src any) error <span class="cov0" title="0">{
        switch src := src.(type) </span>{
        case []byte:<span class="cov0" title="0">
                return a.scanBytes(src)</span>
        case string:<span class="cov0" title="0">
                return a.scanBytes([]byte(src))</span>
        case nil:<span class="cov0" title="0">
                *a = nil
                return nil</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("database: cannot convert %T to Float32", src)</span>
}

func (a *Float32) scanBytes(src []byte) error <span class="cov0" title="0">{
        elems, err := scanLinearArray(src, []byte{','}, "Float32")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if *a != nil &amp;&amp; len(elems) == 0 </span><span class="cov0" title="0">{
                *a = (*a)[:0]
        }</span> else<span class="cov0" title="0"> {
                b := make(Float32, len(elems))
                for i, v := range elems </span><span class="cov0" title="0">{
                        var x float64
                        if x, err = strconv.ParseFloat(string(v), 32); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("database: parsing array element index %d: %v", i, err)
                        }</span>
                        <span class="cov0" title="0">b[i] = float32(x)</span>
                }
                <span class="cov0" title="0">*a = b</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// Value implements the driver.Valuer interface.
func (a Float32) Value() (driver.Value, error) <span class="cov0" title="0">{
        if a == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">if n := len(a); n &gt; 0 </span><span class="cov0" title="0">{
                // There will be at least two curly brackets, N bytes of values,
                // and N-1 bytes of delimiters.
                b := make([]byte, 1, 1+2*n)
                b[0] = '{'

                b = strconv.AppendFloat(b, float64(a[0]), 'f', -1, 32)
                for i := 1; i &lt; n; i++ </span><span class="cov0" title="0">{
                        b = append(b, ',')
                        b = strconv.AppendFloat(b, float64(a[i]), 'f', -1, 32)
                }</span>

                <span class="cov0" title="0">return string(append(b, '}')), nil</span>
        }

        <span class="cov0" title="0">return "{}", nil</span>
}

// Generic implements the driver.Valuer and sql.Scanner interfaces for
// an array or slice of any dimension.
type Generic struct{ A any }

func (Generic) evaluateDestination(rt reflect.Type) (reflect.Type, func([]byte, reflect.Value) error, string) <span class="cov0" title="0">{
        var assign func([]byte, reflect.Value) error
        var del = ","

        // TODO calculate the assign function for other types
        // TODO repeat this section on the element type of arrays or slices (multidimensional)
        </span><span class="cov0" title="0">{
                if reflect.PointerTo(rt).Implements(typeSQLScanner) </span><span class="cov0" title="0">{
                        // dest is always addressable because it is an element of a slice.
                        assign = func(src []byte, dest reflect.Value) (err error) </span><span class="cov0" title="0">{
                                ss := dest.Addr().Interface().(sql.Scanner)
                                if src == nil </span><span class="cov0" title="0">{
                                        err = ss.Scan(nil)
                                }</span> else<span class="cov0" title="0"> {
                                        err = ss.Scan(src)
                                }</span>
                                <span class="cov0" title="0">return</span>
                        }
                        <span class="cov0" title="0">goto FoundType</span>
                }

                <span class="cov0" title="0">assign = func([]byte, reflect.Value) error </span><span class="cov0" title="0">{
                        return fmt.Errorf("database: scanning to %s is not implemented; only sql.Scanner", rt)
                }</span>
        }

FoundType:

        <span class="cov0" title="0">if ad, ok := reflect.Zero(rt).Interface().(Delimiter); ok </span><span class="cov0" title="0">{
                del = ad.Delimiter()
        }</span>

        <span class="cov0" title="0">return rt, assign, del</span>
}

// Scan implements the sql.Scanner interface.
func (a Generic) Scan(src any) error <span class="cov0" title="0">{
        dpv := reflect.ValueOf(a.A)
        switch </span>{
        case dpv.Kind() != reflect.Ptr:<span class="cov0" title="0">
                return fmt.Errorf("database: destination %T is not a pointer to array or slice", a.A)</span>
        case dpv.IsNil():<span class="cov0" title="0">
                return fmt.Errorf("database: destination %T is nil", a.A)</span>
        }

        <span class="cov0" title="0">dv := dpv.Elem()
        switch dv.Kind() </span>{
        case reflect.Slice:<span class="cov0" title="0"></span>
        case reflect.Array:<span class="cov0" title="0"></span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("database: destination %T is not a pointer to array or slice", a.A)</span>
        }

        <span class="cov0" title="0">switch src := src.(type) </span>{
        case []byte:<span class="cov0" title="0">
                return a.scanBytes(src, dv)</span>
        case string:<span class="cov0" title="0">
                return a.scanBytes([]byte(src), dv)</span>
        case nil:<span class="cov0" title="0">
                if dv.Kind() == reflect.Slice </span><span class="cov0" title="0">{
                        dv.Set(reflect.Zero(dv.Type()))
                        return nil
                }</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("database: cannot convert %T to %s", src, dv.Type())</span>
}

func (a Generic) scanBytes(src []byte, dv reflect.Value) error <span class="cov0" title="0">{
        dtype, assign, del := a.evaluateDestination(dv.Type().Elem())
        dims, elems, err := parseArray(src, []byte(del))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // TODO allow multidimensional

        <span class="cov0" title="0">if len(dims) &gt; 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("database: scanning from multidimensional ARRAY%s is not implemented",
                        strings.Replace(fmt.Sprint(dims), " ", "][", -1))
        }</span>

        // Treat a zero-dimensional array like an array with a single dimension of zero.
        <span class="cov0" title="0">if len(dims) == 0 </span><span class="cov0" title="0">{
                dims = append(dims, 0)
        }</span>

        <span class="cov0" title="0">for i, rt := 0, dv.Type(); i &lt; len(dims); i, rt = i+1, rt.Elem() </span><span class="cov0" title="0">{
                switch rt.Kind() </span>{
                case reflect.Slice:<span class="cov0" title="0"></span>
                case reflect.Array:<span class="cov0" title="0">
                        if rt.Len() != dims[i] </span><span class="cov0" title="0">{
                                return fmt.Errorf("database: cannot convert ARRAY%s to %s",
                                        strings.Replace(fmt.Sprint(dims), " ", "][", -1), dv.Type())
                        }</span>
                default:<span class="cov0" title="0"></span>
                        // TODO handle multidimensional
                }
        }

        <span class="cov0" title="0">values := reflect.MakeSlice(reflect.SliceOf(dtype), len(elems), len(elems))
        for i, e := range elems </span><span class="cov0" title="0">{
                if err := assign(e, values.Index(i)); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("database: parsing array element index %d: %v", i, err)
                }</span>
        }

        // TODO handle multidimensional

        <span class="cov0" title="0">switch dv.Kind() </span>{
        case reflect.Slice:<span class="cov0" title="0">
                dv.Set(values.Slice(0, dims[0]))</span>
        case reflect.Array:<span class="cov0" title="0">
                for i := 0; i &lt; dims[0]; i++ </span><span class="cov0" title="0">{
                        dv.Index(i).Set(values.Index(i))
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Value implements the driver.Valuer interface.
func (a Generic) Value() (driver.Value, error) <span class="cov0" title="0">{
        if a.A == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">rv := reflect.ValueOf(a.A)

        switch rv.Kind() </span>{
        case reflect.Slice:<span class="cov0" title="0">
                if rv.IsNil() </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
        case reflect.Array:<span class="cov0" title="0"></span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("database: Unable to convert %T to array", a.A)</span>
        }

        <span class="cov0" title="0">if n := rv.Len(); n &gt; 0 </span><span class="cov0" title="0">{
                // There will be at least two curly brackets, N bytes of values,
                // and N-1 bytes of delimiters.
                b := make([]byte, 0, 1+2*n)

                b, _, err := appendArray(b, rv, n)
                return string(b), err
        }</span>

        <span class="cov0" title="0">return "{}", nil</span>
}

// Int64 represents a one-dimensional array of the PostgreSQL integer types.
type Int64 []int64

// Scan implements the sql.Scanner interface.
func (a *Int64) Scan(src any) error <span class="cov0" title="0">{
        switch src := src.(type) </span>{
        case []byte:<span class="cov0" title="0">
                return a.scanBytes(src)</span>
        case string:<span class="cov0" title="0">
                return a.scanBytes([]byte(src))</span>
        case nil:<span class="cov0" title="0">
                *a = nil
                return nil</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("database: cannot convert %T to Int64", src)</span>
}

func (a *Int64) scanBytes(src []byte) error <span class="cov0" title="0">{
        elems, err := scanLinearArray(src, []byte{','}, "Int64")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if *a != nil &amp;&amp; len(elems) == 0 </span><span class="cov0" title="0">{
                *a = (*a)[:0]
        }</span> else<span class="cov0" title="0"> {
                b := make(Int64, len(elems))
                for i, v := range elems </span><span class="cov0" title="0">{
                        if b[i], err = strconv.ParseInt(string(v), 10, 64); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("database: parsing array element index %d: %v", i, err)
                        }</span>
                }
                <span class="cov0" title="0">*a = b</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// Value implements the driver.Valuer interface.
func (a Int64) Value() (driver.Value, error) <span class="cov0" title="0">{
        if a == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">if n := len(a); n &gt; 0 </span><span class="cov0" title="0">{
                // There will be at least two curly brackets, N bytes of values,
                // and N-1 bytes of delimiters.
                b := make([]byte, 1, 1+2*n)
                b[0] = '{'

                b = strconv.AppendInt(b, a[0], 10)
                for i := 1; i &lt; n; i++ </span><span class="cov0" title="0">{
                        b = append(b, ',')
                        b = strconv.AppendInt(b, a[i], 10)
                }</span>

                <span class="cov0" title="0">return string(append(b, '}')), nil</span>
        }

        <span class="cov0" title="0">return "{}", nil</span>
}

// Int32 represents a one-dimensional array of the PostgreSQL integer types.
type Int32 []int32

// Scan implements the sql.Scanner interface.
func (a *Int32) Scan(src any) error <span class="cov0" title="0">{
        switch src := src.(type) </span>{
        case []byte:<span class="cov0" title="0">
                return a.scanBytes(src)</span>
        case string:<span class="cov0" title="0">
                return a.scanBytes([]byte(src))</span>
        case nil:<span class="cov0" title="0">
                *a = nil
                return nil</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("database: cannot convert %T to Int32", src)</span>
}

func (a *Int32) scanBytes(src []byte) error <span class="cov0" title="0">{
        elems, err := scanLinearArray(src, []byte{','}, "Int32")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if *a != nil &amp;&amp; len(elems) == 0 </span><span class="cov0" title="0">{
                *a = (*a)[:0]
        }</span> else<span class="cov0" title="0"> {
                b := make(Int32, len(elems))
                for i, v := range elems </span><span class="cov0" title="0">{
                        x, err := strconv.ParseInt(string(v), 10, 32)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("database: parsing array element index %d: %v", i, err)
                        }</span>
                        <span class="cov0" title="0">b[i] = int32(x)</span>
                }
                <span class="cov0" title="0">*a = b</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// Value implements the driver.Valuer interface.
func (a Int32) Value() (driver.Value, error) <span class="cov0" title="0">{
        if a == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">if n := len(a); n &gt; 0 </span><span class="cov0" title="0">{
                // There will be at least two curly brackets, N bytes of values,
                // and N-1 bytes of delimiters.
                b := make([]byte, 1, 1+2*n)
                b[0] = '{'

                b = strconv.AppendInt(b, int64(a[0]), 10)
                for i := 1; i &lt; n; i++ </span><span class="cov0" title="0">{
                        b = append(b, ',')
                        b = strconv.AppendInt(b, int64(a[i]), 10)
                }</span>

                <span class="cov0" title="0">return string(append(b, '}')), nil</span>
        }

        <span class="cov0" title="0">return "{}", nil</span>
}

// String represents a one-dimensional array of the PostgreSQL character types.
type String []string

// Scan implements the sql.Scanner interface.
func (a *String) Scan(src any) error <span class="cov0" title="0">{
        switch src := src.(type) </span>{
        case []byte:<span class="cov0" title="0">
                return a.scanBytes(src)</span>
        case string:<span class="cov0" title="0">
                return a.scanBytes([]byte(src))</span>
        case nil:<span class="cov0" title="0">
                *a = nil
                return nil</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("database: cannot convert %T to String", src)</span>
}

func (a *String) scanBytes(src []byte) error <span class="cov0" title="0">{
        elems, err := scanLinearArray(src, []byte{','}, "String")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if *a != nil &amp;&amp; len(elems) == 0 </span><span class="cov0" title="0">{
                *a = (*a)[:0]
        }</span> else<span class="cov0" title="0"> {
                b := make(String, len(elems))
                for i, v := range elems </span><span class="cov0" title="0">{
                        if b[i] = string(v); v == nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("database: parsing array element index %d: cannot convert nil to string", i)
                        }</span>
                }
                <span class="cov0" title="0">*a = b</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// Value implements the driver.Valuer interface.
func (a String) Value() (driver.Value, error) <span class="cov0" title="0">{
        if a == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">if n := len(a); n &gt; 0 </span><span class="cov0" title="0">{
                // There will be at least two curly brackets, 2*N bytes of quotes,
                // and N-1 bytes of delimiters.
                b := make([]byte, 1, 1+3*n)
                b[0] = '{'

                b = appendArrayQuotedBytes(b, []byte(a[0]))
                for i := 1; i &lt; n; i++ </span><span class="cov0" title="0">{
                        b = append(b, ',')
                        b = appendArrayQuotedBytes(b, []byte(a[i]))
                }</span>

                <span class="cov0" title="0">return string(append(b, '}')), nil</span>
        }

        <span class="cov0" title="0">return "{}", nil</span>
}

// appendArray appends rv to the buffer, returning the extended buffer and
// the delimiter used between elements.
//
// It panics when n &lt;= 0 or rv's Kind is not reflect.Array nor reflect.Slice.
func appendArray(b []byte, rv reflect.Value, n int) ([]byte, string, error) <span class="cov0" title="0">{
        var del string
        var err error

        b = append(b, '{')

        if b, del, err = appendArrayElement(b, rv.Index(0)); err != nil </span><span class="cov0" title="0">{
                return b, del, err
        }</span>

        <span class="cov0" title="0">for i := 1; i &lt; n; i++ </span><span class="cov0" title="0">{
                b = append(b, del...)
                if b, del, err = appendArrayElement(b, rv.Index(i)); err != nil </span><span class="cov0" title="0">{
                        return b, del, err
                }</span>
        }

        <span class="cov0" title="0">return append(b, '}'), del, nil</span>
}

// appendArrayElement appends rv to the buffer, returning the extended buffer
// and the delimiter to use before the next element.
//
// When rv's Kind is neither reflect.Array nor reflect.Slice, it is converted
// using driver.DefaultParameterConverter and the resulting []byte or string
// is double-quoted.
//
// See http://www.postgresql.org/docs/current/static/arrays.html#ARRAYS-IO
func appendArrayElement(b []byte, rv reflect.Value) ([]byte, string, error) <span class="cov0" title="0">{
        if k := rv.Kind(); k == reflect.Array || k == reflect.Slice </span><span class="cov0" title="0">{
                if t := rv.Type(); t != typeByteSlice &amp;&amp; !t.Implements(typeDriverValuer) </span><span class="cov0" title="0">{
                        if n := rv.Len(); n &gt; 0 </span><span class="cov0" title="0">{
                                return appendArray(b, rv, n)
                        }</span>

                        <span class="cov0" title="0">return b, "", nil</span>
                }
        }

        <span class="cov0" title="0">var del = ","
        var err error
        var iv = rv.Interface()

        if ad, ok := iv.(Delimiter); ok </span><span class="cov0" title="0">{
                del = ad.Delimiter()
        }</span>

        <span class="cov0" title="0">if iv, err = driver.DefaultParameterConverter.ConvertValue(iv); err != nil </span><span class="cov0" title="0">{
                return b, del, err
        }</span>

        <span class="cov0" title="0">switch v := iv.(type) </span>{
        case nil:<span class="cov0" title="0">
                return append(b, "NULL"...), del, nil</span>
        case []byte:<span class="cov0" title="0">
                return appendArrayQuotedBytes(b, v), del, nil</span>
        case string:<span class="cov0" title="0">
                return appendArrayQuotedBytes(b, []byte(v)), del, nil</span>
        }

        <span class="cov0" title="0">b, err = appendValue(b, iv)
        return b, del, err</span>
}

func appendArrayQuotedBytes(b, v []byte) []byte <span class="cov0" title="0">{
        b = append(b, '"')
        for </span><span class="cov0" title="0">{
                i := bytes.IndexAny(v, `"\`)
                if i &lt; 0 </span><span class="cov0" title="0">{
                        b = append(b, v...)
                        break</span>
                }
                <span class="cov0" title="0">if i &gt; 0 </span><span class="cov0" title="0">{
                        b = append(b, v[:i]...)
                }</span>
                <span class="cov0" title="0">b = append(b, '\\', v[i])
                v = v[i+1:]</span>
        }
        <span class="cov0" title="0">return append(b, '"')</span>
}

func appendValue(b []byte, v driver.Value) ([]byte, error) <span class="cov0" title="0">{
        return append(b, encode(nil, v, 0)...), nil
}</span>

// parseArray extracts the dimensions and elements of an array represented in
// text format. Only representations emitted by the backend are supported.
// Notably, whitespace around brackets and delimiters is significant, and NULL
// is case-sensitive.
//
// See http://www.postgresql.org/docs/current/static/arrays.html#ARRAYS-IO
func parseArray(src, del []byte) (dims []int, elems [][]byte, err error) <span class="cov0" title="0">{
        var depth, i int

        if len(src) &lt; 1 || src[0] != '{' </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("database: unable to parse array; expected %q at offset %d", '{', 0)
        }</span>

<span class="cov0" title="0">Open:
        for i &lt; len(src) </span><span class="cov0" title="0">{
                switch src[i] </span>{
                case '{':<span class="cov0" title="0">
                        depth++
                        i++</span>
                case '}':<span class="cov0" title="0">
                        elems = make([][]byte, 0)
                        goto Close</span>
                default:<span class="cov0" title="0">
                        break Open</span>
                }
        }
        <span class="cov0" title="0">dims = make([]int, i)

Element:
        for i &lt; len(src) </span><span class="cov0" title="0">{
                switch src[i] </span>{
                case '{':<span class="cov0" title="0">
                        if depth == len(dims) </span><span class="cov0" title="0">{
                                break Element</span>
                        }
                        <span class="cov0" title="0">depth++
                        dims[depth-1] = 0
                        i++</span>
                case '"':<span class="cov0" title="0">
                        var elem = []byte{}
                        var escape bool
                        for i++; i &lt; len(src); i++ </span><span class="cov0" title="0">{
                                if escape </span><span class="cov0" title="0">{
                                        elem = append(elem, src[i])
                                        escape = false
                                }</span> else<span class="cov0" title="0"> {
                                        switch src[i] </span>{
                                        default:<span class="cov0" title="0">
                                                elem = append(elem, src[i])</span>
                                        case '\\':<span class="cov0" title="0">
                                                escape = true</span>
                                        case '"':<span class="cov0" title="0">
                                                elems = append(elems, elem)
                                                i++
                                                break Element</span>
                                        }
                                }
                        }
                default:<span class="cov0" title="0">
                        for start := i; i &lt; len(src); i++ </span><span class="cov0" title="0">{
                                if bytes.HasPrefix(src[i:], del) || src[i] == '}' </span><span class="cov0" title="0">{
                                        elem := src[start:i]
                                        if len(elem) == 0 </span><span class="cov0" title="0">{
                                                return nil, nil, fmt.Errorf("database: unable to parse array; unexpected %q at offset %d", src[i], i)
                                        }</span>
                                        <span class="cov0" title="0">if bytes.Equal(elem, []byte("NULL")) </span><span class="cov0" title="0">{
                                                elem = nil
                                        }</span>
                                        <span class="cov0" title="0">elems = append(elems, elem)
                                        break Element</span>
                                }
                        }
                }
        }

        <span class="cov0" title="0">for i &lt; len(src) </span><span class="cov0" title="0">{
                if bytes.HasPrefix(src[i:], del) &amp;&amp; depth &gt; 0 </span><span class="cov0" title="0">{
                        dims[depth-1]++
                        i += len(del)
                        goto Element</span>
                } else<span class="cov0" title="0"> if src[i] == '}' &amp;&amp; depth &gt; 0 </span><span class="cov0" title="0">{
                        dims[depth-1]++
                        depth--
                        i++
                }</span> else<span class="cov0" title="0"> {
                        return nil, nil, fmt.Errorf("database: unable to parse array; unexpected %q at offset %d", src[i], i)
                }</span>
        }

<span class="cov0" title="0">Close:
        for i &lt; len(src) </span><span class="cov0" title="0">{
                if src[i] == '}' &amp;&amp; depth &gt; 0 </span><span class="cov0" title="0">{
                        depth--
                        i++
                }</span> else<span class="cov0" title="0"> {
                        return nil, nil, fmt.Errorf("database: unable to parse array; unexpected %q at offset %d", src[i], i)
                }</span>
        }
        <span class="cov0" title="0">if depth &gt; 0 </span><span class="cov0" title="0">{
                err = fmt.Errorf("database: unable to parse array; expected %q at offset %d", '}', i)
        }</span>
        <span class="cov0" title="0">if err == nil </span><span class="cov0" title="0">{
                for _, d := range dims </span><span class="cov0" title="0">{
                        if (len(elems) % d) != 0 </span><span class="cov0" title="0">{
                                err = fmt.Errorf("database: multidimensional arrays must have elements with matching dimensions")
                        }</span>
                }
        }
        <span class="cov0" title="0">return</span>
}

func scanLinearArray(src, del []byte, typ string) (elems [][]byte, err error) <span class="cov0" title="0">{
        dims, elems, err := parseArray(src, del)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(dims) &gt; 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("database: cannot convert ARRAY%s to %s", strings.Replace(fmt.Sprint(dims), " ", "][", -1), typ)
        }</span>
        <span class="cov0" title="0">return elems, err</span>
}
</pre>
		
		<pre class="file" id="file173" style="display: none">/*
Code taken from https://github.com/lib/pq

Copyright (c) 2011-2013, 'pq' Contributors Portions Copyright (C) 2011 Blake Mizerany

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the
Software, and to permit persons to whom the Software is furnished to do so, subject
to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

package dbarray

import (
        "bytes"
        "encoding/hex"
        "fmt"
        "strconv"
        "time"
)

const (
        infinityTSEnabledAlready        = "database: infinity timestamp enabled already"
        infinityTSNegativeMustBeSmaller = "database: infinity timestamp: negative value must be smaller (before) than positive"
)

var infinityTSEnabled = false
var infinityTSNegative time.Time
var infinityTSPositive time.Time

type parameterStatus struct {
        // server version in the same format as server_version_num, or 0 if unavailable.
        serverVersion int
}

// EnableInfinityTS controls the handling of Postgres' "-infinity" and
// "infinity" "timestamp"s.
//
// If EnableInfinityTS is not called, "-infinity" and "infinity" will return
// []byte("-infinity") and []byte("infinity") respectively, and potentially
// cause error "sql: Scan error on column index 0: unsupported driver -&gt; Scan
// pair: []uint8 -&gt; *time.Time", when scanning into a time.Time value.
//
// Once EnableInfinityTS has been called, all connections created using this
// driver will decode Postgres' "-infinity" and "infinity" for "timestamp",
// "timestamp with time zone" and "date" types to the predefined minimum and
// maximum times, respectively.  When encoding time.Time values, any time which
// equals or precedes the predefined minimum time will be encoded to
// "-infinity".  Any values at or past the maximum time will similarly be
// encoded to "infinity".
//
// If EnableInfinityTS is called with negative &gt;= positive, it will panic.
// Calling EnableInfinityTS after a connection has been established results in
// undefined behavior.  If EnableInfinityTS is called more than once, it will
// panic.
func EnableInfinityTS(negative time.Time, positive time.Time) <span class="cov0" title="0">{
        if infinityTSEnabled </span><span class="cov0" title="0">{
                panic(infinityTSEnabledAlready)</span>
        }
        <span class="cov0" title="0">if !negative.Before(positive) </span><span class="cov0" title="0">{
                panic(infinityTSNegativeMustBeSmaller)</span>
        }
        <span class="cov0" title="0">infinityTSEnabled = true
        infinityTSNegative = negative
        infinityTSPositive = positive</span>
}

func encode(parameterStatus *parameterStatus, x any, oid int) []byte <span class="cov0" title="0">{
        const oidBytea = 17

        switch v := x.(type) </span>{
        case int64:<span class="cov0" title="0">
                return strconv.AppendInt(nil, v, 10)</span>
        case float64:<span class="cov0" title="0">
                return strconv.AppendFloat(nil, v, 'f', -1, 64)</span>
        case []byte:<span class="cov0" title="0">
                if oid == oidBytea </span><span class="cov0" title="0">{
                        return encodeBytea(parameterStatus.serverVersion, v)
                }</span>

                <span class="cov0" title="0">return v</span>
        case string:<span class="cov0" title="0">
                if oid == oidBytea </span><span class="cov0" title="0">{
                        return encodeBytea(parameterStatus.serverVersion, []byte(v))
                }</span>

                <span class="cov0" title="0">return []byte(v)</span>
        case bool:<span class="cov0" title="0">
                return strconv.AppendBool(nil, v)</span>
        case time.Time:<span class="cov0" title="0">
                return formatTS(v)</span>

        default:<span class="cov0" title="0">
                errorf("encode: unknown type for %T", v)</span>
        }

        <span class="cov0" title="0">panic("not reached")</span>
}

// formatTS formats t into a format postgres understands.
func formatTS(t time.Time) []byte <span class="cov0" title="0">{
        if infinityTSEnabled </span><span class="cov0" title="0">{
                // t &lt;= -infinity : ! (t &gt; -infinity)
                if !t.After(infinityTSNegative) </span><span class="cov0" title="0">{
                        return []byte("-infinity")
                }</span>
                // t &gt;= infinity : ! (!t &lt; infinity)
                <span class="cov0" title="0">if !t.Before(infinityTSPositive) </span><span class="cov0" title="0">{
                        return []byte("infinity")
                }</span>
        }
        <span class="cov0" title="0">return formatTimestamp(t)</span>
}

// formatTimestamp formats t into Postgres' text format for timestamps.
func formatTimestamp(t time.Time) []byte <span class="cov0" title="0">{
        // Need to send dates before 0001 A.D. with " BC" suffix, instead of the
        // minus sign preferred by Go.
        // Beware, "0000" in ISO is "1 BC", "-0001" is "2 BC" and so on
        bc := false
        if t.Year() &lt;= 0 </span><span class="cov0" title="0">{
                // flip year sign, and add 1, e.g: "0" will be "1", and "-10" will be "11"
                t = t.AddDate((-t.Year())*2+1, 0, 0)
                bc = true
        }</span>
        <span class="cov0" title="0">b := []byte(t.Format("2006-01-02 15:04:05.999999999Z07:00"))

        _, offset := t.Zone()
        offset %= 60
        if offset != 0 </span><span class="cov0" title="0">{
                // RFC3339Nano already printed the minus sign
                if offset &lt; 0 </span><span class="cov0" title="0">{
                        offset = -offset
                }</span>

                <span class="cov0" title="0">b = append(b, ':')
                if offset &lt; 10 </span><span class="cov0" title="0">{
                        b = append(b, '0')
                }</span>
                <span class="cov0" title="0">b = strconv.AppendInt(b, int64(offset), 10)</span>
        }

        <span class="cov0" title="0">if bc </span><span class="cov0" title="0">{
                b = append(b, " BC"...)
        }</span>
        <span class="cov0" title="0">return b</span>
}

func errorf(s string, args ...any) <span class="cov0" title="0">{
        panic(fmt.Errorf("pq: %s", fmt.Sprintf(s, args...)))</span>
}

// Parse a bytea value received from the server.  Both "hex" and the legacy
// "escape" format are supported.
func parseBytea(s []byte) (result []byte, err error) <span class="cov0" title="0">{
        if len(s) &gt;= 2 &amp;&amp; bytes.Equal(s[:2], []byte("\\x")) </span><span class="cov0" title="0">{
                // bytea_output = hex
                s = s[2:] // trim off leading "\\x"
                result = make([]byte, hex.DecodedLen(len(s)))
                _, err := hex.Decode(result, s)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        } else<span class="cov0" title="0"> {
                // bytea_output = escape
                for len(s) &gt; 0 </span><span class="cov0" title="0">{
                        if s[0] == '\\' </span><span class="cov0" title="0">{
                                // escaped '\\'
                                if len(s) &gt;= 2 &amp;&amp; s[1] == '\\' </span><span class="cov0" title="0">{
                                        result = append(result, '\\')
                                        s = s[2:]
                                        continue</span>
                                }

                                // '\\' followed by an octal number
                                <span class="cov0" title="0">if len(s) &lt; 4 </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("invalid bytea sequence %v", s)
                                }</span>
                                <span class="cov0" title="0">r, err := strconv.ParseUint(string(s[1:4]), 8, 8)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("could not parse bytea value: %s", err.Error())
                                }</span>
                                <span class="cov0" title="0">result = append(result, byte(r))
                                s = s[4:]</span>
                        } else<span class="cov0" title="0"> {
                                // We hit an unescaped, raw byte.  Try to read in as many as
                                // possible in one go.
                                i := bytes.IndexByte(s, '\\')
                                if i == -1 </span><span class="cov0" title="0">{
                                        result = append(result, s...)
                                        break</span>
                                }
                                <span class="cov0" title="0">result = append(result, s[:i]...)
                                s = s[i:]</span>
                        }
                }
        }

        <span class="cov0" title="0">return result, nil</span>
}

func encodeBytea(serverVersion int, v []byte) (result []byte) <span class="cov0" title="0">{
        if serverVersion &gt;= 90000 </span><span class="cov0" title="0">{
                // Use the hex format if we know that the server supports it
                result = make([]byte, 2+hex.EncodedLen(len(v)))
                result[0] = '\\'
                result[1] = 'x'
                hex.Encode(result[2:], v)
        }</span> else<span class="cov0" title="0"> {
                // .. or resort to "escape"
                for _, b := range v </span><span class="cov0" title="0">{
                        if b == '\\' </span><span class="cov0" title="0">{
                                result = append(result, '\\', '\\')
                        }</span> else<span class="cov0" title="0"> if b &lt; 0x20 || b &gt; 0x7e </span><span class="cov0" title="0">{
                                result = append(result, []byte(fmt.Sprintf("\\%03o", b))...)
                        }</span> else<span class="cov0" title="0"> {
                                result = append(result, b)
                        }</span>
                }
        }

        <span class="cov0" title="0">return result</span>
}
</pre>
		
		<pre class="file" id="file174" style="display: none">// Package sqldb provides support for access the database.
package sqldb

import (
        "context"
        "database/sql"
        "errors"
        "fmt"
        "net/url"
        "strings"
        "time"

        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/jackc/pgx/v5/pgconn"
        _ "github.com/jackc/pgx/v5/stdlib"
        "github.com/jmoiron/sqlx"
)

// lib/pq errorCodeNames
// https://github.com/lib/pq/blob/master/error.go#L178
const (
        uniqueViolation = "23505"
        undefinedTable  = "42P01"
)

// Set of error variables for CRUD operations.
var (
        ErrDBNotFound        = sql.ErrNoRows
        ErrDBDuplicatedEntry = errors.New("duplicated entry")
        ErrUndefinedTable    = errors.New("undefined table")
)

// Config is the required properties to use the database.
type Config struct {
        User         string
        Password     string
        Host         string
        Name         string
        Schema       string
        MaxIdleConns int
        MaxOpenConns int
        DisableTLS   bool
}

// Open knows how to open a database connection based on the configuration.
func Open(cfg Config) (*sqlx.DB, error) <span class="cov0" title="0">{
        sslMode := "require"
        if cfg.DisableTLS </span><span class="cov0" title="0">{
                sslMode = "disable"
        }</span>

        <span class="cov0" title="0">q := make(url.Values)
        q.Set("sslmode", sslMode)
        q.Set("timezone", "utc")
        if cfg.Schema != "" </span><span class="cov0" title="0">{
                q.Set("search_path", cfg.Schema)
        }</span>

        <span class="cov0" title="0">u := url.URL{
                Scheme:   "postgres",
                User:     url.UserPassword(cfg.User, cfg.Password),
                Host:     cfg.Host,
                Path:     cfg.Name,
                RawQuery: q.Encode(),
        }

        db, err := sqlx.Open("pgx", u.String())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">db.SetMaxIdleConns(cfg.MaxIdleConns)
        db.SetMaxOpenConns(cfg.MaxOpenConns)

        return db, nil</span>
}

// StatusCheck returns nil if it can successfully talk to the database. It
// returns a non-nil error otherwise.
func StatusCheck(ctx context.Context, db *sqlx.DB) error <span class="cov0" title="0">{

        // If the user doesn't give us a deadline set 1 second.
        if _, ok := ctx.Deadline(); !ok </span><span class="cov0" title="0">{
                var cancel context.CancelFunc
                ctx, cancel = context.WithTimeout(ctx, time.Second)
                defer cancel()
        }</span>

        <span class="cov0" title="0">for attempts := 1; ; attempts++ </span><span class="cov0" title="0">{
                if err := db.Ping(); err == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">time.Sleep(time.Duration(attempts) * 100 * time.Millisecond)

                if ctx.Err() != nil </span><span class="cov0" title="0">{
                        return ctx.Err()
                }</span>
        }

        <span class="cov0" title="0">if ctx.Err() != nil </span><span class="cov0" title="0">{
                return ctx.Err()
        }</span>

        // Run a simple query to determine connectivity.
        // Running this query forces a round trip through the database.
        <span class="cov0" title="0">const q = `SELECT TRUE`
        var tmp bool
        return db.QueryRowContext(ctx, q).Scan(&amp;tmp)</span>
}

// ExecContext is a helper function to execute a CUD operation with
// logging and tracing.
func ExecContext(ctx context.Context, log *logger.Logger, db sqlx.ExtContext, query string) error <span class="cov0" title="0">{
        return NamedExecContext(ctx, log, db, query, struct{}{})
}</span>

// NamedExecContext is a helper function to execute a CUD operation with
// logging and tracing where field replacement is necessary.
func NamedExecContext(ctx context.Context, log *logger.Logger, db sqlx.ExtContext, query string, data any) (err error) <span class="cov0" title="0">{
        q := queryString(query, data)

        defer func() </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        switch data.(type) </span>{
                        case struct{}:<span class="cov0" title="0">
                                log.Infoc(ctx, 6, "database.NamedExecContext", "query", q, "ERROR", err)</span>
                        default:<span class="cov0" title="0">
                                log.Infoc(ctx, 5, "database.NamedExecContext", "query", q, "ERROR", err)</span>
                        }
                }
        }()

        <span class="cov0" title="0">if _, err := sqlx.NamedExecContext(ctx, db, query, data); err != nil </span><span class="cov0" title="0">{
                var pqerr *pgconn.PgError
                if errors.As(err, &amp;pqerr) </span><span class="cov0" title="0">{
                        switch pqerr.Code </span>{
                        case undefinedTable:<span class="cov0" title="0">
                                return ErrUndefinedTable</span>
                        case uniqueViolation:<span class="cov0" title="0">
                                return ErrDBDuplicatedEntry</span>
                        }
                }
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// QuerySlice is a helper function for executing queries that return a
// collection of data to be unmarshalled into a slice.
func QuerySlice[T any](ctx context.Context, log *logger.Logger, db sqlx.ExtContext, query string, dest *[]T) error <span class="cov0" title="0">{
        return namedQuerySlice(ctx, log, db, query, struct{}{}, dest, false)
}</span>

// NamedQuerySlice is a helper function for executing queries that return a
// collection of data to be unmarshalled into a slice where field replacement is
// necessary.
func NamedQuerySlice[T any](ctx context.Context, log *logger.Logger, db sqlx.ExtContext, query string, data any, dest *[]T) error <span class="cov0" title="0">{
        return namedQuerySlice(ctx, log, db, query, data, dest, false)
}</span>

// NamedQuerySliceUsingIn is a helper function for executing queries that return
// a collection of data to be unmarshalled into a slice where field replacement
// is necessary. Use this if the query has an IN clause.
func NamedQuerySliceUsingIn[T any](ctx context.Context, log *logger.Logger, db sqlx.ExtContext, query string, data any, dest *[]T) error <span class="cov0" title="0">{
        return namedQuerySlice(ctx, log, db, query, data, dest, true)
}</span>

func namedQuerySlice[T any](ctx context.Context, log *logger.Logger, db sqlx.ExtContext, query string, data any, dest *[]T, withIn bool) (err error) <span class="cov0" title="0">{
        q := queryString(query, data)

        defer func() </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        log.Infoc(ctx, 6, "database.NamedQuerySlice", "query", q, "ERROR", err)
                }</span>
        }()

        <span class="cov0" title="0">var rows *sqlx.Rows

        switch withIn </span>{
        case true:<span class="cov0" title="0">
                rows, err = func() (*sqlx.Rows, error) </span><span class="cov0" title="0">{
                        named, args, err := sqlx.Named(query, data)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov0" title="0">query, args, err := sqlx.In(named, args...)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov0" title="0">query = db.Rebind(query)
                        return db.QueryxContext(ctx, query, args...)</span>
                }()

        default:<span class="cov0" title="0">
                rows, err = sqlx.NamedQueryContext(ctx, db, query, data)</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                var pqerr *pgconn.PgError
                if errors.As(err, &amp;pqerr) &amp;&amp; pqerr.Code == undefinedTable </span><span class="cov0" title="0">{
                        return ErrUndefinedTable
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov0" title="0">defer rows.Close()

        var slice []T
        for rows.Next() </span><span class="cov0" title="0">{
                v := new(T)
                if err := rows.StructScan(v); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">slice = append(slice, *v)</span>
        }
        <span class="cov0" title="0">*dest = slice

        return nil</span>
}

// QueryStruct is a helper function for executing queries that return a
// single value to be unmarshalled into a struct type where field replacement is necessary.
func QueryStruct(ctx context.Context, log *logger.Logger, db sqlx.ExtContext, query string, dest any) error <span class="cov0" title="0">{
        return namedQueryStruct(ctx, log, db, query, struct{}{}, dest, false)
}</span>

// NamedQueryStruct is a helper function for executing queries that return a
// single value to be unmarshalled into a struct type where field replacement is necessary.
func NamedQueryStruct(ctx context.Context, log *logger.Logger, db sqlx.ExtContext, query string, data any, dest any) error <span class="cov0" title="0">{
        return namedQueryStruct(ctx, log, db, query, data, dest, false)
}</span>

// NamedQueryStructUsingIn is a helper function for executing queries that return
// a single value to be unmarshalled into a struct type where field replacement
// is necessary. Use this if the query has an IN clause.
func NamedQueryStructUsingIn(ctx context.Context, log *logger.Logger, db sqlx.ExtContext, query string, data any, dest any) error <span class="cov0" title="0">{
        return namedQueryStruct(ctx, log, db, query, data, dest, true)
}</span>

func namedQueryStruct(ctx context.Context, log *logger.Logger, db sqlx.ExtContext, query string, data any, dest any, withIn bool) (err error) <span class="cov0" title="0">{
        q := queryString(query, data)

        defer func() </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        log.Infoc(ctx, 6, "database.NamedQuerySlice", "query", q, "ERROR", err)
                }</span>
        }()

        <span class="cov0" title="0">var rows *sqlx.Rows

        switch withIn </span>{
        case true:<span class="cov0" title="0">
                rows, err = func() (*sqlx.Rows, error) </span><span class="cov0" title="0">{
                        named, args, err := sqlx.Named(query, data)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov0" title="0">query, args, err := sqlx.In(named, args...)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov0" title="0">query = db.Rebind(query)
                        return db.QueryxContext(ctx, query, args...)</span>
                }()

        default:<span class="cov0" title="0">
                rows, err = sqlx.NamedQueryContext(ctx, db, query, data)</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                var pqerr *pgconn.PgError
                if errors.As(err, &amp;pqerr) &amp;&amp; pqerr.Code == undefinedTable </span><span class="cov0" title="0">{
                        return ErrUndefinedTable
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov0" title="0">defer rows.Close()

        if !rows.Next() </span><span class="cov0" title="0">{
                return ErrDBNotFound
        }</span>

        <span class="cov0" title="0">if err := rows.StructScan(dest); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// queryString provides a pretty print version of the query and parameters.
func queryString(query string, args any) string <span class="cov0" title="0">{
        query, params, err := sqlx.Named(query, args)
        if err != nil </span><span class="cov0" title="0">{
                return err.Error()
        }</span>

        <span class="cov0" title="0">for _, param := range params </span><span class="cov0" title="0">{
                var value string
                switch v := param.(type) </span>{
                case string:<span class="cov0" title="0">
                        value = fmt.Sprintf("'%s'", v)</span>
                case []byte:<span class="cov0" title="0">
                        value = fmt.Sprintf("'%s'", string(v))</span>
                default:<span class="cov0" title="0">
                        value = fmt.Sprintf("%v", v)</span>
                }
                <span class="cov0" title="0">query = strings.Replace(query, "?", value, 1)</span>
        }

        <span class="cov0" title="0">query = strings.ReplaceAll(query, "\t", "")
        query = strings.ReplaceAll(query, "\n", " ")

        return strings.Trim(query, " ")</span>
}
</pre>
		
		<pre class="file" id="file175" style="display: none">package sqldb

import (
        "fmt"

        "github.com/jmoiron/sqlx"
)

// Beginner represents a value that can begin a transaction.
type Beginner interface {
        Begin() (CommitRollbacker, error)
}

// CommitRollbacker represents a value that can commit or rollback a transaction.
type CommitRollbacker interface {
        Commit() error
        Rollback() error
}

// =============================================================================

// DBBeginner implements the Beginner interface,
type DBBeginner struct {
        sqlxDB *sqlx.DB
}

// NewBeginner constructs a value that implements the beginner interface.
func NewBeginner(sqlxDB *sqlx.DB) *DBBeginner <span class="cov0" title="0">{
        return &amp;DBBeginner{
                sqlxDB: sqlxDB,
        }
}</span>

// Begin implements the Beginner interface and returns a concrete value that
// implements the CommitRollbacker interface.
func (db *DBBeginner) Begin() (CommitRollbacker, error) <span class="cov0" title="0">{
        return db.sqlxDB.Beginx()
}</span>

// GetExtContext is a helper function that extracts the sqlx value
// from the domain transactor interface for transactional use.
func GetExtContext(tx CommitRollbacker) (sqlx.ExtContext, error) <span class="cov0" title="0">{
        ec, ok := tx.(sqlx.ExtContext)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Transactor(%T) not of a type *sql.Tx", tx)
        }</span>

        <span class="cov0" title="0">return ec, nil</span>
}
</pre>
		
		<pre class="file" id="file176" style="display: none">// Package unitest provides support for excuting unit test logic.
package unitest

import (
        "context"
        "testing"
)

// Run performs the actual test logic based on the table data.
func Run(t *testing.T, table []Table, testName string) <span class="cov0" title="0">{
        for _, tt := range table </span><span class="cov0" title="0">{
                f := func(t *testing.T) </span><span class="cov0" title="0">{
                        gotResp := tt.ExcFunc(context.Background())

                        diff := tt.CmpFunc(gotResp, tt.ExpResp)
                        if diff != "" </span><span class="cov0" title="0">{
                                t.Log("DIFF")
                                t.Logf("%s", diff)
                                t.Log("GOT")
                                t.Logf("%#v", gotResp)
                                t.Log("EXP")
                                t.Logf("%#v", tt.ExpResp)
                                t.Fatalf("Should get the expected response")
                        }</span>
                }

                <span class="cov0" title="0">t.Run(testName+"-"+tt.Name, f)</span>
        }
}
</pre>
		
		<pre class="file" id="file177" style="display: none">// Package domain represents the domain type in the system.
package domain

import "fmt"

// The set of roles that can be used.
var (
        User    = newDomain("USER")
        Product = newDomain("FACILITY")
)

// =============================================================================

// Set of known domains.
var domains = make(map[string]Domain)

// Domain represents a domain in the system.
type Domain struct {
        value string
}

func newDomain(domain string) Domain <span class="cov0" title="0">{
        d := Domain{domain}
        domains[domain] = d
        return d
}</span>

// String returns the name of the role.
func (d Domain) String() string <span class="cov0" title="0">{
        return d.value
}</span>

// Equal provides support for the go-cmp package and testing.
func (d Domain) Equal(d2 Domain) bool <span class="cov0" title="0">{
        return d.value == d2.value
}</span>

// MarshalText provides support for logging and any marshal needs.
func (d Domain) MarshalText() ([]byte, error) <span class="cov0" title="0">{
        return []byte(d.value), nil
}</span>

// =============================================================================

// Parse parses the string value and returns a role if one exists.
func Parse(value string) (Domain, error) <span class="cov0" title="0">{
        domain, exists := domains[value]
        if !exists </span><span class="cov0" title="0">{
                return Domain{}, fmt.Errorf("invalid domain %q", value)
        }</span>

        <span class="cov0" title="0">return domain, nil</span>
}

// MustParse parses the string value and returns a role if one exists. If
// an error occurs the function panics.
func MustParse(value string) Domain <span class="cov0" title="0">{
        domain, err := Parse(value)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">return domain</span>
}
</pre>
		
		<pre class="file" id="file178" style="display: none">// Package facilitytype represents a any facilitytype in the system.
package facilitytype

import (
        "fmt"
        "math"
        "regexp"
        "strings"
)

//=============================================================================
// Address Parsing

type Address struct {
        address string
}

func (a Address) String() string <span class="cov0" title="0">{ return a.address }</span>

var re = regexp.MustCompile(`^[A-Za-z0-9 ,./-]{5,80}$`)

func ParseAddress(v string) (Address, error) <span class="cov0" title="0">{
        if !re.MatchString(v) </span><span class="cov0" title="0">{
                return Address{}, fmt.Errorf("invalid address %q", v)
        }</span>
        <span class="cov0" title="0">return Address{address: v}, nil</span>
}

func MustParseAddress(v string) Address <span class="cov0" title="0">{
        ad, err := ParseAddress(v)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return ad</span>
}

func (a Address) Equal(a2 Address) bool <span class="cov0" title="0">{
        return a.address == a2.address
}</span>

//=============================================================================
// Phone-Number Parsing

type PhoneNumber struct{ phonenumber string }

func (p PhoneNumber) String() string <span class="cov0" title="0">{ return p.phonenumber }</span>

var eth = regexp.MustCompile(`^(?:\+251|0)?(9\d{8})$`)

func ParsePhoneNumber(phone string) (PhoneNumber, error) <span class="cov0" title="0">{
        sanPhone := strings.NewReplacer(" ", "", "-", "").Replace(phone)

        if !eth.MatchString(sanPhone) </span><span class="cov0" title="0">{
                return PhoneNumber{}, fmt.Errorf("invalid or unsupported phone number format: %q", phone)
        }</span>

        <span class="cov0" title="0">if strings.HasPrefix(sanPhone, "+251") </span><span class="cov0" title="0">{
                return PhoneNumber{phonenumber: sanPhone[4:]}, nil
        }</span> else<span class="cov0" title="0"> if strings.HasPrefix(sanPhone, "0") </span><span class="cov0" title="0">{
                return PhoneNumber{phonenumber: sanPhone[1:]}, nil
        }</span> else<span class="cov0" title="0"> {
                return PhoneNumber{phonenumber: sanPhone}, nil
        }</span>
}

func ParseCleanPhoneNumber(num string) (PhoneNumber, error) <span class="cov0" title="0">{
        return PhoneNumber{phonenumber: num}, nil
}</span>

func MustParsePhoneNumber(phn string) PhoneNumber <span class="cov0" title="0">{
        phonum, err := ParsePhoneNumber(phn)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return phonum</span>
}

func (p PhoneNumber) Equal(p2 PhoneNumber) bool <span class="cov0" title="0">{
        return p.phonenumber == p2.phonenumber
}</span>

// ====================================================================
// Latitude parsing

type Lat struct{ lat float64 }

func (l Lat) Float64() float64 <span class="cov0" title="0">{ return l.lat }</span>

func ParseLat(lat float64) (Lat, error) <span class="cov0" title="0">{
        if math.IsNaN(lat) || math.IsInf(lat, 0) || lat &lt; -90 || lat &gt; 90 </span><span class="cov0" title="0">{
                return Lat{}, fmt.Errorf("invalid latitude %.6f", lat)
        }</span>
        <span class="cov0" title="0">return Lat{lat: lat}, nil</span>
}

func MustParseLat(lt float64) Lat <span class="cov0" title="0">{
        lat, err := ParseLat(lt)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return lat</span>
}
func (l Lat) Equal(l2 Lat) bool <span class="cov0" title="0">{
        return l.lat == l2.lat
}</span>

// =====================================================================
// Longitude parsing

type Long struct{ long float64 }

func (l Long) Float64() float64 <span class="cov0" title="0">{ return l.long }</span>

func ParseLong(long float64) (Long, error) <span class="cov0" title="0">{
        if math.IsNaN(long) || math.IsInf(long, 0) || long &lt; -180 || long &gt; 180 </span><span class="cov0" title="0">{
                return Long{}, fmt.Errorf("invalid longitude %.6f", long)
        }</span>
        <span class="cov0" title="0">return Long{long: long}, nil</span>
}

func MustParseLong(lg float64) Long <span class="cov0" title="0">{
        lng, err := ParseLong(lg)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return lng</span>
}

func (l Long) Equal(l2 Long) bool <span class="cov0" title="0">{
        return l.long == l2.long
}</span>

// =====================================================================
// Geofence parsing

type Geofence struct{ geofence float64 }

func (g Geofence) Float64() float64 <span class="cov0" title="0">{ return g.geofence }</span>

func ParseGeofence(geofence float64) (Geofence, error) <span class="cov0" title="0">{
        if math.IsNaN(geofence) || math.IsInf(geofence, 0) || geofence &lt;= 0 </span><span class="cov0" title="0">{
                return Geofence{}, fmt.Errorf("invalid geofence %.6f", geofence)
        }</span>
        <span class="cov0" title="0">return Geofence{geofence: geofence}, nil</span>
}

func MustParseGeofence(gf float64) Geofence <span class="cov0" title="0">{
        geofnc, err := ParseGeofence(gf)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return geofnc</span>
}

func (g Geofence) Equal(g2 Geofence) bool <span class="cov0" title="0">{
        return g.geofence == g2.geofence
}</span>
</pre>
		
		<pre class="file" id="file179" style="display: none">// Package genstringtype represents a any strings in the system.
package genstringtype

// GenString represents a generic string in the system.
type GenString struct {
        value string
}

// String returns the value of the generic string.
func (gs GenString) String() string <span class="cov0" title="0">{
        return gs.value
}</span>

// Equal provides support for the go-cmp package and testing.
func (gs GenString) Equal(gs2 GenString) bool <span class="cov0" title="0">{
        return gs.value == gs2.value
}</span>

// MarshalText provides support for logging and any marshal needs.
func (gs GenString) MarshalText() ([]byte, error) <span class="cov0" title="0">{
        return []byte(gs.value), nil
}</span>

// Parse parses the string value and returns a generic string if the value complies
// with the rules for a generic string.
func Parse(value string) (GenString, error) <span class="cov0" title="0">{
        return GenString{value}, nil
}</span>

// MustParse parses the string value and returns a generic string if the value
// complies with the rules for a generic string. If an error occurs the function panics.
func MustParse(value string) GenString <span class="cov0" title="0">{
        genString, err := Parse(value)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">return genString</span>
}

// =============================================================================

// Null represents a generic string in the system that can be empty.
type Null struct {
        value string
        valid bool
}

// String returns the value of the generic string.
func (n Null) String() string <span class="cov0" title="0">{
        if !n.valid </span><span class="cov0" title="0">{
                return "NULL"
        }</span>

        <span class="cov0" title="0">return n.value</span>
}

// Valid tests if the value is null.
func (n Null) Valid() bool <span class="cov0" title="0">{
        return n.valid
}</span>

// Equal provides support for the go-cmp package and testing.
func (n Null) Equal(n2 Null) bool <span class="cov0" title="0">{
        return n.value == n2.value
}</span>

// =============================================================================

// ParseNull parses the string value and returns the generic string if the value complies
// with the rules for a name.
func ParseNull(value string) (Null, error) <span class="cov0" title="0">{
        if value == "" </span><span class="cov0" title="0">{
                return Null{}, nil
        }</span>

        <span class="cov0" title="0">return Null{value, true}, nil</span>
}

// MustParseNull parses the string value and returns the generic string if the value
// complies with the rules for the generic string. If an error occurs the function panics.
func MustParseNull(value string) Null <span class="cov0" title="0">{
        name, err := ParseNull(value)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">return name</span>
}
</pre>
		
		<pre class="file" id="file180" style="display: none">// Package name represents a name in the system.
package name

import (
        "fmt"
        "regexp"
)

// Name represents a name in the system.
type Name struct {
        value string
}

// String returns the value of the name.
func (n Name) String() string <span class="cov0" title="0">{
        return n.value
}</span>

// Equal provides support for the go-cmp package and testing.
func (n Name) Equal(n2 Name) bool <span class="cov0" title="0">{
        return n.value == n2.value
}</span>

// MarshalText provides support for logging and any marshal needs.
func (n Name) MarshalText() ([]byte, error) <span class="cov0" title="0">{
        return []byte(n.value), nil
}</span>

// =============================================================================

var nameRegEx = regexp.MustCompile("^.*$")

// Parse parses the string value and returns a name if the value complies
// with the rules for a name.
func Parse(value string) (Name, error) <span class="cov0" title="0">{
        if !nameRegEx.MatchString(value) </span><span class="cov0" title="0">{
                return Name{}, fmt.Errorf("invalid name %q", value)
        }</span>

        <span class="cov0" title="0">return Name{value}, nil</span>
}

// MustParse parses the string value and returns a name if the value
// complies with the rules for a name. If an error occurs the function panics.
func MustParse(value string) Name <span class="cov0" title="0">{
        name, err := Parse(value)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">return name</span>
}

// =============================================================================

// Null represents a name in the system that can be empty.
type Null struct {
        value string
        valid bool
}

// String returns the value of the name.
func (n Null) String() string <span class="cov0" title="0">{
        if !n.valid </span><span class="cov0" title="0">{
                return "NULL"
        }</span>

        <span class="cov0" title="0">return n.value</span>
}

// Valid tests if the value is null.
func (n Null) Valid() bool <span class="cov0" title="0">{
        return n.valid
}</span>

// Equal provides support for the go-cmp package and testing.
func (n Null) Equal(n2 Null) bool <span class="cov0" title="0">{
        return n.value == n2.value
}</span>

// =============================================================================

// ParseNull parses the string value and returns a name if the value complies
// with the rules for a name.
func ParseNull(value string) (Null, error) <span class="cov0" title="0">{
        if value == "" </span><span class="cov0" title="0">{
                return Null{}, nil
        }</span>

        <span class="cov0" title="0">if !nameRegEx.MatchString(value) </span><span class="cov0" title="0">{
                return Null{}, fmt.Errorf("invalid name %q", value)
        }</span>

        <span class="cov0" title="0">return Null{value, true}, nil</span>
}

// MustParseNull parses the string value and returns a name if the value
// complies with the rules for a name. If an error occurs the function panics.
func MustParseNull(value string) Null <span class="cov0" title="0">{
        name, err := ParseNull(value)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">return name</span>
}
</pre>
		
		<pre class="file" id="file181" style="display: none">// Package role represents the role type in the system.
package role

import "fmt"

// The set of roles that can be used.
var (
        Admin = newRole("ADMIN")
        User  = newRole("USER")
)

// =============================================================================

// Set of known roles.
var roles = make(map[string]Role)

// Role represents a role in the system.
type Role struct {
        value string
}

func newRole(role string) Role <span class="cov0" title="0">{
        r := Role{role}
        roles[role] = r
        return r
}</span>

// String returns the name of the role.
func (r Role) String() string <span class="cov0" title="0">{
        return r.value
}</span>

// Equal provides support for the go-cmp package and testing.
func (r Role) Equal(r2 Role) bool <span class="cov0" title="0">{
        return r.value == r2.value
}</span>

// MarshalText provides support for logging and any marshal needs.
func (r Role) MarshalText() ([]byte, error) <span class="cov0" title="0">{
        return []byte(r.value), nil
}</span>

// =============================================================================

// Parse parses the string value and returns a role if one exists.
func Parse(value string) (Role, error) <span class="cov0" title="0">{
        role, exists := roles[value]
        if !exists </span><span class="cov0" title="0">{
                return Role{}, fmt.Errorf("invalid role %q", value)
        }</span>

        <span class="cov0" title="0">return role, nil</span>
}

// MustParse parses the string value and returns a role if one exists. If
// an error occurs the function panics.
func MustParse(value string) Role <span class="cov0" title="0">{
        role, err := Parse(value)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">return role</span>
}

// ParseToString takes a collection of user roles and converts them to
// a slice of string.
func ParseToString(usrRoles []Role) []string <span class="cov0" title="0">{
        roles := make([]string, len(usrRoles))
        for i, role := range usrRoles </span><span class="cov0" title="0">{
                roles[i] = role.String()
        }</span>

        <span class="cov0" title="0">return roles</span>
}

// ParseMany takes a collection of strings and converts them to a slice
// of roles.
func ParseMany(roles []string) ([]Role, error) <span class="cov0" title="0">{
        usrRoles := make([]Role, len(roles))
        for i, roleStr := range roles </span><span class="cov0" title="0">{
                role, err := Parse(roleStr)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">usrRoles[i] = role</span>
        }

        <span class="cov0" title="0">return usrRoles, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
