
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>auditbus: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/FITHSCS/backend/business/domain/auditbus/auditbus.go (69.2%)</option>
				
				<option value="file1">github.com/FITHSCS/backend/business/domain/auditbus/stores/auditdb/auditdb.go (0.0%)</option>
				
				<option value="file2">github.com/FITHSCS/backend/business/domain/auditbus/stores/auditdb/filter.go (0.0%)</option>
				
				<option value="file3">github.com/FITHSCS/backend/business/domain/auditbus/stores/auditdb/model.go (0.0%)</option>
				
				<option value="file4">github.com/FITHSCS/backend/business/domain/auditbus/stores/auditdb/order.go (0.0%)</option>
				
				<option value="file5">github.com/FITHSCS/backend/business/domain/auditbus/testutil.go (93.3%)</option>
				
				<option value="file6">github.com/FITHSCS/backend/business/domain/delexceptionbus/delexceptionbus.go (78.7%)</option>
				
				<option value="file7">github.com/FITHSCS/backend/business/domain/delexceptionbus/store/delexceptiondb/delexceptiondb.go (0.0%)</option>
				
				<option value="file8">github.com/FITHSCS/backend/business/domain/delexceptionbus/store/delexceptiondb/filter.go (0.0%)</option>
				
				<option value="file9">github.com/FITHSCS/backend/business/domain/delexceptionbus/store/delexceptiondb/model.go (0.0%)</option>
				
				<option value="file10">github.com/FITHSCS/backend/business/domain/delexceptionbus/store/delexceptiondb/order.go (0.0%)</option>
				
				<option value="file11">github.com/FITHSCS/backend/business/domain/delexceptionbus/testutil.go (95.2%)</option>
				
				<option value="file12">github.com/FITHSCS/backend/business/domain/facilitybus/facilitybus.go (68.5%)</option>
				
				<option value="file13">github.com/FITHSCS/backend/business/domain/facilitybus/stores/facilitydb/facilitydb.go (0.0%)</option>
				
				<option value="file14">github.com/FITHSCS/backend/business/domain/facilitybus/stores/facilitydb/filter.go (0.0%)</option>
				
				<option value="file15">github.com/FITHSCS/backend/business/domain/facilitybus/stores/facilitydb/model.go (0.0%)</option>
				
				<option value="file16">github.com/FITHSCS/backend/business/domain/facilitybus/stores/facilitydb/order.go (0.0%)</option>
				
				<option value="file17">github.com/FITHSCS/backend/business/domain/facilitybus/testutil.go (93.8%)</option>
				
				<option value="file18">github.com/FITHSCS/backend/business/domain/gpstrackingbus/gpstrackingbus.go (79.1%)</option>
				
				<option value="file19">github.com/FITHSCS/backend/business/domain/gpstrackingbus/stores/gpstrackingdb/filter.go (0.0%)</option>
				
				<option value="file20">github.com/FITHSCS/backend/business/domain/gpstrackingbus/stores/gpstrackingdb/gpstrackingdb.go (0.0%)</option>
				
				<option value="file21">github.com/FITHSCS/backend/business/domain/gpstrackingbus/stores/gpstrackingdb/model.go (0.0%)</option>
				
				<option value="file22">github.com/FITHSCS/backend/business/domain/gpstrackingbus/stores/gpstrackingdb/order.go (0.0%)</option>
				
				<option value="file23">github.com/FITHSCS/backend/business/domain/gpstrackingbus/testutil.go (93.8%)</option>
				
				<option value="file24">github.com/FITHSCS/backend/business/domain/imagebus/imagebus.go (79.6%)</option>
				
				<option value="file25">github.com/FITHSCS/backend/business/domain/imagebus/stores/imagedb/filter.go (0.0%)</option>
				
				<option value="file26">github.com/FITHSCS/backend/business/domain/imagebus/stores/imagedb/imagedb.go (0.0%)</option>
				
				<option value="file27">github.com/FITHSCS/backend/business/domain/imagebus/stores/imagedb/model.go (0.0%)</option>
				
				<option value="file28">github.com/FITHSCS/backend/business/domain/imagebus/stores/imagedb/order.go (0.0%)</option>
				
				<option value="file29">github.com/FITHSCS/backend/business/domain/imagebus/testutil.go (95.0%)</option>
				
				<option value="file30">github.com/FITHSCS/backend/business/domain/manifestbus/manifestbus.go (79.6%)</option>
				
				<option value="file31">github.com/FITHSCS/backend/business/domain/manifestbus/stores/manifestdb/filter.go (0.0%)</option>
				
				<option value="file32">github.com/FITHSCS/backend/business/domain/manifestbus/stores/manifestdb/manifestdb.go (0.0%)</option>
				
				<option value="file33">github.com/FITHSCS/backend/business/domain/manifestbus/stores/manifestdb/model.go (0.0%)</option>
				
				<option value="file34">github.com/FITHSCS/backend/business/domain/manifestbus/stores/manifestdb/order.go (0.0%)</option>
				
				<option value="file35">github.com/FITHSCS/backend/business/domain/manifestbus/testutil.go (95.2%)</option>
				
				<option value="file36">github.com/FITHSCS/backend/business/domain/pickupbatchbus/pickupbatchbus.go (78.8%)</option>
				
				<option value="file37">github.com/FITHSCS/backend/business/domain/pickupbatchbus/stores/pickupbatchdb/filter.go (0.0%)</option>
				
				<option value="file38">github.com/FITHSCS/backend/business/domain/pickupbatchbus/stores/pickupbatchdb/model.go (0.0%)</option>
				
				<option value="file39">github.com/FITHSCS/backend/business/domain/pickupbatchbus/stores/pickupbatchdb/order.go (0.0%)</option>
				
				<option value="file40">github.com/FITHSCS/backend/business/domain/pickupbatchbus/stores/pickupbatchdb/pickupbatchdb.go (0.0%)</option>
				
				<option value="file41">github.com/FITHSCS/backend/business/domain/pickupbatchbus/testutil.go (94.7%)</option>
				
				<option value="file42">github.com/FITHSCS/backend/business/domain/routebus/routebus.go (79.6%)</option>
				
				<option value="file43">github.com/FITHSCS/backend/business/domain/routebus/stores/routedb/filter.go (0.0%)</option>
				
				<option value="file44">github.com/FITHSCS/backend/business/domain/routebus/stores/routedb/model.go (0.0%)</option>
				
				<option value="file45">github.com/FITHSCS/backend/business/domain/routebus/stores/routedb/order.go (0.0%)</option>
				
				<option value="file46">github.com/FITHSCS/backend/business/domain/routebus/stores/routedb/routedb.go (0.0%)</option>
				
				<option value="file47">github.com/FITHSCS/backend/business/domain/routebus/testutil.go (93.3%)</option>
				
				<option value="file48">github.com/FITHSCS/backend/business/domain/signaturebus/signaturebus.go (82.0%)</option>
				
				<option value="file49">github.com/FITHSCS/backend/business/domain/signaturebus/stores/signaturedb/filter.go (0.0%)</option>
				
				<option value="file50">github.com/FITHSCS/backend/business/domain/signaturebus/stores/signaturedb/model.go (0.0%)</option>
				
				<option value="file51">github.com/FITHSCS/backend/business/domain/signaturebus/stores/signaturedb/order.go (0.0%)</option>
				
				<option value="file52">github.com/FITHSCS/backend/business/domain/signaturebus/stores/signaturedb/signaturedb.go (0.0%)</option>
				
				<option value="file53">github.com/FITHSCS/backend/business/domain/signaturebus/testutil.go (95.0%)</option>
				
				<option value="file54">github.com/FITHSCS/backend/business/domain/syncbatchbus/stores/syncbatchdb/model.go (0.0%)</option>
				
				<option value="file55">github.com/FITHSCS/backend/business/domain/syncbatchbus/stores/syncbatchdb/syncbatchdb.go (0.0%)</option>
				
				<option value="file56">github.com/FITHSCS/backend/business/domain/syncbatchbus/syncbatchbus.go (0.0%)</option>
				
				<option value="file57">github.com/FITHSCS/backend/business/domain/userbus/extensions/useraudit/useraudit.go (0.0%)</option>
				
				<option value="file58">github.com/FITHSCS/backend/business/domain/userbus/stores/usercache/usercache.go (0.0%)</option>
				
				<option value="file59">github.com/FITHSCS/backend/business/domain/userbus/stores/userdb/filter.go (0.0%)</option>
				
				<option value="file60">github.com/FITHSCS/backend/business/domain/userbus/stores/userdb/model.go (0.0%)</option>
				
				<option value="file61">github.com/FITHSCS/backend/business/domain/userbus/stores/userdb/order.go (0.0%)</option>
				
				<option value="file62">github.com/FITHSCS/backend/business/domain/userbus/stores/userdb/userdb.go (0.0%)</option>
				
				<option value="file63">github.com/FITHSCS/backend/business/domain/userbus/testutil.go (93.3%)</option>
				
				<option value="file64">github.com/FITHSCS/backend/business/domain/userbus/userbus.go (50.8%)</option>
				
				<option value="file65">github.com/FITHSCS/backend/business/domain/vehiclebus/stores/vehicledb/filter.go (0.0%)</option>
				
				<option value="file66">github.com/FITHSCS/backend/business/domain/vehiclebus/stores/vehicledb/model.go (0.0%)</option>
				
				<option value="file67">github.com/FITHSCS/backend/business/domain/vehiclebus/stores/vehicledb/order.go (0.0%)</option>
				
				<option value="file68">github.com/FITHSCS/backend/business/domain/vehiclebus/stores/vehicledb/vehicledb.go (0.0%)</option>
				
				<option value="file69">github.com/FITHSCS/backend/business/domain/vehiclebus/testutil.go (93.3%)</option>
				
				<option value="file70">github.com/FITHSCS/backend/business/domain/vehiclebus/vehiclebus.go (80.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package auditbus provides a business logic layer for handling audit events.
package auditbus

import (
        "context"
        "encoding/json"
        "fmt"
        "time"

        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/google/uuid"
)

// Storer interface declares the behavior this package needs to persist and
// retrieve data.
type Storer interface {
        Create(ctx context.Context, audit Audit) error
        Query(ctx context.Context, filter QueryFilter, orderBy order.By, page page.Page) ([]Audit, error)
        Count(ctx context.Context, filter QueryFilter) (int, error)
}

// Business manages the set of APIs for audit access.
type Business struct {
        log    *logger.Logger
        storer Storer
}

// NewBusiness constructs a audit business API for use.
func NewBusiness(log *logger.Logger, storer Storer) *Business <span class="cov1" title="1">{
        return &amp;Business{
                log:    log,
                storer: storer,
        }
}</span>

// Create adds a new audit record to the system.
func (b *Business) Create(ctx context.Context, na NewAudit) (Audit, error) <span class="cov10" title="2">{

        jsonData, err := json.Marshal(na.Data)
        if err != nil </span><span class="cov0" title="0">{
                return Audit{}, fmt.Errorf("marshal object: %w", err)
        }</span>

        <span class="cov10" title="2">audit := Audit{
                ID:        uuid.New(),
                ObjID:     na.ObjID,
                ObjDomain: na.ObjDomain,
                ObjName:   na.ObjName,
                ActorID:   na.ActorID,
                Action:    na.Action,
                Data:      jsonData,
                Message:   na.Message,
                Timestamp: time.Now(),
        }

        if err := b.storer.Create(ctx, audit); err != nil </span><span class="cov0" title="0">{
                return Audit{}, fmt.Errorf("create audit: %w", err)
        }</span>

        <span class="cov10" title="2">return audit, nil</span>
}

// Query retrieves a list of existing audit records.
func (b *Business) Query(ctx context.Context, filter QueryFilter, orderBy order.By, page page.Page) ([]Audit, error) <span class="cov1" title="1">{

        audits, err := b.storer.Query(ctx, filter, orderBy, page)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("query audits: %w", err)
        }</span>

        <span class="cov1" title="1">return audits, nil</span>
}

// Count returns the total number of users.
func (b *Business) Count(ctx context.Context, filter QueryFilter) (int, error) <span class="cov0" title="0">{
        return b.storer.Count(ctx, filter)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">// Package auditdb contains audit related CRUD functionality.
package auditdb

import (
        "bytes"
        "context"
        "fmt"

        "github.com/FITHSCS/backend/business/domain/auditbus"
        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/business/sdk/sqldb"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/jmoiron/sqlx"
)

// Store manages the set of APIs for audit database access.
type Store struct {
        log *logger.Logger
        db  sqlx.ExtContext
}

// NewStore constructs the API for data access.
func NewStore(log *logger.Logger, db *sqlx.DB) *Store <span class="cov0" title="0">{
        return &amp;Store{
                log: log,
                db:  db,
        }
}</span>

// Create inserts a new audit record into the database.
func (s *Store) Create(ctx context.Context, a auditbus.Audit) error <span class="cov0" title="0">{
        const q = `
        INSERT INTO audit
                (id, obj_id, obj_domain, obj_name, actor_id, action, data, message, timestamp)
        VALUES
                (:id, :obj_id, :obj_domain, :obj_name, :actor_id, :action, :data, :message, :timestamp)`

        dbAudit, err := toDBAudit(a)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := sqldb.NamedExecContext(ctx, s.log, s.db, q, dbAudit); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("namedexeccontext: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *Store) Query(ctx context.Context, filter auditbus.QueryFilter, orderBy order.By, page page.Page) ([]auditbus.Audit, error) <span class="cov0" title="0">{
        data := map[string]any{
                "offset":        (page.Number() - 1) * page.RowsPerPage(),
                "rows_per_page": page.RowsPerPage(),
        }

        const q = `
        SELECT
                id, obj_id, obj_domain, obj_name, actor_id, action, data, message, timestamp
        FROM
                audit
        `

        buf := bytes.NewBufferString(q)
        applyFilter(filter, data, buf)

        orderByClause, err := orderByClause(orderBy)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">buf.WriteString(orderByClause)
        buf.WriteString(" OFFSET :offset ROWS FETCH NEXT :rows_per_page ROWS ONLY")

        var dbAudits []audit
        if err := sqldb.NamedQuerySlice(ctx, s.log, s.db, buf.String(), data, &amp;dbAudits); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("namedqueryslice: %w", err)
        }</span>

        <span class="cov0" title="0">return toBusAudits(dbAudits)</span>
}

// Count returns the total number of users in the DB.
func (s *Store) Count(ctx context.Context, filter auditbus.QueryFilter) (int, error) <span class="cov0" title="0">{
        data := map[string]any{}

        const q = `
        SELECT
                count(1)
        FROM
                audit`

        buf := bytes.NewBufferString(q)
        applyFilter(filter, data, buf)

        var count struct {
                Count int `db:"count"`
        }
        if err := sqldb.NamedQueryStruct(ctx, s.log, s.db, buf.String(), data, &amp;count); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("db: %w", err)
        }</span>

        <span class="cov0" title="0">return count.Count, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package auditdb

import (
        "bytes"
        "fmt"
        "strings"

        "github.com/FITHSCS/backend/business/domain/auditbus"
)

func applyFilter(filter auditbus.QueryFilter, data map[string]any, buf *bytes.Buffer) <span class="cov0" title="0">{
        var wc []string

        if filter.ObjID != nil </span><span class="cov0" title="0">{
                data["obj_id"] = filter.ObjID
                wc = append(wc, "obj_id = :obj_id")
        }</span>

        <span class="cov0" title="0">if filter.ObjDomain != nil </span><span class="cov0" title="0">{
                data["obj_domain"] = filter.ObjDomain.String()
                wc = append(wc, "obj_domain = :obj_domain")
        }</span>

        <span class="cov0" title="0">if filter.ObjName != nil </span><span class="cov0" title="0">{
                data["obj_name"] = fmt.Sprintf("%%%s%%", filter.ObjName.String())
                wc = append(wc, "obj_name LIKE :obj_name")
        }</span>

        <span class="cov0" title="0">if filter.ActorID != nil </span><span class="cov0" title="0">{
                data["actor_id"] = filter.ActorID
                wc = append(wc, "actor_id = :actor_id")
        }</span>

        <span class="cov0" title="0">if filter.Action != nil </span><span class="cov0" title="0">{
                data["action"] = filter.Action
                wc = append(wc, "action = :action")
        }</span>

        <span class="cov0" title="0">if filter.Since != nil </span><span class="cov0" title="0">{
                data["since"] = filter.Since
                wc = append(wc, "timestamp &gt;= :since")
        }</span>

        <span class="cov0" title="0">if filter.Until != nil </span><span class="cov0" title="0">{
                data["until"] = filter.Until
                wc = append(wc, "timestamp &lt;= :until")
        }</span>

        <span class="cov0" title="0">if len(wc) &gt; 0 </span><span class="cov0" title="0">{
                buf.WriteString(" WHERE ")
                buf.WriteString(strings.Join(wc, " AND "))
        }</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package auditdb

import (
        "encoding/json"
        "fmt"
        "time"

        "github.com/FITHSCS/backend/business/domain/auditbus"
        "github.com/FITHSCS/backend/business/types/domain"
        "github.com/FITHSCS/backend/business/types/name"
        "github.com/google/uuid"
        "github.com/jmoiron/sqlx/types"
)

type audit struct {
        ID        uuid.UUID          `db:"id"`
        ObjID     uuid.UUID          `db:"obj_id"`
        ObjDomain string             `db:"obj_domain"`
        ObjName   string             `db:"obj_name"`
        ActorID   uuid.UUID          `db:"actor_id"`
        Action    string             `db:"action"`
        Data      types.NullJSONText `db:"data"`
        Message   string             `db:"message"`
        Timestamp time.Time          `db:"timestamp"`
}

func toDBAudit(bus auditbus.Audit) (audit, error) <span class="cov0" title="0">{
        db := audit{
                ID:        bus.ID,
                ObjID:     bus.ObjID,
                ObjDomain: bus.ObjDomain.String(),
                ObjName:   bus.ObjName.String(),
                ActorID:   bus.ActorID,
                Action:    bus.Action,
                Data:      types.NullJSONText{JSONText: []byte(bus.Data), Valid: true},
                Message:   bus.Message,
                Timestamp: bus.Timestamp.UTC(),
        }

        return db, nil
}</span>

func toBusAudit(db audit) (auditbus.Audit, error) <span class="cov0" title="0">{
        domain, err := domain.Parse(db.ObjDomain)
        if err != nil </span><span class="cov0" title="0">{
                return auditbus.Audit{}, fmt.Errorf("parse domain: %w", err)
        }</span>

        <span class="cov0" title="0">name, err := name.Parse(db.ObjName)
        if err != nil </span><span class="cov0" title="0">{
                return auditbus.Audit{}, fmt.Errorf("parse name: %w", err)
        }</span>

        <span class="cov0" title="0">bus := auditbus.Audit{
                ID:        db.ID,
                ObjID:     db.ObjID,
                ObjDomain: domain,
                ObjName:   name,
                ActorID:   db.ActorID,
                Action:    db.Action,
                Data:      json.RawMessage(db.Data.JSONText),
                Message:   db.Message,
                Timestamp: db.Timestamp.Local(),
        }

        return bus, nil</span>
}

func toBusAudits(dbs []audit) ([]auditbus.Audit, error) <span class="cov0" title="0">{
        audits := make([]auditbus.Audit, len(dbs))

        for i, db := range dbs </span><span class="cov0" title="0">{
                a, err := toBusAudit(db)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">audits[i] = a</span>
        }

        <span class="cov0" title="0">return audits, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package auditdb

import (
        "fmt"

        "github.com/FITHSCS/backend/business/domain/auditbus"
        "github.com/FITHSCS/backend/business/sdk/order"
)

var orderByFields = map[string]string{
        auditbus.OrderByObjID:     "obj_id",
        auditbus.OrderByObjDomain: "obj_domain",
        auditbus.OrderByObjName:   "obj_name",
        auditbus.OrderByActorID:   "actor_id",
        auditbus.OrderByAction:    "action",
}

func orderByClause(orderBy order.By) (string, error) <span class="cov0" title="0">{

        by, exists := orderByFields[orderBy.Field]
        if !exists </span><span class="cov0" title="0">{
                return "", fmt.Errorf("field %q does not exist", orderBy.Field)
        }</span>

        <span class="cov0" title="0">return " ORDER BY " + by + " " + orderBy.Direction, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package auditbus

import (
        "context"
        "fmt"
        "math/rand"

        "github.com/FITHSCS/backend/business/types/domain"
        "github.com/FITHSCS/backend/business/types/name"
        "github.com/google/uuid"
)

// TestNewAudits is a helper method for testing.
func TestNewAudits(n int, actorID uuid.UUID, objDomain domain.Domain, action string) []NewAudit <span class="cov1" title="1">{
        newAudits := make([]NewAudit, n)

        idx := rand.Intn(10000)
        for i := range n </span><span class="cov10" title="2">{
                idx++

                na := NewAudit{
                        ObjID:     uuid.New(),
                        ObjDomain: objDomain,
                        ObjName:   name.MustParse(fmt.Sprintf("ObjName%d", idx)),
                        ActorID:   actorID,
                        Action:    action,
                        Data:      struct{ Name string }{Name: fmt.Sprintf("Name%d", idx)},
                        Message:   fmt.Sprintf("Message%d", idx),
                }

                newAudits[i] = na
        }</span>

        <span class="cov1" title="1">return newAudits</span>
}

// TestSeedAudits is a helper method for testing.
func TestSeedAudits(ctx context.Context, n int, actorID uuid.UUID, objDomain domain.Domain, action string, api *Business) ([]Audit, error) <span class="cov1" title="1">{
        newAudits := TestNewAudits(n, actorID, objDomain, action)

        audits := make([]Audit, len(newAudits))
        for i, na := range newAudits </span><span class="cov10" title="2">{
                adt, err := api.Create(ctx, na)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("seeding audit: idx: %d : %w", i, err)
                }</span>

                <span class="cov10" title="2">audits[i] = adt</span>
        }

        <span class="cov1" title="1">return audits, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Package delexceptionbus provides business access to facilities domain.
package delexceptionbus

import (
        "context"
        "errors"
        "fmt"
        "time"

        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/google/uuid"
)

var (
        ErrNotFound              = errors.New("exception not found")
        ErrAuthenticationFailure = errors.New("authentication failed")
)

type Storer interface {
        Create(ctx context.Context, delexception DeliveryException) error
        Update(ctx context.Context, delexception DeliveryException) error
        SoftDelete(ctx context.Context, delexceptionID uuid.UUID) error
        HardDelete(ctx context.Context, delexceptionID uuid.UUID) error
        Query(ctx context.Context, filter QueryFilter, orderby order.By, page page.Page) ([]DeliveryException, error)
        Count(ctx context.Context, filter QueryFilter) (int, error)
        QueryByID(ctx context.Context, facilityID uuid.UUID) (DeliveryException, error)
}

type Business struct {
        log    *logger.Logger
        storer Storer
}

func NewBusiness(log *logger.Logger, storer Storer) *Business <span class="cov1" title="1">{
        return &amp;Business{
                log:    log,
                storer: storer,
        }
}</span>

func (b *Business) Create(ctx context.Context, nde NewDeliveryException) (DeliveryException, error) <span class="cov10" title="6">{
        now := time.Now().Truncate(time.Microsecond)

        facility := DeliveryException{
                ExceptionID:      uuid.New(),
                ManifestID:       nde.ManifestID,
                DeliveryPersonID: nde.DeliveryPersonID,
                Severity:         nde.Severity,
                ExceptionType:    nde.ExceptionType,
                Description:      nde.Description,
                CapturedAt:       nde.CapturedAt,
                ResolutionStatus: nde.ResolutionStatus,
                ResolvedBy:       nde.ResolvedBy,
                IsDeleted:        false,
                IsSynced:         nde.IsSynced,
                TimeStamp:        nde.TimeStamp,
                CreatedAt:        now,
                UpdatedAt:        now,
        }
        if err := b.storer.Create(ctx, facility); err != nil </span><span class="cov0" title="0">{
                return DeliveryException{}, fmt.Errorf("create: %w", err)
        }</span>
        <span class="cov10" title="6">return facility, nil</span>
}

func (b *Business) Update(ctx context.Context, excID uuid.UUID, uptdelexc UpdateDeliveryException) (DeliveryException, error) <span class="cov4" title="2">{

        delexcDBRtrvd, err := b.storer.QueryByID(ctx, excID)
        if err != nil </span><span class="cov0" title="0">{
                return DeliveryException{}, fmt.Errorf("Update: %w", err)
        }</span>

        <span class="cov4" title="2">if uptdelexc.ManifestID != nil </span><span class="cov4" title="2">{
                delexcDBRtrvd.ManifestID = *uptdelexc.ManifestID
        }</span>

        <span class="cov4" title="2">if uptdelexc.DeliveryPersonID != nil </span><span class="cov4" title="2">{
                delexcDBRtrvd.DeliveryPersonID = *uptdelexc.DeliveryPersonID
        }</span>

        <span class="cov4" title="2">if uptdelexc.Severity != nil </span><span class="cov4" title="2">{
                delexcDBRtrvd.Severity = *uptdelexc.Severity
        }</span>

        <span class="cov4" title="2">if uptdelexc.ExceptionType != nil </span><span class="cov4" title="2">{
                delexcDBRtrvd.ExceptionType = *uptdelexc.ExceptionType
        }</span>

        <span class="cov4" title="2">if uptdelexc.Description != nil </span><span class="cov4" title="2">{
                delexcDBRtrvd.Description = *uptdelexc.Description
        }</span>

        <span class="cov4" title="2">if uptdelexc.ResolutionStatus != nil </span><span class="cov4" title="2">{
                delexcDBRtrvd.ResolutionStatus = *uptdelexc.ResolutionStatus
        }</span>

        <span class="cov4" title="2">if uptdelexc.ResolvedBy != nil </span><span class="cov4" title="2">{
                delexcDBRtrvd.ResolvedBy = *uptdelexc.ResolvedBy
        }</span>

        <span class="cov4" title="2">delexcDBRtrvd.UpdatedAt = time.Now().Truncate(time.Microsecond)

        if err := b.storer.Update(ctx, delexcDBRtrvd); err != nil </span><span class="cov0" title="0">{
                return DeliveryException{}, fmt.Errorf("update: %w", err)
        }</span>
        <span class="cov4" title="2">return delexcDBRtrvd, nil</span>
}

func (b *Business) QueryByID(ctx context.Context, excID uuid.UUID) (DeliveryException, error) <span class="cov1" title="1">{

        facility, err := b.storer.QueryByID(ctx, excID)
        if err != nil </span><span class="cov0" title="0">{
                return DeliveryException{}, fmt.Errorf("query: deliveryExceptionID[%s]: %w", excID, err)
        }</span>
        <span class="cov1" title="1">return facility, nil</span>
}
func (b *Business) Query(ctx context.Context, filter QueryFilter, orderBy order.By, page page.Page) ([]DeliveryException, error) <span class="cov1" title="1">{

        delExceptions, err := b.storer.Query(ctx, filter, orderBy, page)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Query: %w", err)
        }</span>
        <span class="cov1" title="1">return delExceptions, nil</span>
}

func (b *Business) Count(ctx context.Context, filter QueryFilter) (int, error) <span class="cov0" title="0">{
        return b.storer.Count(ctx, filter)
}</span>

func (b *Business) SoftDelete(ctx context.Context, delExceptionID uuid.UUID) error <span class="cov4" title="2">{

        facility, err := b.storer.QueryByID(ctx, delExceptionID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("softdeletequery: delExceptionID[%s]: %w", delExceptionID, err)
        }</span>

        <span class="cov4" title="2">if facility.IsDeleted </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: already deleted", delExceptionID)
        }</span>

        <span class="cov4" title="2">if err := b.storer.SoftDelete(ctx, delExceptionID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("delete: %w", err)
        }</span>
        <span class="cov4" title="2">return nil</span>

}

func (b *Business) HardDelete(ctx context.Context, delExceptionID uuid.UUID) error <span class="cov4" title="2">{

        if err := b.storer.HardDelete(ctx, delExceptionID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("delete: %w", err)
        }</span>
        <span class="cov4" title="2">return nil</span>

}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Package delexceptiondb contains product related CRUD functionality.
package delexceptiondb

import (
        "bytes"
        "context"
        "errors"
        "fmt"

        "github.com/FITHSCS/backend/business/domain/delexceptionbus"
        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/business/sdk/sqldb"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/google/uuid"
        "github.com/jmoiron/sqlx"
)

type Store struct {
        log *logger.Logger
        db  sqlx.ExtContext
}

func NewStore(log *logger.Logger, db *sqlx.DB) *Store <span class="cov0" title="0">{
        return &amp;Store{
                log: log,
                db:  db,
        }
}</span>

func (s *Store) Create(ctx context.Context, f delexceptionbus.DeliveryException) error <span class="cov0" title="0">{
        const stmt = `
    INSERT INTO delivery_exception (
      exception_id,
          manifest_id,
          delivery_personnel_id,
          severity,
          exception_type,
          description,
      captured_at,
          resolution_status,
          resolved_by,
          is_deleted,
          is_synced,
          time_stamp,
      created_at,
          updated_at
    ) VALUES (
      :exception_id, 
          :manifest_id, 
          :delivery_personnel_id, 
          :severity,
          :exception_type, 
          :description,
      :captured_at, 
          :resolution_status, 
          :resolved_by,
      :is_deleted,
          :is_synced,
          :time_stamp,
      :created_at, 
          :updated_at
    )`

        return sqldb.NamedExecContext(ctx, s.log, s.db, stmt, toDBDeliveryException(f))
}</span>

func (s *Store) Update(ctx context.Context, f delexceptionbus.DeliveryException) error <span class="cov0" title="0">{
        const stmt = `
    UPDATE 
                delivery_exception
        SET 
                manifest_id                           = :manifest_id,
            delivery_personnel_id   = :delivery_personnel_id,
                severity                                = :severity,
            exception_type                 = :exception_type,
                description                         = :description, 
            resolution_status       = :resolution_status,
            resolved_by                         = :resolved_by,
               updated_at                      = :updated_at
    WHERE 
                exception_id = :exception_id`
        return sqldb.NamedExecContext(ctx, s.log, s.db, stmt, toDBDeliveryException(f))
}</span>

func (s *Store) Query(ctx context.Context, filter delexceptionbus.QueryFilter, orderBy order.By, page page.Page) ([]delexceptionbus.DeliveryException, error) <span class="cov0" title="0">{

        data := map[string]any{
                "offset":        (page.Number() - 1) * page.RowsPerPage(),
                "rows_per_page": page.RowsPerPage(),
        }

        const q = `
    SELECT
      exception_id,
          manifest_id,
          delivery_personnel_id,
          severity,
          exception_type,
          description,
      captured_at,
          resolution_status,
          resolved_by,
          is_deleted,
          is_synced,
          time_stamp,
      created_at,
          updated_at
    FROM 
                delivery_exception`

        buf := bytes.NewBufferString(q)
        s.applyFilter(filter, data, buf)

        orderByClause, err := orderByClause(orderBy)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">buf.WriteString(orderByClause)
        buf.WriteString(" OFFSET :offset ROWS FETCH NEXT :rows_per_page ROWS ONLY")

        var dbRecs []deliveryexceptiondb
        if err := sqldb.NamedQuerySlice(ctx, s.log, s.db, buf.String(), data, &amp;dbRecs); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("namedqueryslice: %w", err)
        }</span>
        <span class="cov0" title="0">fmt.Println(dbRecs)
        return toBusDeliveryExceptions(dbRecs)</span>
}

// Count returns the total number of users in the DB.
func (s *Store) Count(ctx context.Context, filter delexceptionbus.QueryFilter) (int, error) <span class="cov0" title="0">{
        data := map[string]any{}

        const q = `
        SELECT
                count(1)
        FROM
                delivery_exception`

        buf := bytes.NewBufferString(q)
        s.applyFilter(filter, data, buf)

        var count struct {
                Count int `db:"count"`
        }
        if err := sqldb.NamedQueryStruct(ctx, s.log, s.db, buf.String(), data, &amp;count); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("db: %w", err)
        }</span>

        <span class="cov0" title="0">return count.Count, nil</span>
}

func (s *Store) QueryByID(ctx context.Context, id uuid.UUID) (delexceptionbus.DeliveryException, error) <span class="cov0" title="0">{
        param := map[string]any{
                "exception_id": id.String(),
        }
        const stmt = `
    SELECT
                exception_id,
                manifest_id,
                delivery_personnel_id,
                severity,
                exception_type,
                description,
                captured_at,
                resolution_status,
                resolved_by,
                is_deleted,
                is_synced,
                time_stamp,
                created_at,
                updated_at
          FROM 
                delivery_exception
          WHERE 
                exception_id = :exception_id`

        var rec deliveryexceptiondb
        if err := sqldb.NamedQueryStruct(ctx, s.log, s.db, stmt, param, &amp;rec); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sqldb.ErrDBNotFound) </span><span class="cov0" title="0">{
                        return delexceptionbus.DeliveryException{}, delexceptionbus.ErrNotFound
                }</span>
                <span class="cov0" title="0">return delexceptionbus.DeliveryException{}, err</span>
        }
        <span class="cov0" title="0">return toBusDeliveryException(rec)</span>
}

func (s *Store) SoftDelete(ctx context.Context, DeliveryExceptionID uuid.UUID) error <span class="cov0" title="0">{

        const q = `
    UPDATE
        delivery_exception
        SET
                is_deleted = :is_deleted
    WHERE
        exception_id = :exception_id`

        dbDeliveryException := deliveryexceptiondb{ExceptionID: DeliveryExceptionID, IsDeleted: true}

        if err := sqldb.NamedExecContext(ctx, s.log, s.db, q, dbDeliveryException); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("namedexeccontext: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *Store) HardDelete(ctx context.Context, DeliveryExceptionID uuid.UUID) error <span class="cov0" title="0">{

        const q = `
    DELETE FROM
        delivery_exception
    WHERE
        exception_id = :exception_id`

        dbDeliveryException := deliveryexceptiondb{ExceptionID: DeliveryExceptionID}

        if err := sqldb.NamedExecContext(ctx, s.log, s.db, q, dbDeliveryException); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("namedexeccontext: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package delexceptiondb

import (
        "bytes"
        "strings"

        "github.com/FITHSCS/backend/business/domain/delexceptionbus"
)

func (s *Store) applyFilter(filter delexceptionbus.QueryFilter, data map[string]any, buf *bytes.Buffer) <span class="cov0" title="0">{

        var wc []string

        if filter.CreatedAt != nil </span><span class="cov0" title="0">{
                data["created_at"] = filter.CreatedAt.UTC()
                wc = append(wc, "created_at &gt;= :created_at")
        }</span>

        <span class="cov0" title="0">if filter.UpdatedAt != nil </span><span class="cov0" title="0">{
                data["updated_at"] = filter.UpdatedAt.UTC()
                wc = append(wc, "updated_at &lt;= :updated_at")
        }</span>

        <span class="cov0" title="0">if len(wc) &gt; 0 </span><span class="cov0" title="0">{
                buf.WriteString(" WHERE ")
                buf.WriteString(strings.Join(wc, " AND "))
        }</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package delexceptiondb

import (
        "fmt"
        "time"

        "github.com/FITHSCS/backend/business/domain/delexceptionbus"
        "github.com/FITHSCS/backend/business/types/genstringtype"
        "github.com/google/uuid"
)

type deliveryexceptiondb struct {
        ExceptionID      uuid.UUID     `db:"exception_id"`
        ManifestID       uuid.UUID     `db:"manifest_id"`
        DeliveryPersonID uuid.UUID     `db:"delivery_personnel_id"`
        Severity         string        `db:"severity"`
        ExceptionType    string        `db:"exception_type"`
        Description      string        `db:"description"`
        CapturedAt       time.Time     `db:"captured_at"`
        ResolutionStatus string        `db:"resolution_status"`
        ResolvedBy       uuid.NullUUID `db:"resolved_by"`
        IsDeleted        bool          `db:"is_deleted"`
        IsSynced         bool          `db:"is_synced"`
        TimeStamp        time.Time     `db:"time_stamp"`
        CreatedAt        time.Time     `db:"created_at"`
        UpdatedAt        time.Time     `db:"updated_at"`
}

func toDBDeliveryException(bus delexceptionbus.DeliveryException) deliveryexceptiondb <span class="cov0" title="0">{

        return deliveryexceptiondb{
                ExceptionID:      bus.ExceptionID,
                ManifestID:       bus.ManifestID,
                DeliveryPersonID: bus.DeliveryPersonID,
                Severity:         bus.Severity.String(),
                ExceptionType:    bus.ExceptionType.String(),
                Description:      bus.Description.String(),
                CapturedAt:       bus.CapturedAt.UTC(),
                ResolutionStatus: bus.ResolutionStatus.String(),
                ResolvedBy:       bus.ResolvedBy,
                IsDeleted:        bus.IsDeleted,
                IsSynced:         bus.IsSynced,
                TimeStamp:        bus.TimeStamp.UTC(),
                CreatedAt:        bus.CreatedAt.UTC(),
                UpdatedAt:        bus.UpdatedAt.UTC(),
        }
}</span>

func toBusDeliveryException(db deliveryexceptiondb) (delexceptionbus.DeliveryException, error) <span class="cov0" title="0">{

        exctype, err := genstringtype.Parse(db.ExceptionType)
        if err != nil </span><span class="cov0" title="0">{
                return delexceptionbus.DeliveryException{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">desc, err := genstringtype.Parse(db.Description)
        if err != nil </span><span class="cov0" title="0">{
                return delexceptionbus.DeliveryException{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">resusts, err := genstringtype.Parse(db.ResolutionStatus)
        if err != nil </span><span class="cov0" title="0">{
                return delexceptionbus.DeliveryException{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">sev, err := genstringtype.Parse(db.Severity)
        if err != nil </span><span class="cov0" title="0">{
                return delexceptionbus.DeliveryException{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">bus := delexceptionbus.DeliveryException{
                ExceptionID:      db.ExceptionID,
                ManifestID:       db.ManifestID,
                DeliveryPersonID: db.DeliveryPersonID,
                Severity:         sev,
                ExceptionType:    exctype,
                Description:      desc,
                CapturedAt:       db.CapturedAt.In(time.Local),
                ResolutionStatus: resusts,
                ResolvedBy:       db.ResolvedBy,
                IsDeleted:        db.IsDeleted,
                IsSynced:         db.IsSynced,
                TimeStamp:        db.TimeStamp.In(time.Local),
                CreatedAt:        db.CreatedAt.In(time.Local),
                UpdatedAt:        db.UpdatedAt.In(time.Local),
        }
        return bus, nil</span>

}

func toBusDeliveryExceptions(dbs []deliveryexceptiondb) ([]delexceptionbus.DeliveryException, error) <span class="cov0" title="0">{
        bus := make([]delexceptionbus.DeliveryException, len(dbs))
        for i, db := range dbs </span><span class="cov0" title="0">{
                var err error
                bus[i], err = toBusDeliveryException(db)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">return bus, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package delexceptiondb

import (
        "fmt"

        "github.com/FITHSCS/backend/business/domain/delexceptionbus"
        "github.com/FITHSCS/backend/business/sdk/order"
)

var orderByFields = map[string]string{
        delexceptionbus.OrderByExceptionID:      "exception_id",
        delexceptionbus.OrderByManifestID:       "manifest_id",
        delexceptionbus.OrderByExceptionType:    "exception_type",
        delexceptionbus.OrderByResolutionStatus: "resolution_status",
        delexceptionbus.OrderByCreatedAt:        "created_at",
        delexceptionbus.OrderByUpdatedAt:        "updated_at",
}

// orderByClause converts an order.By value into the final
// " ORDER BY … ASC|DESC" fragment the store adds to its SELECT.
func orderByClause(ob order.By) (string, error) <span class="cov0" title="0">{
        col, ok := orderByFields[ob.Field]
        if !ok </span><span class="cov0" title="0">{
                return "", fmt.Errorf("field %q does not exist", ob.Field)
        }</span>
        <span class="cov0" title="0">return " ORDER BY " + col + " " + ob.Direction, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package delexceptionbus

import (
        "context"
        "fmt"
        "math/rand"
        "time"

        "github.com/FITHSCS/backend/business/types/genstringtype"
        "github.com/google/uuid"
)

func TestGenerateNewDeliveryException(n int, manID, delpersID, resBy uuid.UUID) []NewDeliveryException <span class="cov5" title="2">{
        newfs := make([]NewDeliveryException, n)
        svr := []string{"low", "medium", "high"}
        exetype := []string{"damaged", "descripancy", "refused", "no_recipient", "wrong_address", "other"}
        resolsts := []string{"pending", "resolved"}
        resby := []uuid.NullUUID{
                {UUID: resBy, Valid: true},
                {UUID: uuid.UUID{}, Valid: false},
        }

        CapturedAt, _ := time.Parse(time.RFC3339, "2025-06-10T15:59:33+03:00")
        timestamp := CapturedAt.Add(time.Minute + 1)

        idx := rand.Intn(10000)
        for i := range n </span><span class="cov10" title="4">{
                idx++

                nf := NewDeliveryException{
                        ManifestID:       manID,
                        DeliveryPersonID: delpersID,
                        Severity:         genstringtype.MustParse(svr[i%3]),
                        ExceptionType:    genstringtype.MustParse(exetype[i%6]),
                        Description:      genstringtype.MustParse("This is the description for this exception"),
                        CapturedAt:       CapturedAt,
                        ResolutionStatus: genstringtype.MustParse(resolsts[i%2]),
                        ResolvedBy:       resby[i%2],
                        IsSynced:         true,
                        TimeStamp:        timestamp,
                }

                newfs[i] = nf
        }</span>

        <span class="cov5" title="2">return newfs</span>
}

func TestGenerateSeedDeliveryException(ctx context.Context, n int, api *Business, manID, delpersID, resBy uuid.UUID) ([]DeliveryException, error) <span class="cov5" title="2">{
        newfs := TestGenerateNewDeliveryException(n, manID, delpersID, resBy)

        facs := make([]DeliveryException, len(newfs))
        for i, np := range newfs </span><span class="cov10" title="4">{
                prd, err := api.Create(ctx, np)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("seeding deliveryexception: idx: %d : %w", i, err)
                }</span>

                <span class="cov10" title="4">facs[i] = prd</span>
        }

        <span class="cov5" title="2">return facs, nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// Package facilitybus provides business access to facilities domain.
package facilitybus

import (
        "context"
        "errors"
        "fmt"

        "time"

        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/google/uuid"
)

var (
        ErrNotFound              = errors.New("facility not found")
        ErrAuthenticationFailure = errors.New("authentication failed")
)

type Storer interface {
        Create(ctx context.Context, facility Facility) error
        Update(ctx context.Context, facility Facility) error
        SoftDelete(ctx context.Context, facilityID uuid.UUID) error
        HardDelete(ctx context.Context, facilityID uuid.UUID) error
        Query(ctx context.Context, filter QueryFilter, orderby order.By, page page.Page) ([]Facility, error)
        Count(ctx context.Context, filter QueryFilter) (int, error)
        QueryByID(ctx context.Context, facilityID uuid.UUID) (Facility, error)
}

func (b *Business) GetStorer() Storer <span class="cov0" title="0">{
        return b.storer
}</span>

type Business struct {
        log    *logger.Logger
        storer Storer
}

func NewBusiness(log *logger.Logger, storer Storer) *Business <span class="cov1" title="1">{
        return &amp;Business{
                log:    log,
                storer: storer,
        }
}</span>

func (b *Business) Create(ctx context.Context, nf NewFacility) (Facility, error) <span class="cov10" title="5">{
        now := time.Now().Truncate(time.Microsecond)

        facility := Facility{
                ID:              uuid.New(),
                FacilityName:    nf.FacilityName,
                FacilityType:    nf.FacilityType,
                Address:         nf.Address,
                Region:          nf.Region,
                Latitude:        nf.Latitude,
                Longitude:       nf.Longitude,
                GeofenceRadius:  nf.GeofenceRadius,
                ContactPersonID: nf.ContactPersonID,
                ContactPhone:    nf.ContactPhone,
                IsDeleted:       false,
                CreatedAt:       now,
                UpdatedAt:       now,
        }
        if err := b.storer.Create(ctx, facility); err != nil </span><span class="cov0" title="0">{
                return Facility{}, fmt.Errorf("create: %w", err)
        }</span>
        <span class="cov10" title="5">return facility, nil</span>
}

func (b *Business) Update(ctx context.Context, facilityID uuid.UUID, updtFacility UpdateFacility) (Facility, error) <span class="cov1" title="1">{

        facDBRetrieved, err := b.storer.QueryByID(ctx, facilityID)
        if err != nil </span><span class="cov0" title="0">{
                return Facility{}, fmt.Errorf("Update: %w", err)
        }</span>

        <span class="cov1" title="1">if updtFacility.FacilityName != nil </span><span class="cov1" title="1">{
                facDBRetrieved.FacilityName = *updtFacility.FacilityName
        }</span>

        <span class="cov1" title="1">if updtFacility.FacilityType != nil </span><span class="cov1" title="1">{
                facDBRetrieved.FacilityType = *updtFacility.FacilityType
        }</span>

        <span class="cov1" title="1">if updtFacility.Address != nil </span><span class="cov1" title="1">{
                facDBRetrieved.Address = *updtFacility.Address
        }</span>

        <span class="cov1" title="1">if updtFacility.Region != nil </span><span class="cov1" title="1">{
                facDBRetrieved.Region = *updtFacility.Region
        }</span>

        <span class="cov1" title="1">if updtFacility.Latitude != nil </span><span class="cov1" title="1">{
                facDBRetrieved.Latitude = *updtFacility.Latitude
        }</span>
        <span class="cov1" title="1">if updtFacility.Longitude != nil </span><span class="cov1" title="1">{
                facDBRetrieved.Longitude = *updtFacility.Longitude
        }</span>
        <span class="cov1" title="1">if updtFacility.GeofenceRadius != nil </span><span class="cov1" title="1">{
                facDBRetrieved.GeofenceRadius = *updtFacility.GeofenceRadius
        }</span>

        <span class="cov1" title="1">if updtFacility.ContactPersonID != nil </span><span class="cov1" title="1">{
                facDBRetrieved.ContactPersonID = *updtFacility.ContactPersonID
        }</span>

        <span class="cov1" title="1">if updtFacility.ContactPhone != nil </span><span class="cov1" title="1">{
                facDBRetrieved.ContactPhone = *updtFacility.ContactPhone
        }</span>

        <span class="cov1" title="1">if updtFacility.IsDeleted != nil </span><span class="cov0" title="0">{
                facDBRetrieved.IsDeleted = *updtFacility.IsDeleted
        }</span>

        <span class="cov1" title="1">facDBRetrieved.UpdatedAt = time.Now().Truncate(time.Microsecond)

        if err := b.storer.Update(ctx, facDBRetrieved); err != nil </span><span class="cov0" title="0">{
                return Facility{}, fmt.Errorf("update: %w", err)
        }</span>
        <span class="cov1" title="1">return facDBRetrieved, nil</span>
}

func (b *Business) QueryByID(ctx context.Context, facilityID uuid.UUID) (Facility, error) <span class="cov1" title="1">{

        facility, err := b.storer.QueryByID(ctx, facilityID)
        if err != nil </span><span class="cov0" title="0">{
                return Facility{}, fmt.Errorf("query: facilityID[%s]: %w", facilityID, err)
        }</span>
        <span class="cov1" title="1">return facility, nil</span>
}
func (b *Business) Query(ctx context.Context, filter QueryFilter, orderBy order.By, page page.Page) ([]Facility, error) <span class="cov1" title="1">{

        facilities, err := b.storer.Query(ctx, filter, orderBy, page)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Query: %w", err)
        }</span>
        <span class="cov1" title="1">return facilities, nil</span>
}

func (b *Business) Count(ctx context.Context, filter QueryFilter) (int, error) <span class="cov0" title="0">{
        return b.storer.Count(ctx, filter)
}</span>

func (b *Business) SoftDelete(ctx context.Context, facilityID uuid.UUID) error <span class="cov0" title="0">{

        facility, err := b.storer.QueryByID(ctx, facilityID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("softdeletequery: facilityID[%s]: %w", facilityID, err)
        }</span>

        <span class="cov0" title="0">if facility.IsDeleted </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: already deleted", facilityID)
        }</span>

        <span class="cov0" title="0">if err := b.storer.SoftDelete(ctx, facilityID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("delete: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>

}

func (b *Business) HardDelete(ctx context.Context, facilityID uuid.UUID) error <span class="cov4" title="2">{

        if err := b.storer.HardDelete(ctx, facilityID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("delete: %w", err)
        }</span>
        <span class="cov4" title="2">return nil</span>

}
</pre>
		
		<pre class="file" id="file13" style="display: none">// Package facilitydb contains product related CRUD functionality.
package facilitydb

import (
        "bytes"
        "context"
        "errors"
        "fmt"

        "github.com/FITHSCS/backend/business/domain/facilitybus"
        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/business/sdk/sqldb"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/google/uuid"
        "github.com/jmoiron/sqlx"
)

// -----------------------------------------------------------------------------
// Store
// -----------------------------------------------------------------------------

type Store struct {
        log *logger.Logger
        db  sqlx.ExtContext
}
func NewStore(log *logger.Logger, db *sqlx.DB) *Store <span class="cov0" title="0">{
        return &amp;Store{
                log: log,
                db:  db,
        }
}</span>

func (s *Store) Create(ctx context.Context, f facilitybus.Facility) error <span class="cov0" title="0">{
        const stmt = `
    INSERT INTO facility (
      facility_id,
          facility_name,
          facility_type,
          address,
          region,
      latitude,
          longitude,
          geofence_radius,
      contact_person_id,
          contact_person_phone,
          is_deleted,
      created_at,
          updated_at
    ) VALUES (
      :facility_id, 
          :facility_name, 
          :facility_type, 
          :address, 
          :region,
      :latitude, 
          :longitude, 
          :geofence_radius,
      :contact_person_id, 
          :contact_person_phone,
      :is_deleted,
      :created_at, 
          :updated_at
    )`

        return sqldb.NamedExecContext(ctx, s.log, s.db, stmt, toDBFacility(f))
}</span>

func (s *Store) Update(ctx context.Context, f facilitybus.Facility) error <span class="cov0" title="0">{
        const stmt = `
    UPDATE 
                facility
        SET 
                facility_name           = :facility_name,
            facility_type           = :facility_type,
            address                 = :address,
                region                                 = :region, 
            latitude                = :latitude,
            longitude               = :longitude,
            geofence_radius         = :geofence_radius,
            contact_person_id          = :contact_person_id,
            contact_person_phone   = :contact_person_phone,
               updated_at              = :updated_at
    WHERE 
                facility_id = :facility_id`
        return sqldb.NamedExecContext(ctx, s.log, s.db, stmt, toDBFacility(f))
}</span>

func (s *Store) Query(ctx context.Context, filter facilitybus.QueryFilter, orderBy order.By, page page.Page) ([]facilitybus.Facility, error) <span class="cov0" title="0">{

        data := map[string]any{
                "offset":        (page.Number() - 1) * page.RowsPerPage(),
                "rows_per_page": page.RowsPerPage(),
        }

        const q = `
    SELECT
              facility_id,
                facility_name, 
                facility_type, 
                address,
                region, 
              latitude, 
                longitude, 
                geofence_radius,      
                contact_person_id, 
                contact_person_phone,  
                is_deleted,    
                created_at, 
                updated_at
    FROM 
                facility`

        buf := bytes.NewBufferString(q)
        s.applyFilter(filter, data, buf)

        orderByClause, err := orderByClause(orderBy)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">buf.WriteString(orderByClause)
        buf.WriteString(" OFFSET :offset ROWS FETCH NEXT :rows_per_page ROWS ONLY")

        var dbRecs []facilitydb
        if err := sqldb.NamedQuerySlice(ctx, s.log, s.db, buf.String(), data, &amp;dbRecs); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("namedqueryslice: %w", err)
        }</span>
        <span class="cov0" title="0">fmt.Println(dbRecs)
        return toBusFacilities(dbRecs)</span>
}

// Count returns the total number of users in the DB.
func (s *Store) Count(ctx context.Context, filter facilitybus.QueryFilter) (int, error) <span class="cov0" title="0">{
        data := map[string]any{}

        const q = `
        SELECT
                count(1)
        FROM
                facility`

        buf := bytes.NewBufferString(q)
        s.applyFilter(filter, data, buf)

        var count struct {
                Count int `db:"count"`
        }
        if err := sqldb.NamedQueryStruct(ctx, s.log, s.db, buf.String(), data, &amp;count); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("db: %w", err)
        }</span>

        <span class="cov0" title="0">return count.Count, nil</span>
}

func (s *Store) QueryByID(ctx context.Context, id uuid.UUID) (facilitybus.Facility, error) <span class="cov0" title="0">{
        param := map[string]any{
                "facility_id": id.String(),
        }
        const stmt = `
    SELECT
                facility_id,
                facility_name,
                facility_type,
                address,
                region,
                latitude, longitude,
                geofence_radius,
                contact_person_id,
                contact_person_phone,
                is_deleted,
                created_at, updated_at
          FROM 
                facility
          WHERE 
                facility_id = :facility_id`

        var rec facilitydb
        if err := sqldb.NamedQueryStruct(ctx, s.log, s.db, stmt, param, &amp;rec); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sqldb.ErrDBNotFound) </span><span class="cov0" title="0">{
                        return facilitybus.Facility{}, facilitybus.ErrNotFound
                }</span>
                <span class="cov0" title="0">return facilitybus.Facility{}, err</span>
        }
        <span class="cov0" title="0">return toBusFacility(rec)</span>
}

func (s *Store) SoftDelete(ctx context.Context, facilityID uuid.UUID) error <span class="cov0" title="0">{

        const q = `
    UPDATE
        facility
        SET
                is_deleted = :is_deleted
    WHERE
        facility_id = :facility_id`

        dbFacility := facilitydb{ID: facilityID, IsDeleted: true}

        if err := sqldb.NamedExecContext(ctx, s.log, s.db, q, dbFacility); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("namedexeccontext: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *Store) HardDelete(ctx context.Context, facilityID uuid.UUID) error <span class="cov0" title="0">{

        const q = `
    DELETE FROM
        facility
    WHERE
        facility_id = :facility_id`

        dbFacility := facilitydb{ID: facilityID}

        if err := sqldb.NamedExecContext(ctx, s.log, s.db, q, dbFacility); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("namedexeccontext: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package facilitydb

import (
        "bytes"
        "strings"

        "github.com/FITHSCS/backend/business/domain/facilitybus"
        "github.com/google/uuid"
)

func (s *Store) applyFilter(filter facilitybus.QueryFilter, data map[string]any, buf *bytes.Buffer) <span class="cov0" title="0">{

        var wc []string

        if filter.ID != uuid.Nil </span><span class="cov0" title="0">{
                data["facility_id"] = &amp;filter.ID
                wc = append(wc, "facility_id = :facility_id")
        }</span>

        <span class="cov0" title="0">if filter.FacilityName != nil </span><span class="cov0" title="0">{
                data["facility_name"] = *filter.FacilityName
                wc = append(wc, "facility_name LIKE :facility_name")
        }</span>
        <span class="cov0" title="0">if filter.FacilityType != nil </span><span class="cov0" title="0">{
                data["facility_type"] = *filter.FacilityType
                wc = append(wc, "facility_type = :facility_type")
        }</span>
        <span class="cov0" title="0">if filter.Address != nil </span><span class="cov0" title="0">{
                data["address"] = *filter.Address
                wc = append(wc, "address LIKE :address")
        }</span>

        <span class="cov0" title="0">if filter.Region != nil </span><span class="cov0" title="0">{
                data["region"] = *filter.Region
                wc = append(wc, "region LIKE :region")
        }</span>
        <span class="cov0" title="0">if filter.Latitude != nil </span><span class="cov0" title="0">{
                data["latitude"] = *filter.Latitude
                wc = append(wc, "latitude = :latitude")
        }</span>
        <span class="cov0" title="0">if filter.Longitude != nil </span><span class="cov0" title="0">{
                data["longitude"] = *filter.Longitude
                wc = append(wc, "longitude = :longitude")
        }</span>
        <span class="cov0" title="0">if filter.GeofenceRadius != nil </span><span class="cov0" title="0">{
                data["geofence_radius"] = *filter.GeofenceRadius
                wc = append(wc, "geofence_radius = :geofence_radius")
        }</span>

        <span class="cov0" title="0">if filter.ContactPerson != nil </span><span class="cov0" title="0">{
                data["contact_person"] = *filter.ContactPerson
                wc = append(wc, "contact_person = :contact_person")
        }</span>

        <span class="cov0" title="0">if filter.ContactPhone != nil </span><span class="cov0" title="0">{
                data["contact_phone"] = *filter.ContactPhone
                wc = append(wc, "contact_phone = :contact_phone")
        }</span>
        <span class="cov0" title="0">if filter.CreatedAt != nil </span><span class="cov0" title="0">{
                data["created_at"] = filter.CreatedAt.UTC()
                wc = append(wc, "created_at &gt;= :created_at")
        }</span>
        <span class="cov0" title="0">if filter.UpdatedAt != nil </span><span class="cov0" title="0">{
                data["updated_at"] = filter.UpdatedAt.UTC()
                wc = append(wc, "updated_at &lt;= :updated_at")
        }</span>
  
        <span class="cov0" title="0">if len(wc) &gt; 0 </span><span class="cov0" title="0">{
                buf.WriteString(" WHERE ")
                buf.WriteString(strings.Join(wc, " AND "))
        }</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package facilitydb

import (
        //"database/sql"
        "fmt"
        //"net/mail"
        "time"

        "github.com/FITHSCS/backend/business/domain/facilitybus"

        "github.com/FITHSCS/backend/business/types/facilitytype"
        "github.com/FITHSCS/backend/business/types/genstringtype"
        "github.com/google/uuid"
)

// &lt;============struct that is going to be passed to database schema =&gt; Final =======&gt;

type facilitydb struct {
        ID              uuid.UUID `db:"facility_id"`
        FacilityName    string    `db:"facility_name"`
        FacilityType    string    `db:"facility_type"`
        Address         string    `db:"address"`
        Region          string    `db:"region"`
        Latitude        float64   `db:"latitude"`
        Longitude       float64   `db:"longitude"`
        GeofenceRadius  float64   `db:"geofence_radius"`
        ContactPersonID uuid.UUID `db:"contact_person_id"`
        ContactPhone    string    `db:"contact_person_phone"`
        IsDeleted       bool      `db:"is_deleted"`
        CreatedAt       time.Time `db:"created_at"`
        UpdatedAt       time.Time `db:"updated_at"`
}

//&lt;==========================================================&gt;

// &lt;====================converting it to DB SCHEMA WHICH WILL BE USED =======================&gt;

func toDBFacility(bus facilitybus.Facility) facilitydb <span class="cov0" title="0">{

        return facilitydb{
                ID:              bus.ID,
                FacilityName:    bus.FacilityName.String(),
                FacilityType:    bus.FacilityType.String(),
                Address:         bus.Address.String(),
                Region:          bus.Region.String(),
                Latitude:        bus.Latitude.Float64(),
                Longitude:       bus.Longitude.Float64(),
                GeofenceRadius:  bus.GeofenceRadius.Float64(),
                ContactPersonID: bus.ContactPersonID,
                ContactPhone:    bus.ContactPhone.String(),
                IsDeleted:       bus.IsDeleted,
                CreatedAt:       bus.CreatedAt.UTC(),
                UpdatedAt:       bus.UpdatedAt.UTC(),
        }
}</span>

// =======================================================================
func toBusFacility(db facilitydb) (facilitybus.Facility, error) <span class="cov0" title="0">{

        facName, err := genstringtype.Parse(db.FacilityName)
        if err != nil </span><span class="cov0" title="0">{
                return facilitybus.Facility{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">facType, err := genstringtype.Parse(db.FacilityType)
        if err != nil </span><span class="cov0" title="0">{
                return facilitybus.Facility{}, fmt.Errorf("parse: %w", err)
        }</span>
        <span class="cov0" title="0">facAddress, err := facilitytype.ParseAddress(db.Address)
        if err != nil </span><span class="cov0" title="0">{
                return facilitybus.Facility{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">facRegion, err := genstringtype.Parse(db.Region)
        if err != nil </span><span class="cov0" title="0">{
                return facilitybus.Facility{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">facLongitude, err := facilitytype.ParseLong(db.Longitude)
        if err != nil </span><span class="cov0" title="0">{
                return facilitybus.Facility{}, fmt.Errorf("parse: %w", err)
        }</span>
        <span class="cov0" title="0">facLatitude, err := facilitytype.ParseLat(db.Latitude)
        if err != nil </span><span class="cov0" title="0">{
                return facilitybus.Facility{}, fmt.Errorf("parse: %w", err)
        }</span>
        <span class="cov0" title="0">facGeofence, err := facilitytype.ParseGeofence(db.GeofenceRadius)
        if err != nil </span><span class="cov0" title="0">{
                return facilitybus.Facility{}, fmt.Errorf("parse: %w", err)
        }</span>
        <span class="cov0" title="0">facContPhone, err := facilitytype.ParseCleanPhoneNumber(db.ContactPhone)
        if err != nil </span><span class="cov0" title="0">{
                return facilitybus.Facility{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">bus := facilitybus.Facility{
                ID:              db.ID,
                FacilityName:    facName,
                FacilityType:    facType,
                Address:         facAddress,
                Region:          facRegion,
                Latitude:        facLatitude,
                Longitude:       facLongitude,
                GeofenceRadius:  facGeofence,
                ContactPersonID: db.ContactPersonID,
                ContactPhone:    facContPhone,
                IsDeleted:       db.IsDeleted,
                CreatedAt:       db.CreatedAt.In(time.Local),
                UpdatedAt:       db.UpdatedAt.In(time.Local),
        }
        return bus, nil</span>

}

func toBusFacilities(dbs []facilitydb) ([]facilitybus.Facility, error) <span class="cov0" title="0">{
        bus := make([]facilitybus.Facility, len(dbs))
        for i, db := range dbs </span><span class="cov0" title="0">{
                var err error
                bus[i], err = toBusFacility(db)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">return bus, nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package facilitydb

import (
        "fmt"

        "github.com/FITHSCS/backend/business/domain/facilitybus"
        "github.com/FITHSCS/backend/business/sdk/order"
)

var orderByFields = map[string]string{
        facilitybus.OrderByID:        "facility_id",
        facilitybus.OrderByName:      "name",
        facilitybus.OrderByType:      "type",
        facilitybus.OrderByCreatedAt: "created_at",
        facilitybus.OrderByUpdatedAt: "updated_at",
}

// orderByClause converts an order.By value into the final
// " ORDER BY … ASC|DESC" fragment the store adds to its SELECT.
func orderByClause(ob order.By) (string, error) <span class="cov0" title="0">{
        col, ok := orderByFields[ob.Field]
        if !ok </span><span class="cov0" title="0">{
                return "", fmt.Errorf("field %q does not exist", ob.Field)
        }</span>
        <span class="cov0" title="0">return " ORDER BY " + col + " " + ob.Direction, nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package facilitybus

import (
        "context"
        "fmt"
        "math/rand"

        "github.com/FITHSCS/backend/business/types/facilitytype"
        "github.com/FITHSCS/backend/business/types/genstringtype"
        "github.com/google/uuid"
)

func TestGenerateNewFacilities(n int, userID uuid.UUID) []NewFacility <span class="cov5" title="2">{
        newfs := make([]NewFacility, n)
        facTypes := []string{"warehouse", "health_facility"}

        idx := rand.Intn(10000)
        for i := range n </span><span class="cov10" title="4">{
                idx++

                nf := NewFacility{
                        FacilityName:    genstringtype.MustParse(fmt.Sprintf("Name%d", idx)),
                        FacilityType:    genstringtype.MustParse(facTypes[i%2]),
                        Address:         facilitytype.MustParseAddress(fmt.Sprintf("FacName%d", idx)),
                        Region:          genstringtype.MustParse(fmt.Sprintf("Region:%d", idx)),
                        Latitude:        facilitytype.MustParseLat(9.019499778747559),
                        Longitude:       facilitytype.MustParseLong(38.739200592041016),
                        GeofenceRadius:  facilitytype.MustParseGeofence(10.0),
                        ContactPersonID: userID,
                        ContactPhone:    facilitytype.MustParsePhoneNumber(fmt.Sprintf("092233%04d", idx)),
                }

                newfs[i] = nf
        }</span>

        <span class="cov5" title="2">return newfs</span>
}

func TestGenerateSeedFacilities(ctx context.Context, n int, api *Business, usrID uuid.UUID) ([]Facility, error) <span class="cov5" title="2">{
        newfs := TestGenerateNewFacilities(n, usrID)

        facs := make([]Facility, len(newfs))
        for i, np := range newfs </span><span class="cov10" title="4">{
                prd, err := api.Create(ctx, np)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("seeding facilities: idx: %d : %w", i, err)
                }</span>

                <span class="cov10" title="4">facs[i] = prd</span>
        }

        <span class="cov5" title="2">return facs, nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">// Package gpstrackingbus provides business access to gps tracking bus domain.
package gpstrackingbus

import (
        "context"
        "errors"
        "fmt"
        "time"

        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/google/uuid"
)

// Set of error variables for CRUD operations.
var (
        ErrNotFound     = errors.New("track and trace not found")
        ErrUserDisabled = errors.New("user disabled")
)

// Storer interface declares the behavior this package needs to persist and
// retrieve data.
type Storer interface {
        Create(ctx context.Context, trackTrace TrackTrace) error
        Update(ctx context.Context, trackTrace TrackTrace) error
        QueryByID(ctx context.Context, trackTraceID uuid.UUID) (TrackTrace, error)
        SoftDelete(ctx context.Context, trackTraceID uuid.UUID) error
        HardDelete(ctx context.Context, trackTraceID uuid.UUID) error
        Query(ctx context.Context, filter QueryFilter, orderBy order.By, page page.Page) ([]TrackTrace, error)
        Count(ctx context.Context, filter QueryFilter) (int, error)
}

func (b *Business) GetStorer() Storer <span class="cov0" title="0">{
        return b.storer
}</span>

// Business manages the set of APIs for epickup access.
type Business struct {
        log    *logger.Logger
        storer Storer
}

// NewBusiness constructs a epickup business API for use.
func NewBusiness(log *logger.Logger, storer Storer) *Business <span class="cov1" title="1">{
        return &amp;Business{
                log:    log,
                storer: storer,
        }

}</span>

// Create adds a new tracktrace to the system.
func (b *Business) Create(ctx context.Context, ntt NewTrackTrace) (TrackTrace, error) <span class="cov10" title="5">{

        now := time.Now().Truncate(time.Millisecond)

        tracktrace := TrackTrace{
                TrackTraceID:        uuid.New(),
                RouteID:             ntt.RouteID,
                DeliveryPersonnelID: ntt.DeliveryPersonnelID,
                VehicleID:           ntt.VehicleID,
                Latitude:            ntt.Latitude,
                Longitude:           ntt.Longitude,
                Accuracy:            ntt.Accuracy,
                Speed:               ntt.Speed,
                BatteryLevel:        ntt.BatteryLevel,
                IsSynced:            ntt.IsSynced,
                TimeStamp:           ntt.TimeStamp,
                IsDeleted:           false,
                CreatedAt:           now,
                UpdatedAt:           now,
        }

        if err := b.storer.Create(ctx, tracktrace); err != nil </span><span class="cov0" title="0">{
                return TrackTrace{}, fmt.Errorf("create: %w", err)
        }</span>

        <span class="cov10" title="5">return tracktrace, nil</span>
}

func (b *Business) Update(ctx context.Context, utracktrace UpdateTrackTrace, trackTraceID uuid.UUID) (TrackTrace, error) <span class="cov1" title="1">{

        // Fetch the original pickup data
        origTrackTrace, err := b.storer.QueryByID(ctx, trackTraceID)
        if err != nil </span><span class="cov0" title="0">{
                return TrackTrace{}, fmt.Errorf("user.querybyid: %s: %w", trackTraceID, err)
        }</span>

        <span class="cov1" title="1">if utracktrace.RouteID != nil </span><span class="cov1" title="1">{
                origTrackTrace.RouteID = *utracktrace.RouteID
        }</span>

        <span class="cov1" title="1">if utracktrace.DeliveryPersonnelID != nil </span><span class="cov1" title="1">{
                origTrackTrace.DeliveryPersonnelID = *utracktrace.DeliveryPersonnelID
        }</span>

        <span class="cov1" title="1">if utracktrace.VehicleID != nil </span><span class="cov1" title="1">{
                origTrackTrace.VehicleID = *utracktrace.VehicleID
        }</span>

        <span class="cov1" title="1">if utracktrace.Latitude != nil </span><span class="cov1" title="1">{
                origTrackTrace.Latitude = *utracktrace.Latitude
        }</span>

        <span class="cov1" title="1">if utracktrace.Longitude != nil </span><span class="cov1" title="1">{
                origTrackTrace.Longitude = *utracktrace.Longitude
        }</span>

        // TODO: Decide what to do when the data has already been synced
        <span class="cov1" title="1">if utracktrace.IsSynced != nil </span><span class="cov1" title="1">{
                origTrackTrace.IsSynced = *utracktrace.IsSynced
        }</span>

        <span class="cov1" title="1">if utracktrace.TimeStamp != nil </span><span class="cov1" title="1">{
                origTrackTrace.TimeStamp = *utracktrace.TimeStamp
        }</span>

        <span class="cov1" title="1">origTrackTrace.UpdatedAt = time.Now().Truncate(time.Millisecond)

        if err := b.storer.Update(ctx, origTrackTrace); err != nil </span><span class="cov0" title="0">{
                return TrackTrace{}, fmt.Errorf("update: %w", err)
        }</span>

        <span class="cov1" title="1">return origTrackTrace, nil</span>
}

// QueryByID finds the epickup by the specified ID.
func (b *Business) QueryByID(ctx context.Context, trackTraceID uuid.UUID) (TrackTrace, error) <span class="cov1" title="1">{

        trackTrace, err := b.storer.QueryByID(ctx, trackTraceID)
        if err != nil </span><span class="cov0" title="0">{
                return TrackTrace{}, fmt.Errorf("query: trackTraceID[%s]: %w", trackTraceID, err)
        }</span>

        <span class="cov1" title="1">return trackTrace, nil</span>
}

// Query retrieves a list of existing products.
func (b *Business) Query(ctx context.Context, filter QueryFilter, orderBy order.By, page page.Page) ([]TrackTrace, error) <span class="cov1" title="1">{
        prds, err := b.storer.Query(ctx, filter, orderBy, page)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("query: %w", err)
        }</span>

        <span class="cov1" title="1">return prds, nil</span>
}

// Count returns the total number of pickups.
func (b *Business) Count(ctx context.Context, filter QueryFilter) (int, error) <span class="cov0" title="0">{
        return b.storer.Count(ctx, filter)
}</span>

func (b *Business) HardDelete(ctx context.Context, trackTraceID uuid.UUID) error <span class="cov4" title="2">{

        if err := b.storer.HardDelete(ctx, trackTraceID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("delete: %w", err)
        }</span>

        <span class="cov4" title="2">return nil</span>
}

func (b *Business) SoftDelete(ctx context.Context, trackTraceID uuid.UUID) error <span class="cov4" title="2">{

        if err := b.storer.SoftDelete(ctx, trackTraceID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("delete: %w", err)
        }</span>

        <span class="cov4" title="2">return nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package gpstrackingdb

import (
        "bytes"
        "strings"

        "github.com/FITHSCS/backend/business/domain/gpstrackingbus"
)

func (s *Store) applyFilter(filter gpstrackingbus.QueryFilter, data map[string]any, buf *bytes.Buffer) <span class="cov0" title="0">{
        var wc []string

        if filter.TrackTraceID != nil </span><span class="cov0" title="0">{
                data["tracking_id"] = *filter.TrackTraceID
                wc = append(wc, "tracking_id = :tracking_id")
        }</span>

        <span class="cov0" title="0">if filter.RouteID != nil </span><span class="cov0" title="0">{
                data["route_id"] = *filter.RouteID
                wc = append(wc, "route_id = :route_id")
        }</span>

        <span class="cov0" title="0">if filter.PackageDetailID != nil </span><span class="cov0" title="0">{
                data["package_detail_id"] = *filter.PackageDetailID
                wc = append(wc, "package_detail_id = :package_detail_id")
        }</span>

        <span class="cov0" title="0">if filter.VehicleID != nil </span><span class="cov0" title="0">{
                data["vehicle_id"] = *filter.VehicleID
                wc = append(wc, "vehicle_id = :vehicle_id")
        }</span>

        <span class="cov0" title="0">if len(wc) &gt; 0 </span><span class="cov0" title="0">{
                buf.WriteString(" WHERE ")
                buf.WriteString(strings.Join(wc, " AND "))
        }</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">// Package gpstrackingdb contains product related CRUD functionality.
package gpstrackingdb

import (
        "bytes"
        "context"
        "errors"
        "fmt"

        "github.com/FITHSCS/backend/business/domain/gpstrackingbus"
        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/business/sdk/sqldb"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/google/uuid"
        "github.com/jmoiron/sqlx"
)

// Store manages the set of APIs for product database access.
type Store struct {
        log *logger.Logger
        db  sqlx.ExtContext
}

// NewStore constructs the api for data access.
func NewStore(log *logger.Logger, db *sqlx.DB) *Store <span class="cov0" title="0">{
        return &amp;Store{
                log: log,
                db:  db,
        }
}</span>

// Create adds a Product to the sqldb. It returns the created Product with
// fields like ID and DateCreated populated.
func (s *Store) Create(ctx context.Context, trc gpstrackingbus.TrackTrace) error <span class="cov0" title="0">{

        const q = `
        INSERT INTO gps_tracking
                (
                        tracking_id,
                        route_id, 
                        delivery_personnel_id, 
                        vehicle_id, 
                        latitude, 
                        longitude, 
                        accuracy, 
                        speed, 
                        battery_level, 
                        time_stamp, 
                        is_deleted,
                        is_synced,
                        created_at,
                        updated_at
                )
        VALUES
                (
                        :tracking_id, 
                        :route_id, 
                        :delivery_personnel_id, 
                        :vehicle_id, 
                        :latitude, 
                        :longitude, 
                        :accuracy, 
                        :speed, 
                        :battery_level, 
                        :time_stamp,
                        :is_deleted,
                        :is_synced,
                        :created_at,
                        :updated_at
                )
        `

        if err := sqldb.NamedExecContext(ctx, s.log, s.db, q, toDBTrackTrace(trc)); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("namedexeccontext: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// QueryByID finds the epickup identified by a given ID.
func (s *Store) QueryByID(ctx context.Context, trackingID uuid.UUID) (gpstrackingbus.TrackTrace, error) <span class="cov0" title="0">{
        data := struct {
                ID string `db:"tracking_id"`
        }{
                ID: trackingID.String(),
        }

        const q = `
        SELECT
            tracking_id,
                route_id, 
                delivery_personnel_id, 
                vehicle_id, 
                latitude, 
                longitude, 
                accuracy, 
                speed, 
                battery_level, 
                time_stamp,
                is_deleted, 
                is_synced,
                created_at,
                updated_at
        FROM
                gps_tracking
        WHERE
                tracking_id = :tracking_id`

        var trackTraceDB TrackTraceDB
        if err := sqldb.NamedQueryStruct(ctx, s.log, s.db, q, data, &amp;trackTraceDB); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sqldb.ErrDBNotFound) </span><span class="cov0" title="0">{
                        return gpstrackingbus.TrackTrace{}, fmt.Errorf("db: %w", gpstrackingbus.ErrNotFound)
                }</span>
                <span class="cov0" title="0">return gpstrackingbus.TrackTrace{}, fmt.Errorf("db: %w", err)</span>
        }

        <span class="cov0" title="0">return toBusTrackTrace(trackTraceDB)</span>
}

func (s *Store) Update(ctx context.Context, tracktrace gpstrackingbus.TrackTrace) error <span class="cov0" title="0">{
        const q = `
        UPDATE gps_tracking
        SET
                tracking_id = :tracking_id,
                route_id = :route_id,
                delivery_personnel_id = :delivery_personnel_id,
                vehicle_id = :vehicle_id,
                latitude = :latitude,
                longitude = :longitude,
                accuracy = :accuracy,
                speed = :speed,
                battery_level = :battery_level,
                is_synced = :is_synced,
                is_deleted = :is_deleted,
                time_stamp = :time_stamp,
                created_at = :created_at,
                updated_at = :updated_at
        WHERE
                tracking_id = :tracking_id`

        if err := sqldb.NamedExecContext(ctx, s.log, s.db, q, toDBTrackTrace(tracktrace)); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("namedexeccontext: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *Store) HardDelete(ctx context.Context, tracktraceID uuid.UUID) error <span class="cov0" title="0">{

        const q = `
        DELETE FROM
                gps_tracking
        WHERE
                tracking_id = :tracking_id`

        data := TrackTraceDB{TrackTraceID: tracktraceID}

        if err := sqldb.NamedExecContext(ctx, s.log, s.db, q, data); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("namedexeccontext: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *Store) SoftDelete(ctx context.Context, tracktraceID uuid.UUID) error <span class="cov0" title="0">{

        const q = `
        UPDATE gps_tracking
        SET
                is_deleted = :is_deleted
        WHERE
                tracking_id = :tracking_id`

        data := TrackTraceDB{TrackTraceID: tracktraceID, IsDeleted: true}

        if err := sqldb.NamedExecContext(ctx, s.log, s.db, q, data); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("namedexeccontext: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Query gets all epickups from the database.
func (s *Store) Query(ctx context.Context, filter gpstrackingbus.QueryFilter, orderBy order.By, page page.Page) ([]gpstrackingbus.TrackTrace, error) <span class="cov0" title="0">{
        data := map[string]any{
                "offset":        (page.Number() - 1) * page.RowsPerPage(),
                "rows_per_page": page.RowsPerPage(),
        }

        const q = `
        SELECT
            tracking_id,
                route_id, 
                delivery_personnel_id, 
                vehicle_id, 
                latitude, 
                longitude, 
                accuracy, 
                speed, 
                battery_level,
                time_stamp, 
                is_deleted,
                is_synced,
                created_at,
                updated_at
        FROM
                gps_tracking`

        buf := bytes.NewBufferString(q)
        s.applyFilter(filter, data, buf)

        orderByClause, err := orderByClause(orderBy)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">buf.WriteString(orderByClause)
        buf.WriteString(" OFFSET :offset ROWS FETCH NEXT :rows_per_page ROWS ONLY")

        var dbPrds []TrackTraceDB
        if err := sqldb.NamedQuerySlice(ctx, s.log, s.db, buf.String(), data, &amp;dbPrds); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("namedqueryslice: %w", err)
        }</span>

        <span class="cov0" title="0">return toBusTrackTraces(dbPrds)</span>
}

// Count returns the total number of records in the DB.
func (s *Store) Count(ctx context.Context, filter gpstrackingbus.QueryFilter) (int, error) <span class="cov0" title="0">{
        data := map[string]any{}

        const q = `
        SELECT
                count(1)
        FROM
                gps_tracking`

        buf := bytes.NewBufferString(q)
        s.applyFilter(filter, data, buf)

        var count struct {
                Count int `db:"count"`
        }
        if err := sqldb.NamedQueryStruct(ctx, s.log, s.db, buf.String(), data, &amp;count); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("db: %w", err)
        }</span>

        <span class="cov0" title="0">return count.Count, nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package gpstrackingdb

import (
        "fmt"
        "time"

        "github.com/FITHSCS/backend/business/domain/gpstrackingbus"
        "github.com/FITHSCS/backend/business/types/facilitytype"
        "github.com/google/uuid"
)

type TrackTraceDB struct {
        TrackTraceID        uuid.UUID `db:"tracking_id"`
        RouteID             uuid.UUID `db:"route_id"`
        DeliveryPersonnelID uuid.UUID `db:"delivery_personnel_id"`
        VehicleID           uuid.UUID `db:"vehicle_id"`
        Latitude            float64   `db:"latitude"`
        Longitude           float64   `db:"longitude"`
        Accuracy            float64   `db:"accuracy"`
        Speed               float64   `db:"speed"`
        BatteryLevel        float64   `db:"battery_level"`
        IsSynced            bool      `db:"is_synced"`
        IsDeleted           bool      `db:"is_deleted"`
        TimeStamp           time.Time `db:"time_stamp"`
        CreatedAt           time.Time `db:"created_at"`
        UpdatedAt           time.Time `db:"updated_at"`
}

func toDBTrackTrace(bus gpstrackingbus.TrackTrace) TrackTraceDB <span class="cov0" title="0">{

        db := TrackTraceDB{
                TrackTraceID:        bus.TrackTraceID,
                RouteID:             bus.RouteID,
                DeliveryPersonnelID: bus.DeliveryPersonnelID,
                VehicleID:           bus.VehicleID,
                Latitude:            bus.Latitude.Float64(),
                Longitude:           bus.Longitude.Float64(),
                Accuracy:            bus.Accuracy,
                Speed:               bus.Speed,
                BatteryLevel:        bus.BatteryLevel,
                IsDeleted:           bus.IsDeleted,
                IsSynced:            bus.IsSynced,
                TimeStamp:           bus.TimeStamp.UTC(),
                CreatedAt:           bus.CreatedAt.UTC(),
                UpdatedAt:           bus.UpdatedAt.UTC(),
        }
        return db
}</span>

// toBusTrackTrace converts an TrackTraceDB (database object) back to an TrackTraceBus (business object).
func toBusTrackTrace(db TrackTraceDB) (gpstrackingbus.TrackTrace, error) <span class="cov0" title="0">{
        // Perform any necessary parsing or validation if complex types were used.
        // In this case, types map directly or only involve time zone conversion.

        lat, err := facilitytype.ParseLat(db.Latitude)
        if err != nil </span><span class="cov0" title="0">{
                return gpstrackingbus.TrackTrace{}, fmt.Errorf("parse: %v", err)
        }</span>

        <span class="cov0" title="0">long, err := facilitytype.ParseLong(db.Longitude)
        if err != nil </span><span class="cov0" title="0">{
                return gpstrackingbus.TrackTrace{}, fmt.Errorf("parse: %v", err)
        }</span>

        <span class="cov0" title="0">bus := gpstrackingbus.TrackTrace{
                TrackTraceID:        db.TrackTraceID,
                RouteID:             db.RouteID,
                DeliveryPersonnelID: db.DeliveryPersonnelID,
                VehicleID:           db.VehicleID,
                Latitude:            lat,
                Longitude:           long,
                Accuracy:            db.Accuracy,
                Speed:               db.Speed,
                BatteryLevel:        db.BatteryLevel,
                IsDeleted:           db.IsDeleted,
                IsSynced:            db.IsSynced,
                TimeStamp:           db.TimeStamp.In(time.Local),
                CreatedAt:           db.CreatedAt.In(time.Local),
                UpdatedAt:           db.UpdatedAt.In(time.Local),
        }

        return bus, nil</span>
}

// toBusEPickups converts a slice of ePickupDB objects to a slice of EPickup objects.
func toBusTrackTraces(dbs []TrackTraceDB) ([]gpstrackingbus.TrackTrace, error) <span class="cov0" title="0">{
        bus := make([]gpstrackingbus.TrackTrace, len(dbs))

        for i, db := range dbs </span><span class="cov0" title="0">{
                var err error
                bus[i], err = toBusTrackTrace(db)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">return bus, nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package gpstrackingdb

import (
        "fmt"

        "github.com/FITHSCS/backend/business/domain/gpstrackingbus"
        "github.com/FITHSCS/backend/business/sdk/order"
)

var orderByFields = map[string]string{
        gpstrackingbus.OrderByTrackAndTraceID:     "tracking_id",
        gpstrackingbus.OrderByDeliveryPersonnelID: "delivery_personnel_id",
        gpstrackingbus.OrderByRouteID:             "route_id",
        gpstrackingbus.OrderByCreatedAt:           "created_at",
        gpstrackingbus.OrderByBatteryLevel:        "battery_level",
}

func orderByClause(orderBy order.By) (string, error) <span class="cov0" title="0">{
        by, exists := orderByFields[orderBy.Field]
        if !exists </span><span class="cov0" title="0">{
                return "", fmt.Errorf("field %q does not exist", orderBy.Field)
        }</span>

        <span class="cov0" title="0">return " ORDER BY " + by + " " + orderBy.Direction, nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package gpstrackingbus

import (
        "context"
        "fmt"
        "math/rand"
        "time"

        "github.com/FITHSCS/backend/business/types/facilitytype"
        "github.com/google/uuid"
)

func TestGenerateNewGPSTracking(n int, rte, delperID, vehID uuid.UUID) []NewTrackTrace <span class="cov5" title="2">{
        newroute := make([]NewTrackTrace, n)

        tmesmp, _ := time.Parse(time.RFC3339, "2025-06-10T15:59:33+03:00")

        idx := rand.Intn(10000)
        for i := range n </span><span class="cov10" title="4">{
                idx++

                nf := NewTrackTrace{
                        RouteID:             rte,
                        DeliveryPersonnelID: delperID,
                        VehicleID:           vehID,
                        Latitude:            facilitytype.MustParseLat(9.01949999999),
                        Longitude:           facilitytype.MustParseLong(38.7399999999),
                        Accuracy:            10.21,
                        Speed:               32.2,
                        BatteryLevel:        67,
                        IsSynced:            true,
                        TimeStamp:           tmesmp,
                }

                newroute[i] = nf
        }</span>

        <span class="cov5" title="2">return newroute</span>
}

func TestGenerateSeedGPSTracking(ctx context.Context, n int, api *Business, rte, delperID, vehID uuid.UUID) ([]TrackTrace, error) <span class="cov5" title="2">{
        newfs := TestGenerateNewGPSTracking(n, rte, delperID, vehID)

        facs := make([]TrackTrace, len(newfs))
        for i, np := range newfs </span><span class="cov10" title="4">{
                prd, err := api.Create(ctx, np)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("seeding routes: idx: %d : %w", i, err)
                }</span>

                <span class="cov10" title="4">facs[i] = prd</span>
        }

        <span class="cov5" title="2">return facs, nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">// Package imagebus provides business access to image domain.
package imagebus

import (
        "context"
        "errors"
        "fmt"
        "time"

        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/google/uuid"
)

var (
        ErrNotFound       = errors.New("iamge not found")
        ErrAuthentication = errors.New("authentication failed")
)

type Storer interface {
        Create(ctx context.Context, image Image) error
        Update(ctx context.Context, image Image) error
        SoftDelete(ctx context.Context, imageID uuid.UUID) error
        HardDelete(ctx context.Context, imageID uuid.UUID) error
        Query(ctx context.Context, filter QueryFilter, orderby order.By, page page.Page) ([]Image, error)
        QueryByID(ctx context.Context, imageID uuid.UUID) (Image, error)
        Count(ctx context.Context, filter QueryFilter) (int, error)
}

type Business struct {
        log    *logger.Logger
        storer Storer
}

func NewBusiness(log *logger.Logger, storer Storer) *Business <span class="cov1" title="1">{

        return &amp;Business{
                log:    log,
                storer: storer,
        }
}</span>

func (b *Business) Create(ctx context.Context, ni NewImage) (Image, error) <span class="cov10" title="6">{

        now := time.Now().Truncate(time.Millisecond)

        image := Image{
                ImageID:     uuid.New(),
                ManifestID:  ni.ManifestID,
                CapturedBy:  ni.CapturedBy,
                ExceptionID: ni.ExceptionID,
                EventType:   ni.EventType,
                ImageType:   ni.ImageType,
                ImageURL:    ni.ImageURL,
                ImageHash:   ni.ImageHash,
                IsSynced:    ni.IsSynced,
                IsDeleted:   false,
                TimeStamp:   now,
                CreatedAt:   now,
                UpdatedAt:   now,
        }

        if err := b.storer.Create(ctx, image); err != nil </span><span class="cov0" title="0">{
                return Image{}, fmt.Errorf("Create: %w", err)
        }</span>
        <span class="cov10" title="6">return image, nil</span>
}

func (b *Business) Update(ctx context.Context, imgID uuid.UUID, updateimg UpdateImage) (Image, error) <span class="cov4" title="2">{

        imgOrgnl, err := b.storer.QueryByID(ctx, imgID)
        if err != nil </span><span class="cov0" title="0">{
                return Image{}, fmt.Errorf("querybyid: %w", err)
        }</span>

        <span class="cov4" title="2">if updateimg.ManifestID != nil </span><span class="cov4" title="2">{
                imgOrgnl.ManifestID = *updateimg.ManifestID
        }</span>

        <span class="cov4" title="2">if updateimg.CapturedBy != nil </span><span class="cov4" title="2">{
                imgOrgnl.CapturedBy = *updateimg.CapturedBy
        }</span>

        <span class="cov4" title="2">if updateimg.ExceptionID != nil </span><span class="cov4" title="2">{
                imgOrgnl.ExceptionID = *updateimg.ExceptionID
        }</span>

        <span class="cov4" title="2">if updateimg.EventType != nil </span><span class="cov4" title="2">{
                imgOrgnl.EventType = *updateimg.EventType
        }</span>

        <span class="cov4" title="2">if updateimg.ImageType != nil </span><span class="cov4" title="2">{
                imgOrgnl.ImageType = *updateimg.ImageType
        }</span>

        <span class="cov4" title="2">if updateimg.ImageURL != nil </span><span class="cov4" title="2">{
                imgOrgnl.ImageURL = updateimg.ImageURL
        }</span>

        <span class="cov4" title="2">if updateimg.ImageHash != nil </span><span class="cov4" title="2">{
                imgOrgnl.ImageHash = *updateimg.ImageHash
        }</span>

        <span class="cov4" title="2">if updateimg.IsSynced != nil </span><span class="cov4" title="2">{
                imgOrgnl.IsSynced = *updateimg.IsSynced
        }</span>

        <span class="cov4" title="2">imgOrgnl.UpdatedAt = time.Now().Truncate(time.Microsecond)

        if err := b.storer.Update(ctx, imgOrgnl); err != nil </span><span class="cov0" title="0">{
                return Image{}, fmt.Errorf("update: %w", err)
        }</span>

        <span class="cov4" title="2">return imgOrgnl, nil</span>
}

func (b *Business) Query(ctx context.Context, filter QueryFilter, orderBy order.By, page page.Page) ([]Image, error) <span class="cov1" title="1">{
        images, err := b.storer.Query(ctx, filter, orderBy, page)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Query: %w", err)
        }</span>
        <span class="cov1" title="1">return images, nil</span>
}
func (b *Business) Count(ctx context.Context, filter QueryFilter) (int, error) <span class="cov0" title="0">{
        return b.storer.Count(ctx, filter)
}</span>

func (b *Business) QueryByID(ctx context.Context, ImageID uuid.UUID) (Image, error) <span class="cov1" title="1">{

        pickupbatch, err := b.storer.QueryByID(ctx, ImageID)
        if err != nil </span><span class="cov0" title="0">{
                return Image{}, fmt.Errorf("query: ImageID[%s]: %w", ImageID, err)
        }</span>
        <span class="cov1" title="1">return pickupbatch, nil</span>
}

func (b *Business) SoftDelete(ctx context.Context, ImageID uuid.UUID) error <span class="cov4" title="2">{
        facility, err := b.storer.QueryByID(ctx, ImageID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("softdeletequery: imageID[%s]: %w", ImageID, err)
        }</span>
        <span class="cov4" title="2">if facility.IsDeleted </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: already deleted", ImageID)
        }</span>

        <span class="cov4" title="2">if err := b.storer.SoftDelete(ctx, ImageID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("delete: %w", err)
        }</span>

        <span class="cov4" title="2">return nil</span>
}

func (b *Business) HardDelete(ctx context.Context, ImageID uuid.UUID) error <span class="cov4" title="2">{

        if err := b.storer.HardDelete(ctx, ImageID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("delete: %w", err)
        }</span>
        <span class="cov4" title="2">return nil</span>

}
</pre>
		
		<pre class="file" id="file25" style="display: none">package imagedb

import (
        "bytes"
        "strings"

        "github.com/FITHSCS/backend/business/domain/imagebus"
)

func applyFilter(filter imagebus.QueryFilter, data map[string]any, buf *bytes.Buffer) <span class="cov0" title="0">{

        var wc []string

        if filter.ID != nil </span><span class="cov0" title="0">{
                data["image_id"] = &amp;filter.ID
                wc = append(wc, "image_id = :image_id")
        }</span>

        <span class="cov0" title="0">if filter.EventType != nil </span><span class="cov0" title="0">{
                data["event_type"] = &amp;filter.ID
                wc = append(wc, "event_type = :event_type")
        }</span>

        <span class="cov0" title="0">if len(wc) &gt; 0 </span><span class="cov0" title="0">{
                buf.WriteString(" WHERE ")
                buf.WriteString(strings.Join(wc, " AND "))
        }</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">// Package imagedb contains product related CRUD functionality.
package imagedb

import (
        "bytes"
        "context"
        "errors"
        "fmt"

        "github.com/FITHSCS/backend/business/domain/imagebus"
        "github.com/FITHSCS/backend/business/domain/pickupbatchbus"
        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/business/sdk/sqldb"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/google/uuid"
        "github.com/jmoiron/sqlx"
)

type Store struct {
        log *logger.Logger
        db  sqlx.ExtContext
}

func NewStore(log *logger.Logger, db *sqlx.DB) *Store <span class="cov0" title="0">{
        return &amp;Store{log: log, db: db}
}</span>

func (s *Store) Create(ctx context.Context, p imagebus.Image) error <span class="cov0" title="0">{
        const stmt = `
    INSERT INTO image (
            image_id, 
                manifest_id,
                captured_by,
                exception_id, 
            event_type,
                image_type,
                image_url,
                image_hash,
            is_synced, 
                is_deleted,
                time_stamp, 
            created_at,
                updated_at 
    ) 
        VALUES (
            :image_id, 
                :manifest_id, 
                :captured_by,
                :exception_id, 
            :event_type, 
                :image_type,
                :image_url,
                :image_hash,
            :is_synced, 
                :is_deleted,
                :time_stamp, 
            :created_at, 
                :updated_at
    )`
        returnedValue, err := toDBImage(p)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return sqldb.NamedExecContext(ctx, s.log, s.db, stmt, returnedValue)</span>
}

func (s *Store) Update(ctx context.Context, p imagebus.Image) error <span class="cov0" title="0">{
        const stmt = `
    UPDATE 
                image
    SET 
                manifest_id       = :manifest_id,
        captured_by       = :captured_by,
        exception_id      = :exception_id,
        event_type        = :event_type,
        image_type        = :image_type,
        image_url         = :image_url,
                image_hash                   = :image_hash,
        is_synced         = :is_synced,
        is_deleted        = :is_deleted,
        time_stamp        = :time_stamp,
        updated_at        = :updated_at
    WHERE 
                image_id          = :image_id`

        returnedValue, err := toDBImage(p)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return sqldb.NamedExecContext(ctx, s.log, s.db, stmt, returnedValue)</span>
}

func (s *Store) Query(ctx context.Context, filter imagebus.QueryFilter, orderBy order.By, page page.Page) ([]imagebus.Image, error) <span class="cov0" title="0">{

        data := map[string]any{
                "offset":        (page.Number() - 1) * page.RowsPerPage(),
                "rows_per_page": page.RowsPerPage(),
        }

        const q = `
    SELECT
            image_id, 
                manifest_id,
                captured_by,
                exception_id, 
            event_type,
                image_type,
                image_url,
                image_hash,
            is_synced, 
                is_deleted,
                time_stamp, 
            created_at,
                updated_at 
    FROM 
                image        `

        var buf bytes.Buffer
        buf.WriteString(q)
        applyFilter(filter, data, &amp;buf)

        clause, err := orderByClause(orderBy)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">buf.WriteString(clause)
        buf.WriteString(" OFFSET :offset ROWS FETCH NEXT :rows_per_page ROWS ONLY")

        var dbRecs []imagedb

        if err := sqldb.NamedQuerySlice(ctx, s.log, s.db, buf.String(), data, &amp;dbRecs); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("namedqueryslice: %w", err)
        }</span>

        <span class="cov0" title="0">return toBusImages(dbRecs)</span>
}

func (s *Store) Count(ctx context.Context, filter imagebus.QueryFilter) (int, error) <span class="cov0" title="0">{
        data := map[string]any{}
        const base = `SELECT count(1) FROM image`

        var buf bytes.Buffer
        buf.WriteString(base)
        applyFilter(filter, data, &amp;buf)

        var out struct {
                Count int `db:"count"`
        }
        if err := sqldb.NamedQueryStruct(ctx, s.log, s.db, buf.String(), data, &amp;out); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("db: %w", err)
        }</span>
        <span class="cov0" title="0">return out.Count, nil</span>
}

func (s *Store) QueryByID(ctx context.Context, imageID uuid.UUID) (imagebus.Image, error) <span class="cov0" title="0">{
        param := map[string]any{
                "image_id": imageID.String(),
        }
        const stmt = `
    SELECT
            image_id, 
                manifest_id,
                captured_by,
                exception_id, 
            event_type,
                image_type,
                image_url,
                image_hash,
            is_synced, 
                is_deleted,
                time_stamp, 
            created_at,
                updated_at 
        FROM 
                  image
        WHERE 
                  image_id = :image_id`

        var rec imagedb
        if err := sqldb.NamedQueryStruct(ctx, s.log, s.db, stmt, param, &amp;rec); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sqldb.ErrDBNotFound) </span><span class="cov0" title="0">{
                        return imagebus.Image{}, fmt.Errorf("db: %w", pickupbatchbus.ErrNotFound)
                }</span>
                <span class="cov0" title="0">return imagebus.Image{}, fmt.Errorf("db: %w", err)</span>
        }
        <span class="cov0" title="0">return toBusImage(rec)</span>
}

func (s *Store) SoftDelete(ctx context.Context, imageID uuid.UUID) error <span class="cov0" title="0">{

        const q = `
    UPDATE
        image
        SET
                is_deleted = :is_deleted
    WHERE
        image_id = :image_id`

        img := imagedb{ImageID: imageID, IsDeleted: true}

        if err := sqldb.NamedExecContext(ctx, s.log, s.db, q, img); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("namedexeccontext: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *Store) HardDelete(ctx context.Context, manifestID uuid.UUID) error <span class="cov0" title="0">{
        const q = `
    DELETE FROM
        image
    WHERE
        image_id = :image_id`

        img := imagedb{ImageID: manifestID}

        if err := sqldb.NamedExecContext(ctx, s.log, s.db, q, img); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("namedexeccontext: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package imagedb

import (
        "fmt"
        "net/url"
        "time"

        "github.com/FITHSCS/backend/business/domain/imagebus"
        "github.com/FITHSCS/backend/business/types/genstringtype"
        "github.com/google/uuid"
)

type imagedb struct {
        ImageID     uuid.UUID     `db:"image_id"`
        ManifestID  uuid.UUID     `db:"manifest_id"`
        CapturedBy  uuid.UUID     `db:"captured_by"`
        ExceptionID uuid.NullUUID `db:"exception_id"`
        EventType   string        `db:"event_type"`
        ImageType   string        `db:"image_type"`
        ImageURL    string        `db:"image_url"`
        ImageHash   string        `db:"image_hash"`
        IsSynced    bool          `db:"is_synced"`
        IsDeleted   bool          `db:"is_deleted"`
        TimeStamp   time.Time     `db:"time_stamp"`
        CreatedAt   time.Time     `db:"created_at"`
        UpdatedAt   time.Time     `db:"updated_at"`
}

func toDBImage(bus imagebus.Image) (imagedb, error) <span class="cov0" title="0">{

        img := imagedb{
                ImageID:     bus.ImageID,
                ManifestID:  bus.ManifestID,
                CapturedBy:  bus.CapturedBy,
                ExceptionID: bus.ExceptionID,
                EventType:   bus.EventType.String(),
                ImageType:   bus.ImageType.String(),
                ImageURL:    bus.ImageURL.String(),
                ImageHash:   bus.ImageHash.String(),
                IsSynced:    bus.IsSynced,
                IsDeleted:   bus.IsDeleted,
                TimeStamp:   bus.TimeStamp.UTC(),
                CreatedAt:   bus.CreatedAt.UTC(),
                UpdatedAt:   bus.UpdatedAt.UTC(),
        }

        return img, nil
}</span>

func toBusImage(db imagedb) (imagebus.Image, error) <span class="cov0" title="0">{

        entyp, err := genstringtype.Parse(db.EventType)
        if err != nil </span><span class="cov0" title="0">{
                return imagebus.Image{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">imgtyp, err := genstringtype.Parse(db.ImageType)
        if err != nil </span><span class="cov0" title="0">{
                return imagebus.Image{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">imgurl, err := url.Parse(db.ImageURL)
        if err != nil </span><span class="cov0" title="0">{
                return imagebus.Image{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">imghsh, err := genstringtype.Parse(db.ImageHash)
        if err != nil </span><span class="cov0" title="0">{
                return imagebus.Image{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">bus := imagebus.Image{
                ImageID:     db.ImageID,
                ManifestID:  db.ManifestID,
                CapturedBy:  db.CapturedBy,
                ExceptionID: db.ExceptionID,
                EventType:   entyp,
                ImageType:   imgtyp,
                ImageURL:    imgurl,
                ImageHash:   imghsh,
                IsSynced:    db.IsSynced,
                IsDeleted:   db.IsDeleted,
                TimeStamp:   db.TimeStamp.In(time.Local),
                CreatedAt:   db.CreatedAt.In(time.Local),
                UpdatedAt:   db.UpdatedAt.In(time.Local),
        }
        return bus, nil</span>

}

func toBusImages(dbs []imagedb) ([]imagebus.Image, error) <span class="cov0" title="0">{
        bus := make([]imagebus.Image, len(dbs))

        for i, db := range dbs </span><span class="cov0" title="0">{
                var err error
                bus[i], err = toBusImage(db)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">return bus, nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package imagedb

import (
        "fmt"

        "github.com/FITHSCS/backend/business/domain/imagebus"
        "github.com/FITHSCS/backend/business/sdk/order"
)

var orderByFields = map[string]string{
        imagebus.OrderByID:        "image_id",
        imagebus.OrderByEventType: "event_type",
        imagebus.OrderByImageType: "image_type",
        imagebus.OrderByIsSynced:  "is_synced",
        imagebus.OrderByTimeStamp: "time_stamp",
        imagebus.OrderByCreatedAt: "created_at",
        imagebus.OrderByUpdatedAt: "updated_at",
}

// orderByClause converts an order.By value into the final
// " ORDER BY … ASC|DESC" fragment the store adds to its SELECT.
func orderByClause(ob order.By) (string, error) <span class="cov0" title="0">{
        col, ok := orderByFields[ob.Field]
        if !ok </span><span class="cov0" title="0">{
                return "", fmt.Errorf("field %q does not exist", ob.Field)
        }</span>
        <span class="cov0" title="0">return " ORDER BY " + col + " " + ob.Direction, nil</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package imagebus

import (
        "context"
        "fmt"
        "math/rand"
        "net/url"
        "time"

        "github.com/FITHSCS/backend/business/types/genstringtype"
        "github.com/google/uuid"
)

func TestGenerateNewImage(n int, manID, capbyID uuid.UUID, delexID []uuid.NullUUID) []NewImage <span class="cov5" title="2">{
        newfs := make([]NewImage, n)
        eventype := []string{"pickup", "delivery_exception", "delivery"}
        imgType := []string{"model19", "model19_descripancy", "exception"}

        CapturedAt, _ := time.Parse(time.RFC3339, "2025-06-10T15:59:33+03:00")
        timestamp := CapturedAt.Add(time.Minute + 1)

        u, _ := url.Parse("example.com/imge/url")

        idx := rand.Intn(10000)
        for i := range n </span><span class="cov10" title="4">{
                idx++

                nf := NewImage{
                        ManifestID:  manID,
                        CapturedBy:  capbyID,
                        ExceptionID: delexID[i%2],
                        EventType:   genstringtype.MustParse(eventype[i%6]),
                        ImageType:   genstringtype.MustParse(imgType[i%6]),
                        ImageURL:    u,
                        ImageHash:   genstringtype.MustParse("imagehash3242342gegfqrefviopqruqv8903prv9w"),
                        IsSynced:    true,
                        TimeStamp:   timestamp,
                }

                newfs[i] = nf
        }</span>

        <span class="cov5" title="2">return newfs</span>
}

func TestGenerateSeedImage(ctx context.Context, n int, api *Business, manID, capbyID uuid.UUID, delexID []uuid.NullUUID) ([]Image, error) <span class="cov5" title="2">{
        newfs := TestGenerateNewImage(n, manID, capbyID, delexID)

        facs := make([]Image, len(newfs))
        for i, np := range newfs </span><span class="cov10" title="4">{
                prd, err := api.Create(ctx, np)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("seeding image: idx: %d : %w", i, err)
                }</span>

                <span class="cov10" title="4">facs[i] = prd</span>
        }

        <span class="cov5" title="2">return facs, nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">// Package manifestbus provides business access to packagedetail domain.
package manifestbus

import (
        "context"
        "errors"
        "fmt"
        "time"

        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/google/uuid"
)

var (
        ErrNotFound       = errors.New("pickupbatch not found")
        ErrAuthentication = errors.New("authentication failed")
)

type Storer interface {
        Create(ctx context.Context, manifest Manifest) error
        Update(ctx context.Context, manifest Manifest) error
        SoftDelete(ctx context.Context, manifestID uuid.UUID) error
        HardDelete(ctx context.Context, manifestID uuid.UUID) error
        Query(ctx context.Context, filter QueryFilter, orderby order.By, page page.Page) ([]Manifest, error)
        QueryByID(ctx context.Context, manifestID uuid.UUID) (Manifest, error)
        Count(ctx context.Context, filter QueryFilter) (int, error)
}

func (b *Business) GetStorer() Storer <span class="cov0" title="0">{
        return b.storer
}</span>

type Business struct {
        log    *logger.Logger
        storer Storer
}

func NewBusiness(log *logger.Logger, storer Storer) *Business <span class="cov1" title="1">{

        return &amp;Business{
                log:    log,
                storer: storer,
        }
}</span>

func (b *Business) Create(ctx context.Context, nm NewManifest) (Manifest, error) <span class="cov10" title="5">{

        now := time.Now().Truncate(time.Millisecond)

        manifest := Manifest{
                ID:                    uuid.New(),
                PickupBatchID:         nm.PickupBatchID,
                OriginFacilityID:      nm.OriginFacilityID,
                DestinationFacilityID: nm.DestinationFacilityID,
                OrderID:               nm.OrderID,
                DeliveryID:            nm.DeliveryID,
                Status:                nm.Status,
                ItemsSummary:          nm.ItemsSummary,
                PickupTime:            nm.PickupTime,
                DeliveryTime:          nm.DeliveryTime,
                IsDeleted:             false,
                IsSynced:              nm.IsSynced,
                TimeStamp:             now,
                CreatedAt:             now,
                UpdatedAt:             now,
        }

        if err := b.storer.Create(ctx, manifest); err != nil </span><span class="cov0" title="0">{
                return Manifest{}, fmt.Errorf("Create: %w", err)
        }</span>
        <span class="cov10" title="5">return manifest, nil</span>
}

func (b *Business) Update(ctx context.Context, pickupBatchID uuid.UUID, updatemanifest UpdateManifest) (Manifest, error) <span class="cov1" title="1">{

        mnfstOrgnl, err := b.storer.QueryByID(ctx, pickupBatchID)
        if err != nil </span><span class="cov0" title="0">{
                return Manifest{}, fmt.Errorf("querybyid: %w", err)
        }</span>

        <span class="cov1" title="1">if updatemanifest.PickupBatchID != nil </span><span class="cov1" title="1">{
                mnfstOrgnl.PickupBatchID = *updatemanifest.PickupBatchID
        }</span>

        <span class="cov1" title="1">if updatemanifest.OriginFacilityID != nil </span><span class="cov1" title="1">{
                mnfstOrgnl.OriginFacilityID = *updatemanifest.OriginFacilityID
        }</span>

        <span class="cov1" title="1">if updatemanifest.OrderID != nil </span><span class="cov1" title="1">{
                mnfstOrgnl.OrderID = *updatemanifest.OrderID
        }</span>

        <span class="cov1" title="1">if updatemanifest.DeliveryID != nil </span><span class="cov1" title="1">{
                mnfstOrgnl.DeliveryID = *updatemanifest.DeliveryID
        }</span>

        <span class="cov1" title="1">if updatemanifest.Status != nil </span><span class="cov1" title="1">{
                mnfstOrgnl.Status = *updatemanifest.Status
        }</span>

        <span class="cov1" title="1">if updatemanifest.ItemsSummary != nil </span><span class="cov1" title="1">{
                mnfstOrgnl.ItemsSummary = *updatemanifest.ItemsSummary
        }</span>

        <span class="cov1" title="1">if updatemanifest.PickupTime != nil </span><span class="cov1" title="1">{
                mnfstOrgnl.PickupTime = *updatemanifest.PickupTime
        }</span>

        <span class="cov1" title="1">if updatemanifest.DeliveryTime != nil </span><span class="cov1" title="1">{
                mnfstOrgnl.DeliveryTime = *updatemanifest.DeliveryTime
        }</span>

        <span class="cov1" title="1">if updatemanifest.TimeStamp != nil </span><span class="cov1" title="1">{
                mnfstOrgnl.TimeStamp = *updatemanifest.TimeStamp
        }</span>

        <span class="cov1" title="1">if updatemanifest.IsSynced != nil </span><span class="cov1" title="1">{
                mnfstOrgnl.IsSynced = *updatemanifest.IsSynced
        }</span>

        <span class="cov1" title="1">mnfstOrgnl.UpdatedAt = time.Now().Truncate(time.Microsecond)

        if err := b.storer.Update(ctx, mnfstOrgnl); err != nil </span><span class="cov0" title="0">{
                return Manifest{}, fmt.Errorf("update: %w", err)
        }</span>

        <span class="cov1" title="1">return mnfstOrgnl, nil</span>
}

func (b *Business) Query(ctx context.Context, filter QueryFilter, orderBy order.By, page page.Page) ([]Manifest, error) <span class="cov1" title="1">{
        manifests, err := b.storer.Query(ctx, filter, orderBy, page)

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Query: %w", err)
        }</span>
        <span class="cov1" title="1">return manifests, nil</span>
}
func (b *Business) Count(ctx context.Context, filter QueryFilter) (int, error) <span class="cov0" title="0">{
        return b.storer.Count(ctx, filter)
}</span>

func (b *Business) QueryByID(ctx context.Context, pickupBatchID uuid.UUID) (Manifest, error) <span class="cov1" title="1">{

        pickupbatch, err := b.storer.QueryByID(ctx, pickupBatchID)
        if err != nil </span><span class="cov0" title="0">{
                return Manifest{}, fmt.Errorf("query: pickupbatchID[%s]: %w", pickupBatchID, err)
        }</span>
        <span class="cov1" title="1">return pickupbatch, nil</span>
}

func (b *Business) SoftDelete(ctx context.Context, pickupBatchID uuid.UUID) error <span class="cov4" title="2">{
        facility, err := b.storer.QueryByID(ctx, pickupBatchID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("softdeletequery: manifestID[%s]: %w", pickupBatchID, err)
        }</span>
        <span class="cov4" title="2">if facility.IsDeleted </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: already deleted", pickupBatchID)
        }</span>

        <span class="cov4" title="2">if err := b.storer.SoftDelete(ctx, pickupBatchID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("delete: %w", err)
        }</span>

        <span class="cov4" title="2">return nil</span>
}

func (b *Business) HardDelete(ctx context.Context, pickupBatchID uuid.UUID) error <span class="cov4" title="2">{

        if err := b.storer.HardDelete(ctx, pickupBatchID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("delete: %w", err)
        }</span>
        <span class="cov4" title="2">return nil</span>

}
</pre>
		
		<pre class="file" id="file31" style="display: none">package manifestdb

import (
        "bytes"
        "strings"

        "github.com/FITHSCS/backend/business/domain/manifestbus"
)

func applyFilter(filter manifestbus.QueryFilter, data map[string]any, buf *bytes.Buffer) <span class="cov0" title="0">{

        var wc []string

        if filter.ManifestID != nil </span><span class="cov0" title="0">{
                data["manifest_id"] = &amp;filter.ManifestID
                wc = append(wc, "manifest_id = :manifest_id")
        }</span>

        <span class="cov0" title="0">if len(wc) &gt; 0 </span><span class="cov0" title="0">{
                buf.WriteString(" WHERE ")
                buf.WriteString(strings.Join(wc, " AND "))
        }</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">// Package manifestdb contains product related CRUD functionality.
package manifestdb

import (
        "bytes"
        "context"
        "errors"
        "fmt"

        "github.com/FITHSCS/backend/business/domain/manifestbus"
        "github.com/FITHSCS/backend/business/domain/pickupbatchbus"
        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/business/sdk/sqldb"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/google/uuid"
        "github.com/jmoiron/sqlx"
)

type Store struct {
        log *logger.Logger
        db  sqlx.ExtContext
}

func NewStore(log *logger.Logger, db *sqlx.DB) *Store <span class="cov0" title="0">{
        return &amp;Store{log: log, db: db}
}</span>

func (s *Store) Create(ctx context.Context, p manifestbus.Manifest) error <span class="cov0" title="0">{
        const stmt = `
    INSERT INTO manifest (
            manifest_id, 
                pickup_batch_id,
                origin_facility_id,
                destination_facility_id, 
            order_id,
                delivery_id,
                status,
                items_summary,
                pickup_time,
                delivery_time,
            is_synced, 
                is_deleted,
                time_stamp, 
            created_at,
                updated_at 
    ) 
        VALUES (
            :manifest_id, 
                :pickup_batch_id, 
                :origin_facility_id,
                :destination_facility_id, 
            :order_id, 
                :delivery_id,
                :status,
                :items_summary,
                :pickup_time,
                :delivery_time,
            :is_synced, 
                :is_deleted,
                :time_stamp, 
            :created_at, 
                :updated_at
    )`
        returnedValue, err := toDBManifest(p)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return sqldb.NamedExecContext(ctx, s.log, s.db, stmt, returnedValue)</span>
}

func (s *Store) Update(ctx context.Context, p manifestbus.Manifest) error <span class="cov0" title="0">{
        const stmt = `
    UPDATE 
                manifest
    SET 
                pickup_batch_id              = :pickup_batch_id,
        origin_facility_id           = :origin_facility_id,
        destination_facility_id      = :destination_facility_id,
        order_id                                 = :order_id,
        delivery_id                           = :delivery_id,
        status                                    = :status,
                items_summary                                   = :items_summary,
                pickup_time                                   = :pickup_time,
                delivery_time                                   = :delivery_time,
        is_synced                    = :is_synced,
        is_deleted                   = :is_deleted,
        time_stamp                   = :time_stamp,
        updated_at                   = :updated_at
    WHERE 
                manifest_id                             = :manifest_id`

        returnedValue, err := toDBManifest(p)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return sqldb.NamedExecContext(ctx, s.log, s.db, stmt, returnedValue)</span>
}

func (s *Store) Query(ctx context.Context,
        filter manifestbus.QueryFilter, orderBy order.By, page page.Page) ([]manifestbus.Manifest, error) <span class="cov0" title="0">{

        data := map[string]any{
                "offset":        (page.Number() - 1) * page.RowsPerPage(),
                "rows_per_page": page.RowsPerPage(),
        }

        const q = `
    SELECT
                manifest_id,
            pickup_batch_id,
                origin_facility_id,
                destination_facility_id, 
            order_id,
                delivery_id,
                status,
                items_summary,
                pickup_time,
                delivery_time,
            is_synced, 
                is_deleted,
                time_stamp, 
            created_at,
                updated_at 
    FROM 
                manifest        `

        var buf bytes.Buffer
        buf.WriteString(q)
        applyFilter(filter, data, &amp;buf)

        clause, err := orderByClause(orderBy)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">buf.WriteString(clause)
        buf.WriteString(" OFFSET :offset ROWS FETCH NEXT :rows_per_page ROWS ONLY")

        var dbRecs []manifestdb
        if err := sqldb.NamedQuerySlice(ctx, s.log, s.db, buf.String(), data, &amp;dbRecs); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("namedqueryslice: %w", err)
        }</span>
        <span class="cov0" title="0">fmt.Println(dbRecs)
        return toBusManifests(dbRecs)</span>
}

func (s *Store) Count(ctx context.Context, filter manifestbus.QueryFilter) (int, error) <span class="cov0" title="0">{
        data := map[string]any{}
        const base = `SELECT count(1) FROM manifest`

        var buf bytes.Buffer
        buf.WriteString(base)
        applyFilter(filter, data, &amp;buf)

        var out struct {
                Count int `db:"count"`
        }
        if err := sqldb.NamedQueryStruct(ctx, s.log, s.db, buf.String(), data, &amp;out); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("db: %w", err)
        }</span>
        <span class="cov0" title="0">return out.Count, nil</span>
}

func (s *Store) QueryByID(ctx context.Context, manifestID uuid.UUID) (manifestbus.Manifest, error) <span class="cov0" title="0">{
        param := map[string]any{
                "manifest_id": manifestID.String(),
        }
        const stmt = `
    SELECT
            manifest_id,
            pickup_batch_id,
                origin_facility_id,
                destination_facility_id, 
            order_id,
                delivery_id,
                status,
                items_summary,
                pickup_time,
                delivery_time,
            is_synced, 
                is_deleted,
                time_stamp, 
            created_at,
                updated_at 
        FROM 
                  manifest
        WHERE 
                  manifest_id = :manifest_id`

        var rec manifestdb
        if err := sqldb.NamedQueryStruct(ctx, s.log, s.db, stmt, param, &amp;rec); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sqldb.ErrDBNotFound) </span><span class="cov0" title="0">{
                        return manifestbus.Manifest{}, fmt.Errorf("db: %w", pickupbatchbus.ErrNotFound)
                }</span>
                <span class="cov0" title="0">return manifestbus.Manifest{}, fmt.Errorf("db: %w", err)</span>
        }
        <span class="cov0" title="0">return toBusManifest(rec)</span>
}

func (s *Store) SoftDelete(ctx context.Context, manifestID uuid.UUID) error <span class="cov0" title="0">{

        const q = `
    UPDATE
        manifest
        SET
                is_deleted = :is_deleted
    WHERE
        manifest_id = :manifest_id`

        manifest := manifestdb{ID: manifestID, IsDeleted: true}

        if err := sqldb.NamedExecContext(ctx, s.log, s.db, q, manifest); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("namedexeccontext: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *Store) HardDelete(ctx context.Context, manifestID uuid.UUID) error <span class="cov0" title="0">{
        const q = `
    DELETE FROM
        manifest
    WHERE
        manifest_id = :manifest_id`

        manifest := manifestdb{ID: manifestID}

        if err := sqldb.NamedExecContext(ctx, s.log, s.db, q, manifest); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("namedexeccontext: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package manifestdb

import (
        "encoding/json"
        "fmt"
        "time"

        "github.com/FITHSCS/backend/business/domain/manifestbus"
        "github.com/FITHSCS/backend/business/types/genstringtype"
        "github.com/google/uuid"
        "github.com/jmoiron/sqlx/types"
)

type manifestdb struct {
        ID                    uuid.UUID          `db:"manifest_id"`
        PickupBatchID         uuid.UUID          `db:"pickup_batch_id"`
        OriginFacilityID      uuid.UUID          `db:"origin_facility_id"`
        DestinationFacilityID uuid.UUID          `db:"destination_facility_id"`
        OrderID               string             `db:"order_id"`
        DeliveryID            string             `db:"delivery_id"`
        Status                string             `db:"status"`
        ItemsSummary          types.NullJSONText `db:"items_summary"`
        PickupTime            time.Time          `db:"pickup_time"`
        DeliveryTime          time.Time          `db:"delivery_time"`
        IsSynced              bool               `db:"is_synced"`
        IsDeleted             bool               `db:"is_deleted"`
        TimeStamp             time.Time          `db:"time_stamp"`
        CreatedAt             time.Time          `db:"created_at"`
        UpdatedAt             time.Time          `db:"updated_at"`
}

func toDBManifest(bus manifestbus.Manifest) (manifestdb, error) <span class="cov0" title="0">{

        pkpBatch := manifestdb{
                ID:                    bus.ID,
                PickupBatchID:         bus.PickupBatchID,
                OriginFacilityID:      bus.OriginFacilityID,
                DestinationFacilityID: bus.DestinationFacilityID,
                OrderID:               bus.OrderID.String(),
                DeliveryID:            bus.DeliveryID.String(),
                Status:                bus.Status.String(),
                ItemsSummary:          types.NullJSONText{JSONText: []byte(bus.ItemsSummary), Valid: true},
                PickupTime:            bus.PickupTime.UTC(),
                DeliveryTime:          bus.DeliveryTime.UTC(),
                IsSynced:              bus.IsSynced,
                IsDeleted:             bus.IsDeleted,
                TimeStamp:             bus.TimeStamp.UTC(),
                CreatedAt:             bus.CreatedAt.UTC(),
                UpdatedAt:             bus.UpdatedAt.UTC(),
        }

        return pkpBatch, nil
}</span>

func toBusManifest(db manifestdb) (manifestbus.Manifest, error) <span class="cov0" title="0">{

        OrdrID, err := genstringtype.Parse(db.OrderID)
        if err != nil </span><span class="cov0" title="0">{
                return manifestbus.Manifest{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">dlvryID, err := genstringtype.Parse(db.DeliveryID)
        if err != nil </span><span class="cov0" title="0">{
                return manifestbus.Manifest{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">sts, err := genstringtype.Parse(db.Status)
        if err != nil </span><span class="cov0" title="0">{
                return manifestbus.Manifest{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">bus := manifestbus.Manifest{
                ID:                    db.ID,
                PickupBatchID:         db.PickupBatchID,
                OriginFacilityID:      db.OriginFacilityID,
                DestinationFacilityID: db.DestinationFacilityID,
                OrderID:               OrdrID,
                DeliveryID:            dlvryID,
                Status:                sts,
                ItemsSummary:          json.RawMessage(db.ItemsSummary.JSONText),
                PickupTime:            db.PickupTime.In(time.Local),
                DeliveryTime:          db.DeliveryTime.In(time.Local),
                IsDeleted:             db.IsDeleted,
                IsSynced:              db.IsSynced,
                TimeStamp:             db.TimeStamp.In(time.Local),
                CreatedAt:             db.CreatedAt.In(time.Local),
                UpdatedAt:             db.UpdatedAt.In(time.Local),
        }
        return bus, nil</span>

}

func toBusManifests(dbs []manifestdb) ([]manifestbus.Manifest, error) <span class="cov0" title="0">{
        bus := make([]manifestbus.Manifest, len(dbs))

        for i, db := range dbs </span><span class="cov0" title="0">{
                var err error
                bus[i], err = toBusManifest(db)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">return bus, nil</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package manifestdb

import (
        "fmt"

        "github.com/FITHSCS/backend/business/domain/manifestbus"
        "github.com/FITHSCS/backend/business/sdk/order"
)

var orderByFields = map[string]string{
        manifestbus.OrderByID:             "manifest_id",
        manifestbus.OrderByRouteID:        "route_id",
        manifestbus.OrderByOriginFacility: "origin_facility_id",
        manifestbus.OrderByIsSynced:       "is_synced",
        manifestbus.OrderByTimeStamp:      "time_stamp",
        manifestbus.OrderByCreatedAt:      "created_at",
        manifestbus.OrderByUpdatedAt:      "updated_at",
}

// orderByClause converts an order.By value into the final
// " ORDER BY … ASC|DESC" fragment the store adds to its SELECT.
func orderByClause(ob order.By) (string, error) <span class="cov0" title="0">{
        col, ok := orderByFields[ob.Field]
        if !ok </span><span class="cov0" title="0">{
                return "", fmt.Errorf("field %q does not exist", ob.Field)
        }</span>
        <span class="cov0" title="0">return " ORDER BY " + col + " " + ob.Direction, nil</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package manifestbus

import (
        "context"
        "encoding/json"
        "fmt"
        "math/rand"
        "time"

        "github.com/FITHSCS/backend/business/types/genstringtype"
        "github.com/google/uuid"
)

func TestGenerateNewManifest(n int, pickupBatchID, origFacID, destFacID uuid.UUID) []NewManifest <span class="cov5" title="2">{
        newfs := make([]NewManifest, n)
        sts := []string{"pending", "picked_up", "in_transit", "delivered", "exception"}

        pickupTime, _ := time.Parse(time.RFC3339, "2025-06-10T15:59:33+03:00")
        delTime := pickupTime.Add(time.Hour * 10)
        timestamp := pickupTime.Add(time.Minute + 1)

        idx := rand.Intn(10000)
        for i := range n </span><span class="cov10" title="4">{
                idx++

                jsonString := fmt.Sprintf(`{
                            "total_items": %d,
                            "total_weight_kg": %.2f,
                            "items": 
                                        {
                                        "Code": %d,
                                        "Type": %d
                                        },
                            "contains_fragile": %t
                }`, (i+1)*5, rand.Float64()*20, (i+1)*2, (i+1)*3, i%2 == 0)

                itemsSummaryJSON := json.RawMessage(jsonString)

                nf := NewManifest{
                        PickupBatchID:         pickupBatchID,
                        OriginFacilityID:      origFacID,
                        DestinationFacilityID: destFacID,
                        OrderID:               genstringtype.MustParse(fmt.Sprintf("OrderID:%d", idx)),
                        DeliveryID:            genstringtype.MustParse(fmt.Sprintf("DeliveryID:%d", idx)),
                        Status:                genstringtype.MustParse(sts[i%5]),
                        ItemsSummary:          itemsSummaryJSON,
                        PickupTime:            pickupTime,
                        DeliveryTime:          delTime,
                        IsSynced:              false,
                        TimeStamp:             timestamp,
                }

                newfs[i] = nf
        }</span>

        <span class="cov5" title="2">return newfs</span>
}

func TestGenerateSeedManifest(ctx context.Context, n int, api *Business, pickupBatchID, origFacID, destFacID uuid.UUID) ([]Manifest, error) <span class="cov5" title="2">{
        newfs := TestGenerateNewManifest(n, pickupBatchID, origFacID, destFacID)

        facs := make([]Manifest, len(newfs))
        for i, np := range newfs </span><span class="cov10" title="4">{
                prd, err := api.Create(ctx, np)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("seeding pickupbatch: idx: %d : %w", i, err)
                }</span>

                <span class="cov10" title="4">facs[i] = prd</span>
        }

        <span class="cov5" title="2">return facs, nil</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">// Package pickupbatchbus provides business access to packagedetail domain.
package pickupbatchbus

import (
        "context"
        "errors"
        "fmt"

        "time"

        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/google/uuid"
)

var (
        ErrNotFound       = errors.New("pickupbatch not found")
        ErrAuthentication = errors.New("authentication failed")
)

type Storer interface {
        Create(ctx context.Context, pickupbatch PickupBatch) error
        Update(ctx context.Context, pickupbatch PickupBatch) error
        SoftDelete(ctx context.Context, pickupBatchID uuid.UUID) error
        HardDelete(ctx context.Context, pickupBatchID uuid.UUID) error
        Query(ctx context.Context, filter QueryFilter, orderby order.By, page page.Page) ([]PickupBatch, error)
        QueryByID(ctx context.Context, pickupBatchID uuid.UUID) (PickupBatch, error)
        Count(ctx context.Context, filter QueryFilter) (int, error)
}

func (b *Business) GetStorer() Storer <span class="cov0" title="0">{
        return b.storer
}</span>

type Business struct {
        log    *logger.Logger
        storer Storer
}

func NewBusiness(log *logger.Logger, storer Storer) *Business <span class="cov1" title="1">{

        return &amp;Business{
                log:    log,
                storer: storer,
        }
}</span>

func (b *Business) Create(ctx context.Context, pb NewPickupBatch) (PickupBatch, error) <span class="cov10" title="5">{

        now := time.Now()

        pickupbatch := PickupBatch{
                ID:                  uuid.New(),
                RouteID:             pb.RouteID,
                OriginFacilityID:    pb.OriginFacilityID,
                VehicleID:           pb.VehicleID,
                DeliveryPersonnelID: pb.DeliveryPersonnelID,
                BatchName:           pb.BatchName,
                BatchStatus:         pb.BatchStatus,
                PickedStartedAt:     pb.PickedStartedAt,
                PickupCompletedAt:   pb.PickupCompletedAt,
                TimeStamp:           now,
                IsDeleted:           false,
                IsSynced:            pb.IsSynced,
                CreatedAt:           now,
                UpdatedAt:           now,
        }

        if err := b.storer.Create(ctx, pickupbatch); err != nil </span><span class="cov0" title="0">{
                return PickupBatch{}, fmt.Errorf("Create: %w", err)
        }</span>

        <span class="cov10" title="5">return pickupbatch, nil</span>
}

func (b *Business) Update(ctx context.Context, pickupBatchID uuid.UUID, updatePickupbatch UpdatePickupBatch) (PickupBatch, error) <span class="cov1" title="1">{

        pkupBtchOrgnl, err := b.storer.QueryByID(ctx, pickupBatchID)
        if err != nil </span><span class="cov0" title="0">{
                return PickupBatch{}, fmt.Errorf("querybyid: %w", err)
        }</span>

        <span class="cov1" title="1">if updatePickupbatch.RouteID != nil </span><span class="cov1" title="1">{
                pkupBtchOrgnl.RouteID = *updatePickupbatch.RouteID
        }</span>

        <span class="cov1" title="1">if updatePickupbatch.OriginFacilityID != nil </span><span class="cov1" title="1">{
                pkupBtchOrgnl.OriginFacilityID = *updatePickupbatch.OriginFacilityID
        }</span>

        <span class="cov1" title="1">if updatePickupbatch.VehicleID != nil </span><span class="cov1" title="1">{
                pkupBtchOrgnl.VehicleID = *updatePickupbatch.VehicleID
        }</span>

        <span class="cov1" title="1">if updatePickupbatch.DeliveryPersonnelID != nil </span><span class="cov1" title="1">{
                pkupBtchOrgnl.DeliveryPersonnelID = *updatePickupbatch.DeliveryPersonnelID
        }</span>

        <span class="cov1" title="1">if updatePickupbatch.BatchStatus != nil </span><span class="cov1" title="1">{
                pkupBtchOrgnl.BatchStatus = *updatePickupbatch.BatchStatus
        }</span>

        <span class="cov1" title="1">if updatePickupbatch.BatchName != nil </span><span class="cov1" title="1">{
                pkupBtchOrgnl.BatchName = *updatePickupbatch.BatchName
        }</span>

        <span class="cov1" title="1">if updatePickupbatch.PickedStartedAt != nil </span><span class="cov1" title="1">{
                pkupBtchOrgnl.PickedStartedAt = *updatePickupbatch.PickedStartedAt
        }</span>

        <span class="cov1" title="1">if updatePickupbatch.PickupCompletedAt != nil </span><span class="cov1" title="1">{
                pkupBtchOrgnl.PickupCompletedAt = *updatePickupbatch.PickupCompletedAt
        }</span>

        <span class="cov1" title="1">if updatePickupbatch.TimeStamp != nil </span><span class="cov1" title="1">{
                pkupBtchOrgnl.TimeStamp = *updatePickupbatch.TimeStamp
        }</span>

        <span class="cov1" title="1">pkupBtchOrgnl.UpdatedAt = time.Now().Truncate(time.Microsecond)

        if err := b.storer.Update(ctx, pkupBtchOrgnl); err != nil </span><span class="cov0" title="0">{
                return PickupBatch{}, fmt.Errorf("update: %w", err)
        }</span>
        <span class="cov1" title="1">return pkupBtchOrgnl, nil</span>
}

func (b *Business) QueryByID(ctx context.Context, pickupBatchID uuid.UUID) (PickupBatch, error) <span class="cov1" title="1">{

        pickupbatch, err := b.storer.QueryByID(ctx, pickupBatchID)
        if err != nil </span><span class="cov0" title="0">{
                return PickupBatch{}, fmt.Errorf("query: pickupbatchID[%s]: %w", pickupBatchID, err)
        }</span>
        <span class="cov1" title="1">return pickupbatch, nil</span>
}

func (b *Business) Query(ctx context.Context, filter QueryFilter, orderBy order.By, page page.Page) ([]PickupBatch, error) <span class="cov1" title="1">{

        pickupbatches, err := b.storer.Query(ctx, filter, orderBy, page)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Query: %w", err)
        }</span>
        <span class="cov1" title="1">return pickupbatches, nil</span>
}

func (b *Business) Count(ctx context.Context, filter QueryFilter) (int, error) <span class="cov0" title="0">{

        return b.storer.Count(ctx, filter)
}</span>

func (b *Business) SoftDelete(ctx context.Context, pickupBatchID uuid.UUID) error <span class="cov4" title="2">{

        facility, err := b.storer.QueryByID(ctx, pickupBatchID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("softdeletequery: pickupBatch[%s]: %w", pickupBatchID, err)
        }</span>

        <span class="cov4" title="2">if facility.IsDeleted </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: already deleted", pickupBatchID)
        }</span>

        <span class="cov4" title="2">if err := b.storer.SoftDelete(ctx, pickupBatchID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("delete: %w", err)
        }</span>
        <span class="cov4" title="2">return nil</span>

}

func (b *Business) HardDelete(ctx context.Context, pickupBatchID uuid.UUID) error <span class="cov4" title="2">{

        if err := b.storer.HardDelete(ctx, pickupBatchID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("delete: %w", err)
        }</span>
        <span class="cov4" title="2">return nil</span>

}
</pre>
		
		<pre class="file" id="file37" style="display: none">package pickupbatchdb

import (
        "bytes"
        //"fmt"
        "strings"

        "github.com/FITHSCS/backend/business/domain/pickupbatchbus"
        "github.com/google/uuid"
)

func applyFilter(filter pickupbatchbus.QueryFilter, data map[string]any, buf *bytes.Buffer) <span class="cov0" title="0">{

        var wc []string

        if filter.ID != uuid.Nil </span><span class="cov0" title="0">{
                data["pickup_batch_id"] = &amp;filter.ID
                wc = append(wc, "pickupb_batch_id = :pickupb_batch_id")
        }</span>
        <span class="cov0" title="0">if filter.RouteID != nil </span><span class="cov0" title="0">{
                data["route_id"] = *filter.RouteID
                wc = append(wc, "route_id = :route_id")
        }</span>

        <span class="cov0" title="0">if filter.VehicleID != nil </span><span class="cov0" title="0">{
                data["vehicle_id"] = *filter.VehicleID
                wc = append(wc, "vehicle_id = :vehicle_id")
        }</span>
        <span class="cov0" title="0">if filter.OriginFacility != nil </span><span class="cov0" title="0">{
                data["origin_facility_id"] = *filter.OriginFacility
                wc = append(wc, "origin_facility_id = :origin_facility_id")
        }</span>
        <span class="cov0" title="0">if filter.DeliveryPersonnelID != nil </span><span class="cov0" title="0">{
                data["delivery_personnel_id"] = *filter.DeliveryPersonnelID
                wc = append(wc, "deliver_personnel_id = :delivery_personnel_id")
        }</span>

        <span class="cov0" title="0">if filter.DeliveryPersonnelSignature != nil </span><span class="cov0" title="0">{
                data["delivery_personnel_signature"] = *filter.DeliveryPersonnelSignature
                wc = append(wc, "deliver_personnel_signature = :delivery_personnel_signature")
        }</span>
        <span class="cov0" title="0">if filter.IsSynced != nil </span><span class="cov0" title="0">{
                data["is_synced"] = *filter.IsSynced
                wc = append(wc, "is_synced = :is_synced")
        }</span>

        <span class="cov0" title="0">if filter.IsSynced != nil </span><span class="cov0" title="0">{
                data["is_synced"] = *filter.IsSynced
                wc = append(wc, "is_synced = :is_synced")
        }</span>
        <span class="cov0" title="0">if filter.TimeStamp != nil </span><span class="cov0" title="0">{
                data["time_stamp"] = *filter.TimeStamp
                wc = append(wc, "time_stamp = :time_stamp")
        }</span>

        <span class="cov0" title="0">if filter.CreatedAt != nil </span><span class="cov0" title="0">{
                data["created_at"] = filter.CreatedAt.UTC()
                wc = append(wc, "date_created &gt;= :created_at")
        }</span>
        <span class="cov0" title="0">if filter.UpdatedAt != nil </span><span class="cov0" title="0">{
                data["updated_at"] = filter.UpdatedAt.UTC()
                wc = append(wc, "updated_at &lt;= :updated_at")
        }</span>

        <span class="cov0" title="0">if len(wc) &gt; 0 </span><span class="cov0" title="0">{
                buf.WriteString(" WHERE ")
                buf.WriteString(strings.Join(wc, " AND "))
        }</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package pickupbatchdb

import (
        "fmt"
        "time"

        "github.com/FITHSCS/backend/business/domain/pickupbatchbus"
        "github.com/FITHSCS/backend/business/types/genstringtype"

        "github.com/google/uuid"
)

type pickupbatch struct {
        ID                  uuid.UUID `db:"pickup_batch_id"`
        RouteID             uuid.UUID `db:"route_id"`
        OriginFacilityID    uuid.UUID `db:"origin_facility_id"`
        VehicleID           uuid.UUID `db:"vehicle_id"`
        DeliveryPersonnelID uuid.UUID `db:"delivery_personnel_id"`
        BatchName           string    `db:"batch_name"`
        BatchStatus         string    `db:"batch_status"`
        PickupStartedAt     time.Time `db:"pickup_started_at"`
        PickupCompletedAt   time.Time `db:"pickup_completed_at"`
        IsSynced            bool      `db:"is_synced"`
        IsDeleted           bool      `db:"is_deleted"`
        TimeStamp           time.Time `db:"time_stamp"`
        CreatedAt           time.Time `db:"created_at"`
        UpdatedAt           time.Time `db:"updated_at"`
}

//=============================================================================&gt;

func toDBPickupBatch(bus pickupbatchbus.PickupBatch) (pickupbatch, error) <span class="cov0" title="0">{

        pkpBatch := pickupbatch{
                ID:                  bus.ID,
                RouteID:             bus.RouteID,
                VehicleID:           bus.VehicleID,
                OriginFacilityID:    bus.OriginFacilityID,
                DeliveryPersonnelID: bus.DeliveryPersonnelID,
                BatchName:           bus.BatchName.String(),
                BatchStatus:         bus.BatchStatus.String(),
                PickupStartedAt:     bus.PickedStartedAt.UTC(),
                PickupCompletedAt:   bus.PickupCompletedAt.UTC(),
                IsSynced:            bus.IsSynced,
                IsDeleted:           bus.IsDeleted,
                TimeStamp:           bus.TimeStamp.UTC(),
                CreatedAt:           bus.CreatedAt.UTC(),
                UpdatedAt:           bus.UpdatedAt.UTC(),
        }

        return pkpBatch, nil
}</span>

func toBusPickupBatch(db pickupbatch) (pickupbatchbus.PickupBatch, error) <span class="cov0" title="0">{
        batchSts, err := genstringtype.Parse(db.BatchStatus)
        if err != nil </span><span class="cov0" title="0">{
                return pickupbatchbus.PickupBatch{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">batchName, err := genstringtype.Parse(db.BatchName)
        if err != nil </span><span class="cov0" title="0">{
                return pickupbatchbus.PickupBatch{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">bus := pickupbatchbus.PickupBatch{
                ID:                  db.ID,
                RouteID:             db.RouteID,
                OriginFacilityID:    db.OriginFacilityID,
                VehicleID:           db.VehicleID,
                DeliveryPersonnelID: db.DeliveryPersonnelID,
                BatchName:           batchName,
                BatchStatus:         batchSts,
                PickedStartedAt:     db.PickupStartedAt.In(time.Local),
                PickupCompletedAt:   db.PickupCompletedAt.In(time.Local),
                IsDeleted:           db.IsDeleted,
                IsSynced:            db.IsSynced,
                TimeStamp:           db.TimeStamp.In(time.Local),
                CreatedAt:           db.CreatedAt.In(time.Local),
                UpdatedAt:           db.UpdatedAt.In(time.Local),
        }

        return bus, nil</span>

}

func toBusPickupBatches(dbs []pickupbatch) ([]pickupbatchbus.PickupBatch, error) <span class="cov0" title="0">{

        bus := make([]pickupbatchbus.PickupBatch, len(dbs))

        for i, db := range dbs </span><span class="cov0" title="0">{
                var err error
                bus[i], err = toBusPickupBatch(db)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">return bus, nil</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package pickupbatchdb

import (
        "fmt"

        "github.com/FITHSCS/backend/business/domain/pickupbatchbus"
        "github.com/FITHSCS/backend/business/sdk/order"
)

var orderByFields = map[string]string{
        pickupbatchbus.OrderByID:                  "pickup_batch_id",
        pickupbatchbus.OrderByRouteID:             "route_id",
        pickupbatchbus.OrderByVehicleID:           "vehicle_id",
        pickupbatchbus.OrderByOriginFacility:      "origin_facility_id",
        pickupbatchbus.OrderByDeliveryPersonnelID: "delivery_personnel_id",
        pickupbatchbus.OrderByIsSynced:            "is_synced",
        pickupbatchbus.OrderByTimeStamp:           "time_stamp",
        pickupbatchbus.OrderByCreatedAt:           "created_at",
        pickupbatchbus.OrderByUpdatedAt:           "updated_at",
}

// orderByClause converts an order.By value into the final
// " ORDER BY … ASC|DESC" fragment the store adds to its SELECT.
func orderByClause(ob order.By) (string, error) <span class="cov0" title="0">{
        col, ok := orderByFields[ob.Field]
        if !ok </span><span class="cov0" title="0">{
                return "", fmt.Errorf("field %q does not exist", ob.Field)
        }</span>
        <span class="cov0" title="0">return " ORDER BY " + col + " " + ob.Direction, nil</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">// Package pickupbatchdb contains product related CRUD functionality.
package pickupbatchdb

import (
        "bytes"
        "context"
        "errors"
        "fmt"

        "github.com/FITHSCS/backend/business/domain/pickupbatchbus"
        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/business/sdk/sqldb"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/google/uuid"
        "github.com/jmoiron/sqlx"
)

type Store struct {
        log *logger.Logger
        db  sqlx.ExtContext
}

func NewStore(log *logger.Logger, db *sqlx.DB) *Store <span class="cov0" title="0">{
        return &amp;Store{log: log, db: db}
}</span>

func (s *Store) Create(ctx context.Context, p pickupbatchbus.PickupBatch) error <span class="cov0" title="0">{
        const stmt = `
    INSERT INTO pickup_batch (
            pickup_batch_id, 
                route_id,
                origin_facility_id,
                vehicle_id, 
            delivery_personnel_id,
                batch_name,
                batch_status,
                pickup_started_at,
                pickup_completed_at,
            is_synced, 
                is_deleted,
                time_stamp, 
            created_at,
                updated_at 
    ) 
        VALUES (
            :pickup_batch_id, 
                :route_id, 
                :origin_facility_id,
                :vehicle_id, 
            :delivery_personnel_id, 
                :batch_name,
                :batch_status,
                :pickup_started_at,
                :pickup_completed_at,
            :is_synced, 
                :is_deleted,
                :time_stamp, 
            :created_at, 
                :updated_at
    )`
        returnedValue, err := toDBPickupBatch(p)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return sqldb.NamedExecContext(ctx, s.log, s.db, stmt, returnedValue)</span>
}

func (s *Store) Update(ctx context.Context, p pickupbatchbus.PickupBatch) error <span class="cov0" title="0">{
        const stmt = `
    UPDATE 
                pickup_batch
    SET 
                route_id                     = :route_id,
        origin_facility_id           = :origin_facility_id,
        vehicle_id                   = :vehicle_id,
        delivery_personnel_id        = :delivery_personnel_id,
        batch_name                           = :batch_name,
        batch_status                           = :batch_status,
                pickup_started_at                          = :pickup_started_at,
                pickup_completed_at                  = :pickup_completed_at,
        is_synced                    = :is_synced,
        is_deleted                   = :is_deleted,
        time_stamp                   = :time_stamp,
        updated_at                   = :updated_at
    WHERE pickup_batch_id            = :pickup_batch_id`

        returnedValue, err := toDBPickupBatch(p)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return sqldb.NamedExecContext(ctx, s.log, s.db, stmt, returnedValue)</span>
}

func (s *Store) Query(ctx context.Context,
        filter pickupbatchbus.QueryFilter, orderBy order.By, page page.Page) ([]pickupbatchbus.PickupBatch, error) <span class="cov0" title="0">{

        data := map[string]any{
                "offset":        (page.Number() - 1) * page.RowsPerPage(),
                "rows_per_page": page.RowsPerPage(),
        }

        const q = `
    SELECT
      pickup_batch_id,
          route_id, 
          origin_facility_id, 
          vehicle_id,
          delivery_personnel_id,
      batch_name,
          batch_status,
          pickup_started_at,
          pickup_completed_at, 
          is_synced,
          is_deleted,
          time_stamp,
      created_at, 
          updated_at
    FROM pickup_batch`

        var buf bytes.Buffer
        buf.WriteString(q)
        applyFilter(filter, data, &amp;buf)

        clause, err := orderByClause(orderBy)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">buf.WriteString(clause)
        buf.WriteString(" OFFSET :offset ROWS FETCH NEXT :rows_per_page ROWS ONLY")

        var dbRecs []pickupbatch
        if err := sqldb.NamedQuerySlice(ctx, s.log, s.db, buf.String(), data, &amp;dbRecs); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("namedqueryslice: %w", err)
        }</span>
        <span class="cov0" title="0">fmt.Println(dbRecs)
        return toBusPickupBatches(dbRecs)</span>
}

func (s *Store) QueryByID(ctx context.Context, pkupBatchID uuid.UUID) (pickupbatchbus.PickupBatch, error) <span class="cov0" title="0">{
        param := map[string]any{
                "pickup_batch_id": pkupBatchID.String(),
        }
        const stmt = `
    SELECT
            pickup_batch_id,
                  route_id, 
                  origin_facility_id, 
                vehicle_id,
                  delivery_personnel_id,
              batch_name,
                  batch_status,
                  pickup_started_at,
                  pickup_completed_at,
                  is_synced,
                  is_deleted,
                  time_stamp,
              created_at, 
                  updated_at
        FROM 
                  pickup_batch
        WHERE 
                  pickup_batch_id = :pickup_batch_id`

        var rec pickupbatch
        if err := sqldb.NamedQueryStruct(ctx, s.log, s.db, stmt, param, &amp;rec); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sqldb.ErrDBNotFound) </span><span class="cov0" title="0">{
                        return pickupbatchbus.PickupBatch{}, fmt.Errorf("db: %w", pickupbatchbus.ErrNotFound)
                }</span>
                <span class="cov0" title="0">return pickupbatchbus.PickupBatch{}, fmt.Errorf("db: %w", err)</span>
        }
        <span class="cov0" title="0">return toBusPickupBatch(rec)</span>
}

func (s *Store) Count(ctx context.Context, filter pickupbatchbus.QueryFilter) (int, error) <span class="cov0" title="0">{
        data := map[string]any{}
        const base = `SELECT count(1) FROM pickup_batch`

        var buf bytes.Buffer
        buf.WriteString(base)
        applyFilter(filter, data, &amp;buf)

        var out struct {
                Count int `db:"count"`
        }
        if err := sqldb.NamedQueryStruct(ctx, s.log, s.db, buf.String(), data, &amp;out); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("db: %w", err)
        }</span>
        <span class="cov0" title="0">return out.Count, nil</span>
}

func (s *Store) SoftDelete(ctx context.Context, pickupBatchID uuid.UUID) error <span class="cov0" title="0">{

        const q = `
    UPDATE
        pickup_batch
        SET
                is_deleted = :is_deleted
    WHERE
        pickup_batch_id = :pickup_batch_id`

        dbPickupBatch := pickupbatch{ID: pickupBatchID, IsDeleted: true}

        if err := sqldb.NamedExecContext(ctx, s.log, s.db, q, dbPickupBatch); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("namedexeccontext: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *Store) HardDelete(ctx context.Context, pickupBatchID uuid.UUID) error <span class="cov0" title="0">{
        const q = `
    DELETE FROM
        pickup_batch
    WHERE
        pickup_batch_id = :pickup_batch_id`

        dbPickupBatch := pickupbatch{ID: pickupBatchID}

        if err := sqldb.NamedExecContext(ctx, s.log, s.db, q, dbPickupBatch); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("namedexeccontext: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package pickupbatchbus

import (
        "context"
        "fmt"
        "math/rand"
        "time"

        "github.com/FITHSCS/backend/business/types/genstringtype"
        "github.com/google/uuid"
)

func TestGenerateNewPickupBatch(n int, routeID, deliveryPersonnelID, OrigfacID, VehID uuid.UUID) []NewPickupBatch <span class="cov5" title="2">{
        newfs := make([]NewPickupBatch, n)
        sts := []string{"pending", "picked_up", "in_transit", "delivered"}

        pickupTime, _ := time.Parse(time.RFC3339, "2025-06-10T15:59:33+03:00")
        CompTime := pickupTime.Add(time.Hour * 10)
        timestamp := pickupTime.Add(time.Minute + 1)

        idx := rand.Intn(10000)
        for i := range n </span><span class="cov10" title="4">{
                idx++

                nf := NewPickupBatch{
                        RouteID:             routeID,
                        DeliveryPersonnelID: deliveryPersonnelID,
                        OriginFacilityID:    OrigfacID,
                        VehicleID:           VehID,
                        BatchName:           genstringtype.MustParse(fmt.Sprintf("BatchName%d", idx)),
                        BatchStatus:         genstringtype.MustParse(sts[i%2]),
                        PickedStartedAt:     pickupTime,
                        PickupCompletedAt:   CompTime,
                        IsSynced:            true,
                        IsDeleted:           false,
                        TimeStamp:           timestamp,
                }

                newfs[i] = nf
        }</span>

        <span class="cov5" title="2">return newfs</span>
}

func TestGenerateSeedPickupBatch(ctx context.Context, n int, api *Business, routeID, deliveryPersonnelID, OrigfacID, VehID uuid.UUID) ([]PickupBatch, error) <span class="cov5" title="2">{
        newfs := TestGenerateNewPickupBatch(n, routeID, deliveryPersonnelID, OrigfacID, VehID)

        facs := make([]PickupBatch, len(newfs))
        for i, np := range newfs </span><span class="cov10" title="4">{
                prd, err := api.Create(ctx, np)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("seeding pickupbatch: idx: %d : %w", i, err)
                }</span>

                <span class="cov10" title="4">facs[i] = prd</span>
        }

        <span class="cov5" title="2">return facs, nil</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">// Package routebus provides business access to route domain.
package routebus

import (
        "context"
        "fmt"
        "time"

        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/google/uuid"
)

type Storer interface {
        Create(ctx context.Context, route Route) error
        Update(ctx context.Context, route Route) error
        Delete(ctx context.Context, routeID uuid.UUID) error
        Query(ctx context.Context, filter QueryFilter, orderby order.By, page page.Page) ([]Route, error)
        QueryByID(ctx context.Context, routeID uuid.UUID) (Route, error)
        Count(ctx context.Context, filter QueryFilter) (int, error)
}

func (b *Business) GetStorer() Storer <span class="cov0" title="0">{
        return b.storer
}</span>

type Business struct {
        log    *logger.Logger
        storer Storer
}

func NewBusiness(log *logger.Logger, storer Storer) *Business <span class="cov1" title="1">{
        return &amp;Business{
                log:    log,
                storer: storer,
        }
}</span>

func (b *Business) Create(ctx context.Context, pb NewRoute) (Route, error) <span class="cov10" title="5">{

        now := time.Now().Truncate(time.Millisecond)

        route := Route{
                RouteID:         uuid.New(),
                StartFacilityID: pb.StartFacilityID,
                EndFacilityID:   pb.EndFacilityID,
                RouteName:       pb.RouteName,
                TotalKM:         pb.TotalKM,
                TotalStops:      pb.TotalStops,
                StartLatitude:   pb.StartLatitude,
                StartLongitude:  pb.StartLongitude,
                EndLatitude:     pb.EndLatitude,
                EndLongitude:    pb.EndLongitude,
                IsActive:        true,
                CreatedAt:       now,
                UpdatedAt:       now,
        }

        if err := b.storer.Create(ctx, route); err != nil </span><span class="cov0" title="0">{
                return Route{}, fmt.Errorf("Create: %w", err)
        }</span>

        <span class="cov10" title="5">return route, nil</span>
}

func (b *Business) Update(ctx context.Context, routeID uuid.UUID, updrte UpdateRoute) (Route, error) <span class="cov1" title="1">{

        rteOrig, err := b.storer.QueryByID(ctx, routeID)
        if err != nil </span><span class="cov0" title="0">{
                return Route{}, fmt.Errorf("querybyid: %w", err)
        }</span>

        <span class="cov1" title="1">if updrte.StartFacilityID != nil </span><span class="cov1" title="1">{
                rteOrig.StartFacilityID = *updrte.StartFacilityID
        }</span>

        <span class="cov1" title="1">if updrte.EndFacilityID != nil </span><span class="cov1" title="1">{
                rteOrig.EndFacilityID = *updrte.EndFacilityID
        }</span>

        <span class="cov1" title="1">if updrte.RouteName != nil </span><span class="cov1" title="1">{
                rteOrig.RouteName = *updrte.RouteName
        }</span>

        <span class="cov1" title="1">if updrte.TotalKM != nil </span><span class="cov1" title="1">{
                rteOrig.TotalKM = *updrte.TotalKM
        }</span>

        <span class="cov1" title="1">if updrte.TotalStops != nil </span><span class="cov1" title="1">{
                rteOrig.TotalStops = *updrte.TotalStops
        }</span>

        <span class="cov1" title="1">if updrte.StartLatitude != nil </span><span class="cov1" title="1">{
                rteOrig.StartLatitude = *updrte.StartLatitude
        }</span>

        <span class="cov1" title="1">if updrte.StartLongitude != nil </span><span class="cov1" title="1">{
                rteOrig.StartLongitude = *updrte.StartLongitude
        }</span>

        <span class="cov1" title="1">if updrte.EndLatitude != nil </span><span class="cov1" title="1">{
                rteOrig.EndLatitude = *updrte.EndLatitude
        }</span>

        <span class="cov1" title="1">if updrte.EndLongitude != nil </span><span class="cov1" title="1">{
                rteOrig.EndLongitude = *updrte.EndLongitude
        }</span>

        <span class="cov1" title="1">rteOrig.UpdatedAt = time.Now().Truncate(time.Microsecond)

        if err := b.storer.Update(ctx, rteOrig); err != nil </span><span class="cov0" title="0">{
                return Route{}, fmt.Errorf("update: %w", err)
        }</span>
        <span class="cov1" title="1">return rteOrig, nil</span>
}

func (b *Business) QueryByID(ctx context.Context, routeID uuid.UUID) (Route, error) <span class="cov1" title="1">{

        rte, err := b.storer.QueryByID(ctx, routeID)
        if err != nil </span><span class="cov0" title="0">{
                return Route{}, fmt.Errorf("query: routeid[%s]: %w", routeID, err)
        }</span>
        <span class="cov1" title="1">return rte, nil</span>
}

func (b *Business) Query(ctx context.Context, filter QueryFilter, orderBy order.By, page page.Page) ([]Route, error) <span class="cov1" title="1">{
        rtebtch, err := b.storer.Query(ctx, filter, orderBy, page)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Query: %w", err)
        }</span>
        <span class="cov1" title="1">return rtebtch, nil</span>
}

func (b *Business) Count(ctx context.Context, filter QueryFilter) (int, error) <span class="cov0" title="0">{
        return b.storer.Count(ctx, filter)
}</span>

func (b *Business) Delete(ctx context.Context, routeID uuid.UUID) error <span class="cov4" title="2">{

        facility, err := b.storer.QueryByID(ctx, routeID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("delete: pickupBatch[%s]: %w", routeID, err)
        }</span>

        <span class="cov4" title="2">if !facility.IsActive </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: already deleted", routeID)
        }</span>

        <span class="cov4" title="2">if err := b.storer.Delete(ctx, routeID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("delete: %w", err)
        }</span>
        <span class="cov4" title="2">return nil</span>

}
</pre>
		
		<pre class="file" id="file43" style="display: none">package routedb

import (
        "bytes"
        "strings"

        "github.com/FITHSCS/backend/business/domain/routebus"
)

func applyFilter(filter routebus.QueryFilter, data map[string]any, buf *bytes.Buffer) <span class="cov0" title="0">{

        var wc []string

        if filter.ID != nil </span><span class="cov0" title="0">{
                data["route_id"] = &amp;filter.ID
                wc = append(wc, "route_id = :route_id")
        }</span>
        <span class="cov0" title="0">if filter.StartFacility != nil </span><span class="cov0" title="0">{
                data["start_facility_id"] = *filter.StartFacility
                wc = append(wc, "start_facility_id = :start_facility_id")
        }</span>

        <span class="cov0" title="0">if filter.EndFacility != nil </span><span class="cov0" title="0">{
                data["end_facility_id"] = *filter.EndFacility
                wc = append(wc, "end_facility_id = :end_facility_id")
        }</span>

        <span class="cov0" title="0">if filter.RouteName != nil </span><span class="cov0" title="0">{
                data["route_name"] = *filter.RouteName
                wc = append(wc, "route_name = :route_name")
        }</span>

        <span class="cov0" title="0">if filter.TotalKM != nil </span><span class="cov0" title="0">{
                data["total_km"] = *filter.TotalKM
                wc = append(wc, "total_km &gt;= :total_km")
        }</span>

        <span class="cov0" title="0">if filter.IsActive != nil </span><span class="cov0" title="0">{
                data["is_active"] = *filter.IsActive
                wc = append(wc, "is_active = :is_active")
        }</span>

        <span class="cov0" title="0">if filter.CreatedAt != nil </span><span class="cov0" title="0">{
                data["created_at"] = filter.CreatedAt.UTC()
                wc = append(wc, "date_created &gt;= :created_at")
        }</span>
        <span class="cov0" title="0">if filter.UpdatedAt != nil </span><span class="cov0" title="0">{
                data["updated_at"] = filter.UpdatedAt.UTC()
                wc = append(wc, "updated_at &lt;= :updated_at")
        }</span>

        <span class="cov0" title="0">if len(wc) &gt; 0 </span><span class="cov0" title="0">{
                buf.WriteString(" WHERE ")
                buf.WriteString(strings.Join(wc, " AND "))
        }</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package routedb

import (
        "fmt"
        "time"

        "github.com/FITHSCS/backend/business/domain/routebus"
        "github.com/FITHSCS/backend/business/types/facilitytype"
        "github.com/FITHSCS/backend/business/types/genstringtype"
        "github.com/google/uuid"
)

type routedb struct {
        ID              uuid.UUID `db:"route_id"`
        StartFacilityID uuid.UUID `db:"start_facility_id"`
        EndFacilityID   uuid.UUID `db:"end_facility_id"`
        RouteName       string    `db:"route_name"`
        TotalKM         float64   `db:"total_km"`
        TotalStops      int       `db:"total_stops"`
        StartLatitude   float64   `db:"start_latitude"`
        EndLatitude     float64   `db:"end_latitude"`
        StartLongitude  float64   `db:"start_longitude"`
        EndLongitude    float64   `db:"end_longitude"`
        IsActive        bool      `db:"is_active"`
        CreatedAt       time.Time `db:"created_at"`
        UpdatedAt       time.Time `db:"updated_at"`
}

func toDBRoutedb(bus routebus.Route) (routedb, error) <span class="cov0" title="0">{

        routedb := routedb{
                ID:              bus.RouteID,
                StartFacilityID: bus.StartFacilityID,
                EndFacilityID:   bus.EndFacilityID,
                RouteName:       bus.RouteName.String(),
                TotalKM:         bus.TotalKM,
                TotalStops:      bus.TotalStops,
                StartLatitude:   bus.StartLatitude.Float64(),
                EndLatitude:     bus.EndLatitude.Float64(),
                StartLongitude:  bus.StartLongitude.Float64(),
                EndLongitude:    bus.EndLongitude.Float64(),
                IsActive:        bus.IsActive,
                CreatedAt:       bus.CreatedAt.UTC(),
                UpdatedAt:       bus.UpdatedAt.UTC(),
        }

        return routedb, nil
}</span>

func toBusRoute(db routedb) (routebus.Route, error) <span class="cov0" title="0">{

        rteName, err := genstringtype.Parse(db.RouteName)
        if err != nil </span><span class="cov0" title="0">{
                return routebus.Route{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">stlat, err := facilitytype.ParseLat(db.StartLatitude)
        if err != nil </span><span class="cov0" title="0">{
                return routebus.Route{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">stlong, err := facilitytype.ParseLong(db.StartLongitude)
        if err != nil </span><span class="cov0" title="0">{
                return routebus.Route{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">endlat, err := facilitytype.ParseLat(db.EndLatitude)
        if err != nil </span><span class="cov0" title="0">{
                return routebus.Route{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">endlong, err := facilitytype.ParseLong(db.EndLongitude)
        if err != nil </span><span class="cov0" title="0">{
                return routebus.Route{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">rtebus := routebus.Route{
                RouteID:         db.ID,
                StartFacilityID: db.StartFacilityID,
                EndFacilityID:   db.EndFacilityID,
                RouteName:       rteName,
                TotalKM:         db.TotalKM,
                TotalStops:      db.TotalStops,
                StartLatitude:   stlat,
                StartLongitude:  stlong,
                EndLatitude:     endlat,
                EndLongitude:    endlong,
                IsActive:        db.IsActive,
                CreatedAt:       db.CreatedAt.In(time.Local),
                UpdatedAt:       db.UpdatedAt.In(time.Local),
        }

        return rtebus, nil</span>
}

func toBusRoutes(dbs []routedb) ([]routebus.Route, error) <span class="cov0" title="0">{

        bus := make([]routebus.Route, len(dbs))

        for i, db := range dbs </span><span class="cov0" title="0">{
                var err error
                bus[i], err = toBusRoute(db)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">return bus, nil</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package routedb

import (
        "fmt"

        "github.com/FITHSCS/backend/business/domain/routebus"
        "github.com/FITHSCS/backend/business/sdk/order"
)

var orderByFields = map[string]string{
        routebus.OrderByID:            "route_id",
        routebus.OrderByStartFacility: "start_facility_id",
        routebus.OrderByEndFacility:   "end_facility_id",
        routebus.OrderByRouteName:     "route_name",
        routebus.OrderByTotalKms:      "total_km",
        routebus.OrderByTotalStops:    "total_stops",
        routebus.OrderByIsActive:      "is_active",
        routebus.OrderByCreatedAt:     "created_at",
        routebus.OrderByUpdatedAt:     "updated_at",
}

// orderByClause converts an order.By value into the final
// " ORDER BY … ASC|DESC" fragment the store adds to its SELECT.
func orderByClause(ob order.By) (string, error) <span class="cov0" title="0">{
        col, ok := orderByFields[ob.Field]
        if !ok </span><span class="cov0" title="0">{
                return "", fmt.Errorf("field %q does not exist", ob.Field)
        }</span>
        <span class="cov0" title="0">return " ORDER BY " + col + " " + ob.Direction, nil</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">// Package routedb contains product related CRUD functionality.
package routedb

import (
        "bytes"
        "context"
        "errors"
        "fmt"

        "github.com/FITHSCS/backend/business/domain/pickupbatchbus"
        "github.com/FITHSCS/backend/business/domain/routebus"
        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/business/sdk/sqldb"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/google/uuid"
        "github.com/jmoiron/sqlx"
)

type Store struct {
        log *logger.Logger
        db  sqlx.ExtContext
}

func NewStore(log *logger.Logger, db *sqlx.DB) *Store <span class="cov0" title="0">{
        return &amp;Store{log: log, db: db}
}</span>

func (s *Store) Create(ctx context.Context, r routebus.Route) error <span class="cov0" title="0">{
        const stmt = `
    INSERT INTO route (
            route_id, 
                start_facility_id,
                end_facility_id,
                route_name, 
            total_km,
                total_stops,
                start_latitude,
                start_longitude,
                end_latitude,
            end_longitude, 
                is_active,
            created_at,
                updated_at 
    ) 
        VALUES (
                :route_id, 
            :start_facility_id, 
                :end_facility_id,
                :route_name, 
            :total_km, 
                :total_stops,
                :start_latitude,
                :start_longitude,
                :end_latitude,
            :end_longitude, 
                :is_active,
            :created_at, 
                :updated_at
    )`
        returnedValue, err := toDBRoutedb(r)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return sqldb.NamedExecContext(ctx, s.log, s.db, stmt, returnedValue)</span>
}

func (s *Store) Update(ctx context.Context, r routebus.Route) error <span class="cov0" title="0">{
        const stmt = `
    UPDATE 
                route
    SET 
        start_facility_id   = :start_facility_id,
        end_facility_id     = :end_facility_id,
        route_name                = :route_name,
        total_km                  = :total_km,
        total_stops         = :total_stops,
                start_latitude                 = :start_latitude,
                start_longitude         = :start_longitude,
        end_latitude        = :end_latitude,
        end_longitude       = :end_longitude,
        is_active           = :is_active,
        updated_at          = :updated_at
    WHERE route_id          = :route_id`

        returnedValue, err := toDBRoutedb(r)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return sqldb.NamedExecContext(ctx, s.log, s.db, stmt, returnedValue)</span>
}

func (s *Store) Query(ctx context.Context,
        filter routebus.QueryFilter, orderBy order.By, page page.Page) ([]routebus.Route, error) <span class="cov0" title="0">{

        data := map[string]any{
                "offset":        (page.Number() - 1) * page.RowsPerPage(),
                "rows_per_page": page.RowsPerPage(),
        }

        const q = `
    SELECT
            route_id, 
                start_facility_id,
                end_facility_id,
                route_name, 
            total_km,
                total_stops,
                start_latitude,
                start_longitude,
                end_latitude,
            end_longitude, 
                is_active,
            created_at,
                updated_at 
    FROM 
                route`

        var buf bytes.Buffer
        buf.WriteString(q)
        applyFilter(filter, data, &amp;buf)

        clause, err := orderByClause(orderBy)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">buf.WriteString(clause)
        buf.WriteString(" OFFSET :offset ROWS FETCH NEXT :rows_per_page ROWS ONLY")

        var dbRecs []routedb
        if err := sqldb.NamedQuerySlice(ctx, s.log, s.db, buf.String(), data, &amp;dbRecs); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("namedqueryslice: %w", err)
        }</span>
        <span class="cov0" title="0">return toBusRoutes(dbRecs)</span>
}

func (s *Store) QueryByID(ctx context.Context, routeID uuid.UUID) (routebus.Route, error) <span class="cov0" title="0">{
        param := map[string]any{
                "route_id": routeID.String(),
        }
        const stmt = `
    SELECT
        route_id, 
                start_facility_id,
                end_facility_id,
                route_name, 
            total_km,
                total_stops,
                start_latitude,
                start_longitude,
                end_latitude,
            end_longitude, 
                is_active,
            created_at,
                updated_at 
        FROM 
                  route
        WHERE 
                  route_id = :route_id`

        var rec routedb
        if err := sqldb.NamedQueryStruct(ctx, s.log, s.db, stmt, param, &amp;rec); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sqldb.ErrDBNotFound) </span><span class="cov0" title="0">{
                        return routebus.Route{}, fmt.Errorf("db: %w", pickupbatchbus.ErrNotFound)
                }</span>
                <span class="cov0" title="0">return routebus.Route{}, fmt.Errorf("db: %w", err)</span>
        }
        <span class="cov0" title="0">return toBusRoute(rec)</span>
}

func (s *Store) Count(ctx context.Context, filter routebus.QueryFilter) (int, error) <span class="cov0" title="0">{
        data := map[string]any{}
        const base = `SELECT count(1) FROM route`

        var buf bytes.Buffer
        buf.WriteString(base)
        applyFilter(filter, data, &amp;buf)

        var out struct {
                Count int `db:"count"`
        }
        if err := sqldb.NamedQueryStruct(ctx, s.log, s.db, buf.String(), data, &amp;out); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("db: %w", err)
        }</span>
        <span class="cov0" title="0">return out.Count, nil</span>
}

func (s *Store) Delete(ctx context.Context, routeID uuid.UUID) error <span class="cov0" title="0">{

        const q = `
    UPDATE
        route
        SET
                is_active = :is_active
    WHERE
        route_id = :route_id`

        dbPickupBatch := routedb{ID: routeID, IsActive: false}

        if err := sqldb.NamedExecContext(ctx, s.log, s.db, q, dbPickupBatch); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("namedexeccontext: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package routebus

import (
        "context"
        "fmt"
        "math/rand"

        "github.com/FITHSCS/backend/business/types/facilitytype"
        "github.com/FITHSCS/backend/business/types/genstringtype"
        "github.com/google/uuid"
)

func TestGenerateNewRoutes(n int, stFacID uuid.UUID, endFacID uuid.UUID) []NewRoute <span class="cov5" title="2">{
        newroute := make([]NewRoute, n)

        idx := rand.Intn(10000)
        for i := range n </span><span class="cov10" title="4">{
                idx++

                nf := NewRoute{
                        StartFacilityID: stFacID,
                        EndFacilityID:   endFacID,
                        RouteName:       genstringtype.MustParse(fmt.Sprintf("RouteName%d", idx)),
                        TotalKM:         float64(idx % 1000),
                        TotalStops:      int(idx % 100),
                        StartLatitude:   facilitytype.MustParseLat(9.01949999999),
                        EndLatitude:     facilitytype.MustParseLat(9.069499999999),
                        StartLongitude:  facilitytype.MustParseLong(38.7399999999),
                        EndLongitude:    facilitytype.MustParseLong(38.78929999999),
                        IsActive:        true,
                }

                newroute[i] = nf
        }</span>

        <span class="cov5" title="2">return newroute</span>
}

func TestGenerateSeedRoutes(ctx context.Context, n int, api *Business, stfacid uuid.UUID, endfacid uuid.UUID) ([]Route, error) <span class="cov5" title="2">{
        newfs := TestGenerateNewRoutes(n, stfacid, endfacid)

        facs := make([]Route, len(newfs))
        for i, np := range newfs </span><span class="cov10" title="4">{
                prd, err := api.Create(ctx, np)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("seeding routes: idx: %d : %w", i, err)
                }</span>

                <span class="cov10" title="4">facs[i] = prd</span>
        }

        <span class="cov5" title="2">return facs, nil</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">// Package signaturebus provides business access to vehicles bus domain.
package signaturebus

import (
        "context"
        "fmt"
        "time"

        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/google/uuid"
)

type Storer interface {
        Create(ctx context.Context, signature Signature) error
        Update(ctx context.Context, signature Signature) error
        SoftDelete(ctx context.Context, signatureID uuid.UUID) error
        HardDelete(ctx context.Context, signatureID uuid.UUID) error
        Query(ctx context.Context, filter QueryFilter, orderby order.By, page page.Page) ([]Signature, error)
        QueryByID(ctx context.Context, signatureID uuid.UUID) (Signature, error)
        Count(ctx context.Context, filter QueryFilter) (int, error)
}


func (b *Business) GetStorer() Storer <span class="cov0" title="0">{
    return b.storer
}</span>



type Business struct {
        log    *logger.Logger
        storer Storer
}

func NewBusiness(log *logger.Logger, storer Storer) *Business <span class="cov1" title="1">{
        return &amp;Business{
                log:    log,
                storer: storer,
        }
}</span>

func (b *Business) Create(ctx context.Context, ns NewSignature) (Signature, error) <span class="cov10" title="5">{
        now := time.Now()

        signature := Signature{
                SignatureID:    uuid.New(),
                ManifestID:     ns.ManifestID,
                SignedByID:     ns.SignedByID,
                EventType:      ns.EventType,
                SignatureType:  ns.SignatureType,
                SignatureHash:  ns.SignatureHash,
                DeviceID:       ns.DeviceID,
                SignedAt:       ns.SignedAt,
                Longitude:      ns.Longitude,
                Latitude:       ns.Latitude,
                InsideGeofence: ns.InsideGeofence,
                IsVerified:     ns.IsVerified,
                IsDeleted:      false,
                IsSynced:       ns.IsSynced,
                TimeStamp:      now,
                CreatedAt:      now,
                UpdatedAt:      now,
        }

        if err := b.storer.Create(ctx, signature); err != nil </span><span class="cov0" title="0">{
                return Signature{}, fmt.Errorf("Create: %w", err)
        }</span>

        <span class="cov10" title="5">fmt.Printf("\n\n\nsignature: %v\n\n\n", signature)
        return signature, nil</span>
}

func (b *Business) Update(ctx context.Context, singatureID uuid.UUID, updateSignature UpdateSignature) (Signature, error) <span class="cov1" title="1">{

        signOrig, err := b.storer.QueryByID(ctx, singatureID)
        if err != nil </span><span class="cov0" title="0">{
                return Signature{}, fmt.Errorf("querybyid: %w", err)
        }</span>

        <span class="cov1" title="1">if updateSignature.ManifestID != nil </span><span class="cov1" title="1">{
                signOrig.ManifestID = *updateSignature.ManifestID
        }</span>

        <span class="cov1" title="1">if updateSignature.SignedByID != nil </span><span class="cov1" title="1">{
                signOrig.SignedByID = *updateSignature.SignedByID
        }</span>

        <span class="cov1" title="1">if updateSignature.EventType != nil </span><span class="cov1" title="1">{
                signOrig.EventType = *updateSignature.EventType
        }</span>

        <span class="cov1" title="1">if updateSignature.SignatureType != nil </span><span class="cov1" title="1">{
                signOrig.SignatureType = *updateSignature.SignatureType
        }</span>

        <span class="cov1" title="1">if updateSignature.SignatureHash != nil </span><span class="cov1" title="1">{
                signOrig.SignatureHash = *updateSignature.SignatureHash
        }</span>

        <span class="cov1" title="1">if updateSignature.DeviceID != nil </span><span class="cov1" title="1">{
                signOrig.DeviceID = *updateSignature.DeviceID
        }</span>

        <span class="cov1" title="1">if updateSignature.SignedAt != nil </span><span class="cov1" title="1">{
                signOrig.SignedAt = *updateSignature.SignedAt
        }</span>

        <span class="cov1" title="1">if updateSignature.Longitude != nil </span><span class="cov1" title="1">{
                signOrig.Longitude = *updateSignature.Longitude
        }</span>

        <span class="cov1" title="1">if updateSignature.Latitude != nil </span><span class="cov1" title="1">{
                signOrig.Latitude = *updateSignature.Latitude
        }</span>

        <span class="cov1" title="1">if updateSignature.InsideGeofence != nil </span><span class="cov1" title="1">{
                signOrig.InsideGeofence = *updateSignature.InsideGeofence
        }</span>

        <span class="cov1" title="1">if updateSignature.IsVerified != nil </span><span class="cov1" title="1">{
                signOrig.IsVerified = *updateSignature.IsVerified
        }</span>

        <span class="cov1" title="1">if updateSignature.IsSynced != nil </span><span class="cov1" title="1">{
                signOrig.IsSynced = *updateSignature.IsSynced
        }</span>

        <span class="cov1" title="1">if updateSignature.TimeStamp != nil </span><span class="cov1" title="1">{
                signOrig.TimeStamp = *updateSignature.TimeStamp
        }</span>

        <span class="cov1" title="1">signOrig.UpdatedAt = time.Now().Truncate(time.Microsecond)

        if err := b.storer.Update(ctx, signOrig); err != nil </span><span class="cov0" title="0">{
                return Signature{}, fmt.Errorf("update: %w", err)
        }</span>
        <span class="cov1" title="1">return signOrig, nil</span>
}

func (b *Business) QueryByID(ctx context.Context, signatureID uuid.UUID) (Signature, error) <span class="cov1" title="1">{

        signature, err := b.storer.QueryByID(ctx, signatureID)
        if err != nil </span><span class="cov0" title="0">{
                return Signature{}, fmt.Errorf("query: signatureID[%s]: %w", signatureID, err)
        }</span>
        <span class="cov1" title="1">return signature, nil</span>
}

func (b *Business) Query(ctx context.Context, filter QueryFilter, orderBy order.By, page page.Page) ([]Signature, error) <span class="cov1" title="1">{

        signatures, err := b.storer.Query(ctx, filter, orderBy, page)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Query: %w", err)
        }</span>
        <span class="cov1" title="1">return signatures, nil</span>
}

func (b *Business) Count(ctx context.Context, filter QueryFilter) (int, error) <span class="cov0" title="0">{
        return b.storer.Count(ctx, filter)
}</span>

func (b *Business) SoftDelete(ctx context.Context, signatureID uuid.UUID) error <span class="cov4" title="2">{

        facility, err := b.storer.QueryByID(ctx, signatureID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("softdeletequery: signature[%s]: %w", signatureID, err)
        }</span>

        <span class="cov4" title="2">if facility.IsDeleted </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: already deleted", signatureID)
        }</span>

        <span class="cov4" title="2">if err := b.storer.SoftDelete(ctx, signatureID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("delete: %w", err)
        }</span>
        <span class="cov4" title="2">return nil</span>

}

func (b *Business) HardDelete(ctx context.Context, signatureID uuid.UUID) error <span class="cov4" title="2">{
        if err := b.storer.HardDelete(ctx, signatureID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("delete: %w", err)
        }</span>
        <span class="cov4" title="2">return nil</span>

}
</pre>
		
		<pre class="file" id="file49" style="display: none">package signaturedb

import (
        "bytes"
        "strings"

        "github.com/FITHSCS/backend/business/domain/signaturebus"
)

func applyFilter(filter signaturebus.QueryFilter, data map[string]any, buf *bytes.Buffer) <span class="cov0" title="0">{

        var wc []string

        if filter.DeviceID != nil </span><span class="cov0" title="0">{
                data["is_synced"] = *filter.DeviceID
                wc = append(wc, "device_id = :device_id")
        }</span>

        <span class="cov0" title="0">if filter.InsideGeofence != nil </span><span class="cov0" title="0">{
                data["is_synced"] = *filter.InsideGeofence
                wc = append(wc, "inside_geofence = :inside_geofence")
        }</span>

        <span class="cov0" title="0">if filter.IsVerified != nil </span><span class="cov0" title="0">{
                data["is_synced"] = *filter.IsVerified
                wc = append(wc, "is_verified = :is_verified")
        }</span>

        <span class="cov0" title="0">if filter.IsSynced != nil </span><span class="cov0" title="0">{
                data["is_synced"] = *filter.IsSynced
                wc = append(wc, "is_synced = :is_synced")
        }</span>

        <span class="cov0" title="0">if filter.TimeStamp != nil </span><span class="cov0" title="0">{
                data["time_stamp"] = *filter.TimeStamp
                wc = append(wc, "time_stamp = :time_stamp")
        }</span>

        <span class="cov0" title="0">if filter.CreatedAt != nil </span><span class="cov0" title="0">{
                data["created_at"] = filter.CreatedAt.UTC()
                wc = append(wc, "date_created &gt;= :created_at")
        }</span>
        <span class="cov0" title="0">if filter.UpdatedAt != nil </span><span class="cov0" title="0">{
                data["updated_at"] = filter.UpdatedAt.UTC()
                wc = append(wc, "updated_at &lt;= :updated_at")
        }</span>

        <span class="cov0" title="0">if len(wc) &gt; 0 </span><span class="cov0" title="0">{
                buf.WriteString(" WHERE ")
                buf.WriteString(strings.Join(wc, " AND "))
        }</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package signaturedb

import (
        "fmt"
        "time"

        "github.com/FITHSCS/backend/business/domain/signaturebus"
        "github.com/FITHSCS/backend/business/types/facilitytype"
        "github.com/FITHSCS/backend/business/types/genstringtype"
        "github.com/google/uuid"
)

type signaturedb struct {
        SignatureID    uuid.UUID `db:"signature_id"`
        ManifestID     uuid.UUID `db:"manifest_id"`
        SignedByID     uuid.UUID `db:"signed_by_id"`
        EventType      string    `db:"event_type"`
        SignatureType  string    `db:"signature_type"`
        SignatureHash  string    `db:"signature_hash"`
        DeviceID       string    `db:"device_id"`
        SignedAt       time.Time `db:"signed_at"`
        Longitude      float64   `db:"longitude"`
        Latitude       float64   `db:"latitude"`
        InsideGeofence bool      `db:"inside_geofence"`
        IsVerified     bool      `db:"is_verified"`
        IsDeleted      bool      `db:"is_deleted"`
        IsSynced       bool      `db:"is_synced"`
        TimeStamp      time.Time `db:"time_stamp"`
        CreatedAt      time.Time `db:"created_at"`
        UpdatedAt      time.Time `db:"updated_at"`
}

//=============================================================================&gt;

func toDBSignature(bus signaturebus.Signature) (signaturedb, error) <span class="cov0" title="0">{

        siganture := signaturedb{
                SignatureID:    bus.SignatureID,
                ManifestID:     bus.ManifestID,
                SignedByID:     bus.SignedByID,
                EventType:      bus.EventType.String(),
                SignatureType:  bus.SignatureType.String(),
                SignatureHash:  bus.SignatureHash.String(),
                DeviceID:       bus.DeviceID.String(),
                SignedAt:       bus.SignedAt.UTC(),
                Longitude:      bus.Longitude.Float64(),
                Latitude:       bus.Latitude.Float64(),
                InsideGeofence: bus.InsideGeofence,
                IsVerified:     bus.IsVerified,
                IsSynced:       bus.IsSynced,
                IsDeleted:      bus.IsDeleted,
                TimeStamp:      bus.TimeStamp.UTC(),
                CreatedAt:      bus.CreatedAt.UTC(),
                UpdatedAt:      bus.UpdatedAt.UTC(),
        }

        return siganture, nil
}</span>

func toBusSignature(db signaturedb) (signaturebus.Signature, error) <span class="cov0" title="0">{
        snatureid, err := uuid.Parse(db.SignatureID.String())
        if err != nil </span><span class="cov0" title="0">{
                return signaturebus.Signature{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">manid, err := uuid.Parse(db.ManifestID.String())
        if err != nil </span><span class="cov0" title="0">{
                return signaturebus.Signature{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">signdbyid, err := uuid.Parse(db.SignedByID.String())
        if err != nil </span><span class="cov0" title="0">{
                return signaturebus.Signature{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">evntype, err := genstringtype.Parse(db.EventType)
        if err != nil </span><span class="cov0" title="0">{
                return signaturebus.Signature{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">signtype, err := genstringtype.Parse(db.SignatureType)
        if err != nil </span><span class="cov0" title="0">{
                return signaturebus.Signature{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">sgnhash, err := genstringtype.Parse(db.SignatureHash)
        if err != nil </span><span class="cov0" title="0">{
                return signaturebus.Signature{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">dvceid, err := genstringtype.Parse(db.DeviceID)
        if err != nil </span><span class="cov0" title="0">{
                return signaturebus.Signature{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">var sgnat time.Time
        if !db.SignedAt.IsZero() </span><span class="cov0" title="0">{
                sgnat = db.SignedAt.In(time.Local)
        }</span>

        <span class="cov0" title="0">lng, err := facilitytype.ParseLong(db.Longitude)
        if err != nil </span><span class="cov0" title="0">{
                return signaturebus.Signature{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">lat, err := facilitytype.ParseLat(db.Latitude)
        if err != nil </span><span class="cov0" title="0">{
                return signaturebus.Signature{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">bus := signaturebus.Signature{
                SignatureID:    snatureid,
                ManifestID:     manid,
                SignedByID:     signdbyid,
                EventType:      evntype,
                SignatureType:  signtype,
                SignatureHash:  sgnhash,
                DeviceID:       dvceid,
                SignedAt:       sgnat,
                Longitude:      lng,
                Latitude:       lat,
                InsideGeofence: db.InsideGeofence,
                IsVerified:     db.IsVerified,
                IsDeleted:      db.IsDeleted,
                IsSynced:       db.IsSynced,
                TimeStamp:      db.TimeStamp.In(time.Local),
                CreatedAt:      db.CreatedAt.In(time.Local),
                UpdatedAt:      db.UpdatedAt.In(time.Local),
        }

        return bus, nil</span>

}

func toBusSignatures(dbs []signaturedb) ([]signaturebus.Signature, error) <span class="cov0" title="0">{
        bus := make([]signaturebus.Signature, len(dbs))

        for i, db := range dbs </span><span class="cov0" title="0">{
                var err error
                bus[i], err = toBusSignature(db)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">return bus, nil</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">package signaturedb

import (
        "fmt"

        "github.com/FITHSCS/backend/business/domain/signaturebus"
        "github.com/FITHSCS/backend/business/sdk/order"
)

var orderByFields = map[string]string{
        signaturebus.OrderBySignatureID: "signature_id",
        signaturebus.OrderByCreatedAt:   "created_at",
        signaturebus.OrderByDeviceID:    "device_id",
        signaturebus.OrderByEventType:   "event_type",
        signaturebus.OrderByTimeStamp:   "timestamp",
        signaturebus.OrderByUpdatedAt:   "updated_at",
}

// orderByClause converts an order.By value into the final
// " ORDER BY … ASC|DESC" fragment the store adds to its SELECT.
func orderByClause(ob order.By) (string, error) <span class="cov0" title="0">{
        col, ok := orderByFields[ob.Field]

        if !ok </span><span class="cov0" title="0">{
                return "", fmt.Errorf("field %q does not exist", ob.Field)
        }</span>
        <span class="cov0" title="0">return " ORDER BY " + col + " " + ob.Direction, nil</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">// Package signaturedb contains product related CRUD functionality.
package signaturedb

import (
        "bytes"
        "context"
        "errors"
        "fmt"

        "github.com/FITHSCS/backend/business/domain/pickupbatchbus"
        "github.com/FITHSCS/backend/business/domain/signaturebus"
        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/business/sdk/sqldb"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/google/uuid"
        "github.com/jmoiron/sqlx"
)

type Store struct {
        log *logger.Logger
        db  sqlx.ExtContext
}

func NewStore(log *logger.Logger, db *sqlx.DB) *Store <span class="cov0" title="0">{
        return &amp;Store{log: log, db: db}
}</span>

func (s *Store) Create(ctx context.Context, p signaturebus.Signature) error <span class="cov0" title="0">{
        const stmt = `
    INSERT INTO signature (
            signature_id, 
                manifest_id,
                signed_by_id,
                event_type, 
            signature_type,
                signature_hash,
                device_id,
                signed_at,
                longitude,
                latitude,
                inside_geofence,
                is_verified,
                is_deleted,
            is_synced, 
                time_stamp, 
            created_at,
                updated_at 
    ) 
        VALUES (
            :signature_id, 
                :manifest_id, 
                :signed_by_id,
                :event_type, 
            :signature_type, 
                :signature_hash,
                :device_id,
                :signed_at,
                :longitude,
            :latitude, 
                :inside_geofence,
                :is_verified,
                :is_deleted,
                :is_synced,
                :time_stamp, 
            :created_at, 
                :updated_at
    )`
        returnedValue, err := toDBSignature(p)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return sqldb.NamedExecContext(ctx, s.log, s.db, stmt, returnedValue)</span>
}

func (s *Store) Update(ctx context.Context, p signaturebus.Signature) error <span class="cov0" title="0">{
        const stmt = `
    UPDATE 
                signature
    SET 
        manifest_id       = :manifest_id,
        signed_by_id      = :signed_by_id,
        event_type        = :event_type,
        signature_type    = :signature_type,
        signature_hash    = :signature_hash,
                device_id                   = :device_id,
                signed_at                   = :signed_at,
                longitude                   = :longitude,
                latitude                   = :latitude,
                inside_geofence   = :inside_geofence,
                is_verified           = :is_verified,
        is_synced         = :is_synced,
        time_stamp        = :time_stamp,
        updated_at        = :updated_at
    WHERE 
                signature_id = :signature_id`

        returnedValue, err := toDBSignature(p)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return sqldb.NamedExecContext(ctx, s.log, s.db, stmt, returnedValue)</span>
}

func (s *Store) Query(ctx context.Context,
        filter signaturebus.QueryFilter, orderBy order.By, page page.Page) ([]signaturebus.Signature, error) <span class="cov0" title="0">{
        data := map[string]any{
                "offset":        (page.Number() - 1) * page.RowsPerPage(),
                "rows_per_page": page.RowsPerPage(),
        }

        const q = `
    SELECT
            signature_id, 
                manifest_id,
                signed_by_id,
                event_type, 
            signature_type,
                signature_hash,
                device_id,
                signed_at,
                longitude,
                latitude,
                inside_geofence,
                is_verified,
                is_deleted,
            is_synced, 
                time_stamp, 
            created_at,
                updated_at 
    FROM 
                signature`

        var buf bytes.Buffer
        buf.WriteString(q)
        applyFilter(filter, data, &amp;buf)

        clause, err := orderByClause(orderBy)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">buf.WriteString(clause)
        buf.WriteString(" OFFSET :offset ROWS FETCH NEXT :rows_per_page ROWS ONLY")

        var dbRecs []signaturedb
        if err := sqldb.NamedQuerySlice(ctx, s.log, s.db, buf.String(), data, &amp;dbRecs); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("namedqueryslice: %w", err)
        }</span>
        <span class="cov0" title="0">return toBusSignatures(dbRecs)</span>
}

func (s *Store) QueryByID(ctx context.Context, signatureID uuid.UUID) (signaturebus.Signature, error) <span class="cov0" title="0">{
        param := map[string]any{
                "signature_id": signatureID.String(),
        }
        const stmt = `
    SELECT
            signature_id, 
                manifest_id,
                signed_by_id,
                event_type, 
            signature_type,
                signature_hash,
                device_id,
                signed_at,
                longitude,
                latitude,
                inside_geofence,
                is_verified,
                is_deleted,
            is_synced, 
                time_stamp, 
            created_at,
                updated_at
        FROM 
                  signature
        WHERE 
                  signature_id = :signature_id`

        var rec signaturedb
        if err := sqldb.NamedQueryStruct(ctx, s.log, s.db, stmt, param, &amp;rec); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sqldb.ErrDBNotFound) </span><span class="cov0" title="0">{
                        return signaturebus.Signature{}, fmt.Errorf("db: %w", pickupbatchbus.ErrNotFound)
                }</span>
                <span class="cov0" title="0">return signaturebus.Signature{}, fmt.Errorf("db: %w", err)</span>
        }
        <span class="cov0" title="0">return toBusSignature(rec)</span>
}

func (s *Store) Count(ctx context.Context, filter signaturebus.QueryFilter) (int, error) <span class="cov0" title="0">{
        data := map[string]any{}
        const base = `SELECT count(1) FROM signature`

        var buf bytes.Buffer
        buf.WriteString(base)
        applyFilter(filter, data, &amp;buf)

        var out struct {
                Count int `db:"count"`
        }
        if err := sqldb.NamedQueryStruct(ctx, s.log, s.db, buf.String(), data, &amp;out); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("db: %w", err)
        }</span>
        <span class="cov0" title="0">return out.Count, nil</span>
}

func (s *Store) SoftDelete(ctx context.Context, signatureID uuid.UUID) error <span class="cov0" title="0">{

        const q = `
    UPDATE
        signature
        SET
                is_deleted = :is_deleted
    WHERE
        signature_id = :signature_id`

        dbSignature := signaturedb{SignatureID: signatureID, IsDeleted: true}

        if err := sqldb.NamedExecContext(ctx, s.log, s.db, q, dbSignature); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("namedexeccontext: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *Store) HardDelete(ctx context.Context, signatureID uuid.UUID) error <span class="cov0" title="0">{
        const q = `
    DELETE FROM
        signature
    WHERE
        signature_id = :signature_id`

        dbSignature := signaturedb{SignatureID: signatureID}

        if err := sqldb.NamedExecContext(ctx, s.log, s.db, q, dbSignature); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("namedexeccontext: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">package signaturebus

import (
        "context"
        "fmt"
        "math/rand"
        "time"

        "github.com/FITHSCS/backend/business/types/facilitytype"
        "github.com/FITHSCS/backend/business/types/genstringtype"
        "github.com/google/uuid"
)

func TestGenerateNewSignature(n int, manID, sndbyID uuid.UUID) []NewSignature <span class="cov5" title="2">{
        newfs := make([]NewSignature, n)
        ecntype := []string{"pickup", "delivery"}
        signtype := []string{"PIN", "Freehand", "Fingerprint", "FaceID"}
        booleans := []bool{true, false}

        sndat, _ := time.Parse(time.RFC3339, "2025-06-10T15:59:33+03:00")
        timestamp := sndat.Add(time.Minute + 1)

        idx := rand.Intn(10000)
        for i := range n </span><span class="cov10" title="4">{
                idx++

                nf := NewSignature{
                        ManifestID:     manID,
                        SignedByID:     sndbyID,
                        EventType:      genstringtype.MustParse(ecntype[i%2]),
                        SignatureType:  genstringtype.MustParse(signtype[i%2]),
                        SignatureHash:  genstringtype.MustParse("q24cr98mq3vt9m9q4wrm9sdf3112"),
                        DeviceID:       genstringtype.MustParse(fmt.Sprintf("Device:%2d", idx)),
                        SignedAt:       sndat,
                        Longitude:      facilitytype.MustParseLong(38.739200592041016),
                        Latitude:       facilitytype.MustParseLat(9.019499778747559),
                        InsideGeofence: booleans[i%2],
                        IsVerified:     booleans[i%2],
                        IsSynced:       booleans[i%2],
                        TimeStamp:      timestamp,
                }

                newfs[i] = nf
        }</span>

        <span class="cov5" title="2">return newfs</span>
}

func TestGenerateSeedSignature(ctx context.Context, n int, api *Business, manID, sndbyID uuid.UUID) ([]Signature, error) <span class="cov5" title="2">{
        newfs := TestGenerateNewSignature(n, manID, sndbyID)

        facs := make([]Signature, len(newfs))
        for i, np := range newfs </span><span class="cov10" title="4">{
                prd, err := api.Create(ctx, np)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("seeding signature: idx: %d : %w", i, err)
                }</span>

                <span class="cov10" title="4">facs[i] = prd</span>
        }

        <span class="cov5" title="2">return facs, nil</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package syncbatchdb

import (
        //"database/sql"
        "fmt"
        //"net/mail"
        "time"

        "github.com/FITHSCS/backend/business/domain/syncbatchbus"

        //"github.com/FITHSCS/backend/business/sdk/sqldb/dbarray"
        "github.com/FITHSCS/backend/business/types/name"
        //"github.com/FITHSCS/backend/business/types/facilitytype"
        "github.com/google/uuid"
)

// &lt;=================== Struct that is going to be passed to database schema =&gt; //
type syncbatch struct {
        ID        uuid.UUID `db:"syncbatch_id"`
        BatchID   uuid.UUID `db:"batch_id"`
        DeviceID  uuid.UUID `db:"device_id"`
        EventID   uuid.UUID `db:"event_id"`
        TimeStamp time.Time `db:"time_stamp"`
        Status    string    `db:"status"`
        CreatedAt time.Time `db:"created_at"`
}

func toDBSyncBatch(bus syncbatchbus.SyncBatch) (syncbatch, error) <span class="cov0" title="0">{

        batchID, err := uuid.Parse(bus.BatchID.String())

        if err != nil </span><span class="cov0" title="0">{
                return syncbatch{}, err
        }</span>

        <span class="cov0" title="0">deviceID, err := uuid.Parse(bus.DeviceID.String())
        if err != nil </span><span class="cov0" title="0">{
                return syncbatch{}, err
        }</span>

        <span class="cov0" title="0">eventID, err := uuid.Parse(bus.EventID.String())
        if err != nil </span><span class="cov0" title="0">{
                return syncbatch{}, err
        }</span>

        <span class="cov0" title="0">return syncbatch{
                ID:        bus.ID,
                BatchID:   batchID,
                DeviceID:  deviceID,
                EventID:   eventID,
                TimeStamp: bus.TimeStamp.UTC(),
                Status:    bus.Status,
                CreatedAt: bus.CreatedAt.UTC(),
        }, nil</span>

}

func toBusSyncBatch(db syncbatch) (syncbatchbus.SyncBatch, error) <span class="cov0" title="0">{

        batchID, err := name.Parse(db.BatchID.String())
        if err != nil </span><span class="cov0" title="0">{
                return syncbatchbus.SyncBatch{}, fmt.Errorf("parse: %w", err)
        }</span>
        <span class="cov0" title="0">deviceID, err := name.Parse(db.DeviceID.String())
        if err != nil </span><span class="cov0" title="0">{
                return syncbatchbus.SyncBatch{}, fmt.Errorf("parse: %w", err)
        }</span>
        <span class="cov0" title="0">eventID, err := name.Parse(db.EventID.String())
        if err != nil </span><span class="cov0" title="0">{
                return syncbatchbus.SyncBatch{}, fmt.Errorf("parse: %w", err)
        }</span>
        <span class="cov0" title="0">status := db.Status

        bus := syncbatchbus.SyncBatch{

                ID:        db.ID,
                BatchID:   batchID,
                DeviceID:  deviceID,
                EventID:   eventID,
                TimeStamp: db.TimeStamp.In(time.Local),
                Status:    status,
                CreatedAt: db.CreatedAt.In(time.Local),
        }
        return bus, nil</span>
}
</pre>
		
		<pre class="file" id="file55" style="display: none">// Package syncbatchdb contains product related CRUD functionality.
package syncbatchdb

import (
        "context"
        "errors"
        "fmt"

        "github.com/FITHSCS/backend/business/domain/syncbatchbus"
        "github.com/FITHSCS/backend/business/sdk/sqldb"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/google/uuid"
        "github.com/jmoiron/sqlx"
)

type Store struct {
        log *logger.Logger
        db  sqlx.ExtContext
}

func NewStore(log *logger.Logger, db *sqlx.DB) *Store <span class="cov0" title="0">{
        return &amp;Store{log: log, db: db}
}</span>

func (s *Store) Create(ctx context.Context, sb syncbatchbus.SyncBatch) error <span class="cov0" title="0">{
        fmt.Println("YOOOOOOOOOO AM INSIDE HERE")
        fmt.Println(sb)
        fmt.Println("Database Instance: ", s.db)
        const stmt = `
        INSERT INTO syncbatch (
            syncbatch_id, batch_id, device_id, event_id,
            time_stamp, status, created_at
        ) VALUES (
            :syncbatch_id, :batch_id, :device_id,
            :event_id, :time_stamp, :status, :created_at
        )`

        returnedValue, err := toDBSyncBatch(sb)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">fmt.Printf("Final DB Payload: %+v\n", returnedValue)
        return sqldb.NamedExecContext(ctx, s.log, s.db, stmt, returnedValue)</span>
}

func (s *Store) QueryByID(ctx context.Context, id uuid.UUID) (syncbatchbus.SyncBatch, error) <span class="cov0" title="0">{

        param := map[string]any{
                "batch_id": id.String(),
        }
        fmt.Println("I am query ID: ", id)
        const stmt = `
          SELECT
        syncbatch_id,
        batch_id,
        device_id,
        event_id,
        time_stamp,
        status,
        created_at
        FROM syncbatch
        WHERE batch_id = :batch_id
      `
        var rec syncbatch
        if err := sqldb.NamedQueryStruct(ctx, s.log, s.db, stmt, param, &amp;rec); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sqldb.ErrDBNotFound) </span><span class="cov0" title="0">{
                        return syncbatchbus.SyncBatch{}, syncbatchbus.ErrNotFound
                }</span>
                <span class="cov0" title="0">return syncbatchbus.SyncBatch{}, err</span>
        }
        <span class="cov0" title="0">return toBusSyncBatch(rec)</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">// Package syncbatchbus provides business access to syncbatch bus domain.
package syncbatchbus

import (
        "context"
        "errors"
        "fmt"
        "time"

        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/google/uuid"
)

var (
        ErrNotFound       = errors.New("packagedetail not found")
        ErrAuthentication = errors.New("authentication failed")
)

type Storer interface {
        Create(ctx context.Context, syncbatch SyncBatch) error
        QueryByID(ctx context.Context, syncbatchID uuid.UUID) (SyncBatch, error)
}

func (b *Business) GetStorer() Storer <span class="cov0" title="0">{
        return b.storer
}</span>

type Business struct {
        log    *logger.Logger
        storer Storer
}

func NewBusiness(log *logger.Logger, storer Storer) *Business <span class="cov0" title="0">{

        return &amp;Business{
                log:    log,
                storer: storer,
        }
}</span>

func (b *Business) Create(ctx context.Context, sb NewSyncBatch) (SyncBatch, error) <span class="cov0" title="0">{

        now := time.Now()

        syncbatch := SyncBatch{
                ID:        uuid.New(),
                BatchID:   sb.BatchID,
                DeviceID:  sb.DeviceID,
                EventID:   sb.EventID,
                TimeStamp: now,
                Status:    sb.Status,
                CreatedAt: now,
        }
        if err := b.storer.Create(ctx, syncbatch); err != nil </span><span class="cov0" title="0">{
                return SyncBatch{}, fmt.Errorf("Create: %w", err)
        }</span>
        <span class="cov0" title="0">return syncbatch, nil</span>
}

func (b *Business) QueryByID(ctx context.Context, syncbatchID uuid.UUID) (SyncBatch, error) <span class="cov0" title="0">{

        syncBatch, err := b.storer.QueryByID(ctx, syncbatchID)
        if err != nil </span><span class="cov0" title="0">{
                return SyncBatch{}, err
        }</span>
        <span class="cov0" title="0">return syncBatch, nil</span>
}
</pre>
		
		<pre class="file" id="file57" style="display: none">// Package useraudit provides an extension for userbus that adds
// auditing functionality.
package useraudit

import (
        "context"
        "net/mail"

        "github.com/FITHSCS/backend/business/domain/auditbus"
        "github.com/FITHSCS/backend/business/domain/userbus"
        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/business/types/domain"
        "github.com/FITHSCS/backend/business/types/facilitytype"
        "github.com/google/uuid"
)

// Extension provides a wrapper for audit functionality around the userbus.
type Extension struct {
        bus      userbus.ExtBusiness
        auditBus *auditbus.Business
}

// NewExtension constructs a new extension that wraps the userbus with audit.
func NewExtension(auditBus *auditbus.Business) userbus.Extension <span class="cov0" title="0">{
        return func(bus userbus.ExtBusiness) userbus.ExtBusiness </span><span class="cov0" title="0">{
                return &amp;Extension{
                        bus:      bus,
                        auditBus: auditBus,
                }
        }</span>
}

// Create applies auditing to the user creation process.
func (ext *Extension) Create(ctx context.Context, actorID uuid.UUID, nu userbus.NewUser) (userbus.User, error) <span class="cov0" title="0">{
        usr, err := ext.bus.Create(ctx, actorID, nu)
        if err != nil </span><span class="cov0" title="0">{
                return userbus.User{}, err
        }</span>

        <span class="cov0" title="0">na := auditbus.NewAudit{
                ObjID:     usr.ID,
                ObjDomain: domain.User,
                ObjName:   usr.Name,
                ActorID:   actorID,
                Action:    "created",
                Data:      nu,
                Message:   "user created",
        }

        if _, err := ext.auditBus.Create(ctx, na); err != nil </span><span class="cov0" title="0">{
                return userbus.User{}, err
        }</span>

        <span class="cov0" title="0">return usr, nil</span>
}

// Update applies auditing to the user update process.
func (ext *Extension) Update(ctx context.Context, actorID uuid.UUID, usr userbus.User, uu userbus.UpdateUser) (userbus.User, error) <span class="cov0" title="0">{
        usr, err := ext.bus.Update(ctx, actorID, usr, uu)
        if err != nil </span><span class="cov0" title="0">{
                return userbus.User{}, err
        }</span>

        <span class="cov0" title="0">na := auditbus.NewAudit{
                ObjID:     usr.ID,
                ObjDomain: domain.User,
                ObjName:   usr.Name,
                ActorID:   actorID,
                Action:    "updated",
                Data:      uu,
                Message:   "user updated",
        }

        if _, err := ext.auditBus.Create(ctx, na); err != nil </span><span class="cov0" title="0">{
                return userbus.User{}, err
        }</span>

        <span class="cov0" title="0">return usr, nil</span>
}

// Delete applies auditing to the user deletion process.
func (ext *Extension) Delete(ctx context.Context, actorID uuid.UUID, usr userbus.User) error <span class="cov0" title="0">{
        if err := ext.bus.Delete(ctx, actorID, usr); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">na := auditbus.NewAudit{
                ObjID:     usr.ID,
                ObjDomain: domain.User,
                ObjName:   usr.Name,
                ActorID:   actorID,
                Action:    "deleted",
                Data:      nil,
                Message:   "user deleted",
        }

        if _, err := ext.auditBus.Create(ctx, na); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Query does not apply auditing.
func (ext *Extension) Query(ctx context.Context, filter userbus.QueryFilter, orderBy order.By, page page.Page) ([]userbus.User, error) <span class="cov0" title="0">{
        return ext.bus.Query(ctx, filter, orderBy, page)
}</span>

// Count does not apply auditing.
func (ext *Extension) Count(ctx context.Context, filter userbus.QueryFilter) (int, error) <span class="cov0" title="0">{
        return ext.bus.Count(ctx, filter)
}</span>

// QueryByID does not apply auditing.
func (ext *Extension) QueryByID(ctx context.Context, userID uuid.UUID) (userbus.User, error) <span class="cov0" title="0">{
        return ext.bus.QueryByID(ctx, userID)
}</span>

// QueryByEmail does not apply auditing.
func (ext *Extension) QueryByEmail(ctx context.Context, email mail.Address) (userbus.User, error) <span class="cov0" title="0">{
        return ext.bus.QueryByEmail(ctx, email)
}</span>

// QueryByPhone does not apply auditing.
func (ext *Extension) QueryByPhone(ctx context.Context, phone facilitytype.PhoneNumber) (userbus.User, error) <span class="cov0" title="0">{
        return ext.bus.QueryByPhone(ctx, phone)
}</span>

// Authenticate does not apply auditing.
func (ext *Extension) Authenticate(ctx context.Context, phone facilitytype.PhoneNumber, password string) (userbus.User, error) <span class="cov0" title="0">{
        return ext.bus.Authenticate(ctx, phone, password)
}</span>
</pre>
		
		<pre class="file" id="file58" style="display: none">// Package usercache contains user related CRUD functionality with caching.
package usercache

import (
        "context"
        "net/mail"
        "time"

        "github.com/FITHSCS/backend/business/domain/userbus"
        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/business/types/facilitytype"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/google/uuid"
        "github.com/viccon/sturdyc"
)

// Store manages the set of APIs for user data and caching.
type Store struct {
        log    *logger.Logger
        storer userbus.Storer
        cache  *sturdyc.Client[userbus.User]
}

// NewStore constructs the api for data and caching access.
func NewStore(log *logger.Logger, storer userbus.Storer, ttl time.Duration) *Store <span class="cov0" title="0">{
        const capacity = 10000
        const numShards = 10
        const evictionPercentage = 10

        return &amp;Store{
                log:    log,
                storer: storer,
                cache:  sturdyc.New[userbus.User](capacity, numShards, ttl, evictionPercentage),
        }
}</span>

// Create inserts a new user into the database.
func (s *Store) Create(ctx context.Context, usr userbus.User) error <span class="cov0" title="0">{
        if err := s.storer.Create(ctx, usr); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">s.writeCache(usr)

        return nil</span>
}

// Update replaces a user document in the database.
func (s *Store) Update(ctx context.Context, usr userbus.User) error <span class="cov0" title="0">{
        if err := s.storer.Update(ctx, usr); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">s.writeCache(usr)

        return nil</span>
}

// Delete removes a user from the database.
func (s *Store) Delete(ctx context.Context, usr userbus.User) error <span class="cov0" title="0">{
        if err := s.storer.Delete(ctx, usr); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">s.deleteCache(usr)

        return nil</span>
}

// Query retrieves a list of existing users from the database.
func (s *Store) Query(ctx context.Context, filter userbus.QueryFilter, orderBy order.By, page page.Page) ([]userbus.User, error) <span class="cov0" title="0">{
        return s.storer.Query(ctx, filter, orderBy, page)
}</span>

// Count returns the total number of cards in the DB.
func (s *Store) Count(ctx context.Context, filter userbus.QueryFilter) (int, error) <span class="cov0" title="0">{
        return s.storer.Count(ctx, filter)
}</span>

// QueryByID gets the specified user from the database.
func (s *Store) QueryByID(ctx context.Context, userID uuid.UUID) (userbus.User, error) <span class="cov0" title="0">{
        cachedUsr, ok := s.readCache(userID.String())
        if ok </span><span class="cov0" title="0">{
                return cachedUsr, nil
        }</span>

        <span class="cov0" title="0">usr, err := s.storer.QueryByID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return userbus.User{}, err
        }</span>

        <span class="cov0" title="0">s.writeCache(usr)

        return usr, nil</span>
}

// QueryByEmail gets the specified user from the database by email.
func (s *Store) QueryByEmail(ctx context.Context, email mail.Address) (userbus.User, error) <span class="cov0" title="0">{
        cachedUsr, ok := s.readCache(email.Address)
        if ok </span><span class="cov0" title="0">{
                return cachedUsr, nil
        }</span>

        <span class="cov0" title="0">usr, err := s.storer.QueryByEmail(ctx, email)
        if err != nil </span><span class="cov0" title="0">{
                return userbus.User{}, err
        }</span>

        <span class="cov0" title="0">s.writeCache(usr)

        return usr, nil</span>
}

// QueryByPhone gets the specified user from the database by email.
func (s *Store) QueryByPhone(ctx context.Context, phone facilitytype.PhoneNumber) (userbus.User, error) <span class="cov0" title="0">{
        cachedUsr, ok := s.readCache(phone.String())
        if ok </span><span class="cov0" title="0">{
                return cachedUsr, nil
        }</span>

        <span class="cov0" title="0">usr, err := s.storer.QueryByPhone(ctx, phone)
        if err != nil </span><span class="cov0" title="0">{
                return userbus.User{}, err
        }</span>

        <span class="cov0" title="0">s.writeCache(usr)

        return usr, nil</span>
}

// readCache performs a safe search in the cache for the specified key.
func (s *Store) readCache(key string) (userbus.User, bool) <span class="cov0" title="0">{
        usr, exists := s.cache.Get(key)
        if !exists </span><span class="cov0" title="0">{
                return userbus.User{}, false
        }</span>

        <span class="cov0" title="0">return usr, true</span>
}

// writeCache performs a safe write to the cache for the specified userbus.
func (s *Store) writeCache(bus userbus.User) <span class="cov0" title="0">{
        s.cache.Set(bus.ID.String(), bus)
        s.cache.Set(bus.Email.Address, bus)
}</span>

// deleteCache performs a safe removal from the cache for the specified userbus.
func (s *Store) deleteCache(bus userbus.User) <span class="cov0" title="0">{
        s.cache.Delete(bus.ID.String())
        s.cache.Delete(bus.Email.Address)
}</span>
</pre>
		
		<pre class="file" id="file59" style="display: none">package userdb

import (
        "bytes"
        "fmt"
        "strings"

        "github.com/FITHSCS/backend/business/domain/userbus"
        "github.com/google/uuid"
)

func applyFilter(filter userbus.QueryFilter, data map[string]any, buf *bytes.Buffer) <span class="cov0" title="0">{
        var wc []string

        if filter.ID != uuid.Nil </span><span class="cov0" title="0">{
                data["user_id"] = &amp;filter.ID
                wc = append(wc, "user_id = :user_id")
        }</span>

        <span class="cov0" title="0">if filter.Name != nil </span><span class="cov0" title="0">{
                data["name"] = fmt.Sprintf("%%%s%%", *filter.Name)
                wc = append(wc, "name LIKE :name")
        }</span>

        <span class="cov0" title="0">if filter.Email != nil </span><span class="cov0" title="0">{
                data["email"] = (*filter.Email).String()
                wc = append(wc, "email = :email")
        }</span>

        <span class="cov0" title="0">if filter.Phone != nil </span><span class="cov0" title="0">{
                data["phone"] = (*filter.Email).String()
                wc = append(wc, "phone = :phone")
        }</span>

        <span class="cov0" title="0">if filter.StartCreatedDate != nil </span><span class="cov0" title="0">{
                data["start_date_created"] = filter.StartCreatedDate.UTC()
                wc = append(wc, "created_at &gt;= :start_date_created")
        }</span>

        <span class="cov0" title="0">if filter.EndCreatedDate != nil </span><span class="cov0" title="0">{
                data["end_date_created"] = filter.EndCreatedDate.UTC()
                wc = append(wc, "created_at &lt;= :end_date_created")
        }</span>

        <span class="cov0" title="0">if len(wc) &gt; 0 </span><span class="cov0" title="0">{
                buf.WriteString(" WHERE ")
                buf.WriteString(strings.Join(wc, " AND "))
        }</span>
}
</pre>
		
		<pre class="file" id="file60" style="display: none">package userdb

import (
        "database/sql"
        "fmt"
        "net/mail"
        "time"

        "github.com/FITHSCS/backend/business/domain/userbus"
        "github.com/FITHSCS/backend/business/sdk/sqldb/dbarray"
        "github.com/FITHSCS/backend/business/types/facilitytype"
        "github.com/FITHSCS/backend/business/types/name"
        "github.com/FITHSCS/backend/business/types/role"
        "github.com/google/uuid"
)

type user struct {
        ID           uuid.UUID      `db:"user_id"`
        Name         string         `db:"name"`
        Email        string         `db:"email"`
        Phone        string         `db:"phone"`
        Roles        dbarray.String `db:"roles"`
        PasswordHash []byte         `db:"password_hash"`
        Department   sql.NullString `db:"department"`
        Enabled      bool           `db:"enabled"`
        DateCreated  time.Time      `db:"created_at"`
        DateUpdated  time.Time      `db:"updated_at"`
}

func toDBUser(bus userbus.User) user <span class="cov0" title="0">{
        return user{
                ID:           bus.ID,
                Name:         bus.Name.String(),
                Email:        bus.Email.Address,
                Phone:        bus.Phone.String(),
                Roles:        role.ParseToString(bus.Roles),
                PasswordHash: bus.PasswordHash,
                Department: sql.NullString{
                        String: bus.Department.String(),
                        Valid:  bus.Department.Valid(),
                },
                Enabled:     bus.Enabled,
                DateCreated: bus.DateCreated.UTC(),
                DateUpdated: bus.DateUpdated.UTC(),
        }
}</span>

func toBusUser(db user) (userbus.User, error) <span class="cov0" title="0">{
        addr := mail.Address{
                Address: db.Email,
        }

        roles, err := role.ParseMany(db.Roles)
        if err != nil </span><span class="cov0" title="0">{
                return userbus.User{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">nme, err := name.Parse(db.Name)
        if err != nil </span><span class="cov0" title="0">{
                return userbus.User{}, fmt.Errorf("parse name: %w", err)
        }</span>

        <span class="cov0" title="0">department, err := name.ParseNull(db.Department.String)
        if err != nil </span><span class="cov0" title="0">{
                return userbus.User{}, fmt.Errorf("parse department: %w", err)
        }</span>

        <span class="cov0" title="0">pne, err := facilitytype.ParsePhoneNumber(db.Phone)
        if err != nil </span><span class="cov0" title="0">{
                return userbus.User{}, fmt.Errorf("parse phonenum: %w", err)
        }</span>

        <span class="cov0" title="0">bus := userbus.User{
                ID:           db.ID,
                Name:         nme,
                Email:        addr,
                Phone:        pne,
                Roles:        roles,
                PasswordHash: db.PasswordHash,
                Enabled:      db.Enabled,
                Department:   department,
                DateCreated:  db.DateCreated.In(time.Local),
                DateUpdated:  db.DateUpdated.In(time.Local),
        }

        return bus, nil</span>
}

func toBusUsers(dbs []user) ([]userbus.User, error) <span class="cov0" title="0">{
        bus := make([]userbus.User, len(dbs))

        for i, db := range dbs </span><span class="cov0" title="0">{
                var err error
                bus[i], err = toBusUser(db)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">return bus, nil</span>
}
</pre>
		
		<pre class="file" id="file61" style="display: none">package userdb

import (
        "fmt"

        "github.com/FITHSCS/backend/business/domain/userbus"
        "github.com/FITHSCS/backend/business/sdk/order"
)

var orderByFields = map[string]string{
        userbus.OrderByID:      "user_id",
        userbus.OrderByName:    "name",
        userbus.OrderByEmail:   "email",
        userbus.OrderByPhone:   "phone",
        userbus.OrderByRoles:   "roles",
        userbus.OrderByEnabled: "enabled",
}

func orderByClause(orderBy order.By) (string, error) <span class="cov0" title="0">{
        by, exists := orderByFields[orderBy.Field]
        if !exists </span><span class="cov0" title="0">{
                return "", fmt.Errorf("field %q does not exist", orderBy.Field)
        }</span>

        <span class="cov0" title="0">return " ORDER BY " + by + " " + orderBy.Direction, nil</span>
}
</pre>
		
		<pre class="file" id="file62" style="display: none">// Package userdb contains product related CRUD functionality.
package userdb

import (
        "bytes"
        "context"
        "errors"
        "fmt"
        "net/mail"

        "github.com/FITHSCS/backend/business/domain/userbus"
        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/business/sdk/sqldb"
        "github.com/FITHSCS/backend/business/types/facilitytype"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/google/uuid"
        "github.com/jmoiron/sqlx"
)

// Store manages the set of APIs for user database access.
type Store struct {
        log *logger.Logger
        db  sqlx.ExtContext
}

// NewStore constructs the api for data access.
func NewStore(log *logger.Logger, db *sqlx.DB) *Store <span class="cov0" title="0">{
        return &amp;Store{
                log: log,
                db:  db,
        }
}</span>

// Create inserts a new user into the database.
func (s *Store) Create(ctx context.Context, usr userbus.User) error <span class="cov0" title="0">{
        const query = `
        INSERT INTO users
                (user_id, name, email, phone, password_hash, roles, department, enabled, created_at, updated_at)
        VALUES
                (:user_id, :name, :email, :phone, :password_hash, :roles, :department, :enabled, :created_at, :updated_at)`

        if err := sqldb.NamedExecContext(ctx, s.log, s.db, query, toDBUser(usr)); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sqldb.ErrDBDuplicatedEntry) </span><span class="cov0" title="0">{
                        return fmt.Errorf("creation Error: %w", userbus.ErrUniqueEmail)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("namedexeccontext: %w", err)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Update replaces a user document in the database.
func (s *Store) Update(ctx context.Context, usr userbus.User) error <span class="cov0" title="0">{
        const q = `
        UPDATE
                users
        SET 
                "name" = :name,
                "email" = :email,
                "phone" = :phone,
                "roles" = :roles,
                "password_hash" = :password_hash,
                "department" = :department,
                "enabled" = :enabled,
                "updated_at" = :updated_at
        WHERE
                user_id = :user_id`

        if err := sqldb.NamedExecContext(ctx, s.log, s.db, q, toDBUser(usr)); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sqldb.ErrDBDuplicatedEntry) </span><span class="cov0" title="0">{
                        return userbus.ErrUniqueEmail
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("namedexeccontext: %w", err)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Delete removes a user from the database.
func (s *Store) Delete(ctx context.Context, usr userbus.User) error <span class="cov0" title="0">{
        const q = `
        DELETE FROM
                users
        WHERE
                user_id = :user_id`

        if err := sqldb.NamedExecContext(ctx, s.log, s.db, q, toDBUser(usr)); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("namedexeccontext: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Query retrieves a list of existing users from the database.
func (s *Store) Query(ctx context.Context, filter userbus.QueryFilter, orderBy order.By, page page.Page) ([]userbus.User, error) <span class="cov0" title="0">{
        data := map[string]any{
                "offset":        (page.Number() - 1) * page.RowsPerPage(),
                "rows_per_page": page.RowsPerPage(),
        }

        const q = `
        SELECT
                user_id, name, email, phone, password_hash, roles, department, enabled, created_at, updated_at
        FROM
                users`

        buf := bytes.NewBufferString(q)
        applyFilter(filter, data, buf)

        orderByClause, err := orderByClause(orderBy)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">buf.WriteString(orderByClause)
        buf.WriteString(" OFFSET :offset ROWS FETCH NEXT :rows_per_page ROWS ONLY")

        var dbUsrs []user
        if err := sqldb.NamedQuerySlice(ctx, s.log, s.db, buf.String(), data, &amp;dbUsrs); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("namedqueryslice: %w", err)
        }</span>

        <span class="cov0" title="0">return toBusUsers(dbUsrs)</span>
}

// Count returns the total number of users in the DB.
func (s *Store) Count(ctx context.Context, filter userbus.QueryFilter) (int, error) <span class="cov0" title="0">{
        data := map[string]any{}

        const q = `
        SELECT
                count(1)
        FROM
                users`

        buf := bytes.NewBufferString(q)
        applyFilter(filter, data, buf)

        var count struct {
                Count int `db:"count"`
        }
        if err := sqldb.NamedQueryStruct(ctx, s.log, s.db, buf.String(), data, &amp;count); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("db: %w", err)
        }</span>

        <span class="cov0" title="0">return count.Count, nil</span>
}

// QueryByID gets the specified user from the database.
func (s *Store) QueryByID(ctx context.Context, userID uuid.UUID) (userbus.User, error) <span class="cov0" title="0">{
        data := struct {
                ID string `db:"user_id"`
        }{
                ID: userID.String(),
        }

        const q = `
        SELECT
        user_id, name, email, phone ,password_hash, roles, department, enabled, created_at, updated_at
        FROM
                users
        WHERE 
                user_id = :user_id`

        var dbUsr user
        if err := sqldb.NamedQueryStruct(ctx, s.log, s.db, q, data, &amp;dbUsr); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sqldb.ErrDBNotFound) </span><span class="cov0" title="0">{
                        return userbus.User{}, fmt.Errorf("db: %w", userbus.ErrNotFound)
                }</span>
                <span class="cov0" title="0">return userbus.User{}, fmt.Errorf("db: %w", err)</span>
        }

        <span class="cov0" title="0">return toBusUser(dbUsr)</span>
}

// QueryByEmail gets the specified user from the database by email.
func (s *Store) QueryByEmail(ctx context.Context, email mail.Address) (userbus.User, error) <span class="cov0" title="0">{
        data := struct {
                Email string `db:"email"`
        }{
                Email: email.Address,
        }

        const q = `
        SELECT
        user_id, name, email, phone, password_hash, roles, department, enabled, created_at, updated_at
        FROM
                users
        WHERE
                email = :email`

        var dbUsr user
        if err := sqldb.NamedQueryStruct(ctx, s.log, s.db, q, data, &amp;dbUsr); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sqldb.ErrDBNotFound) </span><span class="cov0" title="0">{
                        return userbus.User{}, fmt.Errorf("db: %w", userbus.ErrNotFound)
                }</span>
                <span class="cov0" title="0">return userbus.User{}, fmt.Errorf("db: %w", err)</span>
        }

        <span class="cov0" title="0">return toBusUser(dbUsr)</span>
}

// QueryByPhone gets the specified user from the database by email.
func (s *Store) QueryByPhone(ctx context.Context, phone facilitytype.PhoneNumber) (userbus.User, error) <span class="cov0" title="0">{
        data := struct {
                Phone string `db:"phone"`
        }{
                Phone: phone.String(),
        }

        const q = `
        SELECT
        user_id, name, email, phone, password_hash, roles, department, enabled, created_at, updated_at
        FROM
                users
        WHERE
                phone = :phone`

        var dbUsr user
        if err := sqldb.NamedQueryStruct(ctx, s.log, s.db, q, data, &amp;dbUsr); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sqldb.ErrDBNotFound) </span><span class="cov0" title="0">{
                        return userbus.User{}, fmt.Errorf("db: %w", userbus.ErrNotFound)
                }</span>
                <span class="cov0" title="0">return userbus.User{}, fmt.Errorf("db: %w", err)</span>
        }

        <span class="cov0" title="0">return toBusUser(dbUsr)</span>
}
</pre>
		
		<pre class="file" id="file63" style="display: none">package userbus

import (
        "context"
        "fmt"
        "math/rand"
        "net/mail"

        "github.com/FITHSCS/backend/business/types/facilitytype"
        "github.com/FITHSCS/backend/business/types/name"
        "github.com/FITHSCS/backend/business/types/role"
        "github.com/google/uuid"
)

func TestNewUsers(n int, rle role.Role) []NewUser <span class="cov5" title="2">{
        newUsrs := make([]NewUser, n)

        idx := rand.Intn(10000)
        for i := range n </span><span class="cov10" title="4">{
                idx++

                nu := NewUser{
                        Name:       name.MustParse(fmt.Sprintf("Name%d", idx)),
                        Email:      mail.Address{Address: fmt.Sprintf("mail%d@gmail.com", idx)},
                        Phone:      facilitytype.MustParsePhoneNumber(fmt.Sprintf("092233%04d", idx)),
                        Roles:      []role.Role{rle},
                        Department: name.MustParseNull(fmt.Sprintf("Department%d", idx)),
                        Password:   fmt.Sprintf("Password%d", idx),
                }

                newUsrs[i] = nu
        }</span>

        <span class="cov5" title="2">return newUsrs</span>
}

// TestSeedUsers is a helper method for testing.
func TestSeedUsers(ctx context.Context, n int, role role.Role, api ExtBusiness) ([]User, error) <span class="cov5" title="2">{
        newUsrs := TestNewUsers(n, role)

        usrs := make([]User, len(newUsrs))
        for i, nu := range newUsrs </span><span class="cov10" title="4">{
                usr, err := api.Create(ctx, uuid.UUID{}, nu)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("seeding user: idx: %d : %w", i, err)
                }</span>
                <span class="cov10" title="4">usrs[i] = usr</span>
        }

        <span class="cov5" title="2">return usrs, nil</span>
}
</pre>
		
		<pre class="file" id="file64" style="display: none">// Package userbus provides business access to user domain.
package userbus

import (
        "context"
        "errors"
        "fmt"
        "net/mail"
        "time"

        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/business/types/facilitytype"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/google/uuid"
        "golang.org/x/crypto/bcrypt"
)

// Set of error variables for CRUD operations.
var (
        ErrNotFound              = errors.New("user not found")
        ErrUniqueEmail           = errors.New("email is not unique")
        ErrAuthenticationFailure = errors.New("authentication failed")
)

// Storer interface declares the behavior this package needs to persist and
// retrieve data.
type Storer interface {
        Create(ctx context.Context, usr User) error
        Update(ctx context.Context, usr User) error
        Delete(ctx context.Context, usr User) error
        Query(ctx context.Context, filter QueryFilter, orderBy order.By, page page.Page) ([]User, error)
        Count(ctx context.Context, filter QueryFilter) (int, error)
        QueryByID(ctx context.Context, userID uuid.UUID) (User, error)
        QueryByEmail(ctx context.Context, email mail.Address) (User, error)
        QueryByPhone(ctx context.Context, pgone facilitytype.PhoneNumber) (User, error)
}

// ExtBusiness interface provides support for extensions that wrap extra functionality
// around the core busines logic.
type ExtBusiness interface {
        Create(ctx context.Context, actorID uuid.UUID, nu NewUser) (User, error)
        Update(ctx context.Context, actorID uuid.UUID, usr User, uu UpdateUser) (User, error)
        Delete(ctx context.Context, actorID uuid.UUID, usr User) error
        Query(ctx context.Context, filter QueryFilter, orderBy order.By, page page.Page) ([]User, error)
        Count(ctx context.Context, filter QueryFilter) (int, error)
        QueryByID(ctx context.Context, userID uuid.UUID) (User, error)
        QueryByEmail(ctx context.Context, email mail.Address) (User, error)
        QueryByPhone(ctx context.Context, phone facilitytype.PhoneNumber) (User, error)
        Authenticate(ctx context.Context, phone facilitytype.PhoneNumber, password string) (User, error)
}

// Extension is a function that wraps a new layer of business logic
// around the existing business logic.
type Extension func(ExtBusiness) ExtBusiness

// Business manages the set of APIs for user access.
type Business struct {
        log    *logger.Logger
        storer Storer
}

// NewBusiness constructs a user business API for use.
func NewBusiness(log *logger.Logger, storer Storer, extensions ...Extension) ExtBusiness <span class="cov1" title="1">{

        b := ExtBusiness(&amp;Business{
                log:    log,
                storer: storer,
        })

        for i := len(extensions) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                ext := extensions[i]
                if ext != nil </span><span class="cov0" title="0">{
                        b = ext(b)
                }</span>
        }

        <span class="cov1" title="1">return b</span>
}

// Create adds a new user to the system.
func (b *Business) Create(ctx context.Context, actorID uuid.UUID, nu NewUser) (User, error) <span class="cov10" title="5">{
        hash, err := bcrypt.GenerateFromPassword([]byte(nu.Password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return User{}, fmt.Errorf("generatefrompassword: %w", err)
        }</span>
        <span class="cov10" title="5">now := time.Now().Truncate(time.Microsecond)

        usr := User{
                ID:           uuid.New(),
                Name:         nu.Name,
                Email:        nu.Email,
                Phone:        nu.Phone,
                Roles:        nu.Roles,
                PasswordHash: hash,
                Department:   nu.Department,
                Enabled:      true,
                DateCreated:  now,
                DateUpdated:  now,
        }

        if err := b.storer.Create(ctx, usr); err != nil </span><span class="cov0" title="0">{
                return User{}, fmt.Errorf("create: %w", err)
        }</span>

        <span class="cov10" title="5">return usr, nil</span>
}

// Update modifies information about a user.
func (b *Business) Update(ctx context.Context, actorID uuid.UUID, usr User, uu UpdateUser) (User, error) <span class="cov1" title="1">{
        if uu.Name != nil </span><span class="cov1" title="1">{
                usr.Name = *uu.Name
        }</span>

        <span class="cov1" title="1">if uu.Email != nil </span><span class="cov1" title="1">{
                usr.Email = *uu.Email
        }</span>

        <span class="cov1" title="1">if uu.Phone != nil </span><span class="cov0" title="0">{
                usr.Phone = *uu.Phone
        }</span>

        <span class="cov1" title="1">if uu.Roles != nil </span><span class="cov1" title="1">{
                usr.Roles = uu.Roles
        }</span>

        <span class="cov1" title="1">if uu.Password != nil </span><span class="cov1" title="1">{
                pw, err := bcrypt.GenerateFromPassword([]byte(*uu.Password), bcrypt.DefaultCost)
                if err != nil </span><span class="cov0" title="0">{
                        return User{}, fmt.Errorf("generatefrompassword: %w", err)
                }</span>
                <span class="cov1" title="1">usr.PasswordHash = pw</span>
        }

        <span class="cov1" title="1">if uu.Department != nil </span><span class="cov1" title="1">{
                usr.Department = *uu.Department
        }</span>

        <span class="cov1" title="1">if uu.Enabled != nil </span><span class="cov0" title="0">{
                usr.Enabled = *uu.Enabled
        }</span>

        <span class="cov1" title="1">usr.DateUpdated = time.Now().Truncate(time.Microsecond)

        if err := b.storer.Update(ctx, usr); err != nil </span><span class="cov0" title="0">{
                return User{}, fmt.Errorf("update: %w", err)
        }</span>

        <span class="cov1" title="1">return usr, nil</span>
}

// Delete removes the specified user.
func (b *Business) Delete(ctx context.Context, actorID uuid.UUID, usr User) error <span class="cov4" title="2">{
        if err := b.storer.Delete(ctx, usr); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("delete: %w", err)
        }</span>

        <span class="cov4" title="2">return nil</span>
}

// Query retrieves a list of existing users.
func (b *Business) Query(ctx context.Context, filter QueryFilter, orderBy order.By, page page.Page) ([]User, error) <span class="cov1" title="1">{
        users, err := b.storer.Query(ctx, filter, orderBy, page)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("query: %w", err)
        }</span>

        <span class="cov1" title="1">return users, nil</span>
}

// Count returns the total number of users.
func (b *Business) Count(ctx context.Context, filter QueryFilter) (int, error) <span class="cov0" title="0">{
        return b.storer.Count(ctx, filter)
}</span>

// QueryByID finds the user by the specified ID.
func (b *Business) QueryByID(ctx context.Context, userID uuid.UUID) (User, error) <span class="cov0" title="0">{
        user, err := b.storer.QueryByID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return User{}, fmt.Errorf("query: userID[%s]: %w", userID, err)
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}

// QueryByEmail finds the user by a specified user email.
func (b *Business) QueryByEmail(ctx context.Context, email mail.Address) (User, error) <span class="cov0" title="0">{
        user, err := b.storer.QueryByEmail(ctx, email)
        if err != nil </span><span class="cov0" title="0">{
                return User{}, fmt.Errorf("query: email[%s]: %w", email, err)
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}

// QueryByPhone finds the user by a specified user email.
func (b *Business) QueryByPhone(ctx context.Context, pne facilitytype.PhoneNumber) (User, error) <span class="cov0" title="0">{
        user, err := b.storer.QueryByPhone(ctx, pne)
        if err != nil </span><span class="cov0" title="0">{
                return User{}, fmt.Errorf("query: phone number[%s]: %w", pne, err)
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}

// Authenticate finds a user by their email and verifies their password. On
// success it returns a Claims User representing this user. The claims can be
// used to generate a token for future authentication.
func (b *Business) Authenticate(ctx context.Context, phone facilitytype.PhoneNumber, password string) (User, error) <span class="cov0" title="0">{
        usr, err := b.QueryByPhone(ctx, phone)
        if err != nil </span><span class="cov0" title="0">{
                return User{}, fmt.Errorf("query: phone[%s]: %w", phone, err)
        }</span>

        <span class="cov0" title="0">if err := bcrypt.CompareHashAndPassword(usr.PasswordHash, []byte(password)); err != nil </span><span class="cov0" title="0">{
                return User{}, fmt.Errorf("comparehashandpassword: %w", ErrAuthenticationFailure)
        }</span>

        <span class="cov0" title="0">return usr, nil</span>
}
</pre>
		
		<pre class="file" id="file65" style="display: none">package vehicledb


import (
        "bytes"
        "fmt"
        "strings"

        "github.com/FITHSCS/backend/business/domain/vehiclebus"
        "github.com/google/uuid"
)
func applyFilter(filter vehiclebus.QueryFilter, data map[string]any, buf *bytes.Buffer) <span class="cov0" title="0">{

    var wc []string

    if filter.ID != uuid.Nil </span><span class="cov0" title="0">{
        data["vehicle_id"] = &amp;filter.ID
        wc = append(wc, "vehicle_id = :vehicle_id")
    }</span>
    <span class="cov0" title="0">if filter.PlateNumber != nil </span><span class="cov0" title="0">{
                  data["plate_number"] = fmt.Sprintf("%%%s%%", *filter.PlateNumber)
                  wc = append(wc, "plate_number LIKE :plate_number")
          }</span>
          <span class="cov0" title="0">if filter.VehicleType != nil </span><span class="cov0" title="0">{
                  data["vehicle_type"] = *filter.VehicleType
                  wc = append(wc, "vehicle_type = :vehicle_type")
          }</span>
          <span class="cov0" title="0">if filter.WeightCapacity != nil </span><span class="cov0" title="0">{
                  data["weight_capacity"] = fmt.Sprintf("%%%s%%", *filter.WeightCapacity)
                  wc = append(wc, "weight_capacity LIKE :weight_capacity")
          }</span>

          <span class="cov0" title="0">if filter.VolumeCapacity != nil </span><span class="cov0" title="0">{
                  data["volume_capacity"] = fmt.Sprintf("%%%s%%", *filter.VolumeCapacity)
      wc = append(wc, "volume_capacity LIKE :volume_capacity")
          }</span>
 
    
    <span class="cov0" title="0">if filter.CurrentStatus != nil </span><span class="cov0" title="0">{
        data["current_status"] = *filter.CurrentStatus
        wc = append(wc, "current_status = :current_status")
    }</span>
    
    <span class="cov0" title="0">if filter.CreatedAt != nil </span><span class="cov0" title="0">{
      data["created_at"] = filter.CreatedAt.UTC()
      wc = append(wc, "date_created &gt;= :created_at")
    }</span>
    <span class="cov0" title="0">if filter.UpdatedAt != nil </span><span class="cov0" title="0">{
        data["updated_at"] = filter.UpdatedAt.UTC()
        wc = append(wc, "updated_at &lt;= :updated_at")
    }</span>

    <span class="cov0" title="0">if len(wc) &gt; 0 </span><span class="cov0" title="0">{
        buf.WriteString(" WHERE ")
        buf.WriteString(strings.Join(wc, " AND "))
    }</span>
} 

</pre>
		
		<pre class="file" id="file66" style="display: none">package vehicledb

import (
        //"database/sql"
        "fmt"
        //"net/mail"
        "time"

        "github.com/FITHSCS/backend/business/domain/vehiclebus"

        "github.com/FITHSCS/backend/business/types/genstringtype"
        "github.com/google/uuid"
)

//&lt;============struct that is going to be passed to database schema =&gt; Final =======&gt;

type vehicle struct {
        ID             uuid.UUID `db:"vehicle_id"`
        PlateNumber    string    `db:"plate_number"`
        VehicleType    string    `db:"vehicle_type"`
        WeightCapacity int       `db:"weight_capacity"`
        VolumeCapacity int       `db:"volume_capacity"`
        CurrentStatus  string    `db:"current_status"`
        CreatedAt      time.Time `db:"created_at"`
        UpdatedAt      time.Time `db:"updated_at"`
}

//=============================================================================&gt;

func toDBVehicle(bus vehiclebus.Vehicle) vehicle <span class="cov0" title="0">{

        return vehicle{

                ID:             bus.ID,
                PlateNumber:    bus.PlateNumber.String(),
                VehicleType:    bus.VehicleType.String(),
                WeightCapacity: bus.WeightCapacity,
                VolumeCapacity: bus.VolumeCapacity,
                CurrentStatus:  bus.CurrentStatus.String(),
                CreatedAt:      bus.CreatedAt.UTC(),
                UpdatedAt:      bus.UpdatedAt.UTC(),
        }
}</span>

func toBusVehicle(db vehicle) (vehiclebus.Vehicle, error) <span class="cov0" title="0">{

        plteNumber, err := genstringtype.Parse(db.PlateNumber)
        if err != nil </span><span class="cov0" title="0">{
                return vehiclebus.Vehicle{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">vhiclType, err := genstringtype.Parse(db.VehicleType)
        if err != nil </span><span class="cov0" title="0">{
                return vehiclebus.Vehicle{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">currentStatus, err := genstringtype.Parse(db.CurrentStatus)
        if err != nil </span><span class="cov0" title="0">{
                return vehiclebus.Vehicle{}, fmt.Errorf("parse: %w", err)
        }</span>

        <span class="cov0" title="0">bus := vehiclebus.Vehicle{

                ID:             db.ID,
                PlateNumber:    plteNumber,
                VehicleType:    vhiclType,
                WeightCapacity: db.WeightCapacity,
                VolumeCapacity: db.VolumeCapacity,
                CurrentStatus:  currentStatus,
                CreatedAt:      db.CreatedAt.In(time.Local),
                UpdatedAt:      db.UpdatedAt.In(time.Local),
        }
        return bus, nil</span>

}

func toBusVehicles(dbs []vehicle) ([]vehiclebus.Vehicle, error) <span class="cov0" title="0">{

        bus := make([]vehiclebus.Vehicle, len(dbs))

        for i, db := range dbs </span><span class="cov0" title="0">{
                var err error
                bus[i], err = toBusVehicle(db)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">return bus, nil</span>
}
</pre>
		
		<pre class="file" id="file67" style="display: none">package vehicledb


import (
  "fmt"

  "github.com/FITHSCS/backend/business/domain/vehiclebus"
  "github.com/FITHSCS/backend/business/sdk/order"
) 

var orderByFields = map[string]string{
    vehiclebus.OrderByID:                   "vehicle_id",
    vehiclebus.OrderByPlateNumber:          "plate_number",
    vehiclebus.OrderByVehicleType:          "vehicle_type",
    vehiclebus.OrderByWeightCapacity:       "weight_capacity",
    vehiclebus.OrderByVolumeCapacity:       "volume_capacity",
    vehiclebus.OrderByCurrentStatus:        "current_status",
    vehiclebus.OrderByCreatedAt:            "created_at",
    vehiclebus.OrderByUpdatedAt:            "updated_at",
}

// orderByClause converts an order.By value into the final
// " ORDER BY … ASC|DESC" fragment the store adds to its SELECT.
func orderByClause(ob order.By) (string, error) <span class="cov0" title="0">{
  col, ok := orderByFields[ob.Field]
  if !ok </span><span class="cov0" title="0">{
    return "", fmt.Errorf("field %q does not exist", ob.Field)
  }</span>
  <span class="cov0" title="0">return " ORDER BY " + col + " " + ob.Direction, nil</span>
}
</pre>
		
		<pre class="file" id="file68" style="display: none">// Package vehicledb contains product related CRUD functionality.
package vehicledb

import (
        "bytes"
        "context"
        "errors"
        "fmt"

        "github.com/FITHSCS/backend/business/domain/vehiclebus"
        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/business/sdk/sqldb"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/google/uuid"
        "github.com/jmoiron/sqlx"
)

type Store struct {
        log *logger.Logger
        db  sqlx.ExtContext
}

func NewStore(log *logger.Logger, db *sqlx.DB) *Store <span class="cov0" title="0">{
        return &amp;Store{log: log, db: db}
}</span>

// -----------------------------------------------------------------------------
// CRUD
// -----------------------------------------------------------------------------

func (s *Store) Create(ctx context.Context, v vehiclebus.Vehicle) error <span class="cov0" title="0">{
        fmt.Println(v)
        const stmt = `
    INSERT INTO vehicle (
            vehicle_id,
                plate_number, 
                vehicle_type, 
                weight_capacity,
            volume_capacity, 
                current_status, 
            created_at, 
                updated_at
    ) VALUES (
            :vehicle_id, 
                :plate_number, 
                :vehicle_type, 
                :weight_capacity,
            :volume_capacity, 
                :current_status,
            :created_at, 
                :updated_at
    )`
        return sqldb.NamedExecContext(ctx, s.log, s.db, stmt, toDBVehicle(v))
}</span>

func (s *Store) Update(ctx context.Context, v vehiclebus.Vehicle) error <span class="cov0" title="0">{
        const stmt = `
    UPDATE 
                vehicle
        SET 
                plate_number      = :plate_number,
            vehicle_type      = :vehicle_type,
            weight_capacity   = :weight_capacity,
            volume_capacity   = :volume_capacity,
            current_status    = :current_status,
            updated_at        = :updated_at
    WHERE 
                vehicle_id        = :vehicle_id`
        return sqldb.NamedExecContext(ctx, s.log, s.db, stmt, toDBVehicle(v))
}</span>

func (s *Store) Query(ctx context.Context,
        filter vehiclebus.QueryFilter, orderBy order.By, page page.Page) ([]vehiclebus.Vehicle, error) <span class="cov0" title="0">{
        //func (s *Store) Query(ctx context.Context) ([]vehiclebus.Vehicle, error) {

        data := map[string]any{
                "offset":        (page.Number() - 1) * page.RowsPerPage(),
                "rows_per_page": page.RowsPerPage(),
        }

        const q = `
    SELECT
            vehicle_id, 
                plate_number, 
                vehicle_type, 
                weight_capacity,
            volume_capacity, 
                current_status,
            created_at, 
                updated_at
    FROM 
                vehicle`

        var buf bytes.Buffer
        buf.WriteString(q)
        applyFilter(filter, data, &amp;buf)

        clause, err := orderByClause(orderBy)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">buf.WriteString(clause)
        buf.WriteString(" OFFSET :offset ROWS FETCH NEXT :rows_per_page ROWS ONLY")

        var dbRecs []vehicle
        if err := sqldb.NamedQuerySlice(ctx, s.log, s.db, buf.String(), data, &amp;dbRecs); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("namedqueryslice: %w", err)
        }</span>
        <span class="cov0" title="0">fmt.Println(dbRecs)
        return toBusVehicles(dbRecs)</span>
}

func (s *Store) Count(ctx context.Context, filter vehiclebus.QueryFilter) (int, error) <span class="cov0" title="0">{
        data := map[string]any{}
        const base = `SELECT count(1) FROM vehicle`

        var buf bytes.Buffer
        buf.WriteString(base)
        applyFilter(filter, data, &amp;buf)

        var out struct {
                Count int `db:"count"`
        }
        if err := sqldb.NamedQueryStruct(ctx, s.log, s.db, buf.String(), data, &amp;out); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("db: %w", err)
        }</span>
        <span class="cov0" title="0">return out.Count, nil</span>
}
func (s *Store) QueryByID(ctx context.Context, id uuid.UUID) (vehiclebus.Vehicle, error) <span class="cov0" title="0">{
        param := map[string]any{
                "vehicle_id": id.String(),
        }
        const stmt = `
    SELECT
                vehicle_id,
                plate_number,
                vehicle_type,
                weight_capacity,
                volume_capacity,
                current_status,
                created_at,
                updated_at
        FROM 
                vehicle
        WHERE 
                vehicle_id = :vehicle_id`

        var rec vehicle
        if err := sqldb.NamedQueryStruct(ctx, s.log, s.db, stmt, param, &amp;rec); err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sqldb.ErrDBNotFound) </span><span class="cov0" title="0">{
                        return vehiclebus.Vehicle{}, vehiclebus.ErrNotFound
                }</span>
                <span class="cov0" title="0">return vehiclebus.Vehicle{}, err</span>
        }
        <span class="cov0" title="0">return toBusVehicle(rec)</span>
}

func (s *Store) Delete(ctx context.Context, vehicleID uuid.UUID) error <span class="cov0" title="0">{

        const q = `
    DELETE FROM
        vehicle
    WHERE
        vehicle_id = :vehicle_id`

        dbFacility := vehicle{ID: vehicleID}

        if err := sqldb.NamedExecContext(ctx, s.log, s.db, q, dbFacility); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("namedexeccontext: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file69" style="display: none">package vehiclebus

import (
        "context"
        "fmt"
        "math/rand"

        "github.com/FITHSCS/backend/business/types/genstringtype"
)

func TestGenerateNewVehicles(n int) []NewVehicle <span class="cov5" title="2">{
        newroute := make([]NewVehicle, n)

        idx := rand.Intn(10000)
        for i := range n </span><span class="cov10" title="4">{
                idx++

                nf := NewVehicle{
                        PlateNumber:    genstringtype.MustParse(fmt.Sprintf("03-B-12%2d", idx)),
                        VehicleType:    genstringtype.MustParse("Truck"),
                        WeightCapacity: idx,
                        VolumeCapacity: idx % 100,
                        CurrentStatus:  genstringtype.MustParse("Active"),
                }

                newroute[i] = nf
        }</span>

        <span class="cov5" title="2">return newroute</span>
}

func TestGenerateSeedVehicles(ctx context.Context, n int, api *Business) ([]Vehicle, error) <span class="cov5" title="2">{
        newfs := TestGenerateNewVehicles(n)

        facs := make([]Vehicle, len(newfs))
        for i, np := range newfs </span><span class="cov10" title="4">{
                prd, err := api.Create(ctx, np)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("seeding routes: idx: %d : %w", i, err)
                }</span>

                <span class="cov10" title="4">facs[i] = prd</span>
        }

        <span class="cov5" title="2">return facs, nil</span>
}
</pre>
		
		<pre class="file" id="file70" style="display: none">// Package vehiclebus provides business access to vehicles bus domain.
package vehiclebus

import (
        "context"
        "errors"
        "fmt"

        "time"

        "github.com/FITHSCS/backend/business/sdk/order"
        "github.com/FITHSCS/backend/business/sdk/page"
        "github.com/FITHSCS/backend/foundation/logger"
        "github.com/google/uuid"
)

var (
        ErrNotFound       = errors.New("vehicle not found")
        ErrAuthentication = errors.New("authentication failed")
)

type Storer interface {
        Create(ctx context.Context, vehicle Vehicle) error
        Update(ctx context.Context, vehicle Vehicle) error
        Query(ctx context.Context, filter QueryFilter, orderby order.By, page page.Page) ([]Vehicle, error)
        QueryByID(ctx context.Context, vehicleID uuid.UUID) (Vehicle, error)
        Count(ctx context.Context, filter QueryFilter) (int, error)
        Delete(ctx context.Context, vehicleID uuid.UUID) error
}

type Business struct {
        log    *logger.Logger
        storer Storer
}

func NewBusiness(log *logger.Logger, storer Storer) *Business <span class="cov1" title="1">{

        return &amp;Business{
                log:    log,
                storer: storer,
        }
}</span>

func (b *Business) Create(ctx context.Context, vf NewVehicle) (Vehicle, error) <span class="cov10" title="5">{

        now := time.Now().Truncate(time.Microsecond)

        vehicle := Vehicle{

                ID:             uuid.New(),
                PlateNumber:    vf.PlateNumber,
                VehicleType:    vf.VehicleType,
                WeightCapacity: vf.WeightCapacity,
                VolumeCapacity: vf.VolumeCapacity,
                CurrentStatus:  vf.CurrentStatus,
                CreatedAt:      now,
                UpdatedAt:      now,
        }

        if err := b.storer.Create(ctx, vehicle); err != nil </span><span class="cov0" title="0">{
                return Vehicle{}, fmt.Errorf("Create: %w", err)
        }</span>
        <span class="cov10" title="5">return vehicle, nil</span>
}

func (b *Business) Update(ctx context.Context, vehicleID uuid.UUID, updateVehicle UpdateVehicle) (Vehicle, error) <span class="cov1" title="1">{

        vehicleDBRetrieved, err := b.storer.QueryByID(ctx, vehicleID)
        if err != nil </span><span class="cov0" title="0">{
                return Vehicle{}, fmt.Errorf("update: %w", err)
        }</span>

        <span class="cov1" title="1">if updateVehicle.PlateNumber != nil </span><span class="cov1" title="1">{
                vehicleDBRetrieved.PlateNumber = *updateVehicle.PlateNumber
        }</span>

        <span class="cov1" title="1">if updateVehicle.VehicleType != nil </span><span class="cov1" title="1">{
                vehicleDBRetrieved.VehicleType = *updateVehicle.VehicleType
        }</span>

        <span class="cov1" title="1">if updateVehicle.WeightCapacity != nil </span><span class="cov1" title="1">{
                vehicleDBRetrieved.WeightCapacity = *updateVehicle.WeightCapacity
        }</span>

        <span class="cov1" title="1">if updateVehicle.VolumeCapacity != nil </span><span class="cov1" title="1">{
                vehicleDBRetrieved.VolumeCapacity = *updateVehicle.VolumeCapacity
        }</span>

        <span class="cov1" title="1">if updateVehicle.CurrentStatus != nil </span><span class="cov1" title="1">{
                vehicleDBRetrieved.CurrentStatus = *updateVehicle.CurrentStatus
        }</span>

        <span class="cov1" title="1">vehicleDBRetrieved.UpdatedAt = time.Now().Truncate(time.Microsecond)

        if err := b.storer.Update(ctx, vehicleDBRetrieved); err != nil </span><span class="cov0" title="0">{
                return Vehicle{}, fmt.Errorf("update: %w", err)
        }</span>
        <span class="cov1" title="1">return vehicleDBRetrieved, nil</span>
}

func (b *Business) QueryByID(ctx context.Context, vehicleID uuid.UUID) (Vehicle, error) <span class="cov1" title="1">{

        vehicle, err := b.storer.QueryByID(ctx, vehicleID)
        if err != nil </span><span class="cov0" title="0">{
                return Vehicle{}, fmt.Errorf("query: vehicleID[%s]: %w", vehicleID, err)
        }</span>
        <span class="cov1" title="1">return vehicle, nil</span>
}

func (b *Business) Query(ctx context.Context, filter QueryFilter, orderBy order.By, page page.Page) ([]Vehicle, error) <span class="cov1" title="1">{
        vehicles, err := b.storer.Query(ctx, filter, orderBy, page)

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Query: %w", err)
        }</span>
        <span class="cov1" title="1">return vehicles, nil</span>
}

func (b *Business) Count(ctx context.Context, filter QueryFilter) (int, error) <span class="cov0" title="0">{
        return b.storer.Count(ctx, filter)
}</span>

func (b *Business) Delete(ctx context.Context, vehicleID uuid.UUID) error <span class="cov4" title="2">{

        if err := b.storer.Delete(ctx, vehicleID); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("delete: %w", err)
        }</span>
        <span class="cov4" title="2">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
